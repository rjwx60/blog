---
typora-root-url: ../../../BlogImgsBed/Source
---



### 一、历史

**<u>HTTP 协议是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范；</u>**

**<u>其通常跑在`TCP/IP协议栈`之上，依靠`IP协议实现寻址和路由`、`TCP协议实现可靠数据传输`、`DNS协议实现域名查找`、`SSL/TLS协议实现安全通信`；</u>**

当然，WebSocket、DNS 依赖于 HTTP；

- **HTTP/0.9** 于 **1990 年**问世，并没有作为正式的标准被建立；
- 作为正式的标准被建立是 **HTTP/1.0**，于 **1996年5月** 发布；
- 目前主流的版本是 **HTTP/1.1**，于 **1997年1月** 发布；
- **2015年5月** 正式发布 **HTTP/2**；(不叫 HTTP/2.0，是因为标准委员会不打算发布子版本，下一个版本直接是 HTTP/3)；



#### 1-1、演进粗览

##### 1-1-1、1.0 协议缺陷

- 无法复用链接，完成即断开，**重新慢启动和 TCP 3次握手**；
- head of line blocking：**线头阻塞**，导致请求之间互相影响；

##### 1-1-2、1.1 协议改进

- **长连接：** 默认 keep-alive，支持长连接和请求的流水线，在一个 TCP 连接上可传送多个 HTTP 请求，避免了因为多次建立 TCP 连接的时间消耗和延时
- **Host 头指定对应虚拟站点：** 在 1.0 中认为每台服务器都有唯一的IP地址，但随着虚拟主机技术发展，多主机共享单一 IP 地址愈发普遍；HTTP1.1 引入 Host 头部字段，且请求消息中若无 Host 头域会报 400 错误；
- **新增功能:**
  - 断点续传：引入 Range 头部；
  - 身份认证
  - 状态管理
  - 缓存处理：引入缓存相关头部字段来控制缓存，详看浏览器缓存章节
    - Cache-Control
    - Expires
    - Last-Modified
    - Etag

##### 1-1-3、2.0 协议增强

- **二进制格式：** 采用二进制格式传输数据，相比于 HTTP/1.1 的文本格式，二进制格式具有更好的解析性和拓展性；
- **多路复用：** 即多个请求都通过一个 TCP 连接并发地完成；
- **首部压缩：** 压缩消息头，减少传输数据的大小；
- **服务端推送：** 服务端能够主动把资源推送给客户端；



##### 1-1-4、3.0 协议改进

HTTP/2 仍然存在一些缺陷，但缺陷并非来自 HTTP/2 协议本身，而是来源于底层的 TCP 协议：虽然 TCP 连接是可靠连接，若出现丢包，则整个连接都要等待重传；HTTP/1.1 可同时使用 6 个 TCP 连接，一旦发生阻塞则另外 5 个还能工作，但 HTTP/2 只有1个 TCP 连接，也即阻塞问题被放大；

由于 TCP 协议已被广泛使用，故很难直接修改 TCP 协议，基于此 HTTP/3 选择了折衷办法：QUIC 基于 UDP 实现，是 HTTP/3 中的底层支撑协议，该协议基于 UDP，又取了 TCP 中的精华，实现了即快又可靠的协议；

- 注意：HTTP/3 之前名为 HTTP-over-QUIC，HTTP/3 最大的改造就是使用了 QUIC；

QUIC 虽然基于 UDP，但是在原本的基础上新增了很多功能，比如：<u>多路复用、0-RTT、使用 TLS1.3 加密、流量控制、有序交付、重传</u>等等功能：

- 多路复用：虽然 HTTP/2 支持了多路复用，但是 TCP 协议终究是没有这个功能；但 QUIC 原生就实现了此功能，并且传输的单个数据流可以保证有序交付且不会影响其他的数据流，这样的技术就解决了之前 TCP 存在的问题；并且 QUIC 在移动端的表现也会比 TCP 好，因为 TCP 是基于 IP 和端口去识别连接的，这种方式在多变的移动端网络环境下是很脆弱的，但 QUIC 是通过 ID 的方式去识别一个连接，不管你网络环境如何变化，只要 ID 不变，就能迅速重连上；

- 0-RTT：通过使用类似 TCP 快速打开的技术，缓存当前会话的上下文，在下次恢复会话时，只需要将之前的缓存传递给服务端验证通过就可进行传输；

- 纠错机制：比如发送三个包，则协议会算出这三个包的异或值并单独发出一个校验包，也即总共发出了四个包；当出现其中的非校验包丢包时，可通过另外三个包计算出丢失的数据包的内容；仅限于丢失一个包的情况下，若出现丢失多个包就不能使用纠错机制，只能使用重传的方式；

详看： [http发展史(http0.9、http1.0、http1.1、http2、http3)](https://juejin.im/post/5dbe8eba5188254fe019dabb#heading-9)



##### 1-1-5、HTTPS 增加安全层

- 证书(公钥)
  - HTTPS 需要申请证书；
- SSL 加密
  - HTTP 是超文本传输协议，是明文传输；HTTPS 是 HTTP 经过 SSL 层加密，传输更安全；
  - HTTPS 比 HTTP 慢，因为 HTTPS 除了 TCP 握手的三个包，还要加上 SSL 握手的九个包；
- 端口 443 
  - HTTPS 使用 443 端口，HTTP 使用80；



#### 1-2、演进细览

##### 1-2-1、HTTP/0.9

```http
GET/index.html
```

此版本当时仅为学术交流，基于请求和响应的模式，在网络中传输HTML超文本的内容；

如上所示，<u>只有一个请求行，没有HTTP请求头和请求体；同样，服务器也没有响应头信息，只是返回了数据</u>；

而因均为 HTML 格式文件，故此决定了返回的文件内容通过 **<u>ASCII字符流</u>** 进行传输；



##### 1-2-2、HTTP/1.0

```http
accept: text/html
accept-encoding: gzip, deflate, br
accept-Charset: ISO-8859-1,utf-8
accept-language: zh-CN,zh
```

1994年底开启拨号上网，网景也在同年推出了第一款浏览器，人们对万维网的需求不再仅局限于学术交流；

W3C和HTTP工作组 **<u>HTTP-WG</u>** 也在此时代创建；为满足人们对浏览器的需求(不光是HTML，还有CSS、JS、图片、音视频等)，文件格式不再局限于 ASCII 编码。

为此，此版本的 HTTP 协议的解决办法是：<u>引入请求头、响应头，同时也引入状态码，为减轻服务器压力，还提供  Cache机制；而服务器需要统计客户端的基础信息，加入用户代理字段；</u>



##### 1-2-3、HTTP/1.1

##### 1-2-3-1、改进持久连接

即一个 TCP 连接可传输多个 HTTP 请求，只要浏览器或者服务器没有断开连接，该 TCP 就会一直保持；

- 注意：持久连接是默认开启的，若想要关闭，则在请求头中加上 **Connection:close** 即可；
- 此外：目前浏览器中对于同一个域名，默认允许同时建立6个TCP持久连接。

##### 1-2-3-2、不成熟的 HTTP 管线化

此版本协议试图通过 <u>**管线化的技术**</u> 来解决队头阻塞问题；但因各种原因，被各大厂商放弃；

##### 1-2-3-3、增加对虚拟主机的支持

过去版本的协议的每个域名都只绑定唯一的 IP 地址，因此一个服务器只能支持一个域名；

<u>但随着虚拟主机技术的发展</u>，一台物理主机上绑定多个虚拟主机的需求大大提升，每个虚拟主机都有自己单独的域名，这些单独的域名都公用同一个IP地址。

因此，此版本协议的通过在请求头中增加 <u>**Host字段**</u>，表示当前的域名地址，服务器可根据不同的Host值做不同的处理；

##### 1-2-3-4、增加对动态生产内容的支持

过去版本的协议需要在响应头中设置完整的数据大小 <u>Content-Length: 900</u>，如此浏览器就可根据设置的数据大小来接收数据；

<u>但随着服务器端技术发展</u>，页面都是动态生成，传输数据前并不知最终数据大小， 导致浏览器不知道何时会接受完所有的文件数据；

因此，此版本协议的通过引入 <u>**Chunk transfer机制**</u> 来解决，服务器将数据分割成若干个任意大小的数据块，每个数据块发送时会附上上一个数据块的长度，最后使用一个长度为 0 的块作为发送数据完成的标志；

##### 1-2-3-5、客户端 Cookie、安全机制

此版本协议引入了 **客户端Cookie机制** 和 **安全机制**；



##### 1-2-4、HTTP/2

##### 1-2-4-1、版本 1.1 的缺陷

对带宽的利用率不理想

- TCP 的慢启动；
- 若同时开启多条 TCP 连接，则多条连接会竞争固定的带宽；
- `HTTP/1.1` 队头阻塞的问题；

##### 1-2-4-2、HTTP/2 多路复用

`HTTP/2`使用多路复用机制解决了上述问题；一个域名只使用一个 TCP 长连接和消除队头阻塞问题；通过引入**二进制分帧层**，实现了 HTTP 的多路复用技术；

##### 1-2-4-3、HTTP/2 服务器推送

服务器可提前将数据推送到浏览器，浏览器有权选择是否接受；浏览器发送 **RST_STREAM帧** 可以选择拒收；

##### 1-2-4-4、HTTP/2 头部压缩

头部压缩大大提升传输效率；HTTP/2 使用 HPACK 算法，在客户端和服务器建立字典，用索引号表示重复的字符串，还采用哈夫曼编码来压缩整数和字符串；

##### 1-2-4-5、HTTP/2 请求的优先级

可设置让某些重要的数据优先被服务器处理并返回；





##### 1-2-5、HTTP/3

##### 1-2-5-1、HTTP/2的缺陷

- **<u>TCP 队头阻塞</u>**

  -  `HTTP/2`只解决应用层面队头阻塞，而阻塞问题根源在 TCP 协议本身，但TCP 传输过程中，由于单个数据包的丢失而造成的阻塞称为 TCP 上的队头阻塞；

- **<u>TCP 建立连接延时</u>**

  - `TCP` 及 `TCP+TLS` 建立连接的所产生的延时也是影响传输效率的一个主要因素；

- **<u>TCP协议僵化</u>**

  - 中间件僵化：将在互联网的各处搭建的设备叫做中间设备(中间件)，比如路由器、NAT、防火墙、交换机等，它们通常依赖一些很少升级的软件，这些软件使用了大量的 TCP 特性，设置后便很少进行更新；而这就对更新 TCP 时造成巨大困难， 新协议的数据包经过这些中间件时，它们不会去理解包的内容从而丢弃掉这些数据包；

  - 操作系统：因为 TCP 协议都是通过操作系统内核来实现的，应用程序只能使用不能修改；而通常操作系统的更新都滞后于软件的更新，所以想要更新操作系统内核中的 TCP 协议也是非常困难；

##### 1-2-5-2、QUIC 协议

`HTTP/3` 选择了个折衷的方法：**<u>基于 UDP 实现了类似于 TCP 的多路数据流、传输可靠性等功能，即 QUIC 协议</u>**；详看：[HTTP/3详解](https://hungryturbo.com/HTTP3-explained/quic/引言.html)

- 实现了类似 TCP 的流量控制、传输可靠性的功能；
- 集成了 TLS 加密功能；
- 实现了 HTTP/2 中的多路复用功能；
- 实现了快速握手功能；




#### 1-X、同层协议

- FTP：文件传输协议，用来在客户机和FTP服务器之间传输文件；
- DNS：提供域名到IP地址之间的解析服务；
- SMTP：邮件发送协议，用户通过SMTP服务器发送邮件；
- DHCP：动态主机配置协议，DHCP服务器为客户机动态分配IP地址；
- POP3：邮件接收协议，用于从POP3服务器接收邮件；



### 二、HTTP

**<u>HTTP 协议是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范；</u>**

**<u>其通常跑在`TCP/IP协议栈`之上，依靠`IP协议实现寻址和路由`、`TCP协议实现可靠数据传输`、`DNS协议实现域名查找`、`SSL/TLS协议实现安全通信`；</u>**

当然，WebSocket、DNS 依赖于 HTTP；

与 TCP 不同：HTTP责任是定义数据形式让对方理解；TCP负责数据在计算机间可靠、稳定、高效传输；



#### 2-1、协议特点

##### 2-1-1、优点/特点

- 无状态(优缺同体)：状态指通信过程的上下文信息；无状态指每次请求均为独立无关联，默认不保留状态信息；具体场景具体分析；
  - 比如若仅为获取某些数据的场景下，而无需保存连接的上下文信息，此时的无状态能有效减少网络开销；
- 灵活可扩展
  - 语义自由：只规定基本格式(分隔符、换行分隔等)，而其他部分无严格语法限制；
  - 形式多样：传输形式多样，可传输文本、图片、视频等任意数据；
- 可靠传输：HTTP 基于 TCP/IP，继承其特性；
- 请求响应模式：报文须一发一收、有来有回；
- <u>持久连接</u>：建立一次 TCP 连接即可进行多次请求或响应的交互，只要有一方没有明确的提出断开连接，则保持连接状态；
  - 原理：HTTP的初始版本是每进行一次HTTP通信就要断开一次TCP连接，下次再进行的时候又要重新连接断开。再如今请求的资源越来越大，每次请求如果都有无谓TCP连接和断开是很大的开销。
  - 优点：减少 TCP 连接和断开的造成的额外开销，减轻服务端的负载，Web 页面加载变快；
  - 注意：HTTP/1.1 中所有连接均默认持久连接 (也即首部字段 `Connection: keep-alive`，若想要关闭可将值设置为 close)，但 HTTP/1.0 并未标准化
- <u>管线化</u>：同时并行发送多个请求，而不必等前一个请求完毕才能发送下一个，<u>但因为各种原因被各大厂商废弃了</u>

##### 2-1-2、缺点/不足

- 无状态(优缺同体)：状态指通信过程的上下文信息；无状态指每次请求均为独立无关联，默认不保留状态信息；具体场景具体分析；
  - 对于一些长连接的场景需要保存上下文信息，以免传输重复的数据。
  - 对于一些应用只是为了获取数据不需要保存上下文信息，无状态减少了网络开销。
- 明文传输：即报文传输使用文本形式而非二进制形式，虽便于调试但暴露了内部信息，内容能被窃取；
- 队头阻塞：当 http 开启长连接时将共用一个 TCP 连接，同一时刻只能处理一个请求，此时若某请求耗时过长，则会导致其它请求处于阻塞状态；
  - 根本原因：在于 HTTP 基于 <u>请求响应</u> 模型，在同一 TCP 长连接中，前一请求没有得到响应，后面的请求就会被阻塞；
  - 注意：与 TCP 队头阻塞区别：TCP 传输的单位是数据包，其队头阻塞表示的是前一个报文没有收到便不会将下一个报文上传给应用层；而 HTTP 队头阻塞是在 请求-响应 层面，前一个请求还没有处理完，后面的请求就被阻塞；

##### 2-1-3、缺点应对

- 无状态：详看：WebSocket
- 明文传输：HTTPS，详看：三：HTTPS
- 队头阻塞：HTTP 传输基于`请求-应答` 模式，报文须一发一收，而其中任务放在任务队列中串行执行，一旦队首请求处理太慢，就会阻塞后续请求的处理：
  - 并发连接：一个域名允许分配多个长连接，相当于增加任务队列数量；
    - 注意：RFC2616 规定过客户端最多并发 2 个连接，而实际中的浏览器上限要比它大，比如 Chrome 中是 6；
  - 域名分片：通过增加域名以实现增加发送数量；
    - 比如：content1.TLP.com 、content2.TLP.com
  - HTTP/2 多路复用：上述 HTTP/1.1 方式并无真正从协议层面解决问题，只是增加 TCP 连接分摊风险，且多条 TCP 连接也会竞争有限的带宽，让真正优先级高的请求不能优先处理；而 HTTP/2 的多路复用真正从协议层面解决此问题，详看 4-1-2；



#### 2-2、报文格式

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200907235829.png" style="zoom:50%;" align=""/>

与TCP 的`tcp头部 + 数据部分`类似，即 `http头部(header) + 数据部分(body)`

还可进一步分拆为 `header(起始行 + 头部 + 空行) + body(实体)` 四部分，其中头部又可分为请求头部和响应头部；



##### 2-2-1、起始行

请求报文起始行由：`方法 + 路径 + http版本` 组成，比如：`GET /home HTTP/1.1`

响应报文起始行由：`http版本 + 状态码 + 原因` 组成，比如：`HTTP/1.1 200 OK`

- 注意：响应报文的起始行也叫做状态行；

- 注意：起始行中每2个部分间用**空格**隔开，最后一部分后还应接**换行**，遵循 [ABNF规范](https://en.wikipedia.org/wiki/Augmented_Backus–Naur_form)

##### 2-2-2、头部

下图分别为请求头部与响应头部，其中各个字段须遵循以下格式：

- 字段名不区分大小写、不允许出现空格，不可出现下划线 `_`
- 字段名后面必须紧跟冒号 `:` 不得空隙；

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200907235830.png" style="zoom:35%;" align="" />

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200907235831.png" style="zoom:35%;" align="" />

##### 2-2-3、空行

用以区分头部与实体，若将空行位置上移，则往后内容均被视为实体部分；

##### 2-2-4、实体

即数据部分；







#### 2-3、报文字段—[MDN](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers)

##### 2-3-X、通用头

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200907235832.png" style="zoom:50%;" align="" />

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200907235833.png" style="zoom:50%;" align="" />

- `Cache-Control` 控制缓存
- `Connection` 连接管理
- `Transfor-Encoding` 报文主体的传输编码格式
- `Date` 创建报文的时间
- `Upgrade` 升级为其他协议



##### 2-3-X、请求头

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200907235834.png" style="zoom:50%;" align="" />

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200907235835.png" style="zoom:50%;" align="" />

- `Host` 请求资源所在的服务器 (唯一一个HTTP/1.1规范里要求必须出现的字段)
- `Accept` 客户端或者代理能够处理的媒体类型
- `If-Match` 比较实体标记 (ETag)
- `If-None-Match` 比较实体标记 (ETag)，与 If-Match 相反
- `If-Modified-Since` 比较资源更新时间 (Last-Modified)
- `If-Unmodified-Since` 比较资源更新时间 (Last-Modified)， 与 If-Modified-Since 相反
- `Range` 实体的字节范围请求
- `User-Agent` 客户端信息



##### 2-3-X、响应头

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200907235836.png" style="zoom:50%;" align="" />

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200907235837.png" style="zoom:50%;" align="" />

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200907235838.png" style="zoom:50%;" align="" />

- `Accept-Ranges` 能接受的字节范围
- `Location` 命令客户端重定向的 URI
- `ETag` 能够表示资源唯一资源的字符串
- `Server` 服务器的信息



##### 2-3-U、实体头

即针对请求报文和响应报文的实体部分使用首部

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200907235839.png" style="zoom:50%;" align="" />

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200907235840.png" style="zoom:50%;" align="" />

`Allow` 资源可支持 HTTP 请求方法

`Last-Modified` 资源最后修改时间

`Expires` 实体主体过期时间

`Content-Language` 实体资源语言

`Content-Encoding` 实体编码格式

`Content-Length` 实体大小

`Content-Type` 实体媒体类型




##### 2-3-1、请求方法

Http1.1 规定的以下请求方法(大写)：

- GET：获取资源，幂等操作
- HEAD：获取报文首部，和GET很像但是不返回报文主体，幂等操作
- POST: 创建或更新资源，非幂等操作
- PUT: 创建或更新资源本身，幂等操作
- PATCH：对资源进行局部更新，幂等操作
- DELETE：删除资源，和PUT功能相反，幂等操作
- OPTIONS：查询服务器端支持的HTTP方法种类(幂等操作)
- CONNECT：建立连接隧道，用于代理服务器，幂等操作
- TRACE：追踪请求，查询发出去的请求是怎样被加工/篡改的，幂等操作。容易引发XST跨站追踪攻击；
- 注意：OPTIONS、CONNECT、TRACE只在HTTP/1.1以上被支持
- 注意：LINK、UNLINK在HTTP/1.1中被废弃





##### 2-3-1-1、GET & POST 区别

<u>GET：可以缓存、相对危险(参数URL、有历史记录)、请求参数长度有限制、参数一般寄放 URL，URL编码仅支持 ASCII字符</u>

- 无副作用：不修改资源，比如对服务器上的资源做改变，搜索是无副作用的，注册是副作用的；
- 幂等：请求次数与资源无关，指发送 M 和 N 次请求（两者不相同且都大于 1），服务器上资源的状态一致；
  - 比如：注册 10 个和 11 个帐号，则此行为不幂等；
  - 比如：对文章进行更改 10 次和 11 次是幂等的；
  - 因为：前者是多了一个账号（资源），后者只是更新同一个资源；

<u>POST：不能缓存、相对安全、请求参数长度非常大、参数寄放请求体、 支持更多的编码类型且不对数据类型限制；</u>

- 注意：实际上，HTTP 协议并无要求 GET/POST 请求参数必须放在 URL 上或请求体中，也无规定 GET 请求长度，而目前对 URL 的长度限制，是各家浏览器设置的限制；GET 和 POST 的根本区别在于：<u>**GET 请求是幂等性的，而 POST 请求不是**</u>；
- 幂等，指对某一资源进行一或多次请求都具有相同的副作用；比如搜索就是一个幂等操作，而删除、新增则不是；由于 GET 请求是幂等，在网络不好的环境中，GET 请求可能会重复尝试，造成重复操作数据的风险，因此，GET 请求用于无副作用的操作(比如搜索)，新增/删除等操作更适合用 POST；
- 注意：从 TCP 角度上，GET 请求会将请求报文一次性发出，但 POST 会分为 2 个 TCP 数据包；首先发送的是 header 部分，若是服务器响应 100(continue)，则会发送 body 部分，火狐浏览器除外，它的 POST 请求只发一个 TCP 包，但并非表示 GET 比 POST 更有效：
  - 首先，GET 和 POST 均有自身语义，最好不要混用；
  - 另外，在网络条件好的情况下，发一次包和发两次包相差的时间基本可无视；否则，两次发包的 TCP 在验证数据包的完整性上还有更大优势；
  - 再者，也并非所有浏览器的 POST 请求都会发送两次 TCP 数据包(不可偏概全)；

- 详看：[HTTP｜GET 和 POST 区别](https://juejin.im/entry/597ca6caf265da3e301e64db)

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200907235841.png" style="zoom:50%;" align=""/>





##### 2-3-1-2、幂等

一个方法是否幂等，可通过：若重复执行多次此方法，产生效果是不是一样来判断；

若为幂等，则其本质上意味着：成功执行请求的结果同它执行的次数无关；只有 **POST** 和 **PATCH** 是 **非幂等** 的，**其它都是幂等操作**：

- GET 方法用于获取资源，不应该有副作用，故**幂等**；
- HEAD 方法 与 GET 情况一样，只不过它只用于获取报文首部，不返回报文主体，故也是**幂等**；
- POST、PUT 均可用于创建、更新资源，但本质差别就在于幂等性上：
  - POST 方法目标主体是 <u>资源操作主体</u> 的操作，对同一URI 进行多次 PUT 的副作用和一次 PUT 是相同的，故为 **非幂等**；
  - PUT 方法目标主体是 <u>资源本身</u> 的更新操作，对同一URI 进行多次 PUT 的副作用和一次 PUT 是相同的，故为 **幂等**；
- DELETE 方法用于删除资源，有副作用，但它却是**幂等**的，因调用一次和调用 N 次对系统产生的副作用相同；
- OPTIONS 这个很好理解，只是为了获取服务器支持的方法，**幂等**；






##### 2-3-2、状态码

RFC 规定 HTTP 的状态码为三位数，被分为五类:

- 1XX：表示请求已接收到，需要进一步处理才能完成，HTTP/1.0 不支持
  - 100 Continue：继续，客户端应继续其请求，上传大文件前使用；
  - <u>101 Switching Protocols：切换协议；服务器根据客户端的请求切换协议，但注意只能切换到更高级的协议；</u>
    - 比如：切换到 HTTP 的新版本协议；
    - 比如：当 HTTP 升级为 WebSocket 时，若服务器同意变更，也会回送此码；
  - 102 Processing：服务器已经收到并正在处理请求，但无响应可用；
- 2XX：表示成功状态；
  - 200 OK：成功状态码；响应体有数据；一般用于GET与POST请求；
  - 201 Created：已创建；成功请求服务端并有新资源在服务器端被成功创建；
  - 202 Accepted：已接受；服务端已接受请求但未处理完成；
  - 203 Non-Authoritative Information：非授权信息；请求成功，但返回的 meta 信息不在原始服务器，而是一个副本；
  - <u>204 No Content：含义与 200 类似，服务器接受并开始处理请求，但请求未处理完成，未返回内容(响应体无数据)；</u>
    - 比如：在未更新网页的情况下，可确保浏览器继续显示当前文档；
  - <u>205 Reset Content：重置内容；表示服务器处理成功，此时用户终端应重置文档视图；</u>
    - 比如：可通过此返回码清除浏览器的表单域；
  - <u>206 Partial Content：表示部分内容，服务器成功处理了部分GET请求，使用 range  协议时返回部分响应内容时的响应码；</u>
    - 比如：使用场景为 HTTP 分块下载和断点续传，当然也会带上相应的响应头字段 Content-Range；
- 3XX：表示重定向状态，资源位置发生变动，需重新请求；
  - 300 Multiple Choices：多种选择，是一个特殊的重定向状态码，请求的资源可包括多个位置，会返回一个有多个链接选项的页面，由用户自行选择；
  - <u>301 Moved Permanently：永久重定向，请求的资源已被永久移动到新 URI，返回信息会包括新 URI，浏览器会自动定向到新 URI，且浏览器会作缓存优化，后续访问时自动访问缓存后的新 URI；</u>
  - <u>302 Found：临时重定向，与301类似，但资源只是临时被移动，客户端应继续使用原有URI，浏览器不作缓存优化；</u>
  - <u>303 See Other：临时重定向，类似于 302，请求的资源临时被移动到了别的URI上，但是明确表示客户端应该使用GET方法获取资源，即重向后的请求方法改为 `GET` 方法；</u>
  - <u>304 Not Modified：未修改，所请求的资源未修改，服务器返回此状态码时，表明服务端验证过期缓存有效后，要求客户端使用该缓存，不会返回任何资源；当协商缓存命中时返回的状态码；</u>
  - 305 Use Proxy：使用代理，所请求的资源必须通过代理访问；
  - 306 Unused：已经被废弃的HTTP状态码；
  - <u>307 Temporary Redirect：临时重定向，但是比 302 更明确，重定向的请求方法和实体都不允许变动；</u>
    - 比如：HSTS 协议，强制客户端使用 `https` 建立连接，若某网站从 `HTTP` 升级到 `HTTPS`，但还是以 http 形式访问时接收到；
  - 308：类似于 301，代表永久重定向，重定向后请求的方法和实体不允许变动；
  - **302 Found，基本的临时重定向**
  - **303 SeeOther，明确表示客户端应该使用GET方法**
  - **307 Temprary Redirect，请求方法和实体都不允许变动**
  
- 4XX：表示请求报文有误；
  - <u>400 Bad Request：服务器认为客户端出现了错误，但不明确，一般是 HTTP 请求格式错误；</u>
  - <u>401 Unauthorized：用户认证信息确实或者不正确；</u>
  - 402 Payment Required：保留码，将来使用；
  - <u>403 Forbidden：服务器理解请求客户端的请求，但是拒绝执行此请求(原因有很多，比如法律禁止、信息敏感、数据保护等)；</u>
  - <u>404 Not Found：服务器没有找到对应的资源；</u>
  - 405 Method Not Allowed：客户端请求中的方法被禁止；
  - 406 Not Acceptable：服务器无法根据客户端请求的内容特性完成请求；
  - 407 Proxy Authentication Required：请求要求代理的身份认证，与 401 类似，对需要经由代理的请求，认证信息未通过代理服务器的验证；
  - 408 Request Timeout：服务器等待客户端发送的请求时间过长，超时；
  - 409 Conflict：服务器处理请求时发生了冲突；
    - 比如：服务器完成客户端的 PUT 请求；
  - 410 Gone：客户端请求的资源已不存在；
    - 注意：410 不同于 404：若资源过去存在，但现在被永久删除可使用 410 代码，亦可通过 301 码指定资源新位置；
  - 411 Length Required：服务器无法处理客户端发送的不带Content-Length的请求信息
  - 412 Precondition Failed：客户端请求信息的先决条件错误
  - 413 Request Entity Too Large：请求体过大，服务器无法处理，因此拒绝请求；
    - 注意：为防止客户端的连续请求，服务器可能会关闭连接。若只是服务器暂时无法处理，则会返回包含 Retry-After 的响应信息；
  - 414 Request-URI Too Long：请求行的 URI 过长，服务器无法处理；
  - 415 Unsupported Media Type：服务器无法处理请求附带的媒体格式；
  - 416 Requested range not satisfiable：客户端请求的范围无效；
  - 417 Expectation Failed：服务器无法满足 Expect 的请求头信息；
  - 429 Too Many Request：客户端发送请求过多；
  - 431 Request Header Fields Too Large：请求头的字段内容太大；

- 5XX：表示服务器端发生错误；
  - <u>500 Internal Server Error：服务器内部错误，且不属于以下错误类型，无法完成请求；</u>
  - <u>501 Not Implemented：表示服务器不支持请求的功能，无法完成请求</u>
  - 502 Bad Gateway：代理服务器无法获取到合法响应；
  - <u>503 Service Unavailable：表示服务器当前正忙(由于超载或系统维护)，服务器尚未准备好处理当前请求；</u>
  - 504 Gateway Time-out：充当网关或代理的服务器，未及时从远端服务器获取请求；
  - 505 HTTP Version not supported：服务器不支持请求的 HTTP 协议版本，无法完成处理；

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200907235842.png" style="zoom:50%;" align=""/>

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200907235843.png" style="zoom:50%;" align=""/>



##### 2-3-3、Accept-### & Content-###

此类字段用于双方确定对方可接收的 **<u>数据格式、压缩方式、支持语言和所使用的字符集</u>**：

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200907235844.png" style="zoom:60%;" align=""/>

<u>*注意：下述内容中，将接收端想象为客户端，将发送端想象为服务端会较好理解；*</u>

- 数据类型：标记数据类型
  - 接收端通过 Accept 字段表示想接收到的数据类型；
  - 发送端通过 Content-type 表示发送数据的类型；
    - text： text/html, text/plain, text/css 等；
    - image: image/gif, image/jpeg, image/png 等；
    - audio/video: audio/mpeg, video/mp4 等；
    - application: application/json, application/javascript, application/pdf, application/octet-stream；
    - 注意：上述取值参考于 **标准 MIME(Multipurpose Internet Mail Extensions, 多用途互联网邮件扩展)**；
- 压缩方式：标记对数据编码压缩的方式
  - 接收端通过 Accept-Encoding 表示可接受的压缩方式；
  - 发送端通过 Content-Encoding 表示对数据采取了何种压缩方式；
    - gzip: 当今最流行的压缩格式；
    - deflate：另外一种著名的压缩格式；
    - br：一种专门为 HTTP 发明的压缩算法；
- 支持语言：标记本机环境所支持的语言
  - 接收端通过 Accept-Language 表示可支持的语言；
  - 发送端通过 Content-Language 表示可支持的语言；
- 字符集：标记可接受的字符集
  - 接收端通过 Accept-Charset 表示可支持的字符集；
  - 发送端通过 Content-Type 表示可支持的字符集；

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200907235845.png" style="zoom:40%;" align=""/>



##### 2-3-4、Cookie

HTTP 是一个无状态的协议，每次请求均为独立、无关，默认不需要保留状态信息，为保存状态，HTTP 引入了 Cookie 字段；**<u>其本质是浏览器中内部以键值对形式存储的、很小的一个文本文件</u>**，浏览器向同一域名下发送请求，都会自动携带相同的 Cookie，服务器拿到 Cookie 进行解析，就能拿到客户端状态；服务端可通过设置响应头的 `Set-Cookie` 字段来为客户端写入`Cookie`，缺点有下：

```http
// 请求头
Cookie: a=xxx;b=xxx
// 响应头
Set-Cookie: a=xxx
set-Cookie: b=xxx
```

- 容量缺陷：Cookie 体积上限只有 `4KB`；
- 性能缺陷：Cookie 紧跟域名，同域所有地址均自动携带发送完整 Cookie，随着请求数的增多，造成性能损耗，可通过 `Domain` 和 `Path` 指定 **作用域** 解决；
- 安全缺陷：Cookie 以纯文本形式在网络中传递，易被非法用户截获和篡改(尤其在有效期内发送)；此外在 `HttpOnly: false` 情况下，Cookie 能直接通过 JS 脚本来读取；



##### 2-3-4-1、Cookie 生存周期与作用域

Cookie 的有效期可通过 **Expires** 和 **Max-Age** 两个属性来设置，若 Cookie 过期，则 Cookie 会被删除，并不会发送给服务端：

- **Expires**：即过期时间；
- **Max-Age**：即时间间隔，单位秒，从浏览器收到报文开始计算；

Cookie 的作用域可通过 **Domain **和 **path** 两个属性来设置，若给 Cookie 绑定域名和路径后，在发送请求前，发现域名或路径与属性不匹配，则不会带上 Cookie；注意：若 Path 设置 `Path: /`：表示域名下任意路径均允许 Cookie；



##### 2-3-4-2、Cookie 安全

- 若 Cookie 字段带上 `Secure`，表示只能通过 HTTPS 传输 cookie；
- 若 Cookie 字段带上`HttpOnly`，表示只能通过 HTTP 协议传输，不能通过 JS 访问，**<u>此乃预防 XSS 攻击的重要手段</u>**；
- 若 Cookie 字段带上 `SameSite`，可用于防御 CSRF 攻击，可设置 3 个值，`Strict`、`Lax`和`None`：
  - None 模式：默认模式，请求会自动携带 Cookie；
  - Strict 模式：浏览器完全禁止三方请求携带Cookie；
    - 比如：请求 `bilili.com` ，则只能在 `bilili.com ` 域名下的请求才能携带 Cookie，其他网站请求均不能；
  - Lax 模式：宽松模式，但只能在 `get 方法提交表单` 或 `a 标签发送 get 请求` 的情况下才可携带 Cookie，其他情况均不能；



##### 2-3-5、定长发送—Content-Length

用于标识报文长度(body 部分)，**<u>发送定长包体</u>**，此属性对于 http 传输过程起十分关键的作用，若设置不当可直接导致传输失败；

- 若设置值 < 实际报文长度会根据设置值截断；
- 若设置值 > 实际报文长度则会报错："该网页无法正常运作"；

```javascript
res.setHeader('Content-Type', 'text/plain');
// ContentLength = "helloworld".length 输出正常
res.setHeader('Content-Length', 10);
res.write("helloworld");
// helloworld

// ContentLength < "helloworld".length 输出被截断
res.setHeader('Content-Length', 5);
res.write("helloworld");
// hello

// ContentLength > "helloworld".length 报错
res.setHeader('Content-Length', 11);
res.write("helloworld");
// error
```



##### 2-3-6、不定长发送—Transfer-Encoding：chunked

用于表示分块传输数据，**<u>发送不定长包体</u>**，设置此字段后会自动产生 2 个效果:

- Content-Length 字段会被忽略；
- 基于长连接持续推送动态内容；

```javascript
const http = require('http');
const server = http.createServer();

server.on('request', (req, res) => {
  if(req.url === '/') {
    res.setHeader('Content-Type', 'text/html; charset=utf8');
    // Content-Length 会被忽略
    res.setHeader('Content-Length', 10);
    res.setHeader('Transfer-Encoding', 'chunked');
    res.write("<p>来啦</p>");
    setTimeout(() => {
      res.write("第一次传输<br/>");
    }, 1000);
    setTimeout(() => {
      res.write("第二次传输");
      res.end()
    }, 2000);
  }
})
server.listen(8009, () => { console.log("成功启动");})
```

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200907235846.png" style="zoom:50%;" align=""/>

```
chunk长度(16进制的数)
第一个chunk的内容
chunk长度(16进制的数)
第二个chunk的内容
......
0

```



##### 2-3-7、表单提交相关

HTTP 有 2 种主要的表单提交方式，体现在 2 种不同的 `Content-Type` 取值：

- application/x-www-form-urlencoded
- multipart/form-data

因表单提交一般是 `POST`请求，很少考虑`GET`，故此处默认提交的数据放在请求体中；



##### 2-3-7-1、application/x-www-form-urlencoded

对于 `application/x-www-form-urlencoded` 格式的表单内容，有以下特点:

- 数据会被编码成以`&`分隔的键值对；
- 字母原样，但字符以 <u>URL编码方式</u> 编码；

```
// 转换过程: 
{a: 1, b: 2} -> a=1&b=2 -> "a%3D1%26b%3D2"
```



##### 2-3-7-2、multipart/form-data

`multipart/form-data` 格式最大特点在于：**每个表单元素均为独立的资源表述**；实际场景中，对于图片等文件的上传，基本采用 `multipart/form-data` 字段而非 `application/x-www-form-urlencoded`，原因是没必要做 URL 编码；

- 请求头中的 `Content-Type` 字段会包含 `boundary(分隔符)`，此值值由浏览器默认指定；
  - 比如： `Content-Type: multipart/form-data;boundary=----WebkitFormBoundaryRRJKeWfHPGrS4LKe`；
  - 注意：`boundary` 是切实存在的，但浏览器和 HTTP 封装了这一系列操作；
- 数据会被拆分成多个部分、部分之间通过分隔符分隔、每部分的表述均有 HTTP 头部描述子包体，比如 `Content-Type`，在最后的分隔符会加上`--`表示结束；
  - 比如：相应的请求体是下面这样:

```http
Content-Disposition: form-data;name="data1";
Content-Type: text/plain
data1
----WebkitFormBoundaryRRJKeWfHPGrS4LKe
Content-Disposition: form-data;name="data2";
Content-Type: text/plain
data2
----WebkitFormBoundaryRRJKeWfHPGrS4LKe--
```



##### 2-3-8、文件上传相关

对于大文件上传，为避免影响用户体验，HTTP 提供 <u>范围请求</u> 方式，允许客户端仅请求资源的某部分(前提是服务端支持 <u>范围请求</u>，可从服务端的响应报文获悉)，

```http
// 服务端告知客户端自身支持范围请求
Accept-Ranges: none
```

具体请求哪部分，客户端可通过 Range 请求字段确定，格式为 `bytes=x-y`，书写格式如下：

- **0-499**：表示从开始到第 499 个字节；
- **500**- ：表示从第 500 字节到文件终点；
- **-100**：表示文件的最后100个字节；

当服务器收到请求后，首先会验证范围 **是否合法**，若越界则返回 `416` 错误码，否则读取相应片段，返回 `206` 状态码；同时，服务器还会在响应报文头部添加  `Content-Range` 字段，此字段的格式根据请求头中 `Range` 字段的不同而不同；具体来说，请求 `单段数据` 和请求 `多段数据`，响应头是不一样的：



##### 2-3-8-1、Range—单段数据

```javascript
// 单段数据
Range: bytes=0-9
// 响应报文:
HTTP/1.1 206 Partial Content
Content-Length: 10
Accept-Ranges: bytes
Content-Range: bytes 0-9/100

hello world

```

其中 Content-Range 字段，0-9 表示请求的返回，100 表示资源的总大小；

##### 2-3-8-2、Range—多段数据

```javascript
// 多段数据
Range: bytes=0-9, 30-39
// 响应报文:
HTTP/1.1 206 Partial Content
Content-Type: multipart/byteranges; boundary=00000010101
Content-Length: 189
Connection: keep-alive
Accept-Ranges: bytes


--00000010101
Content-Type: text/plain
Content-Range: bytes 0-9/96

i am xxxxx
--00000010101
Content-Type: text/plain
Content-Range: bytes 20-29/96

eex jspy e
--00000010101--

```

其中 `Content-Type: multipart/byteranges;boundary=00000010101`，表示：

- 请求一定是多段数据请求
- 响应体中的分隔符是 00000010101

因此，在响应体中各段数据之间会由这里指定的分隔符分开，而且在最后的分隔末尾添上`--`表示结束；



##### 2-3-9、代理相关字段

代理服务器有诸多作用：

- **负载均衡**：客户端请求只会先到达代理服务器，随后通过特定算法(随机算法、轮询、一致性hash、LRU)分发给不同源服务器，让各源服务器负载尽量均衡；
- **保障安全**：利用心跳机制监控后台服务器，一旦发现故障机就移出服务器集群，并对其上下行数据进行过滤，对非法 IP 限流等；
- **缓存代理**：将内容缓存到代理服务器，使客户端可直接从代理获取资源而不用去源服务器；

##### 2-3-9-1、Via

代理服务器需表明自身身份，在 HTTP 传输中留下痕迹，可通过字段 Via 实现记录，其值为在 HTTP 传输中报文传达的顺序：

```javascript
// 客户端 -> 代理1 -> 代理2 -> 源服务器
// 源服务器收到请求后，在请求头部拿到:
Via: proxy_server1, proxy_server2

// 客户端收到响应后，在响应头部拿到:
Via: proxy_server2, proxy_server1
```

##### 2-3-9-2、X-Forwarded-For

记录 <u>请求方(包括代理)</u> IP 地址的字段，表示为谁转发；

- 此外：还有 `X-Forwarded-Host` 和 `X-Forwarded-Proto`，分别记录 `域名` 和 `协议名` (注意：此刻又不包括代理)；
- 问题：`X-Forwarded-For` 的值会随着代理的变更而变更，即代理必须解析 HTTP 请求头，然后才可进行修改，比直接转发数据效率低；且在 HTTPS 通信加密的过程中，原始报文是不允许修改的；
- 解决：通过 <u>代理协议</u> 解决：在HTTP 请求行上面加上以下格式文本：

```http
// PROXY + TCP4/TCP6 + 请求方地址 + 接收方地址 + 请求端口 + 接收端口
PROXY TCP4 0.0.0.1 0.0.0.2 1111 2222
GET / HTTP/1.1
...
```

##### 2-3-9-3、X-Real-IP

记录最初客户端的 IP 的字段，而不管经过多少代理；



##### 2-3-10、缓存相关字段

强缓存与协商缓存请看浏览器一章，总结如下：

- 首先，通过 `Cache-Control` 验证强缓存是否可用
  - 若强缓存可用，直接使用，不发送请求；
  - 否则进入协商缓存，发送 HTTP 请求，服务器通过请求头中的 `If-Modified-Since` 或 `If-None-Match` 的这些 <u>条件请求字段</u> 检查资源是否更新
    - 若资源更新，则返回资源和 200 状态码
    - 否则返回 304 状态码，告诉浏览器应直接从缓存获取资源；

代理缓存：即专门负责提供资源缓存服务的代理服务器，分管源服务器的 HTTP 缓存，减少源服务器压力(尤其是流量巨大时段)，客户端缓存过期后可 <u>就近</u> 到代理缓存中获取，而代理缓存过期时则请求源服务器，缓存代理的控制分为 2 部分：<u>源服务器端的控制</u>，<u>客户端的控制</u>：

- **<u>源服务器的缓存控制</u>**

##### 2-3-10-1、private 和 public

源服务器通过在响应中加上 `Cache-Control` 字段来进行缓存控制，其值通常为：

- `public`：允许代理服务器缓存；
- `private`：禁止代理服务器缓存；
- 注意：此举能防范极私密数据，缓存到代理服务器，从而被恶意用户访问获取；

##### 2-3-10-2、proxy-revalidate

- `must-revalidate`：指示**客户端**缓存过期就去源服务器获取；

- `proxy-revalidate`：指示**代理服务器**缓存过期后到源服务器获取；



##### 2-3-10-3、s-maxage

限定缓存在 <u>代理服务器</u> 中可存放多长时间，`s` 即 `share`，与限制客户端缓存时间的 `max-age` 并不冲突

```javascript
// 源服务器在响应头
Cache-Control: public, max-age=1000, s-maxage=2000
// 表示此响应允许代理服务器缓存，客户端缓存过期则到代理中拿，且在客户端的缓存时间为 1000 s，在代理服务器中的缓存时间为 2000 s;
```



- **<u>客户端的缓存控制</u>**

##### 2-3-10-4、max-stale 和 min-fresh

客户端的请求头中，可加入这 2 个字段，来对代理服务器上的缓存进行 <u>宽容</u> 和 <u>限制</u> 操作：

```
max-stale: 10
// 表示客户端从代理服务器上拿缓存时，即使代理缓存过期也不要紧，只要过期时间在 10 秒之内，就可从代理中获取
min-fresh: 5
// 表示代理缓存需要一定新鲜度，不要等到缓存刚好到期再拿，一定要在到期前 5 秒前的时间拿，否则拿不到
```



##### 2-3-10-5、only-if-cached

表明客户端只接受代理缓存，而不接受源服务器响应；若代理缓存无效，则直接返回 `504（Gateway Timeout）`





#### 2-X、其他补充

##### 2-X-1、URI—统一资源标识符

**<u>*URI(Uniform Resource Identifie)*</u>** 包含 URL 与 URN 两部分，其作用是区分互联网上不同的资源；其只能使用 ASCII 编码，不支持显示 ASCII 以外字符，为顺利表示其他字符，URI 引入一套编码机制：将所有 **<u>非 ASCII 码字符和界定符</u>** 转为十六进制字节值，然后在前面加个 `%`；比如空格被转义成了 `%20`；URI 结构如下：
<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200907235847.png" style="zoom:40%;" align="center"/>

- **scheme**：协议名；诸如 `http`、 `https`、 `file` 等，须跟 `://` 连用；
- **user:passwd@**：表示登录主机时的用户信息，不安全，不推荐使用，不常用；
- **host:port**：主机名:端口；
- **path**：请求路径，标记资源所在位置；
- **query**：查询参数，键值对形式，键值对间用 `&` 分隔；path 与 query 则用 `?` 分隔；
- **fragment**：URI 所定位的资源内的<u>锚点</u>，浏览器可根据此<u>锚点</u>跳转到对应的位置；

```http
https://www.baidu.com/s?wd=HTTP&rsv_spt=1
scheme = https
host:port = www.baidu.com (http 和 https 的默认端口分别为80、443)
path = /s
query = ?wd=HTTP&rsv_spt=1
```



##### 2-X-2、内容协商

即每个 URI 指向的资源可是任何事物，可有很多不同的表述；对于文档来说，可有不同的语言、不同的媒体格式，并针对不同的浏览器提供不同的压缩编码。

- 主动式内容协商：客户端在请求头部中提出需要的表述形式，服务器根据其来进行特定表述
- 响应式内容协商：服务端返回 300 或者 406，由客户端选择一种表述

协商要素

- 质量因子q：内容的质量、可接受类型的优先级
- 媒体资源的 MIME 类型
- 字符编码 (UTF-8)
- 内容编码 (Accept-Encoding:gzip,deflate,br)
- 表述语言 (Accept-Language:zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7)
- 国际化与本地化 (i18n,l10n)








### 三、HTTPS

#### 3-1、基本介绍

HTTP 特性是明文传输，对外完全透明，传输的任一环节(TCP、路由、运营商等)都有可能被第三方窃取或篡改(中间人攻击)，为确保安全性，继而诞生 HTTPS；

但实际上 HTTPS 并非新协议，而是在 HTTP 之下，新增一层 SSL/TLS 协议的集合的统称，即：`HTTPS = HTTP + SSL/TLS`；

即 <u>HTTPS 是在 HTTP 与  TCP 间加入 SSL/TLS  安全套接层</u>，HTTP 向 TCP 通讯时，须先经过此中间层进行加密，中间层则将加密后的数据传给 TCP；

TCP 向 HTTP 通讯时，须将数据交由中间层解密才能传给上层 HTTP；这个中间层也叫安全层，其核心作用是对数据加解密；

综述：HTTPS 并非新协议，它只是在 HTTP 和 TCP 的传输中建立了一个安全层，并利用 `对称加密` 和 `非对称加密` 结合方式 + 数字证书认证，提高传输安全性；

- 注意：HTTPS 也存在一些问题，那就是当使用 SSL 时，它的处理速度会变慢：通信慢、由于大量消耗 CPU 及内存等资源，导致处理速度变慢。
  - 与 HTTP 相比，网络负载可能会慢 2 到 100 倍，除去 TCP 连接、发送 HTTP 请求响应外，还须进行 SSL 通信，因此整体上处理通信量不可避免会增加；
  - 此外 SSL 须进行加密处理：在服务器和客户端都均需进行加密/解密运算处理，因此会更多地消耗服务器和客户端的硬件资源，导致负载增强；
  - 缓解：可使用SSL 通信专用硬件缓解；
- 注意：并非所有信息都要求用 HTTPS 通讯，建议只在包含个人信息等敏感数据时，才利用 HTTPS 加密通信；
- 注意：因成本原因、历史原因，HTTPS 并未广泛使用和推广，HTTPS 与 HTTP 的交互涉及后端内容；




#### 3-2、加密方式与应用

##### 3-2-1、加密演变(greate)

##### 3-2-1-1、对称加密(大门钥匙)

最简单的加密方式，指 **加密** 和 **解密** 使用的是 **相同的密钥**；即：客户端和服务器公用一个密匙用来对消息加解密；客户端和服务器约定好一个加密的密匙。客户端在发消息前用该密匙对消息加密，发送给服务器后，服务器再用该密匙进行解密拿到消息；

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200907235848.png" style="zoom:50%;" />

意义：在一定程度上保证数据的安全性，但密钥一旦泄露(密钥在传输过程中被截获)，传输内容就会暴露，因此需要寻找一种更为安全传递密钥的方法；



##### 3-2-1-2、非对称加密(加解密须协作完成)

采用非对称加密，客户端和服务端均拥有一个公有密匙和一个私有密匙。公有密匙可以对外暴露，而私有密匙只有自己可见；使用公有密匙加密的消息，只有对应的私有密匙才能解开。反过来，使用私有密匙加密的消息，只有公有密匙才能解开；这样客户端在发送消息前，先用服务器的公匙对消息进行加密，服务器收到后再用自己的私匙进行解密；

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200907235849.png" style="zoom:50%;" />

意义：虽解决由于密钥被获取而导致传输内容泄露问题，但中间人仍可用 `篡改(劫持)公钥`的方式来获取/篡改传输内容，且非对称加密的性能比对称加密的差；

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200907235850.png" style="zoom:50%;" />



##### 3-2-1-3、数字证书

上述问题在于：客户端不知道公钥是由服务端返回，还是中间人返回；由此可引入一个第三方认证的环节：即第三方使用私钥加密客户端的 `自己的公钥`，浏览器已内置一些权威第三方认证机构的公钥，浏览器会使用`第三方的公钥`来解开`在服务端用第三方的私钥加密过的，发往客户端的公钥`，从而使得客户端获取公钥(它的思想是中间人无法获取此公钥，资质审核)，若能成功解密，**<u>则说明获取到公钥是合法的(但仍无法确定是否被篡改，因为"水平厉害"的中间人也能申请证书，只能防范"水平一般"的中间人)</u>**；**证书的申请流程看：3-2-1-4**

意义：第三方认证也未能完全解决问题，第三方认证是面向所有人，中间人也能申请证书，若中间人使用自己证书掉包原证书，客户端还是无法确认公钥真伪；

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200907235851.png" style="zoom:50%;" />



##### 3-2-1-4、数字签名

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200907235852.png" style="zoom:40%;" align=""/>

上述问题在于：传输过程中内容可能被篡改，证书可能被调包，为解决通信方身份遭伪装问题，验明通信方的身份；此时可引入 <u>数字签名</u>，以保证数据完整性(一旦中途被篡改即可发现)，**<u>而数字签名随数字证书的申请流程绑定，具体流程如下</u>**：

- 首先，服务器的运营人员会向 <u>双方皆信任的权威数字认证机构(简称CA)</u> 提交 服务器的公钥、组织信息、个人信息、网站等信息并申请认证；
- 然后，CA 在拿到这些信息后会通过线上、线下等各种途径验证申请者提交信息的真实性；
- 然后，在确认其真实性后，CA 给 <u>明文信息</u> 进行数字签名：(注意：将申请者的公钥、组织信息、个人信息及 CA 自己的信息等简称为 <u>明文信息</u>；)
  - 首先，通过单向 Hash 算法(比如MD5)，处理明文信息，生成一串信息摘要；
    - 注意：此摘要是上述信息的 <u>唯一标识(一旦构成数字签名的信息发生变化，Hash 值就会改变)</u>；
  - 然后，CA 使用自身私钥对信息摘要进行加密，此时，生成的文件即 **<u>数字签名</u>**；
- 最后，CA 会将 **<u>明文信息 和 数字签名 组合而成的证书</u>**，颁发给申请者，也即服务器；
- **<u>上述为颁发流程，颁发到申请者手中时，申请者还需验证是否本体：</u>**
  - 首先，CA 会将原文、数字签名(也就是加密后的摘要)一起发送给申请方；
  - 然后，申请方接收后，利用用 Hash 函数处理原文，得到消息摘要A；同时用发送方的公钥(浏览器自带)解密 数字签名得到消息摘要B；
  - 最后，只要比对两份消息摘要是否相等，即可验证出数据有无被篡改；(相等意味着证明了 CA 颁发可信任，数据没有被篡改)
  - 注意：验证证书的过程不仅是数字签名的验证，客户端还会验证证书相关的域名信息，有效时间，是不是在CRL吊销列表里，和它的上一级是否有效等；
  - 注意：验证上一级是否有效是一个递归过程，直到验证到根证书也即操作系统内置的 Root 证书或浏览器内置 Root 证书为止；
- **<u>下述为客户端验证流程，验证服务器证书是否被篡改：</u>**
  - 浏览器拿到数字签名后，会使用 <u>浏览器本地内置</u> 的 CA 公钥解开数字证书并验证，验证流程类似同上，验证通过则拿到正确公钥；
  - 由于非对称加密性能低下，拿到公钥以后，客户端会随机生成一个对称密钥，使用这个公钥加密并发送给服务端，服务端用自己的私钥解开对称密钥，此后的加密连接就通过这个对称密钥进行对称加密；

综上：HTTPS 在验证阶段使用  <u>非对称加密</u> + <u>数字证书</u> + <u>数字签名</u> **获取正确的公钥**，获取到正确的公钥后以 <u>对称加密</u> 的方式通信；

- 非对称加密：增加握手期攻击成本；
- 数字证书：防范无证书认证攻击者；
- 数字签名：防范有认证证书的攻击者；
- 对称加密：降低成本，提高效率





##### 3-2-2、加密的应用

浏览器和服务器进行协商加解密

- **使用对称加密应用**：
  - 首先，浏览器向服务器发送随机数 `client_random` 、加密方法列表；
  - 然后，服务器接收后，给浏览器返回 `server_random`、加密方法；
    - 此时，两者拥有三样相同凭证：`client_random`、`server_random`、加密方法；
  - 最后，双方利用加密方法，利用 2 个随机数生成密钥，此密钥就是浏览器和服务端通信的 <u>密钥</u>；
  - **<u>缺点</u>**：若传输途中被三方窃取，则可轻易制造相同密钥；

- **使用非对称加密**(比对称加密多传送公钥)：
  - 服务器保存 **<u>公钥</u>(所有客户端均可获得并被分配到)** 与 **<u>私钥</u>(只有服务端自身知道)**
  - 首先，浏览器向服务器发送 `client_random` 、加密方法列表；
  - 然后，服务器接收后，给浏览器返回 `server_random`、加密方法、**<u>公钥</u>**；
    - 此时，两者拥有三样相同凭证：`client_random`、`server_random`、加密方法；而服务器含公私两钥，客户端含公钥；
  - 然后，浏览器利用加密方法，使用 **<u>公钥</u>** 将 `client_random` 和 `server_random` 加密，生成与服务器通信的 <u>密钥</u>；
    - 注意：<u>非对称加密：公钥加密的数据只能用私钥解密，私钥加密的数据只能用公钥解密</u>；
  - **<u>优点</u>**：可防范中间人窃取客户端发出的信息并破解(因无私钥)；
  - **<u>缺点</u>**：安全问题：因服务器数据只能使用私钥进行加密(无法利用公钥加密否则客户端无法解密)，所以一旦中间人截取到公钥(第二步)，则无法阻止其窃取从服务端发出的消息；
  - **<u>缺点</u>**：能消耗问题；

- **使用对称与非对称相结合的加密形式：**
  - 首先，浏览器向服务器发送 `client_random`、加密方法列表；
  - 然后，服务器接收后，给浏览器返 `server_random`、加密方法、**<u>公钥</u>**；
    - 此时，两者拥有三样相同凭证：`client_random`、`server_random`、加密方法；而服务器含公私两钥，客户端含公钥；
  - 然后，浏览器接收后，生成另一个随机数 `pre_random`，并用公钥加密，回传给服务器，后者则用私钥解密这个被加密后的 **<u>pre_random</u>**；
    - 此时，两者拥有四样相同凭证：`client_random`、`server_random`、`pre_random`、加密方法；而服务器含公私两钥，客户端含公钥；
  - 然后，双方通过相同加密方法，利用三个随机数，生成最终 <u>密钥</u>；
  - 最后，浏览器和服务器使用同样的密钥进行通信，即使用 <u>对称加密</u>；
  - <u>**优点**</u>：安全性提升：最重要是 **防止了私钥加密的数据外传**，单纯使用非对称加密时是通过传送的公钥进行加密得到的密钥，但公钥在飞行过程中可能会被截获，但此处公钥只是作为生成生成最终密钥的所需参数 `pre_random`(并无直接参与密钥的生成)，而此参数发往服务端时，即便被中间人截获，因无私钥也无法破译；从而保证了安全；
  - **<u>缺点</u>**：若所有步骤均被监听窃取……
  - **<u>缺点</u>**：若服务器是假的……
- **使用数字证书**：为解决上述安全问题：若黑客如果采用 DNS 劫持，将目标地址替换成黑客服务器地址，然后黑客再伪造一份公私钥，则照样能进行数据传输；而对于浏览器用户而言，无法知道自己正访问一个危险服务器；解决方式是引入 **<u>数字证书，让服务器证明自己的合法身份</u>**；而为获取数字证书，服务器运营者需要向 ***<u>第三方认证机构 CA—Certificate Authority</u>*** 获取授权，通过认证则向服务器颁发 **数字证书**，其作用如下：
  - 服务器向浏览器证明自己的身份；
  - 将公钥传给浏览器；

随后，当客户端欲发起 TLS 握手时，服务器接收请求后，会响应 `server_random`、加密方法、**<u>数字证书(包含公钥)</u>**；

然后，在浏览器接收之后，就会开始验证数字证书；若验证通过，则后续过程照常进行，否则拒绝执行；验证流程：

- 首先，读取证书中的明文内容；CA 进行数字证书的签名时会保存一个 Hash 函数，此函数用来计算明文内容得到 `信息A`；
- 然后，用公钥解密明文内容得到 `信息B`，将两份信息进行比对，一致则表示认证合法；
- 注意：CA 的可信任性通过层级保证，若浏览器无法信任 CA，其会查找 CA 的上级 CA，以同样的信息比对方式验证上级 CA 的合法性，而一般根级的 CA 会内置在操作系统当中；若向上找没有找到根级的 CA，则将被视为不合法；



#### 3-3、TLS (SSL)

​	***SSL(Secure Sockets Layer—安全套接层)***，在 OSI 七层模型中处于第5层会话层；此前 SSL 出过 3 个大版本，当它发展到第 3 个版本时被标准化，成为 ***TLS(Transport Layer Security—传输层安全)***，并称 TLS1.0 版本 (SSL3.1)；目前主流版本是 <u>TLS1.2</u>，之前的 TLS1.0、TLS1.1 均被认为是不安全，在不久将来会被完全淘汰；而在 2018 年 <u>TLS1.3</u> 问世，更大大优化 TLS 握手过程；



#### 3-4、TLS 握手过程

- 第一阶段：建立安全能力 包括协议版本 会话Id 密码构件 压缩方法和初始随机数
- 第二阶段：服务器发送证书 密钥交换数据和证书请求，最后发送请求-相应阶段的结束信号
- 第三阶段：如果有证书请求客户端发送此证书 之后客户端发送密钥交换数据 也可以发送证书验证消息
- 第四阶段：变更密码构件和结束握手协议

##### 3-4-1、TLS 握手—RSA

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200907235853.png" style="zoom:60%;" />

- 首先，浏览器向服务器发送 `client_random`、TSL 版本号、加密方法套件(含 RSA)；
- 然后，服务器接收后，给浏览器返 `server_random`、确认 TSL 版本号、加密方法套件(含 RSA)、**<u>数字证书(含公钥)</u>**；
  - 此时，两者拥有三样相同凭证：`client_random`、`server_random`、加密方法；而服务器含公私两钥，客户端含公钥；
- 然后，在浏览器接收之后，就会开始验证数字证书；若验证通过，浏览器利用 **<u>RSA</u>** 生成另一个随机数 `pre_random`，并利用服务器公钥(从证书中获取)进行加密，回传给服务器，后者则用私钥解密得到 **<u>pre_random</u>**；
  - 此时，两者拥有四样相同凭证：`client_random`、`server_random`、`pre_random`、加密方法；而服务器含公私两钥，客户端含公钥；
- 然后，双方通过相同加密方法，利用三个随机数，通过一个 <u>伪随机函数</u> 生成最终 <u>密钥</u>；
- 最后，浏览器和服务器使用同样的密钥进行通信，即使用 <u>对称加密</u>；



##### 3-4-2、TLS1.2 握手—ECDHE

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200907235854.png" style="zoom:60%;" />

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200907235855.png" style="zoom:60%;" />

- 首先，客户端在首次发送 HTTPS 请求时，会将以下内容发送给服务器；
  - TLS 版本号；
  - `随机值A—client_random`；
  - 加密套件列表；
  - (或自身证书，以供服务端验证自身身份和防信息篡改)；
- 然后，服务器在接收确认 TLS 版本号，同时发送以下内容给客户端(注意：此步若需验证客户端证书需要说明；)；
  - `随机值B—server_random`；
  - `server_params`；
  - 需要使用的加密套件；
  - 服务器证书；
- 然后，客户端在收到信息后，首先会对 <u>服务器证书</u> 进行验证：
  - 若验证成功，表示可利用服务端返回的数据有如下内容，并生成和回送  `client_params` 给服务器；
    - `随机值B—server_random`；
    - `server_param`；
  - 同时，客户端会通过 **<u>ECDHE算法</u>**，利用参数 `client_params`、 `server_params` 计算出一个 `随机值C—pre_random`；
  - 补充：ECDHE 基于椭圆曲线离散对数，传入的两个参数也被叫做椭圆曲线的公钥：`ECDHE(client_params,  server_params) = per_random`；
  - 此时，客户端同时拥有下述参数，并利用此些参数通过 **伪随机函数** 计算得出最终后续通信所使用的 <u>**对称密钥 secret**</u>；
    -  `随机值A—client_random`；
    - `随机值B—server_random`；
    - `随机值C—pre_random`；
- 然后，客户端生成完 <u>对称密钥</u> 后，会给服务器发送 <u>收尾消息</u>，告知服务器后续使用对称加密，且对称加密的算法采用首次请求时约定好的；
- 然后，服务器接收到传递来的 `client_params` 后，也会使用和客户端一样的方式，生成  <u>**对称密钥 secret**</u>，并且也会发送 <u>收尾消息</u> 给客户端；
- 最后，当双方都收到收尾消息并验证成功后，握手结束；后面开始用此 <u>对称密钥</u> 加密报文进行传输；
- 总结：在 TLS 握手阶段，两端使用非对称加密方式通信，但因非对称加密损耗的性能比对称加密大，所以在正式传输数据时，两端使用对称加密的方式通信；
- 总结：HTTPS 在验证阶段使用  <u>非对称加密</u> + <u>数字证书</u> + <u>数字签名</u> **获取正确的公钥**，获取到正确的公钥后以 <u>对称加密</u> 的方式通信；
  - 非对称加密：增加握手期攻击成本；
  - 数字证书：防范无证书认证攻击者；
  - 数字签名：防范有认证证书的攻击者；
  - 对称加密：降低成本，提高效率

补充：简化版

- Client 发送 `random1+对称加密套件列表+非对称加密套件列表`
- Server 收到信息， 选择 `对称加密套件+非对称加密套件 并和 random2+证书(公钥在证书中)` 一起返回
- Client 验证证书有效性，并用 `random1+random2 生成 pre-master 通过服务器公钥加密+浏览器确认` 发送给 Server
- Server 收到 `pre-master`，根据约定的加密算法对 `random1+random2+pre-master（解密）生成 master-secret`，然后发送服务器确认
- Client 收到生成同样的 `master-secert`，对称加密秘钥传输完毕

`TLS1.3` 则简化了握手过程，完全握手只需要一个消息往返，提升了性能。不仅如此，还对部分不安全的加密算法进行了删减。



##### 3-4-2-1、Client 协商

浏览器向服务端发送 TLS 版本、client_random、加密套件列表：

- TLS 版本：略；

- `client_random`：用以最终生成 secret 的一个参数；
- 使用的加密套件列表：`TLS_ECDHE_WITH_AES_128_GCM_SHA256`(类似形式)
  - 含义：`TLS` 握手过程中，使用 `ECDHE` 算法生成 `pre_random`，并用 `128` 位的 `AES` 算法进行对称加密，且加密过程中使用主流的 `GCM `分组模式(如何分组是对称加密中很重要的问题)，并告知采用 `SHA256` 算法作为 <u>哈希摘要算法</u>；



##### 3-4-2-2、Server 协商

服务端向客户端回送 `server_random`、`server_params`、确认 TLS 版本、使用的加密套件列表、服务器使用证书；

- 确认 TLS 版本：略；

- `server_random`：用以最终生成 `secret` 的一个参数；
- 使用的加密套件列表：`TLS_ECDHE_WITH_AES_128_GCM_SHA256`(类似形式)
  - 含义：`TLS` 握手过程中，使用 `ECDHE` 算法生成 `pre_random`，并用 `128` 位的 `AES` 算法进行对称加密，且加密过程中使用主流的 `GCM `分组模式(如何分组是对称加密中很重要的问题)，并告知采用 `SHA256` 算法作为 <u>哈希摘要算法</u>；
- 服务器使用证书：用于供客户端验证(验证通过则生成 `client_params`：用于计算 `pre_random` 的一个参数2/1)

- `server_params`：用于计算 `pre_random` 的一个参数2/2；



##### 3-4-2-3、Client 验证证书并生成 secret

客户端验证服务端传来的证书和签名是否通过，若验证通过，则生成并传递参数 `client_params` 给服务器；随后客户端通过 `ECDHE` 算法，传入参数 `server_params` 和 `client_params`，计算出 `pre_random`；(`ECDHE` 基于椭圆曲线离散对数，传入的两个参数也称作椭圆曲线的公钥)；此刻客户端拥有 **<u>client_random</u>**、**<u>server_random</u>**、**<u>pre_random</u>**，最后利用此 3 个数，通过一个伪随机数函数来计算出最终 `secret`；



##### 3-4-2-4、Server 生成 secret

服务端接收客户端的 `client_params`，通过 `ECDHE` 算法，传入参数 `server_params` 和 `client_params`，计算出 `pre_random`；最后，使用与客户端同样的伪随机数函数生成最终 `secret`；



##### 3-4-2-5、注意事项

- 注意(待定)：验证数字证书阶段：服务端利用自身数字证书信息，通过哈希摘要算法，生成一个 **摘要(字符串)** ，用以 **标识** 自身身份，并利用私钥加密，随后将 **加密后的标识(摘要)**，连同 **自身公钥** 传给客户端；随后客户端通过 **公钥** 来解密，生成另外一份摘要；对前后 2 个摘要进行对比，若相同则能确认服务端的身份；此亦就 **数字签名** 原理；整一过程中，除了哈希算法，最重要 **私钥加密，公钥解密**；
  - 若传输过程信息被窃取，则窃取人可获取公钥、解密标识…
  - 若不考虑传输过程的信息窃取，则关键是对数字证书的可信任性；
- 综述：TLS 目的是双方约定唯一 `serect` 进行加密解密操作，类似过去的密码表，但现今还要先确认双方关系，及避免传输过程被三方窃取篡改；`serect` 通过 **<u>client_random</u>**、**<u>server_random</u>**、**<u>pre_random</u>** 生成，前两者通过双方协商传输获得，后者须通过 **<u>server_params</u>** 和 **<u>client_params</u>** 计算得到，而这两个值须通过各自校验后才会生成并发送对方；比如 client_params 的生成须先验证服务端响应的数字证书，通过后才生成，如此确认双方身份；
- 注意：TLS 握手是一个双向认证的过程：前两次传输中，双方均向对方发送了：TLS版本相关内容、**<u>xxx_random</u>**、使用的加密套件列表，而服务端向客户端多发送了数字证书与 **<u>server_params</u>**，目的是供客户端校验服务端身份；校验通过后，客户端生成 **<u>client_params</u>** 并回传，此时服务端也要验证客户端身份，即同样需要走：哈希摘要 + 私钥加密 + 公钥解密 的认证流程；
- 注意：客户端生成 `secret` 后，会给服务端发送一 **<u>*收尾消息*</u>**，告诉服务器之后内容都用对称加密，对称加密的算法就用首次约定的方式；服务端亦然；而此收尾消息包括以下 2 部分，当双方均验证通过后，TLS 握手才正式结束，后续 HTTP 正式开始传输加密报文：
  - Change Cipher Spec：表示后续内容加密传输；
  - Finished消息：此消息是对之前所有发送的数据做的摘要，对摘要进行加密，让对方验证一下；
- 注意：**<u>ECDHE 算法</u>** 利用了 <u>椭圆曲线和离散对数</u> 等思想，按当下计算机算力，很难在短时间进行破解。且每次握手时生成的都是一对临时的公钥和私钥，这样就保证每次的密钥对也不同；即使大费力气破解某次密钥，之前的历史消息也不会受到影响，保证了 <u>前向安全</u>；当然，TLS 协议的安全性受限于当下最快的计算机运行速度，理论上绝对安全的是 <u>量子通讯传递密钥</u>；
- 注意：**<u>RSA 和 ECDHE 握手过程的区别：</u>**

  - 生成对称密钥过程不同：RSA 是使用 RSA 算法生成一个 `pre_random` 并用服务器的公钥加密 `pre_random` 发送给服务器，然后各自用 伪随机函数生成相同的 <u>对称密钥</u>；而在 ECDHE握手中，没有用到 RSA算法，而是用 ECDHE 算法生成的 pre_random，且这个过程中比 RSA 多了 client_params 和 server_params 两个参数；
  - 使用 `ECDHE`，客户端发送完收尾消息后即可提前抢跑，直接发送 HTTP 报文，不必等到收尾消息到达服务器，节省一个 RTT；然后等服务器返回收尾消息给自己，直接开始发请求，这也叫`TLS False Start`；
  - 最主要区别：RSA不具备向前安全性(一次破解并不影响历史信息的性质就是向前安全性)，ECDHE 有；
    - 向前安全性：
    - 比如：RSA 握手过程中，客户端拿到服务端公钥，然后利用公钥加密 `pre_random` 给服务端；若此时有第三方有服务端的私钥，并且截获之前所有报文时，则它就可以破解这段密文并拿到 `pre_random`、`client_random`、`server_random`，并根据对应的伪随机函数生成 secret，即拿到最终通信的 <u>对称密钥</u>，每一个历史报文都能通过这样的方式进行破解，不具有向前安全性；
    - 但是：ECDHE 在每次握手的时候都会产生一个零时的密钥对(也即 `client_params`、`server_params`)，即使第三方有私钥可以破解，但对之前的历史报文并没有影响，它就具有向前安全性；
- 注意：总的来说 HTTPS 比 HTTP 安全在：

  - 通过混合加密保证传输的数据不被窃听
  - 通过数字签名的方式保证数据不会被篡改
  - 通过数字证书保证服务器身份的真实性



##### 3-4-2-6、疑问合集

- 若握手期间信息被三方窃取(WIFI)并最终掌握 sercet 怎么办? ——数字签名防范此类问题；
- 若中间人不修改证书只修改 server_param 怎么办？—— 无法生成相一致的对称密钥，无法通信；
- 若中间人不作任何修改，只监听和盗取怎么办?——全链路 HTTPS；
- 与 [TLS 中间人攻击](https://www.zhihu.com/question/20744215) 有何不同?



#### 3-5、TLS 1.3

TLS 1.3 主要对 TLS 1.2 做了系列改进：废除大量算法，提升安全性，同时利用会话复用，节省重新生成密钥时间，并利用 `PSK`  实现 `0-RTT` 连接：

##### 3-5-1、安全提升

TLS1.3 废除大量有安全漏洞的加密算法，且最后只保留 5 个加密套件：

`TLS_AES_128_GCM_SHA256`、`TLS_AES_256_GCM_SHA384`、`TLS_CHACHA20_POLY1305_SHA256`、`TLS_AES_128_GCM_SHA256`、`TLS_AES_128_GCM_8_SHA256`

- 对称加密算法：保留 **AES** 和 **CHACHA20**；
- 分组模式：保留 **GCM** 和 **POLY1305**；
- 哈希摘要算法：保留 **SHA256** 和 **SHA384**；

去除 RSA 加密原因：

- 2015年发现了`FREAK`攻击，即已有人发现了 RSA 的漏洞，能够进行破解；
- 一旦私钥泄露，那么中间人可以通过私钥计算出之前所有报文的`secret`，破解之前所有的密文；
  - RSA 握手的过程中，客户端拿到服务器的证书后，提取出服务器的公钥，然后生成`pre_random`并用**公钥**加密传给服务器，服务器通过**私钥**解密，从而拿到真实的`pre_random`。当中间人拿到了服务器私钥，并且截获之前所有报文的时候，那么就能拿到`pre_random`、`server_random`和`client_random`并根据对应的随机数函数生成`secret`，也就是拿到了 TLS 最终的会话密钥，每一个历史报文都能通过这样的方式进行破解；
  - 但 `ECDHE` 在每次握手时都会生成临时的密钥对，即使私钥被破解，之前历史消息并不会收到影响。此类一次破解并不影响历史信息(向前安全性)；即 `RSA` 算法不具备前向安全性，而 `ECDHE` 具备，因此在 TLS1.3 中彻底取代了`RSA`。



##### 3-5-2、性能提升

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200907235856.png" style="zoom:60%;" />

TLS 1.3 握手流程大体与 TLS1.2 类似，但比后者减少一个 RTT， 服务端不必等待对方验证数字证书后才能拿到 `client_params`，而是直接在首次握手时即可拿到， 拿到后由 **<u>client_random</u>**、**<u>server_random</u>**、**<u>pre_random(client_params、server_params)</u>  **立即计算 `secret`，节省大量非必需等待时间；此种握手方式亦称 **1-RTT 握手**，此外还可在此基础上进行进一步优化：

- 会话复用—1RTT优化
  - Session ID 方式：首先，客户端和服务器首次连接后各自保存会话 ID，并存储会话密钥；然后，当再次连接时，客户端发送会话 ID，服务器根据 ID 是否存在，选择直接复用先前会话状态、重用会话密钥；或拒绝；缺点是当客户端数量庞大时，对服务端存储、性能要求非常大；
  - Session Ticket 方式：针对上一种方式存在的问题，将服务端压力分摊给客户端(卑鄙)；首先，双方连接成功后，服务器 加密并将 Session Ticket 发给客户端并告知存储；然后客户端下次重连时，发送 Ticket，服务端解密后验证过期与否，若无则直接恢复先前会话状态；缺点是存在安全问题，每次用一个固定密钥来解密 Ticket 数据，一旦黑客拿到密钥，先前所有历史记录也被破解，故密钥需要定期进行更换；

- PSK(Pre-Shared Key)—0RTT优化：
  - 优化至 0RTT：在发送 Session Ticket 的同时携带应用数据，而不用等到服务端确认；缺点是存在安全问题，中间人截获 PSK 数据，不断向服务器发送，类似于 TCP 首次握手即携带数据，增加了服务器被攻击的风险；



#### 3-x、补充

##### 3-X-1、混合加密

对称密钥加密和非对称密钥加密都有它们各种的优缺点，而混合加密机制就是将两者结合利用它们各自的优点来进行加密传输。

比如既然对称密钥的优点是加解密效率快，那么在客户端与服务端确定了连接之后就可以用它来进行加密传输。不过前提是得解决双方都能安全的拿到这把对称密钥。这时候就可以利用非对称密钥加密来传输这把对称密钥，因为我们知道非对称密钥加密的优点就是能保证传输的内容是安全的。

所以它的好处是即保证了对称密钥能在双方之间安全的传输，又能使用对称加密方式进行通信，这比单纯的使用非对称加密通信快了很多。以此来解决了HTTP中内容可能被窃听的问题。







### 四、HTTP/2

HTTPS 专注于安全提升，而 HTTP/2 则专注性能方面的提升(头部压缩、多路复用)，并增加诸多功能(设置请求优先级、服务器推送)；

在 HTTP/1 中，为性能考虑，会引入雪碧图、将小图内联、使用多个域名等等的方式；这一切都是因为浏览器限制了同一域名下的请求数量(Chrome-6)，当页面中需要请求很多资源时，队头阻塞（Head of line blocking）就会导致在达到最大请求数量时，剩余资源需要等待其他资源请求完成后才能发起请求(排队)；

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200907235857.png" style="zoom:30%;" />

在 HTTP/2 中引入了多路复用的技术，这个技术可只通过一个 TCP 连接就可传输所有的请求数据；多路复用很好的解决了浏览器限制同一个域名下的请求数量的问题，同时也间接更容易实现全速传输，毕竟新开一个 TCP 连接都需要慢慢提升传输速度； [HTTP/1与HTTP/2 速度对比](https://http2.akamai.com/demo) ；

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200907235858.png" style="zoom:30%;" />

​	

#### 4-1、二进制帧

HTTP/2 中所有加强性能的核心点在于此。在之前的 HTTP 版本中，是通过文本的方式传输数据；但在 HTTP/2 中引入了新的编码机制，所有传输的数据都会被分割，并采用二进制格式编码；

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200907235859.png" style="zoom:50%;" />

HTTP/2 将报文全部换成二进制格式，即全部传输`01`串，以方便机器解析，减少因字符多义性的状态问题的判断，提升解析效率；原来的 `Headers + Body` 的报文格式被分拆成<u>**二进制帧**</u>，并使用 <u>Headers帧</u> 存放头部字段，用 <u>Data帧</u> 存放请求体数据；HTTP/2 传输的二进制帧格式如下：

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200907235900.png" style="zoom:50%;" />

每个二进制帧由 **<u>帧头—Frame Header</u>** 和 **<u>帧体—Frame Payload</u>** 组成；

- 帧长度：表示 <u>帧体</u> 的长度；
- 帧类型：可分为 **数据帧** 和 **控制帧** 2 种；前者用来存放 HTTP 报文，后者用来管理 <u>流</u> 的传输，比如实现 **优先级** 与 **流量控制**；
- 帧标志：共有 8 个标志位，常用的有 **END_HEADERS **表示头数据结束，**END_STREAM **表示单方向数据发送结束；
- 流标识符—Stream ID：供接收方从乱序二进制帧中选择出 ID 相同的帧，并按顺序(ID按顺序递增)还原成请求/响应报文；
  - 注意：所谓乱序，指的是不同 ID 的 Stream 乱序发送，但同一 Stream ID 的帧一定是按顺序传输。二进制帧到达后对方会将 Stream ID 相同的二进制帧顺序组装(通过 TCP 顺序性实现)成完整的报文；



##### 4-1-1、流及流的状态变化

通信双方均可给对方发送二进制帧，这种二进制帧的<u>**双向传输的序列**</u>，称作 **<u>*流(Stream)*</u>**；而在 HTTP/2 请求和响应过程中，流的状态变化是通过标志位实现：

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200907235901.png" style="zoom:60%;" />

- 首先，双方均未空闲状态，当客户端发送 `Headers帧` 后，开始分配 `Stream ID` ，此时客户端的 <u>流(序列)</u> 打开，而服务端在接收后也打开 <u>流(序列)</u> ，双方均打开 <u>流(序列)</u>  后，即可互相传递二进制帧；
- 然后，当客户端需要关闭时，向服务端发送 `END_STREAM帧`，进入 `半关闭状态`，此时客户端只能接收数据，不能发送数据；
- 然后，当服务端收到 `END_STREAM帧`，也进入 `半关闭状态`，此时服务端只能发送数据，不能接收数据，与客户端情况相反；
- 随后，服务端向客户端发送 `END_STREAM帧`，表示数据发送完毕，双方进入 `关闭状态`；
- 注意：若下次开启新的 <u>流(序列)</u> ，流 ID 需自增直到上限为止(4字节，最高位保留，范围 0-2^31 ≈ 21 亿)，到达上限后开一个新的 TCP 连接重头开始计数；



##### 4-1-2、流的传输特性

- 并发性：一个 HTTP/2 连接可同时发送多个帧，与 HTTP/1 不同，**<u>这是实现多路复用的基础</u>**；
- 自增性：流 ID 不可重用，按顺序递增，达到上限之后又新开 TCP 连接从头开始(没有回绕问题)；
- 双向性：客户端和服务端均可创建流，互不干扰，双方均可作为发送方或接收方；
- 可设置优先级：通过设置数据帧的优先级，让服务端先处理重要资源，优化用户体验；



#### 4-2、性能提升

##### 4-2-1、头部压缩 HPACK

HTTP/1.1 及低版本中，使用文本的形式传输报文，在携带 cookie 的情况下，可能每次都需要重复传输几百到几千的字节；虽然 <u>请求报文请求体</u> 可通过 `Content-Encoding` 头部字段，指定压缩算法压缩请求体；而 HTTP/2 后，<u>请求报文头部</u> 也可通过 HPACK 压缩算法压缩 (GET 请求头部往往是主体，优化力度大)，HPACK 特点有二：

- 首先，服务器和客户端分别建立、维护哈希表，并将用到的字段存放在此表中，随后在传输时对于先前出现过的值，只需将把索引值传给对方即可，对方拿到索引后查表即可完成字段搜索；让请求头字段得到极大程度的精简和复用；
- 然后，对于整数和字符串进行 <u>哈夫曼编码</u>，此编码原理是：先将所有出现的字符建立一张索引表，然后让出现次数多的字符对应的索引尽可能短，传输时也是传输这样的**索引序列**，可达到非常高的压缩率；
- 注意：HTTP/2 废除了起始行概念，将起始行中的请求方法、URI、状态码转换成头字段，并用前缀 `:` 区分请求头；

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200907235902.png" style="zoom:40%;" />



##### 4-2-2、多路复用

HTTP/2 解决的是 HTTP/1.1存在的问题：

- **TCP 慢启动：** TCP 连接建立后，会经历一个先慢后快的发送过程，如同汽车启动一般，若网页文件(HTML/JS/CSS/icon)都经过一次慢启动，对性能是不小的损耗；另外慢启动是 TCP 为减少网络拥塞的一种策略，没有办法改变；
- **多条 TCP 连接竞争带宽：** 若同时建立多条TCP连接，当带宽不足时就会竞争带宽，影响关键资源的下载；
- **HTTP/1.1 队头阻塞：** 虽 HTTP/1.1长链接可通过一 TCP 连接传输多个请求，但同一时刻只能处理一个请求，当前请求未结束，其他请求就只能被阻塞；

而在 HTTP/2 中，有两个非常重要的概念，分别是帧 (frame) 和流 (stream)；

- 帧代表着最小的数据单位，每个帧会标识出该帧属于哪个流；流也就是多个帧组成的数据流；

多路复用：是 HTTP/2 在一个域名里，只使用一个TCP⻓连接来传输数据，而且请求直接是并行的、非阻塞的，也就是说在一个 TCP 连接中可以存在多条流；可发送多个请求，对端可以通过帧中的标识知道属于哪个请求；通过这个技术，可避免 HTTP 旧版本中的队头阻塞问题、减少多条 TCP 连接竞争带宽问题，极大的提高传输性能；

实现原理： HTTP/2 引入一个二进制分帧层，客户端和服务端进行传输时，数据会先经过二进制分帧层处理，转化为一个个带有请求 ID 的帧，这些帧在传输完成后再根据 ID 组合成对应的数据；通俗说就是：多路复用即 HTTP/2 用 <u>流</u> 来在一个 TCP 连接上来进行多个数据帧的通信；因通过拆分报文为二进制帧，而一个 HTTP/2 连接可同时发送多个帧，且接收端可通过相同 StreamID 帧顺序组合还原报文，发送无先后关系，不用排队发送，故 HTTP/2 从协议层面解决 HTTP队头阻塞问题(前一请求未处理完，后续请求被阻塞(不同于 TCP 队头阻塞，后者是前一个报文数据包未收到就不会将提前到达的后续数据包向上传递，为数据包层面，HTTP 队头阻塞是请求层面))





#### 4-3、功能增加

##### 4-3-1、设置请求优先级

##### 4-3-2、服务器推送(Server Push)

在 HTTP/2 当中，服务器已不再是完全被动地接收响应请求，服务器可以在客户端某个请求后，主动推送其他资源；

当 TCP 连接建立之后，比如浏览器请求一个 HTML 文件，服务器就可在返回 HTML 基础上，将 HTML 中引用到的其他资源一并返回给客户端，减少客户端等待；

而某些资源客户端是一定会请求的，这时亦可采取服务端 push 的技术，提前给客户端推送必要的资源，减少一点延迟时间；

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200907235903.png" style="zoom:40%;" />



### 五、HTTP/3

HTTP/2 仍然存在一些缺陷，但缺陷并非来自 HTTP/2 协议本身，而是来源于底层的 TCP 协议：虽然 TCP 连接是可靠连接，若出现丢包，则整个连接都要等待重传；HTTP/1.1 可同时使用 6 个 TCP 连接，一旦发生阻塞则另外 5 个还能工作，但 HTTP/2 只有1个 TCP 连接，也即阻塞问题被放大；

由于 TCP 协议已被广泛使用，故很难直接修改 TCP 协议，基于此 HTTP/3 选择了折衷办法：QUIC 基于 UDP 实现，是 HTTP/3 中的底层支撑协议，该协议基于 UDP，又取了 TCP 中的精华，实现了即快又可靠的协议；

- 注意：HTTP/3 之前名为 HTTP-over-QUIC，HTTP/3 最大的改造就是使用了 QUIC；

QUIC 虽然基于 UDP，但是在原本的基础上新增了很多功能，比如：<u>多路复用、0-RTT、使用 TLS1.3 加密、流量控制、有序交付、重传</u>等等功能：

- 多路复用：虽然 HTTP/2 支持了多路复用，但是 TCP 协议终究是没有这个功能；但 QUIC 原生就实现了此功能，并且传输的单个数据流可以保证有序交付且不会影响其他的数据流，这样的技术就解决了之前 TCP 存在的问题；并且 QUIC 在移动端的表现也会比 TCP 好，因为 TCP 是基于 IP 和端口去识别连接的，这种方式在多变的移动端网络环境下是很脆弱的，但 QUIC 是通过 ID 的方式去识别一个连接，不管你网络环境如何变化，只要 ID 不变，就能迅速重连上；

- 0-RTT：通过使用类似 TCP 快速打开的技术，缓存当前会话的上下文，在下次恢复会话时，只需要将之前的缓存传递给服务端验证通过就可进行传输；

- 纠错机制：比如发送三个包，则协议会算出这三个包的异或值并单独发出一个校验包，也即总共发出了四个包；当出现其中的非校验包丢包时，可通过另外三个包计算出丢失的数据包的内容；仅限于丢失一个包的情况下，若出现丢失多个包就不能使用纠错机制，只能使用重传的方式；

详看： [http发展史(http0.9、http1.0、http1.1、http2、http3)](https://juejin.im/post/5dbe8eba5188254fe019dabb#heading-9)





### X、转载

