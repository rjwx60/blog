<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>一、基本 | Leibnize 个人学习笔记</title>
    <meta name="generator" content="VuePress 1.5.4">
    
    <meta name="description" content="整理自网络">
    <link rel="preload" href="/docs/assets/css/0.styles.2f643d57.css" as="style"><link rel="preload" href="/docs/assets/js/app.cda475f7.js" as="script"><link rel="preload" href="/docs/assets/js/2.c902c426.js" as="script"><link rel="preload" href="/docs/assets/js/58.d994c1a9.js" as="script"><link rel="prefetch" href="/docs/assets/js/10.418fecbd.js"><link rel="prefetch" href="/docs/assets/js/11.e2c998bf.js"><link rel="prefetch" href="/docs/assets/js/12.b627468b.js"><link rel="prefetch" href="/docs/assets/js/13.682b9b92.js"><link rel="prefetch" href="/docs/assets/js/14.0880e743.js"><link rel="prefetch" href="/docs/assets/js/15.4a6c4027.js"><link rel="prefetch" href="/docs/assets/js/16.200e0299.js"><link rel="prefetch" href="/docs/assets/js/17.1c6394bc.js"><link rel="prefetch" href="/docs/assets/js/18.c0560a2b.js"><link rel="prefetch" href="/docs/assets/js/19.f63607cc.js"><link rel="prefetch" href="/docs/assets/js/20.d56d802e.js"><link rel="prefetch" href="/docs/assets/js/21.52c3ae8e.js"><link rel="prefetch" href="/docs/assets/js/22.b47add39.js"><link rel="prefetch" href="/docs/assets/js/23.a8a40e53.js"><link rel="prefetch" href="/docs/assets/js/24.a0e2af55.js"><link rel="prefetch" href="/docs/assets/js/25.1fb24116.js"><link rel="prefetch" href="/docs/assets/js/26.068130b1.js"><link rel="prefetch" href="/docs/assets/js/27.6cb72d75.js"><link rel="prefetch" href="/docs/assets/js/28.d99e5701.js"><link rel="prefetch" href="/docs/assets/js/29.4848d9ba.js"><link rel="prefetch" href="/docs/assets/js/3.be11a00a.js"><link rel="prefetch" href="/docs/assets/js/30.92ed4a03.js"><link rel="prefetch" href="/docs/assets/js/31.de402b39.js"><link rel="prefetch" href="/docs/assets/js/32.b5ca6564.js"><link rel="prefetch" href="/docs/assets/js/33.c3d91abd.js"><link rel="prefetch" href="/docs/assets/js/34.b868c98b.js"><link rel="prefetch" href="/docs/assets/js/35.4128bd9f.js"><link rel="prefetch" href="/docs/assets/js/36.8e4b22b8.js"><link rel="prefetch" href="/docs/assets/js/37.090897e6.js"><link rel="prefetch" href="/docs/assets/js/38.f8d5752b.js"><link rel="prefetch" href="/docs/assets/js/39.f949333a.js"><link rel="prefetch" href="/docs/assets/js/4.64176cb5.js"><link rel="prefetch" href="/docs/assets/js/40.39833f40.js"><link rel="prefetch" href="/docs/assets/js/41.a12c7b96.js"><link rel="prefetch" href="/docs/assets/js/42.a5e6d9e8.js"><link rel="prefetch" href="/docs/assets/js/43.28874788.js"><link rel="prefetch" href="/docs/assets/js/44.8d4042e3.js"><link rel="prefetch" href="/docs/assets/js/45.b148e845.js"><link rel="prefetch" href="/docs/assets/js/46.91062fd6.js"><link rel="prefetch" href="/docs/assets/js/47.2026c6cc.js"><link rel="prefetch" href="/docs/assets/js/48.b0f3d68f.js"><link rel="prefetch" href="/docs/assets/js/49.9d81175e.js"><link rel="prefetch" href="/docs/assets/js/5.1d876c62.js"><link rel="prefetch" href="/docs/assets/js/50.1a00f734.js"><link rel="prefetch" href="/docs/assets/js/51.b16e53d7.js"><link rel="prefetch" href="/docs/assets/js/52.831b9cca.js"><link rel="prefetch" href="/docs/assets/js/53.4ce4ac34.js"><link rel="prefetch" href="/docs/assets/js/54.6d7ca762.js"><link rel="prefetch" href="/docs/assets/js/55.2bb32bbd.js"><link rel="prefetch" href="/docs/assets/js/56.388173c5.js"><link rel="prefetch" href="/docs/assets/js/57.cd784d78.js"><link rel="prefetch" href="/docs/assets/js/59.0665a00b.js"><link rel="prefetch" href="/docs/assets/js/6.bc091efc.js"><link rel="prefetch" href="/docs/assets/js/60.12f3479d.js"><link rel="prefetch" href="/docs/assets/js/61.679d1273.js"><link rel="prefetch" href="/docs/assets/js/62.04ef0d26.js"><link rel="prefetch" href="/docs/assets/js/63.70e8cd2b.js"><link rel="prefetch" href="/docs/assets/js/64.c7956833.js"><link rel="prefetch" href="/docs/assets/js/65.0304095c.js"><link rel="prefetch" href="/docs/assets/js/66.f16304a7.js"><link rel="prefetch" href="/docs/assets/js/67.d0a945f4.js"><link rel="prefetch" href="/docs/assets/js/68.26e1c58d.js"><link rel="prefetch" href="/docs/assets/js/69.ac162984.js"><link rel="prefetch" href="/docs/assets/js/7.255d7d5f.js"><link rel="prefetch" href="/docs/assets/js/70.5408bf05.js"><link rel="prefetch" href="/docs/assets/js/8.2117996a.js"><link rel="prefetch" href="/docs/assets/js/9.e855c324.js">
    <link rel="stylesheet" href="/docs/assets/css/0.styles.2f643d57.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/docs/" class="home-link router-link-active"><!----> <span class="site-name">Leibnize 个人学习笔记</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="https://github.com/rjwx60" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="https://github.com/rjwx60" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span></span> <span class="arrow down"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h3 id="一、基本"><a href="#一、基本" class="header-anchor">#</a> 一、基本</h3> <h3 id="二、浏览器缓存"><a href="#二、浏览器缓存" class="header-anchor">#</a> 二、浏览器缓存</h3> <p>浏览器中的缓存作用分为 2 种情况，一种是需要发送 HTTP 请求(强缓)，另一种则不用(协缓)；首次缓存、非首次缓存、用户行为与缓存如下：</p> <img src="/Image/Chromium/711.png" align="" style="zoom:50%;"> <img src="/Image/Chromium/712.png" align="" style="zoom:50%;"> <img src="/Image/Chromium/713.png" align="" style="zoom:50%;"> <h4 id="_2-1、强缓存"><a href="#_2-1、强缓存" class="header-anchor">#</a> 2-1、强缓存</h4> <p>首先检查强缓存，通过检查字段来实现；但注意 HTTP/1.0 和 HTTP/1.1 所检查的字段不一样：</p> <h5 id="_2-1-1、expires-http-1-0时期"><a href="#_2-1-1、expires-http-1-0时期" class="header-anchor">#</a> 2-1-1、Expires—HTTP/1.0时期</h5> <p>Expires 即过期时间，告知浏览器在此日期前可直接从缓存中获取数据，而无需再次请求；</p> <p><strong><u>缺点</u></strong>：<strong>服务器时间与浏览器本地时间可能不一致(修改时间会使缓存失效)</strong>，即时间计算基准不同就会有问题 (已在 HTTP/1.1版本抛弃)</p> <div class="language-http extra-class"><pre class="language-http"><code>// 位于服务端返回的响应头
// 表示资源在 2020 年 07 月 21 号 8 点 41 分过期，若过期就得向服务端请求重新获取资源
<span class="token header-name keyword">Expires:</span> Tue, 21 July 2020 08:41:00 GMT
</code></pre></div><h5 id="_2-1-2、cache-control-http-1-1时期"><a href="#_2-1-2、cache-control-http-1-1时期" class="header-anchor">#</a> 2-1-2、Cache-Control—HTTP/1.1时期</h5> <p>采用字段 Cache-Control 控制缓存，并用属性 <strong>max-age</strong> 表示缓存过期时间(与 Expires 不同，采用时间段而非具体时间点)；</p> <div class="language- extra-class"><pre class="language-text"><code>// 位于服务端返回的响应头
// 表示从收到此响应开始计算，往后的 3600 秒内，均可直接使用缓存
Cache-Control:max-age=3600
</code></pre></div><p>Cache-Control 还有诸多属性值来对缓存作更细粒度的操作：</p> <ul><li><strong>public</strong>：客户端、中间代理服务器均允许缓存资源；</li> <li><strong>private</strong>：只有客户端能缓存，中间代理服务器不能缓存；</li> <li><strong>no-cache</strong>：跳过当前强缓存检查阶段，直接发送 HTTP 请求，即直接进入协商缓存阶段；</li> <li><strong>no-store</strong>：不进行任何形式的缓存；</li> <li><strong>s-max-age</strong>：作用同 max-age，但针对对象是代理服务器；</li> <li>注意：若 <strong>Expires</strong> 和 <strong>Cache-Control</strong> 同时存在，则优先考虑 <strong>Cache-Control</strong>；</li></ul> <h4 id="_2-2、协商缓存"><a href="#_2-2、协商缓存" class="header-anchor">#</a> 2-2、协商缓存</h4> <p>即若强缓存失效，即资源缓存超时，浏览器在请求头中携带相应的 <u>缓存tag</u> 来向服务器发请求，服务器根据此 tag，来告知浏览器是否继续使用缓存；缓存 Tag 有两种，无分优劣， <strong>Last-Modified</strong>、 <strong>ETag</strong></p> <img src="/Image/Chromium/22.png" align="" style="zoom:50%;"> <h5 id="_2-2-1、last-modified"><a href="#_2-2-1、last-modified" class="header-anchor">#</a> 2-2-1、Last-Modified</h5> <p>响应报文字段，表示资源最后修改时间；使用机制如下：</p> <ul><li><p>首先，当浏览器首次向服务器发送请求后，服务器会在响应头中加上此字段；</p></li> <li><p>然后，而浏览器接收到后，若再次请求，则会在请求头中携带  <strong>If-Modified-Since</strong> 字段，此字段值即服务器传来的最后修改时间；</p></li> <li><p>然后，服务器拿到  请求头中的 <strong>If-Modified-Since</strong> 字段，<u>随即与服务器中该资源的最后修改时间作对比</u>:</p> <ul><li>若请求头中的值 &lt; 服务器上的最后修改时间，即说明资源已更新，服务端返回新资源，与常规 HTTP 请求响应流程一致；</li> <li>否则返回 304 状态码，告诉浏览器直接用缓存；</li></ul></li></ul> <h5 id="_2-2-2、etag"><a href="#_2-2-2、etag" class="header-anchor">#</a> 2-2-2、ETag</h5> <p>响应报文字段，此字段是服务器基于当前文件内容，给文件生成的唯一标识，即值会随内容更新而改变；使用机制如下：</p> <ul><li>首先，浏览器接收到 <strong>ETag</strong> 值，若再次请求，则会在请求头中携带 <strong>If-None-Match</strong>  字段，此字段值即 <strong>ETag</strong> 值；</li> <li>然后，服务器接收到 **If-None-Match **后，<u>随即与服务器中该资源的 ETag 作对比</u>:
<ul><li>若两者不相同，即说明资源已更新，服务端返回新资源，与常规 HTTP 请求响应流程一致；</li> <li>否则返回 304 状态码，告诉浏览器直接用缓存；</li></ul></li></ul> <h5 id="_2-2-3、两者对比"><a href="#_2-2-3、两者对比" class="header-anchor">#</a> 2-2-3、两者对比</h5> <ul><li>精度上，<u><strong>ETag</strong> 优于 <strong>Last-Modified</strong></u>：原因是前者按照内容给资源上标识，能准确感知资源变化，而后者在某些特殊情况下无法准确感知资源变化：
<ul><li>**<u>不该重新请求时，重新请求：</u>**编辑文件，但实际上文件内容并无变更，服务端并不清楚文件是否真正改变，仍通过最后编辑时间进行判断，此时资源再次被请求时，会被当做新资源处理，缓存作用失效；</li> <li>**<u>该重新请求时，无重新请求：</u>**Last-Modified 能感知的最小单位时间是秒，若文件在 1 秒内发生多次改变则无法表现出修改，具有局限性；</li></ul></li> <li>性能上，<u><strong>Last-Modified</strong> 优于 <strong>ETag</strong></u>：前者仅记录时间点，而后者需要服务器根据文件具体内容生成唯一哈希值；</li> <li>优先上，若两种方式均支持，服务器会<u>优先考虑 <strong>ETag 机制 (客户端接收角度为 ETag 优先，服务端接收角度为 If-None-Match 优先)</strong>；</u></li></ul> <h4 id="_2-3、缓存存放位置"><a href="#_2-3、缓存存放位置" class="header-anchor">#</a> 2-3、缓存存放位置</h4> <p>浏览器中的缓存位置一共有四种，按优先级从高到低排列分别是：</p> <ul><li>Service Worker</li> <li>Memory Cache</li> <li>Disk Cache</li> <li>Push Cache</li> <li>网络请求</li></ul> <h5 id="_2-3-1、service-worker"><a href="#_2-3-1、service-worker" class="header-anchor">#</a> 2-3-1、Service Worker</h5> <p><strong>Service Worker</strong>：与 Web Worker类似，是独立的线程(无法直接访问 DOM，无法干扰页面性能)，可帮助实现：<u>离线缓存</u>、<u>消息推送</u>、<u>网络代理</u> 等功能；借助 Service worker 实现的离线缓存即称 <u>Service Worker Cache</u>：可自由选择缓存哪些文件，以及文件的匹配与读取规则，且缓存是持续性的；SW 特点如下:</p> <ul><li><p>借鉴 <code>Web Worker</code> 思路，且是 <code>PWA</code> 重要实现机制；</p></li> <li><p>使用 <code>Service Worker</code> 会涉及到请求拦截，所以需要用 HTTPS 协议来保证安全，即传输协议必须是 <code>HTTPS</code>；</p></li> <li><p>生命周期包括： install、active、working 三个阶段；一旦 Service Worker 被 install，就将始终存在，只会在 active 与 working 间切换，除非主动终止；这是它可用来实现 <u>离线存储</u> 的重要先决条件；</p></li></ul> <h5 id="_2-3-2、memory-cache"><a href="#_2-3-2、memory-cache" class="header-anchor">#</a> 2-3-2、Memory Cache</h5> <p><strong>Memory Cache</strong>：即内存缓存，<u>存取效率最高、但存活时间最短</u>，非持续性，随进程释放而释放；</p> <p>主要存储当前页面已抓取到的资源, 比如已下载的样式、脚本、图片；特点如下：</p> <ul><li>存取效率快，但缓存持续时间短，会随着进程释放而释放(一旦关闭 Tab 页即被释放，未关闭但, 排在前排缓存失效)；</li> <li>从其中读取缓存时，浏览器会忽视 <code>Cache-Control</code>中的一些 <code>max-age、no-cache</code> 等头部配置, 除非设置  <code>no-store</code> 头部配置；</li> <li>几乎所有的请求资源都能进入 <u>Memory Cache</u>，主要分为 <u>preloader</u> 、<u>preload</u> ：
<ul><li>preloader：用于 <u>当浏览器打开网页时，能边解析执行 js/css，边请求下一资源</u>，被请求的资源会被放入 <code>Memory Cache</code> 中，供后续解析执行操作使用；</li> <li>preload：用于显式指定预加载的资源，比如： <code>&lt;link rel=&quot;preload&quot;&gt;</code></li></ul></li></ul> <h5 id="_2-3-3、disk-cache-http-cache"><a href="#_2-3-3、disk-cache-http-cache" class="header-anchor">#</a> 2-3-3、Disk Cache / HTTP Cache</h5> <p><strong>Disk Cache</strong>：即存储在磁盘中的缓存，<u>存取效率较低，但存储容量大和存储持续时间长</u>；</p> <p>会根据 HTTP header 中的缓存字段来判断哪些资源需要缓存、哪些不需要请求而直接使用、哪些已过期需要重新获取，而若是命中缓存，浏览器会从硬盘中直接读取资源，虽无从内存中读取的快，但却比网络缓存快；</p> <ul><li>注意：强缓存、协商缓存也是属于 <code>Disk Cache</code>，它们最终都存储在硬盘里；</li> <li>区别：Memory Cache 与 Disk Cache 存储位置选择的策略如下：
<ul><li>较大的 JS、CSS 文件会直接存入磁盘，反之内存；</li> <li>当系统内存使用率比较高时，文件优先放入磁盘；</li></ul></li></ul> <h5 id="_2-3-4、push-cache"><a href="#_2-3-4、push-cache" class="header-anchor">#</a> 2-3-4、Push Cache</h5> <p>Push Cache 是指 HTTP2 在 server push 阶段存在的缓存，是浏览器缓存最后一道防线(国内尚未普及)，(<a href="https://jakearchibald.com/2017/h2-push-tougher-than-i-thought/" target="_blank" rel="noopener noreferrer">资料1<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>、<a href="https://www.jianshu.com/p/54cc04190252" target="_blank" rel="noopener noreferrer">资料2<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>)：</p> <ul><li><p>Push Cache 是缓存的最后一道防线；浏览器只有在 Memory Cache、HTTP Cache 和 Service Worker Cache 均未命中的情况下才会去询问 Push Cache；</p></li> <li><p>Push Cache 是一种存在于会话—Session 阶段的缓存，当 session 终止时(关闭连接、关闭 Tab)，缓存也随之释放，且缓存时间短暂(Chrome 中只有5分钟)；</p></li> <li><p>不同的页面只要共享同一个 HTTP2 连接，则就可共享同一个 Push Cache；</p> <ul><li>注意：视浏览器实现而定，某些浏览器出于对性能考虑，会对相同域名但不同 Tab 标签使用同一 HTTP 连接；</li></ul></li> <li><p>所有资源都能被推送，且能够被缓存，但 Edge 和 Safari 支持相对较差</p></li> <li><p>可推送 no-cache 和 no-store 资源；</p></li> <li><p>Push Cache 中的缓存只能被使用一次；</p></li> <li><p>浏览器可以拒绝接收已存在的资源推送；</p></li> <li><p>可以给其他域名推送资源；</p></li></ul> <h4 id="_2-4、实际应用与场景"><a href="#_2-4、实际应用与场景" class="header-anchor">#</a> 2-4、实际应用与场景</h4> <h5 id="_2-4-1、实际应用"><a href="#_2-4-1、实际应用" class="header-anchor">#</a> 2-4-1、实际应用</h5> <ul><li>频繁变动的资源使用：<code>Cache-Control: no-cache</code>；
<ul><li>注意：使得浏览器每次都请求服务器，然后配合 <code>ETag</code> 或 <code>Last-Modified</code> 来验证资源是否有效；虽不能节省请求数量，但能显著减少响应数据大小；</li></ul></li> <li>不频繁变动的资源使用：<code>Cache-Control: max-age=31536000</code>，一年的总秒数…
<ul><li>注意：为解决更新问题，可在文件名添加 <code>hash</code>、版本号等动态字段，以实现更改 <u>引用URL</u> 目的(实现更新内容-重新请求资源)；</li></ul></li></ul> <h5 id="_2-4-2、用户场景"><a href="#_2-4-2、用户场景" class="header-anchor">#</a> 2-4-2、用户场景</h5> <ul><li>地址输入栏：先查找 Disk Cache 是否有匹配，否则发送请求；</li> <li>普通 F5 刷新：优先使用 Memory Cache，其次是 Disk Cache；</li> <li>强制 CtrlF5 刷新：浏览器不使用缓存</li></ul> <h4 id="_2-5、缓存过程总结"><a href="#_2-5、缓存过程总结" class="header-anchor">#</a> 2-5、缓存过程总结</h4> <p>首次，浏览器发起 HTTP 请求到获得请求结果，可分为以下几个过程：</p> <ul><li>首先，浏览器首次发起 HTTP 请求，在浏览器缓存中没有发现请求的缓存结果和缓存标识；</li> <li>然后，浏览器向服务器发起 HTTP 请求，获得该请求响应与缓存规则(即 <code>Last-Modified</code> 或 <code>ETag</code>)；</li> <li>然后，浏览器将响应内容存入 <code>Disk Cache</code>，将响应内容的引用，存入 <code>Memory Cache</code>；</li> <li>最后，将响应内容存入 <code>Service Worker</code> 的 <code>Cache Storage</code>  (若 <code>Service Worker</code> 的脚本调用了 <code>cache.put()</code>)</li></ul> <p>然后，在下一次请求相同资源时:</p> <ul><li>调用 <code>Service Worker</code> 的 <code>fetch</code>  事件响应；</li> <li>查看 <code>Memory Cache</code></li> <li>查看 <code>Disk Cache</code>，并通过 <strong>Cache-Control</strong> 验证 <u>强缓存</u> 是否可用
<ul><li>若可用，直接使用，返回 200 状态码</li> <li>否则进入 <u>协商缓存</u>，即发送 HTTP 请求，服务器通过请求头中的 <strong>If-Modified-Since</strong> 或 <strong>If-None-Match</strong> 字段检查资源是否更新
<ul><li>若资源更新，返回资源和  200 状态码；</li> <li>否则，返回 304 状态码，告诉浏览器直接从缓存获取资源；</li></ul></li></ul></li></ul> <img src="/Image/Chromium/16.png" align="" style="zoom:40%;"> <h3 id="三、浏览器存储"><a href="#三、浏览器存储" class="header-anchor">#</a> 三、浏览器存储</h3> <p>浏览器的本地存储主要分为： <strong>Cookie</strong>、<strong>WebStorage(可再分为 localStorage 和 sessionStorage)</strong>、<strong>IndexedDB</strong>；</p> <h4 id="_3-1、cookie"><a href="#_3-1、cookie" class="header-anchor">#</a> 3-1、Cookie</h4> <p>Cookie 设计之处并非用于本地存储，而是为了弥补 HTTP 在状态管理上的不足(无状态协议，服务端无法辨别每次请求的客户端的具体情况)；</p> <p>Cookie 本质是浏览器中存储的一个很小的、内容以键值对形式存储的文本文件，每次向同一域名发送请求，均会自动携带相同 Cookie，服务器拿到 Cookie 后进行解析，即可获取客户端状态；即 Cookie 用于 <u>状态存储</u>，但缺点有如下：</p> <ul><li>容量缺陷：体积上限只有<code>4KB</code>，只能存储少量信息；</li> <li>性能缺陷：Cookie 紧跟域名发送而不管是否真正需要，随着请求数增多性能浪费越严重——请求携带不必要数据；</li> <li>安全缺陷：Cookie 纯文本形式，在飞行途中很容易被非法用户截获篡改，在有效期内发送给服务器更是危险操作；
<ul><li>此外，若 <strong>HttpOnly</strong> 字段为 false，Cookie 信息还可直接通过 JS 脚本来读取；</li></ul></li></ul> <h4 id="_3-2、localstorage"><a href="#_3-2、localstorage" class="header-anchor">#</a> 3-2、localStorage</h4> <h5 id="_3-2-1、与-cookie-的异同"><a href="#_3-2-1、与-cookie-的异同" class="header-anchor">#</a> 3-2-1、与 Cookie 的异同</h5> <p>同一个域名下，会存储相同一段 <strong>localStorage / Cookie</strong>，而不同在：</p> <ul><li>容量：针对每个域名，均有上限为 5M 的存储容量；</li> <li>安全：只存在客户端，默认不参与与服务端通信；</li> <li>接口：接口友好，通过 <code>localStorage</code> 全局暴露，拥有诸多方法可供操作(Cookie 只能自定义)；</li></ul> <h5 id="_3-2-2、操作方式"><a href="#_3-2-2、操作方式" class="header-anchor">#</a> 3-2-2、操作方式</h5> <p><strong>localStorage</strong>  存储的都是字符串，若是存储对象需要调用 <code>JSON.stringify</code>方法，并且用 <code>JSON.parse</code>来解析成对象；</p> <h5 id="_3-2-3、应用场景"><a href="#_3-2-3、应用场景" class="header-anchor">#</a> 3-2-3、应用场景</h5> <p>适合存储一些内容稳定的资源，比如官网的<code>logo</code>，存储<code>Base64</code>格式的图片资源，因此利用<code>localStorage</code>；</p> <h4 id="_3-3、sessionstorage"><a href="#_3-3、sessionstorage" class="header-anchor">#</a> 3-3、sessionStorage</h4> <h5 id="_3-3-1、与-sessionstorage-的异同"><a href="#_3-3-1、与-sessionstorage-的异同" class="header-anchor">#</a> 3-3-1、与 sessionStorage 的异同</h5> <p>最大区别在：<strong>sessionStorage</strong> 只是会话级别的存储，并非持久化存储，一旦会话结束(当前 tab 页面关闭)就消失；</p> <ul><li>容量：容量上限也为 5M；</li> <li>安全：只存在客户端，默认不参与与服务端的通信；</li> <li>接口：接口友好，类似 <strong>localStorage</strong>；</li></ul> <h5 id="_3-3-2、应用场景"><a href="#_3-3-2、应用场景" class="header-anchor">#</a> 3-3-2、应用场景</h5> <ul><li>表单信息进行维护：将表单信息存储在里面，可保证页面即使刷新也不会让先前表单信息丢失；</li> <li>存储本次浏览记录：因关闭页面后不需要这些记录；</li></ul> <h4 id="_3-5、indexeddb"><a href="#_3-5、indexeddb" class="header-anchor">#</a> 3-5、IndexedDB</h4> <p>其实运行在浏览器中的 <u>非关系型数据库</u>，理论上容量是无上限；<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/IndexedDB_API/Using_IndexedDB" target="_blank" rel="noopener noreferrer">使用文档<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，其拥有数据库本身的特性，比如：支持事务，存储二进制数据，还有其他特殊特性：</p> <ul><li>键值对存储：内部采用 <u>对象仓库</u> 存放数据，在此仓库中数据采用 <u>键值对</u> 形式存储；</li> <li>异步操作：数据库的读写属于 I/O 操作，浏览器中对异步 I/O 提供了支持；</li> <li>受同源策略限制，无法访问跨域的数据库；</li></ul> <h4 id="_3-6、总结"><a href="#_3-6、总结" class="header-anchor">#</a> 3-6、总结</h4> <ul><li>Cookie 并不适合存储，而且存在非常多的缺陷；</li> <li>Web Storage 包括 localStorage 和 sessionStorage，默认不会参与和服务器的通信；</li> <li>IndexedDB 为运行在浏览器上的非关系型数据库，为大型数据的存储提供了接口；</li></ul> <h3 id="四、浏览器跨域"><a href="#四、浏览器跨域" class="header-anchor">#</a> 四、浏览器跨域</h3> <p><strong><u><em>浏览器遵循同源政策</em></u></strong>，即(scheme(协议)、host(主机)、port(端口)三种均同)，而非同源站点有如下限制:</p> <ul><li>不能读取和修改对方的 DOM；</li> <li>不读访问对方的 Cookie、IndexDB 和 LocalStorage；</li> <li>限制 XMLHttpRequest 请求；</li></ul> <p>而当浏览器发起某次 Ajax 请求(<u>跨域请求</u>)时，只要当前 URL 和目标 URL 不同源，就会产生 <strong><u><em>跨域</em></u></strong>；<strong><u><em>表现为</em></u></strong>：请求发出，服务器也成功响应，但前端就是拿不到响应；实际上，跨域请求的响应已到达客户端，只是被浏览器所拦截；即**<u><em>跨域是由于浏览器的同源策略引起的</em></u>**；</p> <div class="language- extra-class"><pre class="language-text"><code>// 同源
http://www.example.com:8080/index.html
http://www.example.com:8080/home.html
// 跨域
http://www.example.com:8080/index.html
http://www3.example.com:8080/index.html
// 跨域：http 默认端口80，https 默认端口443
http://www.example.com:80 === http://www.example.com
https://www.example.com:443 === https://www.example.com
</code></pre></div><p><strong><u><em>浏览器禁止跨域原因：</em></u></strong></p> <p>首先，跨域只存在于浏览器端；浏览器为 <code>web</code> 提供了访问入口，且访问方式很简单(地址栏输入地址或点击某链接即可)，因而须要对此种 <strong><u>开放的形态</u></strong> 有所限制；</p> <p>所以，<u>同源策略的产生主要是为了：保证用户信息的安全，防止恶意的网站窃取数据</u>；可细分为两种：Ajax同源策略、DOM同源策略：</p> <ul><li>前者限制：不同源页面不能获取 <code>cookie</code>、不同源页面不能发起 <code>Ajax</code> 请求(可防 CSRF)；</li> <li>后者限制：不同源页面不能获取 <code>DOM</code> (可防点击劫持)；</li></ul> <h4 id="_4-1、跨域拦截机制"><a href="#_4-1、跨域拦截机制" class="header-anchor">#</a> 4-1、跨域拦截机制</h4> <img src="/Image/Chromium/5.png" align="" style="zoom:50%;"> <ul><li>首先，浏览器是多进程的，而 WebKit 渲染引擎 和 V8 引擎 都在渲染进程当中；所以当 <code>xhr.send</code> 被调用时(即请求准备发送时)，尚在渲染进程的处理；
<ul><li>注意：为防止黑客通过脚本触碰系统资源，浏览器将每一<u>渲染进程分配进沙箱</u>，同时为防止 CPU 芯片一直存在的 <u>Spectre</u> 和  <u>Meltdown</u> 漏洞，采取 <u>站点隔离</u>  的手段，给每一<u>不同站点(一级域名不同)分配沙箱</u>，使其互不干扰；<a href="https://www.youtube.com/watch?v=dBuykrdhK-A&amp;feature=emb_logo" target="_blank" rel="noopener noreferrer">YouTube上Chromium安全团队的演讲视频<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>；</li></ul></li> <li>然后，沙箱中的渲染进程无法发送网络请求(只能通过网络进程来发送)，所以就需要 <strong><u>进程间通信(IPC，Inter Process Communication)</u></strong>， 来将数据传递给浏览器主进程，主进程接收到后，才真正地发出相应网络请求；chromium  中进程间通信的源码调用顺序如下：<a href="https://chromium.googlesource.com/chromium/src/+/refs/heads/master/ipc/" target="_blank" rel="noopener noreferrer">IPC源码地址<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>、<a href="https://blog.csdn.net/Luoshengyang/article/details/47822689" target="_blank" rel="noopener noreferrer">Chromium IPC源码解析文章<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>；
<ul><li><img src="/Image/Chromium/6.png" align="" style="zoom:50%;"></li> <li>总结：利用 <code>Unix Domain Socket</code>套接字，配合事件驱动的高性能网络并发库  <code>libevent</code> 完成进程通信 IPC 过程；</li></ul></li> <li>最后，服务端处理完并将响应返回，主进程检查到跨域行为，且无配置 CORS 响应头，遂将响应体全部丢弃，而不会发往渲染进程，实现了拦截数据的目的；</li></ul> <h4 id="_4-2、跨域操作方案"><a href="#_4-2、跨域操作方案" class="header-anchor">#</a> 4-2、跨域操作方案</h4> <h5 id="_4-2-1、cors"><a href="#_4-2-1、cors" class="header-anchor">#</a> 4-2-1、CORS</h5> <p>CORS—跨域资源共享，是 W3C 标准之一，其允许浏览器向跨源服务器，发出 <code>XMLHttpRequest</code> 或 <code>Fetch</code> 请求，且整个 <code>CORS</code> 通信过程均由浏览器自动完成，无需要用户参与；<strong><u>完成 CORS 须要前提</u></strong>：浏览器须支持此功能：<u><strong>非 IE 和 IE10 以上</strong></u>、且服务器端也须同意此种跨域请求：<u><strong>服务器需附加特定的响应头</strong></u>；<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS#Preflighted_requests" target="_blank" rel="noopener noreferrer">MDN<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <ul><li><strong>Access-Control-Allow-Origin</strong>：表示可允许请求的源；可填具体源名，亦可填 <code>*</code> 表示允许任意源请求；</li> <li><strong>Access-Control-Allow-Methods</strong>：表示允许的请求方法列表；</li> <li><strong>Access-Control-Allow-Headers</strong>：表示允许发送的请求头字段；</li> <li><strong>Access-Control-Allow-Credentials</strong>：略；</li> <li><strong>Access-Control-Max-Age</strong>：表示预检请求的有效期，在此期间，不必发出另外一条预检请求；</li></ul> <h5 id="_4-2-1-1、一般流程"><a href="#_4-2-1-1、一般流程" class="header-anchor">#</a> 4-2-1-1、一般流程</h5> <ul><li>首先，客户端先根据同源策略，对前端请求 URL 与后台交互地址 API 做匹配：
<ul><li>若同源则直接发送数据请求；</li> <li>若不同源，则发送跨域请求；</li></ul></li> <li>然后，服务器收到客户端跨域请求后，根据自身配置返回相应文件头：
<ul><li>若未配置允许跨域，则文件头不包含 <code>Access-Control-Allow-origin</code> 字段；</li> <li>若已配置跨域允许，则返回 <code>Access-Control-Allow-origin + 相应配置规则中的域名的方式</code>；</li></ul></li> <li>最后，浏览器根据与接收到的响应头中的 <code>Access-Control-Allow-origin</code> 字段匹配：
<ul><li>若无该字段，则说明不允许跨域，抛出错误；</li> <li>若有该字段，则将 <u>字段内容</u> 同 <u>当前域名</u> 做比对，
<ul><li>若同源，则说明可跨域，浏览器接受该响应；</li> <li>若不同源，则说明该域名不可跨域，浏览器不接受该响应，并抛出错误；</li></ul></li></ul></li></ul> <p>注意：浏览器根据跨域请求方法和跨域请求头的特定字段，将跨域请求分为两类，凡满足下面条件的属于 <strong><u>简单请求</u></strong>，否则为 <strong><u>非简单请求</u></strong>，前者只是单纯请求，后者则会先使用 <code>OPTIONS</code> 方法发起一个预检请求到服务器，以获知服务器是否允许该实际请求，避免跨域请求对服务器的用户数据产生未预期的影响；</p> <ul><li>请求方法为 GET、POST、HEAD 之一；</li> <li>请求头取值范围：<code>Accept</code>、<code>Accept-Language</code>、<code>Content-Language</code>、<code>Content-Type</code>、<code>DPR</code>、<code>Downlink</code>、<code>Save-Data</code>、<code>Viewport-Width</code>、<code>Width</code> <ul><li>注意：<code>Content-Type</code> 仅限3值：<code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>、<code>text/plain</code></li></ul></li> <li>请求中的任意 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequestUpload" target="_blank" rel="noopener noreferrer">XMLHttpRequestUpload<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 对象均无注册任何事件监听器；<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequestUpload" target="_blank" rel="noopener noreferrer">XMLHttpRequestUpload<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 对象可使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/upload" target="_blank" rel="noopener noreferrer">XMLHttpRequest.upload<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 属性访问；</li> <li>请求中没有使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/ReadableStream" target="_blank" rel="noopener noreferrer">ReadableStream<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 对象</li></ul> <h5 id="_4-2-1-2、简单请求"><a href="#_4-2-1-2、简单请求" class="header-anchor">#</a> 4-2-1-2、简单请求</h5> <p>在请求发出前，浏览器会自动为请求头中，添加字段 <code>Origin</code>，用以说明请求来源；当服务器拿到请求并回应时，会相应地添加字段 <code>Access-Control-Allow-Origin</code>，并设置字段值(或请求 Origin 值，或别的值)；然后，当浏览器收到时，若发现 <code>Origin</code> 的值不在此字段范围内时，就会将响应拦截；所以，<strong><u>字段 <code>Access-Control-Allow-Origin</code> 是服务器用来决定浏览器是否拦截此响应的必需字段</u></strong>；</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// 1、./index</span>
<span class="token operator">...</span>
<span class="token operator">&lt;</span>a href<span class="token operator">=</span><span class="token string">&quot;/cors&quot;</span><span class="token operator">&gt;</span><span class="token constant">CORS</span>跨域<span class="token operator">&lt;</span><span class="token operator">/</span>a<span class="token operator">&gt;</span>
<span class="token operator">...</span>

<span class="token comment">// 1-1、./cors/index</span>
<span class="token operator">...</span>
<span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">&quot;https://cdn.bootcss.com/axios/0.19.2/axios.min.js&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>button id<span class="token operator">=</span><span class="token string">&quot;getName&quot;</span><span class="token operator">&gt;</span><span class="token keyword">get</span> name<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>script<span class="token operator">&gt;</span>
  getName<span class="token punctuation">.</span><span class="token function-variable function">onclick</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// 简单请求</span>
  axios<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">&quot;http://127.0.0.1:8080/api/corsname&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
<span class="token operator">...</span>

<span class="token comment">// 2、client.js</span>
<span class="token keyword">const</span> Koa <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'koa'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'fs'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Koa</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token parameter">ctx</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>ctx<span class="token punctuation">.</span>method <span class="token operator">===</span> <span class="token string">'GET'</span> <span class="token operator">&amp;&amp;</span> ctx<span class="token punctuation">.</span>path <span class="token operator">===</span> <span class="token string">'/'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    ctx<span class="token punctuation">.</span>body <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">readFileSync</span><span class="token punctuation">(</span><span class="token string">'./index.html'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>ctx<span class="token punctuation">.</span>method <span class="token operator">===</span> <span class="token string">'GET'</span> <span class="token operator">&amp;&amp;</span> ctx<span class="token punctuation">.</span>path <span class="token operator">===</span> <span class="token string">'/cors'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    ctx<span class="token punctuation">.</span>body <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">readFileSync</span><span class="token punctuation">(</span><span class="token string">'./cors/index.html'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'client 8000...'</span><span class="token punctuation">)</span>
app<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">8000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


<span class="token comment">// 3、server.js</span>
<span class="token keyword">const</span> Koa <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'koa'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Koa</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token parameter">ctx<span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// 关键之处:</span>
  ctx<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">&quot;Access-Control-Allow-Origin&quot;</span><span class="token punctuation">,</span> ctx<span class="token punctuation">.</span>header<span class="token punctuation">.</span>origin<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">await</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>ctx<span class="token punctuation">.</span>path <span class="token operator">===</span> <span class="token string">'/api/corsname'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    ctx<span class="token punctuation">.</span>body <span class="token operator">=</span> <span class="token punctuation">{</span>
      data<span class="token operator">:</span> <span class="token string">'Test'</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'server 8080...'</span><span class="token punctuation">)</span>
app<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">8080</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>此外，还有其他可选的功能性字段，用以描述若不拦截时，则字段将会发挥各自的作用：</p> <ul><li><strong>Access-Control-Allow-Credentials</strong>：布尔值，表示是否允许发送 Cookie，对于跨域请求，浏览器默认值设为 false，否则需要设置为 true，并需在前端也需设置 <code>withCredentials</code> 属性:</li></ul> <div class="language-http extra-class"><pre class="language-http"><code>let xhr = new XMLHttpRequest();
xhr.withCredentials = true;
</code></pre></div><ul><li><strong>Access-Control-Expose-Headers</strong>：给 XMLHttpRequest 对象赋能，使此对象不仅可拿到基本的 6 个响应头字段(<code>Cache-Control</code>、<code>Content-Language</code>、<code>Content-Type</code>、<code>Expires</code>、<code>Last-Modified</code>、<code>Pragma</code>)，还可拿到此字段声明的 <strong>响应头字段</strong>：</li></ul> <div class="language-http extra-class"><pre class="language-http"><code>// 服务端设置响应
<span class="token header-name keyword">Access-Control-Expose-Headers:</span> xxx
// 前端可通过 `XMLHttpRequest.getResponseHeader('xxx')` 拿到 `xxx` 这个字段的值
</code></pre></div><h5 id="_4-2-1-3、非简单请求"><a href="#_4-2-1-3、非简单请求" class="header-anchor">#</a> 4-2-1-3、非简单请求</h5> <p>非简单请求不同于简单请求，前者只是单纯请求，后者则会先使用 <code>OPTIONS</code> 方法发起一个预检请求到服务器，以获知服务器是否允许该实际请求，避免跨域请求对服务器的用户数据产生未预期的影响；即主要体现在两方面：<strong><u>预检请求</u></strong>、<strong><u>响应字段</u></strong>，主流程是：</p> <ul><li>首先，客户端先发送 <u><strong>预检请求(而非实际请求)</strong></u>，用以告知服务器接下来的 CORS 请求的具体信息(方法、请求头)；
<ul><li>Access-Control-Request-Method：指出 (接下来的)CORS 请求用到哪个 HTTP 方法；</li> <li>Access-Control-Request-Headers：指出 (接下来的)CORS 请求将要加上什么请求头；</li></ul></li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// 以非简单请求 PUT 方法为例</span>
<span class="token keyword">var</span> url <span class="token operator">=</span> <span class="token string">'http://xxx.com'</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> xhr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
xhr<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">'PUT'</span><span class="token punctuation">,</span> url<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
xhr<span class="token punctuation">.</span><span class="token function">setRequestHeader</span><span class="token punctuation">(</span><span class="token string">'X-Custom-Header'</span><span class="token punctuation">,</span> <span class="token string">'xxx'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
xhr<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><div class="language-http extra-class"><pre class="language-http"><code>// 预检请求请求头 - 代码执行后浏览器随即自动发送 预检请求
// 预检请求方法为 OPTIONS
OPTIONS / HTTP/1.1
<span class="token header-name keyword">Origin:</span> 源地址
<span class="token header-name keyword">Host:</span> xxx.com - 目的地址
<span class="token header-name keyword">Access-Control-Request-Method:</span> PUT - 非简单请求标志之一
<span class="token header-name keyword">Access-Control-Request-Headers:</span> X-Custom-Header - 非简单请求标志之一
</code></pre></div><ul><li>然后，服务端接收并返回 <u><strong>预检请求的响应</strong></u>，客户端检查此响应：
<ul><li>若 CORS 请求不满足预检请求响应头的条件，则触发 <code>XMLHttpRequest</code> 的 <code>onerror</code>方法，后续真正 CORS 请求不发出；</li> <li>若 CORS 请求满足，则发出真正 CORS 请求；</li></ul></li></ul> <div class="language-http extra-class"><pre class="language-http"><code>// 预检请求响应头
<span class="token response-status">HTTP/1.1 <span class="token property">200 OK</span></span>
<span class="token header-name keyword">Access-Control-Allow-Origin:</span> *
<span class="token header-name keyword">Access-Control-Allow-Methods:</span> GET, POST, PUT
<span class="token header-name keyword">Access-Control-Allow-Headers:</span> X-Custom-Header
<span class="token header-name keyword">Access-Control-Allow-Credentials:</span> true
<span class="token header-name keyword">Access-Control-Max-Age:</span> 1728000
<span class="token header-name keyword">Content-Type:</span> text/html; charset=utf-8
<span class="token header-name keyword">Content-Encoding:</span> gzip
<span class="token header-name keyword">Content-Length:</span> 0
</code></pre></div><ul><li><p>Access-Control-Allow-Credentials：略；</p></li> <li><p>Access-Control-Allow-Methods：表示允许的请求方法列表；</p></li> <li><p>Access-Control-Allow-Headers：表示允许发送的请求头字段；</p></li> <li><p>Access-Control-Max-Age：表示预检请求的有效期，在此期间，不必发出另外一条预检请求；</p></li> <li><p>Access-Control-Allow-Origin：表示可允许请求的源；可填具体源名，亦可填 <code>*</code> 表示允许任意源请求；</p></li> <li><p>最后，若一切允许，则客户端发送真正的 CORS 跨域请求：流程同简单请求：客户端自动加上 <code>Origin</code> 字段，服务端返回  <code>Access-Control-Allow-Origin</code>；</p></li></ul> <h5 id="_4-2-1-4、注意事项"><a href="#_4-2-1-4、注意事项" class="header-anchor">#</a> 4-2-1-4、注意事项</h5> <h5 id="_4-2-1-4-1、减少预检请求次数"><a href="#_4-2-1-4-1、减少预检请求次数" class="header-anchor">#</a> 4-2-1-4-1、减少预检请求次数：</h5> <ul><li>尽量发出简单请求；</li> <li>服务端设置 <code>Access-Control-Max-Age</code> 字段：在有效时间内浏览器无需再为同一请求发送预检请求；
<ul><li>局限性：只能为同一请求缓存，无法针对整个域或模糊匹配 URL 做缓存；</li></ul></li></ul> <h5 id="_4-2-1-4-2、携带身份凭证"><a href="#_4-2-1-4-2、携带身份凭证" class="header-anchor">#</a> 4-2-1-4-2、携带身份凭证</h5> <p>跨域 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest" target="_blank" rel="noopener noreferrer">XMLHttpRequest<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 或 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API" target="_blank" rel="noopener noreferrer">Fetch<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 请求，浏览器默认 **<u>不会</u> **发送身份凭证信息比如 Cookie，若要坚持发送凭证信息，则需满足 3 个条件：</p> <ul><li>客户端请求头设置 <code>withCredentials</code> 为 <code>true</code>；</li> <li>服务器设置首部字段 <code>Access-Control-Allow-Credentials</code> 为 <code>true</code>；</li> <li>服务器的 <code>Access-Control-Allow-Origin</code> 不能为 <code>*</code>；</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// 1、login</span>
<span class="token operator">...</span>
<span class="token operator">&lt;</span>script<span class="token operator">&gt;</span>
<span class="token comment">// 关键 1:</span>
axios<span class="token punctuation">.</span>defaults<span class="token punctuation">.</span>withCredentials <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
axios<span class="token punctuation">.</span>defaults<span class="token punctuation">.</span>baseURL <span class="token operator">=</span> <span class="token string">'http://127.0.0.1:8080'</span>
login<span class="token punctuation">.</span><span class="token function-variable function">onclick</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
	axios<span class="token punctuation">.</span><span class="token function">post</span><span class="token punctuation">(</span><span class="token string">'/api/login'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
<span class="token operator">...</span>

<span class="token comment">// 2、server.js</span>
<span class="token keyword">const</span> Koa <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&quot;koa&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&quot;koa-router&quot;</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> koaBody <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&quot;koa-body&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Koa</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token constant">TOKEN</span> <span class="token operator">=</span> <span class="token string">&quot;xxxxxxx-yyyyyyy-zzzzzzzz&quot;</span><span class="token punctuation">;</span>

app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token parameter">ctx<span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// 关键 2:</span>
  ctx<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">&quot;Access-Control-Allow-Origin&quot;</span><span class="token punctuation">,</span> ctx<span class="token punctuation">.</span>header<span class="token punctuation">.</span>origin<span class="token punctuation">)</span><span class="token punctuation">;</span>
  ctx<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">&quot;Access-Control-Request-Method&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;PUT,POST,GET,DELETE,OPTIONS&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  ctx<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>
    <span class="token string">&quot;Access-Control-Allow-Headers&quot;</span><span class="token punctuation">,</span>
    <span class="token string">&quot;Origin, X-Requested-With, Content-Type, Access, cc&quot;</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 关键 3: </span>
  ctx<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">&quot;Access-Control-Allow-Credentials&quot;</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token parameter">ctx<span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// 若是登录接口则跳过后面的token验证</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>ctx<span class="token punctuation">.</span>path <span class="token operator">===</span> <span class="token string">&quot;/api/login&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">await</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 对所有非登录的请求验证 token</span>
  <span class="token keyword">const</span> cookies <span class="token operator">=</span> ctx<span class="token punctuation">.</span>cookies<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">&quot;token&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>cookies<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>cookies <span class="token operator">&amp;&amp;</span> cookies <span class="token operator">===</span> <span class="token constant">TOKEN</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">await</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  ctx<span class="token punctuation">.</span>body <span class="token operator">=</span> <span class="token punctuation">{</span>
    code<span class="token operator">:</span> <span class="token number">401</span><span class="token punctuation">,</span>
    msg<span class="token operator">:</span> <span class="token string">&quot;权限错误&quot;</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 若不加 multipart：true ctx.request.body 会获取不到值</span>
app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token function">koaBody</span><span class="token punctuation">(</span><span class="token punctuation">{</span> multipart<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

router<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">&quot;/api/corsname&quot;</span><span class="token punctuation">,</span> <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token parameter">ctx</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  ctx<span class="token punctuation">.</span>body <span class="token operator">=</span> <span class="token punctuation">{</span>
    data<span class="token operator">:</span> <span class="token string">&quot;Test&quot;</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

router<span class="token punctuation">.</span><span class="token function">post</span><span class="token punctuation">(</span><span class="token string">&quot;/api/login&quot;</span><span class="token punctuation">,</span> <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token parameter">ctx</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  ctx<span class="token punctuation">.</span>cookies<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">&quot;token&quot;</span><span class="token punctuation">,</span> <span class="token constant">TOKEN</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
    expires<span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token operator">+</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1000</span> <span class="token operator">*</span> <span class="token number">60</span> <span class="token operator">*</span> <span class="token number">60</span> <span class="token operator">*</span> <span class="token number">24</span> <span class="token operator">*</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  ctx<span class="token punctuation">.</span>body <span class="token operator">=</span> <span class="token punctuation">{</span>
    msg<span class="token operator">:</span> <span class="token string">&quot;成功&quot;</span><span class="token punctuation">,</span>
    code<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>router<span class="token punctuation">.</span><span class="token function">routes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;server 8080...&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
app<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">8080</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h5 id="_4-2-1-5、补充"><a href="#_4-2-1-5、补充" class="header-anchor">#</a> 4-2-1-5、补充</h5> <p>简单请求：</p> <ul><li>当发起跨域请求时：
<ul><li><strong><u><em>若是非简单请求</em></u></strong>，浏览器会帮我们自动触发预检请求，也就是 OPTIONS 请求，用于确认目标资源是否支持跨域；</li> <li><strong><u><em>如果是简单请求</em></u></strong>，则不会触发预检，直接发出正常请求；</li></ul></li> <li>浏览器会根据服务端响应的 header 自动处理剩余的请求，如果响应支持跨域，则继续发出正常请求，若不支持，则在控制台显示错误；</li></ul> <p>非简单请求：</p> <ul><li>1、浏览器先根据同源策略，对前端页面和后台交互地址做匹配，若同源，则直接发送数据请求；若不同源，则发送跨域请求；</li> <li>2、服务器收到浏览器跨域请求后，根据自身配置返回对应文件头；
<ul><li>若未配置过任何允许跨域，则文件头里不包含 <code>Access-Control-Allow-origin</code> 字段；</li> <li>若配置过域名，则返回 <code>Access-Control-Allow-origin + 对应配置规则里的域名的方式</code>；</li></ul></li> <li>3、浏览器根据接受到的 响应头里的 <code>Access-Control-Allow-origin</code> 字段做匹配：
<ul><li>若无该字段，说明不允许跨域，从而抛出一个错误；</li> <li>若有该字段，则对字段内容和当前域名做比对；
<ul><li>若同源，则说明可以跨域，浏览器接受该响应；</li> <li>若不同源，则说明该域名不可跨域，浏览器不接受该响应，并抛出一个错误；</li></ul></li></ul></li></ul> <p>注意：在 <code>CORS</code> 中有 <code>简单请求</code> 和 <code>非简单请求</code>，简单请求不会触发 <code>CORS</code> 预检请求，而非简单请求会。</p> <p>注意：<code>&quot;需预检的请求&quot;</code> 要求必须首先使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/OPTIONS" target="_blank" rel="noopener noreferrer">OPTIONS<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>  方法发起一个预检请求到服务器，以获知服务器是否允许该实际请求；</p> <p>注意：&quot;预检请求“的使用，可避免跨域请求对服务器的用户数据产生未预期的影响；</p> <h5 id="_4-2-2、jsonp"><a href="#_4-2-2、jsonp" class="header-anchor">#</a> 4-2-2、JSONP</h5> <p>JSONP 原理：XMLHttpRequest 对象遵循同源政策，但 <code>script</code> 标签没有跨域限制，可通过 src 填上目标地址发出 GET 请求，实现跨域请求；</p> <p>JSONP 原理：主要利用 <code>script</code> 标签的<code>src</code>属性没有跨域的限制，通过指向一个需要访问的地址，由服务端返回一个预先定义好的 <code>Javascript</code> 函数的调用，并且将服务器数据以该函数参数的形式传递过来，此方法需要前后端配合完成；</p> <p>最大优势是兼容性好(兼容 IE 低版本)，但缺点也明显：只支持 GET 请求；执行过程如下：</p> <ul><li>首先，前端定义一个解析函数；比如： <code>jsonpCallback = function (res) {}</code></li> <li>然后，通过 <code>params</code>  的形式包装 <code>script</code> 标签的请求参数，并声明为上述执行函数名；比如：<code>cb=jsonpCallback</code>；</li> <li>然后，后端获取到前端声明的执行函数(<code>jsonpCallback</code>)，并以带上参数且调用执行函数的方式传递给前端</li> <li>最后，前端在 <code>script</code> 标签请求返回资源时就会去执行 <code>jsonpCallback</code>，并通过回调的方式拿到数据；</li></ul> <p><strong><u><em>JSONP 实现1：</em></u></strong></p> <div class="language-html extra-class"><pre class="language-html"><code>// 1、创建全局函数，等待执行
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>text/javascript<span class="token punctuation">'</span></span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
    window<span class="token punctuation">.</span><span class="token function-variable function">jsonpCallback</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">res</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
// 2、通过下方代码 jsonp 构建的请求脚本，写入 html 后便等待请求内容返回
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>http://localhost:8080/api/jsonp?id=1&amp;cb=jsonpCallback<span class="token punctuation">'</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>text/javascript<span class="token punctuation">'</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
// 3、服务端拿到 URL 参数，处理请求，最后在响应体中写入 jsonpCallback(...)，并将处理后的内容以函数参数形式传入
// 4、前端拿到后台内容并执行，执行调用全局函数，并将参数传入函数中执行；
</code></pre></div><div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// 1、前端</span>
<span class="token keyword">const</span> <span class="token function-variable function">jsonp</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> url<span class="token punctuation">,</span> params<span class="token punctuation">,</span> callbackName <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token function-variable function">generateURL</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> dataStr <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">in</span> params<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      dataStr <span class="token operator">+=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>key<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">=</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>params<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">&amp;</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    dataStr <span class="token operator">+=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">callback=</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>callbackName<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>url<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">?</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>dataStr<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 初始化回调函数名称</span>
    callbackName <span class="token operator">=</span> callbackName <span class="token operator">||</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>toString<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">','</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token comment">// 创建 script 元素并加入到当前文档中</span>
    <span class="token keyword">let</span> scriptEle <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'script'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    scriptEle<span class="token punctuation">.</span>src <span class="token operator">=</span> <span class="token function">generateURL</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>scriptEle<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 绑定到 window 上，为了后面调用</span>
    window<span class="token punctuation">[</span>callbackName<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token function">resolve</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">// script 执行完了，成为无用元素，需要清除</span>
      document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>scriptEle<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 3、调用</span>
<span class="token function">jsonp</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  url<span class="token operator">:</span> <span class="token string">'http://localhost:3000'</span><span class="token punctuation">,</span>
  params<span class="token operator">:</span> <span class="token punctuation">{</span> 
    a<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
    b<span class="token operator">:</span> <span class="token number">2</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">data</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// 拿到数据进行处理</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 数据包</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// 2、后端</span>
<span class="token keyword">let</span> express <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'express'</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> app <span class="token operator">=</span> <span class="token function">express</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
app<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> <span class="token punctuation">{</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> callback <span class="token punctuation">}</span> <span class="token operator">=</span> req<span class="token punctuation">.</span>query
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>
  <span class="token comment">// 注意，返回给 script 标签，浏览器直接把这部分字符串执行</span>
  res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>callback<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">('数据包')</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
app<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span>
</code></pre></div><p><strong><u><em>JSONP 实现2：</em></u></strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 1、前端</span>
<span class="token keyword">function</span> <span class="token constant">JSONP</span><span class="token punctuation">(</span><span class="token punctuation">{</span> url<span class="token punctuation">,</span> params <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> callbackKey <span class="token operator">=</span> <span class="token string">&quot;cb&quot;</span><span class="token punctuation">,</span> callback <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 定义本地的唯一 callbackId，若是没有的话则初始化为 1</span>
  <span class="token constant">JSONP</span><span class="token punctuation">.</span>callbackId <span class="token operator">=</span> <span class="token constant">JSONP</span><span class="token punctuation">.</span>callbackId <span class="token operator">||</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> callbackId <span class="token operator">=</span> <span class="token constant">JSONP</span><span class="token punctuation">.</span>callbackId<span class="token punctuation">;</span>
  <span class="token comment">// 把要执行的回调加入到 JSON 对象中，避免污染 window</span>
  <span class="token constant">JSONP</span><span class="token punctuation">.</span>callbacks <span class="token operator">=</span> <span class="token constant">JSONP</span><span class="token punctuation">.</span>callbacks <span class="token operator">||</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token constant">JSONP</span><span class="token punctuation">.</span>callbacks<span class="token punctuation">[</span>callbackId<span class="token punctuation">]</span> <span class="token operator">=</span> callback<span class="token punctuation">;</span>
  <span class="token comment">// 把这个名称加入到参数中: 'cb=JSONP.callbacks[1]'</span>
  params<span class="token punctuation">[</span>callbackKey<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">JSONP.callbacks[</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>callbackId<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">]</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
  <span class="token comment">// 得到'id=1&amp;cb=JSONP.callbacks[1]'</span>
  <span class="token keyword">const</span> paramString <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>params<span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">key</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>key<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">=</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token function">encodeURIComponent</span><span class="token punctuation">(</span>params<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">&quot;&amp;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 创建 script 标签</span>
  <span class="token keyword">const</span> script <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">&quot;script&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  script<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span><span class="token string">&quot;src&quot;</span><span class="token punctuation">,</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>url<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">?</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>paramString<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>script<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// id 自增，保证唯一</span>
  <span class="token constant">JSONP</span><span class="token punctuation">.</span>callbackId<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token constant">JSONP</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  url<span class="token operator">:</span> <span class="token string">&quot;http://localhost:8080/api/jsonps&quot;</span><span class="token punctuation">,</span>
  params<span class="token operator">:</span> <span class="token punctuation">{</span>
    a<span class="token operator">:</span> <span class="token string">&quot;2&amp;b=3&quot;</span><span class="token punctuation">,</span>
    b<span class="token operator">:</span> <span class="token string">&quot;4&quot;</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  callbackKey<span class="token operator">:</span> <span class="token string">&quot;cb&quot;</span><span class="token punctuation">,</span>
  <span class="token function">callback</span><span class="token punctuation">(</span><span class="token parameter">res</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token constant">JSONP</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  url<span class="token operator">:</span> <span class="token string">&quot;http://localhost:8080/api/jsonp&quot;</span><span class="token punctuation">,</span>
  params<span class="token operator">:</span> <span class="token punctuation">{</span>
    id<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  callbackKey<span class="token operator">:</span> <span class="token string">&quot;cb&quot;</span><span class="token punctuation">,</span>
  <span class="token function">callback</span><span class="token punctuation">(</span><span class="token parameter">res</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 注意: encodeURI 和 encodeURIComponent 区别：</span>
<span class="token comment">// 前者不会对本身属于 URI 的特殊字符进行编码，例如冒号、正斜杠、问号和井字号；</span>
<span class="token comment">// 后者则会对它发现的任何非标准字符进行编码</span>
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 2、后端</span>
<span class="token keyword">const</span> Koa <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'koa'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Koa</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> items <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">{</span> id<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> title<span class="token operator">:</span> <span class="token string">'title1'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> id<span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span> title<span class="token operator">:</span> <span class="token string">'title2'</span> <span class="token punctuation">}</span><span class="token punctuation">]</span>

app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token parameter">ctx<span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>ctx<span class="token punctuation">.</span>path <span class="token operator">===</span> <span class="token string">'/api/jsonp'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token punctuation">{</span> cb<span class="token punctuation">,</span> id <span class="token punctuation">}</span> <span class="token operator">=</span> ctx<span class="token punctuation">.</span>query<span class="token punctuation">;</span>
    <span class="token keyword">const</span> title <span class="token operator">=</span> items<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token parameter">item</span> <span class="token operator">=&gt;</span> item<span class="token punctuation">.</span>id <span class="token operator">==</span> id<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token string">'title'</span><span class="token punctuation">]</span>
    ctx<span class="token punctuation">.</span>body <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>cb<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">(</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span><span class="token punctuation">{</span>title<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">)</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>ctx<span class="token punctuation">.</span>path <span class="token operator">===</span> <span class="token string">'/api/jsonps'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token punctuation">{</span> cb<span class="token punctuation">,</span> a<span class="token punctuation">,</span> b <span class="token punctuation">}</span> <span class="token operator">=</span> ctx<span class="token punctuation">.</span>query<span class="token punctuation">;</span>
    ctx<span class="token punctuation">.</span>body <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>cb<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">(</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span><span class="token punctuation">{</span> a<span class="token punctuation">,</span> b <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">)</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'listen 8080...'</span><span class="token punctuation">)</span>
app<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">8080</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h5 id="_4-2-3、nginx-代理服务"><a href="#_4-2-3、nginx-代理服务" class="header-anchor">#</a> 4-2-3、Nginx 代理服务</h5> <ul><li>正向代理服务器是帮助 <strong>客户端</strong>，访问自身无法访问的服务器并将结果返回客户端；</li> <li>反向代理服务器是帮助其他 <strong>服务器</strong>，获取到客户端发送请求并转交服务器；</li></ul> <img src="/Image/Chromium/7.png" align="" style="zoom:40%;"> <p>Nginx 是一种高性能的反向代理服务器，可解决跨域问题：</p> <div class="language-nginx extra-class"><pre class="language-nginx"><code><span class="token keyword">server</span> <span class="token punctuation">{</span>
  <span class="token keyword">listen</span>  <span class="token number">80</span><span class="token punctuation">;</span>
  <span class="token keyword">server_name</span>  client<span class="token punctuation">.</span>com<span class="token punctuation">;</span>
  <span class="token keyword">location</span> <span class="token operator">/</span>api <span class="token punctuation">{</span>
    <span class="token keyword">proxy_pass</span> <span class="token keyword">server</span><span class="token punctuation">.</span>com<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>Nginx 相当于是一个跳板机，域名是 <code>client.com</code>，客户端首先访问 <code>client.com/api</code>，然后 Nginx 服务器作为反向代理，将请求转发给 <code>server.com</code>，当响应返回时又将响应给到客户端，完成整个跨域请求；</p> <h5 id="_4-2-4、题外话"><a href="#_4-2-4、题外话" class="header-anchor">#</a> 4-2-4、题外话</h5> <p>其实还有一些不太常用的方式，大家了解即可，比如<code>postMessage</code>，当然<code>WebSocket</code>也是一种方式，但是已经不属于 HTTP 的范畴，另外一些奇技淫巧就不建议大家去死记硬背了，一方面从来不用，名字都难得记住，另一方面临时背下来，面试官也不会对你印象加分，因为看得出来是背的。当然没有背并不代表减分，把跨域原理和前面三种主要的跨域方式理解清楚，经得起更深一步的推敲，反而会让别人觉得你是一个靠谱的人。</p> <h4 id="_4-x、跨标签通讯"><a href="#_4-x、跨标签通讯" class="header-anchor">#</a> 4-X、跨标签通讯</h4> <p>不同标签页间的通讯，本质原理就是去运用一些可以 <u>共享的中间介质</u>，常用以下方法:</p> <ul><li>通过父页面 <code>window.open()</code>和子页面 <code>postMessage</code>；
<ul><li>异步下，通过 <code>window.open('about: blank')</code> 和 <code>tab.location.href = '*'；</code></li></ul></li> <li>设置同域下共享的 <code>localStorage</code>与监听  <code>window.onstorage</code>；
<ul><li>重复写入相同的值无法触发；</li> <li>会受到浏览器隐身模式等的限制；</li></ul></li> <li>设置共享 <code>cookie</code> 与不断轮询脏检查( <code>setInterval</code>)；</li> <li>借助服务端或者中间层实现；</li></ul> <h3 id="五、浏览器应用"><a href="#五、浏览器应用" class="header-anchor">#</a> 五、浏览器应用</h3> <h4 id="_5-1、防抖与节流"><a href="#_5-1、防抖与节流" class="header-anchor">#</a> 5-1、防抖与节流</h4> <p>防抖与节流函数是一种最常用的 <strong>高频触发优化方式</strong>，均为缓解函数频繁调用、在时间轴上控制函数的执行次数、控制事件触发频率；</p> <img src="/Image/Chromium/333.png" align="" style="zoom:50%;"> <h5 id="_5-1-1、防抖-debounce"><a href="#_5-1-1、防抖-debounce" class="header-anchor">#</a> 5-1-1、防抖 (debounce)</h5> <p>基本：等待一定时间再触发，概念衍生自机械开关和继电器的 &quot;去弹跳&quot;(debounce)；</p> <p><u>防抖，即短时间内大量触发同一事件，只会执行一次函数，将多次高频操作优化为只在最后一次执行；</u></p> <p>原理：为设置一个定时器，约定在xx毫秒后再触发事件处理，每次触发事件都会重新设置计时器，直到xx毫秒内无第二次操作；</p> <p>场景：输入验证过滤、表单提交、滚动条的监听事件处理、只需再输入完成后做一次输入校验即可；</p> <ul><li>按钮提交场景：防止多次提交按钮，只执行最后提交的一次、表单验证</li> <li>后台验证场景：表单验证需要服务端配合，只执行一段连续的输入事件的最后一次，还有搜索联想词功能类似</li> <li>用户窗口缩放：resize事件(如窗口停止改变大小之后重新计算布局)等，没错，这里也可以用防抖</li> <li>搜索输入查询：用户在输入时，没有必要不停地调用去请求服务端接口，等用户停止输入的时候，再调用，设置一个合适的时间间隔，有效减轻服务端压力</li> <li>更多：<a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/129" target="_blank" rel="noopener noreferrer">input 搜索防抖处理中文输入<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> - <u>提示：利用 e.target.compositionstart-ed 事件</u></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 思路：每次触发事件时都取消之前的延时调用方法；</span>
<span class="token comment">// 思路：将多个信号合并成一个信号；防抖意味着 N 秒内函数只会被执行一次，若 N 秒内再次被触发，则重新计算延迟时间；</span>
<span class="token comment">// 思路：持续触发不执行、不触发一段时间后再执行；</span>

<span class="token comment">// 实现1</span>
<span class="token keyword">function</span> <span class="token function">debounce</span><span class="token punctuation">(</span><span class="token parameter">func<span class="token punctuation">,</span> wait</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> timeout <span class="token operator">=</span> <span class="token keyword">null</span>
    <span class="token comment">// 将 debounce 处理结果当做函数返回</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      	<span class="token comment">// 保留调用时的 this 上下文</span>
        <span class="token keyword">let</span> context <span class="token operator">=</span> <span class="token keyword">this</span>
        <span class="token comment">// 保留调用时传入的参数</span>
        <span class="token keyword">let</span> args <span class="token operator">=</span> arguments
        <span class="token comment">// 事件触发时清除先前旧的定时器</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>timeout<span class="token punctuation">)</span> <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span>
      	<span class="token comment">// 设立新定时器</span>
        timeout <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            <span class="token function">func</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> args<span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span> wait<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 实现2</span>
<span class="token keyword">function</span> <span class="token function">debounce</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span> wait<span class="token punctuation">,</span> immediate</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> timer <span class="token operator">=</span> <span class="token keyword">null</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> args <span class="token operator">=</span> arguments
        <span class="token keyword">let</span> context <span class="token operator">=</span> <span class="token keyword">this</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>immediate <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>timer<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> args<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>timer<span class="token punctuation">)</span> <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span>
        timer <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> args<span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span> wait<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 实现3</span>
<span class="token keyword">function</span> <span class="token function">debounce</span><span class="token punctuation">(</span><span class="token parameter">func<span class="token punctuation">,</span> wait</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> timeout<span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> context <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> args <span class="token operator">=</span> arguments<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>timeout<span class="token punctuation">)</span> <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>
    timeout <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token function">func</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> wait<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 使用</span>
window<span class="token punctuation">.</span>onscroll <span class="token operator">=</span> <span class="token function">debounce</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'debounce'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 使用2</span>
document<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'scroll'</span><span class="token punctuation">,</span> <span class="token function">debounce</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> consol<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'debounce done'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><img src="/Image/Chromium/334.png" align="" style="zoom:80%;"> <h5 id="_5-1-2、节流-throttle"><a href="#_5-1-2、节流-throttle" class="header-anchor">#</a> 5-1-2、节流 (throttle)</h5> <p>区别：防抖是延迟执行，而节流是间隔执行；防抖每次触发事件都重置定时器，而节流在定时器到时间后再清空定时器；</p> <p><u>节流，即每隔一段时间就执行一次；每隔一段时间后执行一次，也就是降低频率(稀释函数的执行频率)，将高频操作优化成低频操作；</u></p> <p>原理：设置一个定时器，约定xx毫秒后执行事件，若时间到了，则执行函数并重置定时器；</p> <p>场景：滚动条事件、resize 事件，通常每隔 100~500 ms 执行一次即可；</p> <ul><li>拖拽场景：固定时间内只执行一次，防止超高频次触发位置变动</li> <li>缩放场景：监控浏览器resize</li> <li>动画场景：避免短时间内多次触发动画引起性能问题</li> <li>其他场景：按钮点击事件、拖拽事件、onScoll、计算鼠标移动的距离(mousemove)</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 思路：每次触发事件时都判断当前是否有等待执行的延时函数；</span>
<span class="token comment">// 思路：规定在单位时间内，只能触发一次函数，若这个单位时间内触发多次函数，只有一次生效；</span>
<span class="token comment">// 思路：持续触发并不会执行多次，到一定时间再去执行；</span>

<span class="token comment">// 实现1</span>
<span class="token keyword">function</span> <span class="token function">throttle</span><span class="token punctuation">(</span><span class="token parameter">func<span class="token punctuation">,</span> wait</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> timeout <span class="token operator">=</span> <span class="token keyword">null</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> context <span class="token operator">=</span> <span class="token keyword">this</span>
        <span class="token keyword">let</span> args <span class="token operator">=</span> arguments
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>timeout<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            timeout <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
                timeout <span class="token operator">=</span> <span class="token keyword">null</span>
                <span class="token function">func</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> args<span class="token punctuation">)</span>
            <span class="token punctuation">}</span><span class="token punctuation">,</span> wait<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>

    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 实现2</span>
<span class="token comment">// 使用两个时间戳 prev 旧时间戳和 now 新时间戳，每次触发事件都判断二者的时间差，如果到达规定时间，执行函数并重置旧时间戳</span>
<span class="token keyword">function</span> <span class="token function">throttle</span><span class="token punctuation">(</span><span class="token parameter">func<span class="token punctuation">,</span> wait</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> prev <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> now <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">let</span> context <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
        <span class="token keyword">let</span> args <span class="token operator">=</span> arguments<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>now <span class="token operator">-</span> prev <span class="token operator">&gt;</span> wait<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">func</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
            prev <span class="token operator">=</span> now<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>


<span class="token comment">// 实现3</span>
<span class="token keyword">function</span> <span class="token function">throttle</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span> wait<span class="token punctuation">,</span> immediate</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> timer <span class="token operator">=</span> <span class="token keyword">null</span>
    <span class="token keyword">let</span> callNow <span class="token operator">=</span> immediate
    
    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> context <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">,</span>
            args <span class="token operator">=</span> arguments

        <span class="token keyword">if</span> <span class="token punctuation">(</span>callNow<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> args<span class="token punctuation">)</span>
            callNow <span class="token operator">=</span> <span class="token boolean">false</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>timer<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            timer <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
                <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> args<span class="token punctuation">)</span>
                timer <span class="token operator">=</span> <span class="token keyword">null</span>
            <span class="token punctuation">}</span><span class="token punctuation">,</span> wait<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 实现4</span>
<span class="token keyword">function</span> <span class="token function">throttle</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span> delay</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> prevTime <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> curTime <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>curTime <span class="token operator">-</span> prevTime <span class="token operator">&gt;=</span> delay<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
      prevTime <span class="token operator">=</span> curTime<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 实现5</span>
<span class="token keyword">function</span> <span class="token function">throttle</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span> delay <span class="token operator">=</span> <span class="token number">500</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>flag<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
    flag <span class="token operator">=</span> <span class="token boolean">false</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
      flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> delay<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// ES6</span>
<span class="token keyword">const</span> <span class="token function-variable function">throttle</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span> delay <span class="token operator">=</span> <span class="token number">500</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>flag<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
    flag <span class="token operator">=</span> <span class="token boolean">false</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
      flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> delay<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 实现6</span>


<span class="token comment">// 使用</span>
<span class="token keyword">var</span> throtteScroll <span class="token operator">=</span> <span class="token function">throttle</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'throtte'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
window<span class="token punctuation">.</span>onscroll <span class="token operator">=</span> throtteScroll<span class="token punctuation">;</span>
</code></pre></div><img src="/Image/Chromium/335.png" align="" style="zoom:50%;"> <img src="/Image/Chromium/336.png" align="" style="zoom:50%;"> <p>5-1-3、用 Throttle 来优化 Debbounce</p> <img src="/Image/Chromium/337.png" align="" style="zoom:50%;"> <h4 id="_5-2、图片懒加载"><a href="#_5-2、图片懒加载" class="header-anchor">#</a> 5-2、图片懒加载</h4> <h4 id="_5-3、webworker"><a href="#_5-3、webworker" class="header-anchor">#</a> 5-3、WebWorker</h4> <p>现代浏览器为 JS 创造的 <strong>多线程环境</strong>；可新建并将部分任务分配到<code>worker</code>线程并行运行，两个线程可 <strong>独立运行，互不干扰</strong>，可通过自带的 <strong>消息机制</strong> 相互通信；</p> <ul><li>同源限制</li> <li>无法使用 <code>document</code> / <code>window</code> / <code>alert</code> / <code>confirm</code></li> <li>无法加载本地资源</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 创建 worker</span>
<span class="token keyword">const</span> worker <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Worker</span><span class="token punctuation">(</span><span class="token string">'work.js'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 向 worker 线程推送消息</span>
worker<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span><span class="token string">'Hello World'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 监听 worker 线程发送过来的消息</span>
worker<span class="token punctuation">.</span><span class="token function-variable function">onmessage</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Received message '</span> <span class="token operator">+</span> event<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="六、输入url到展示过程"><a href="#六、输入url到展示过程" class="header-anchor">#</a> 六、输入URL到展示过程</h3> <ul><li>DNS 解析：通过域名查询到具体的 IP (详看 DNS 章节)
<ul><li>操作系统会在本地缓存中查询 IP；若无则去系统配置的 DNS 服务器中查询；若无则直接去 DNS <u>根服务器查询</u>，查询会找出负责 <code>com</code> 这个一级域名的服务器；然后去 <u>一级域名服务器</u> 查询 <code>google</code> 这个二级域名，直至找到最终匹配域名 IP；</li> <li>上述为 DNS 迭代查询，还有种递归查询，区别是前者是由客户端发起请求，后者是由系统配置的 DNS 服务器做请求，得到结果后将数据返回给客户端；</li></ul></li> <li>TCP 三次握手；
<ul><li>应用层会下发数据给传输层，TCP 协议会指明两端的端口号，然后下发给网络层；网络层中的 IP 协议会确定 IP 地址，并且指示数据传输中如何跳转路由器；然后包会再被封装到数据链路层的数据帧结构中，最后就是物理层面的传输；</li></ul></li> <li>TLS 握手；握手流程与加密方式发展；</li> <li>分析 URL，设置请求报文(头，主体)，发送请求；</li> <li>服务器响应；</li> <li>浏览器解析与渲染；
<ul><li>解析时，若是 gzip 格式的话则先解压，然后通过文件的编码格式知道该如何去解码文件；</li> <li>若遇到 script 标签，判断是否存在 async 或 defer ：
<ul><li>前者会并行进行下载和执行 JS，后者会先下载文件，后等待 HTML 解析完成后顺序执行；否则阻塞渲染；</li></ul></li> <li>HTML parser --&gt; DOM Tree
<ul><li>标记化算法，进行元素状态的标记；</li> <li>DOM 树构建；</li></ul></li> <li>CSS parser --&gt; Style Tree
<ul><li>解析 CSS 代码，生成样式树；</li></ul></li> <li>attachment --&gt; Render Tree
<ul><li>结合 DOM 树 与 style 树，生成渲染树；</li></ul></li> <li>Layout：布局</li> <li>GPU painting: 像素绘制页面</li></ul></li></ul> <h4 id="_6-1、网络相关"><a href="#_6-1、网络相关" class="header-anchor">#</a> 6-1、网络相关</h4> <h5 id="_6-1-1、网络请求"><a href="#_6-1-1、网络请求" class="header-anchor">#</a> 6-1-1、网络请求</h5> <ul><li><p>构建请求：浏览器会构建请求行 <code>GET / HTTP/1.1</code></p></li> <li><p>查找强缓存：检查强缓存，若命中直接使用，否则进入下一步；</p></li> <li><p>DNS 解析：域名与 IP 的转换系统，但浏览器提供 <u>DNS数据缓存功能</u>，若某域名已解析过，则会将结果缓存再利用；默认端口 80；</p></li> <li><p>建立 TCP 连接：Chrome 在同一域名下要求同时最多只能有 6 个 TCP 连接，超过则需等待；<u>详看 TCP 协议</u>；</p></li> <li><p>发送 HTTP 请求：请求体只在 POST 方式才会存在；<u>详看 HTTP 协议</u>；</p></li></ul> <div class="language-http extra-class"><pre class="language-http"><code><span class="token header-name keyword">Accept:</span> text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3
<span class="token header-name keyword">Accept-Encoding:</span> gzip, deflate, br
<span class="token header-name keyword">Accept-Language:</span> zh-CN,zh;q=0.9
<span class="token header-name keyword">Cache-Control:</span> no-cache
<span class="token header-name keyword">Connection:</span> keep-alive
<span class="token header-name keyword">Cookie:</span> ......
<span class="token header-name keyword">Host:</span> www.google.com
<span class="token header-name keyword">Pragma:</span> no-cache
<span class="token header-name keyword">Upgrade-Insecure-Requests:</span> 1
<span class="token header-name keyword">User-Agent:</span> Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1
</code></pre></div><h5 id="_6-1-2、网络响应"><a href="#_6-1-2、网络响应" class="header-anchor">#</a> 6-1-2、网络响应</h5> <p>HTTP 请求到达服务器，服务器进行相关处理并响应；<u>详看 HTTP 协议</u>；</p> <p>响应头包含了服务器及其返回数据的一些信息、服务器生成数据的时间、返回的数据类型以及对即将写入的 Cookie 等信息；</p> <p>注意：若请求或响应头中包含 <strong>Connection: Keep-Alive</strong>，则表示建立 <u>持久连接</u>，随后请求统一站点的资源会复用此连接，否则断开连接, 流程结束；</p> <div class="language-http extra-class"><pre class="language-http"><code><span class="token header-name keyword">Cache-Control:</span> no-cache
<span class="token header-name keyword">Connection:</span> keep-alive
<span class="token header-name keyword">Content-Encoding:</span> gzip
<span class="token header-name keyword">Content-Type:</span> text/html;charset=utf-8
<span class="token header-name keyword">Date:</span> Wed, 04 Dec 2019 12:29:13 GMT
<span class="token header-name keyword">Server:</span> apache
<span class="token header-name keyword">Set-Cookie:</span> rsv_i=f9a0SIItKqzv7kqgAAgphbGyRts3RwTg%2FLyU3Y5Eh5LwyfOOrAsvdezbay0QqkDqFZ0DfQXby4wXKT8Au8O7ZT9UuMsBq2k; path=/; domain=.google.com
</code></pre></div><img src="/Image/Chromium/15.png" style="zoom:50%;"> <h4 id="_6-x、浏览器解析渲染流程"><a href="#_6-x、浏览器解析渲染流程" class="header-anchor">#</a> 6-X、浏览器解析渲染流程</h4> <img src="/Image/Chromium/17.png" style="zoom:50%;"> <ul><li>渲染进程将 HTML 内容转换为能够读懂的 <strong><u>DOM 树</u></strong>；</li> <li>渲染引擎将 CSS 样式表转化为浏览器可理解的 styleSheets，计算出 DOM 节点的样式；</li> <li>创建 <strong><u>布局树</u></strong>，并计算元素的布局信息；</li> <li>对布局树进行分层，并生成 <strong><u>分层树</u></strong>；</li> <li>为每个图层生成 <strong><u>绘制列表</u></strong>，并将其提交到 <strong><u>合成线程</u></strong>，合成线程将图层分图块，并栅格化将图块转换成位图；</li> <li>合成线程发送绘制图块命令给浏览器进程，浏览器进程根据指令生成页面，并显示到显示器上；</li></ul> <h4 id="_6-2、解析相关"><a href="#_6-2、解析相关" class="header-anchor">#</a> 6-2、解析相关</h4> <p>完成网络请求，若响应头中  <code>Content-Type</code> 值是 <code>text/html</code>，则**<u>进入浏览器解析与渲染工作</u>**，解析部分主要分为以下几个步骤:</p> <ul><li><strong><u>构建 DOM 树</u></strong></li> <li><strong><u>样式计算</u></strong></li> <li><u><strong>生成布局树(Layout Tree)</strong></u></li></ul> <p><strong><u>注意：下述内容极为简略，只作为回忆说明：</u></strong></p> <ul><li>DOM 树：字节数据—&gt;字符串—&gt;Token—&gt;Node—&gt;DOM
<ul><li>网络01 <u>字节数据</u>—&gt;</li> <li><u>HTML字符串</u>—&gt;</li> <li>通过词法分析转换为 <u>标记(标记化—tokenization)(标记还是字符串，是构成代码的最小单位)</u>—&gt;</li> <li>转换为 Node，并根据不同 Node 之前的联系构建为一颗 DOM 树；</li></ul></li> <li>CSSOM 树(同步进行)：字节数据—&gt;字符串—&gt;Token—&gt;Node—&gt;CSSOM
<ul><li>格式化、标准化、并根据继承与层叠规则计算节点具体样式；</li></ul></li> <li>生成渲染树(旧式)</li> <li>布局显示(旧式)</li></ul> <h5 id="_6-2-1、构建-dom-树"><a href="#_6-2-1、构建-dom-树" class="header-anchor">#</a> 6-2-1、构建 DOM 树</h5> <p>由于浏览器无法直接理解 <strong><u>HTML字符串</u></strong>，因此需要先将 HTML 的原始字节数据，转换为文件指定编码的字符，然后浏览器会根据 HTML 规范来将字符串转换成各种令牌标签，最终解析成一个树状的对象数据结构——<strong><u>DOM树</u></strong>；其本质上是一个以 <code>document</code> 为根节点的多叉树；</p> <h5 id="_6-2-1-1、html-文法本质"><a href="#_6-2-1-1、html-文法本质" class="header-anchor">#</a> 6-2-1-1、HTML 文法本质</h5> <p>注意：此处的 HTML 的文法并非指 <strong><u>上下文无关文法</u></strong>；在计算机科学 <u>编译原理</u> 学科中，有非常明确的定义:</p> <blockquote><p>若一个形式文法G = (N, Σ, P, S) 的产生式规则都取如下的形式：V-&gt;w，则叫上下文无关语法。其中 V∈N ，w∈(N∪Σ)* 。</p></blockquote> <p>其中把 G = (N, Σ, P, S) 中各个参量的意义解释一下:</p> <ol><li>N 是<u><strong>非终结符</strong></u>(即最后的符号不是它，下同)集合；</li> <li>Σ 是<u><strong>终结符</strong></u>集合；</li> <li>P 是**<u>开始符</u>**，它必须属于 N ，也即非终结符；</li> <li>S 就是不同的产生式的集合；比如 S -&gt; aSb 等等；</li></ol> <p>用人话讲，<strong><u>上下文无关的文法，就是这个文法中所有产生式的左边都是一个非终结符</u></strong> ，比如：</p> <div class="language- extra-class"><pre class="language-text"><code>// 下面文法中，每个产生式左边都会有一个非终结符，这就是: 上下文无关的文法; 此时，`xBy`一定是可以规约出`xAy`的；
A -&gt; B
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>// 反例:
// 下面就是: 非上下文无关的文法; 当遇到 B 时，无法判断是否可以规约出 A，因为取决于左边或右边是否有 a 存在, 故下面是和上下文有关的
aA -&gt; B
Aa -&gt; B
</code></pre></div><p>注意：<strong><u>规范的 HTML 语法</u></strong>，<strong><u>是符合上下文无关文法的</u></strong>，能够体现它 <strong><u>非上下文无关文法的</u></strong> 在它的 <strong>不标准的语法</strong>，比如反例证明如下：</p> <p>因为：解析器扫描到 <code>form</code> 标签时，<strong><u>上下文无关文法</u></strong> 的处理方式是直接创建对应 form 的 DOM 对象，而真实 HTML5 场景中却不是这样，解析器会查看 <code>form</code> 上下文，若此 <code>form</code> 标签的父标签也是 <code>form</code>，则 <strong>直接跳过</strong> 当前 <code>form</code> 标签，否则才创建 DOM 对象；</p> <p>所以：在不标准的语法时，是非上下文无关文法，则标准语法中，就是上下文无关文法(注意多重否定表肯定)；</p> <p><strong><u>注意：上面的叙述想表达的是规范的 HTML 语法是符合上下文无关文法的，但真实场景和实际解析中，考虑到不标准语法的行为，所以是非上下文无关文法；</u></strong></p> <p><strong><u>注意：即理论与实际不符，表示 HTML 不能使用常规语言解析器(常规编程语言一般为上下文无关)完成 HTML Parse；</u></strong></p> <h5 id="_6-2-1-2、解析算法"><a href="#_6-2-1-2、解析算法" class="header-anchor">#</a> 6-2-1-2、解析算法</h5> <p>HTML5 <a href="https://html.spec.whatwg.org/multipage/parsing.html" target="_blank" rel="noopener noreferrer">规范<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 详细地介绍解析算法，算法分为两个阶段:</p> <ul><li><strong>标记化算法</strong>；对应过程为 <strong>词法分析</strong>；</li> <li><strong>建树算法</strong>；对应过程为 <strong>语法分析</strong>；</li></ul> <h5 id="_6-2-1-2-1、标记化算法"><a href="#_6-2-1-2-1、标记化算法" class="header-anchor">#</a> 6-2-1-2-1、标记化算法</h5> <p>算法输入为 <u>HTML文本</u>，输出为 <u>HTML标记</u>，故亦称 <u><strong>标记生成器</strong></u>；</p> <p>算法运用 <strong><u>有限自动状态机</u></strong> 来完成：即在当前状态下，接收一或多个字符，就会更新到下一状态；比如：</p> <div class="language-html extra-class"><pre class="language-html"><code>// 标记化过程展示示例
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>
    Hello Beijing
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><ul><li>首先，遇到 <code>&lt;</code>, 状态为 <strong>标记打开</strong>；</li> <li>然后，接收 <code>[a-z]</code> 字符，并进入 <strong>标记名称状态</strong>；</li> <li>然后，上述状态一直保持，直到遇到 <code>&gt;</code>，表示标记名称记录完成，此时进入 <strong>数据状态</strong>；</li> <li>然后，后续的 <code>body</code>  标签做同样处理；</li> <li>然后，当来到 <code>&lt;body&gt;</code> 中的 <code>&gt;</code>，进入<strong>数据状态</strong>，之后保持此状态接收后面字符 <strong>hello sanyuan</strong>；</li> <li>接着，接收 <code>&lt;/body&gt;</code>  中的 <code>&lt;</code>，回到 <strong>标记打开</strong>，在接收下一个字符 <code>/</code>  时，此时会创建一个 <code>end tag</code> 的 token；</li> <li>随后，进入 <strong>标记名称状态</strong>，遇到 <code>&gt;</code> 则回到<strong>数据状态</strong>；</li> <li>最后，以同样的样式处理 <code>&lt;/html&gt;</code>；</li></ul> <h5 id="_6-2-1-2-2、建树算法"><a href="#_6-2-1-2-2、建树算法" class="header-anchor">#</a> 6-2-1-2-2、建树算法</h5> <p>​	回顾一下，解析第一步是构建 <strong><u>DOM 树</u></strong>，是因为浏览器无法直接理解 <strong><u>HTML字符串</u></strong>，因此需要先将这系列的字节流，转换为一种有意义的、且方便操作的数据结构——<strong><u>DOM 树</u></strong>；而 **<u>DOM 树</u>**是一个以 <code>document</code> 为根节点的多叉树；所以，<u><strong>解析器</strong></u>  首先会创建一个 <code>document</code> 对象 (作为 <strong><u>DOM 树</u></strong> 的根节点)；</p> <p>​	随后，<u><strong>标记生成器</strong></u> 会将每个标记的信息发送给 <strong><u>建树器</u></strong>，<strong><u>建树器</u></strong>  接收到相应的标记时，会 <strong>创建对应的 DOM 对象</strong>，在创建这个 <code>DOM对象</code> 后会做两件事：</p> <ul><li>将 <code>DOM对象</code> 加入 <strong><u>DOM 树</u></strong> 中；</li> <li>将对应标记，压入存放 <strong>开放(与<u>闭合标签</u>意思对应)元素</strong> 的栈中；</li></ul> <div class="language- extra-class"><pre class="language-text"><code>&lt;html&gt;
  &lt;body&gt;
    Hello Beijing
  &lt;/body&gt;
&lt;/html&gt;
</code></pre></div><ul><li>首先，状态为  <strong>初始化状态</strong>；</li> <li>然后，(<strong><u>建树器</u></strong>)接收到 <strong><u>标记生成器</u></strong> 传来的 <code>html</code> 标记，此时状态变为 <strong>before html状态</strong>，同时创建一个 <code>HTMLHtmlElement</code> DOM 元素，并将其添加到 <code>document</code> 根对象上，并进行压栈操作；</li> <li>随后，状态自动变为 <strong>before head</strong>，此时从标记生成器那边传来 <code>body</code> 标记，表示并没有 <code>head</code> 标签， 此时 <strong><u>建树器</u></strong> 会自动创建一个 <code>HTMLHeadElement</code>  (DOM 元素)，并将其添加入到 <strong><u>DOM 树</u></strong> 中；</li> <li>然后，进入到 <strong>in head</strong> 状态，随机直接跳到  <strong>after head</strong>；</li> <li>然后，现在 <strong><u>标记生成器</u></strong> 传来了 <code>body</code> 标记，创建 <code>HTMLBodyElement</code>(DOM 元素)，插入到 <strong><u>DOM 树</u></strong> 中，同时压入开放标记栈；</li> <li>随后，状态变为 <strong>in body</strong>，然后接收后面系列字符：<strong>Hello Beijing</strong>，接收到第一个字符时，会创建 <strong>Text</strong> 节点并将字符插入其中，然后把 <strong>Text</strong> 节点插入到 <strong><u>DOM 树</u></strong> 中的 <code>body元素</code>的下面；后续不断接收后面字符，字符会附在 <strong>Text</strong> 节点上；</li> <li>然后，<strong>标记生成器</strong> 传过来一个 <code>body</code> 的结束标记，进入 <strong>after body</strong> 状态；</li> <li>最后，**标记生成器 **传过来一个 <code>html</code> 的结束标记，进入 <strong>after after body</strong> 状态，表示解析过程到此结束；</li></ul> <h5 id="_6-2-1-2-3、容错机制"><a href="#_6-2-1-2-3、容错机制" class="header-anchor">#</a> 6-2-1-2-3、容错机制</h5> <p>HTML5规范宽容策略十分强悍，接下来是 WebKit 中一些经典的容错示例：</p> <ul><li><p>表单元素嵌套：直接忽略里面的 <code>form</code>；</p></li> <li><p>使用 <code>&lt;/br&gt;</code>  而不是 <code>&lt;br&gt;</code></p></li></ul> <div class="language- extra-class"><pre class="language-text"><code>if (t-&gt;isCloseTag(brTag) &amp;&amp; m_document-&gt;inCompatMode()) {
  reportError(MalformedBRError);
  t-&gt;beginTag = true;
}
// 全部换为 &lt;br&gt; 形式
</code></pre></div><ul><li>表格离散</li></ul> <div class="language- extra-class"><pre class="language-text"><code>&lt;table&gt;
  &lt;table&gt;
    &lt;tr&gt;&lt;td&gt;inner table&lt;/td&gt;&lt;/tr&gt;
  &lt;/table&gt;
  &lt;tr&gt;&lt;td&gt;outer table&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>// WebKit 会自动转换为:
&lt;table&gt;
    &lt;tr&gt;&lt;td&gt;outer table&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
&lt;table&gt;
    &lt;tr&gt;&lt;td&gt;inner table&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
</code></pre></div><h5 id="_6-2-1-2-4、流程总结"><a href="#_6-2-1-2-4、流程总结" class="header-anchor">#</a> 6-2-1-2-4、流程总结</h5> <img src="/Image/Chromium/18.png" align="" style="zoom:50%;"> <ul><li><strong>转码(Bytes -&gt; Characters)</strong> <ul><li>读取接收到的 HTML 二进制数据，按指定编码格式将字节转换为 HTML 字符串；</li></ul></li> <li><strong>Tokens 化(Characters -&gt; Tokens)</strong> <ul><li>解析 HTML，将 HTML 字符串转换为结构清晰的 Tokens，每个 Token 都有特殊的含义同时有自己的一套规则；</li></ul></li> <li><strong>构建 Nodes(Tokens -&gt; Nodes)</strong> <ul><li>每个 Node 都添加特定的属性(或属性访问器)，通过指针能够确定 Node 的父、子、兄弟关系和所属 treeScope</li> <li>比如：iframe 的 treeScope 与外层页面的 treeScope 不同；</li></ul></li> <li><strong>构建 DOM 树(Nodes -&gt; DOM Tree)</strong> <ul><li>最重要的工作是建立起每个结点的父子兄弟关系；</li></ul></li></ul> <h5 id="_6-2-2、样式计算"><a href="#_6-2-2、样式计算" class="header-anchor">#</a> 6-2-2、样式计算</h5> <p>即渲染引擎将 CSS 样式表转化为浏览器可以理解的 styleSheets，计算出 DOM 节点的样式；</p> <img src="/Image/Chromium/19.png" align="" style="zoom:50%;"> <p>上图即将所有值转换为渲染引擎容易理解、标准化的计算值，此过程为 <strong><u>属性值标准化</u></strong>，处理完成后再处理样式的 <strong><u>继承和层叠</u></strong>，整一过程亦称 CSSOM 构建过程；</p> <h5 id="_6-2-2-1、格式化样式表"><a href="#_6-2-2-1、格式化样式表" class="header-anchor">#</a> 6-2-2-1、格式化样式表</h5> <p>CSS 样式来源有三种：link 标签引用、style 标签样式、元素的内嵌 style 属性；</p> <p>浏览器是无法直接识别 CSS 样式文本，因此渲染引擎收到 CSS 文本后第一件事情就是将其转化为一个结构化的对象 <strong><u>styleSheets</u></strong>；在浏览器控制台能够通过<code>document.styleSheets</code>来查看这个最终结构，结构包含了以上 3 种 CSS来源，为后面的样式操作提供基础；</p> <p>补充：格式化的过程过于复杂，而且对于不同的浏览器会有不同的优化策略，这里就不展开了；</p> <h5 id="_6-2-2-2、标准化样式属性"><a href="#_6-2-2-2、标准化样式属性" class="header-anchor">#</a> 6-2-2-2、标准化样式属性</h5> <p>有些 CSS 样式的数值并不容易被渲染引擎所理解，因此在计算样式前需要将它们标准化；比如 <code>em-&gt;px、red-&gt;#ff0000、bold-&gt;700</code> 等；</p> <h5 id="_6-2-2-3、计算每个节点的具体样式"><a href="#_6-2-2-3、计算每个节点的具体样式" class="header-anchor">#</a> 6-2-2-3、计算每个节点的具体样式</h5> <p>CSS 样式被 <u>格式化</u> 和 <u>标准化</u> 后，便可计算每个节点的具体样式信息；计算遵从两个规则：<strong>继承</strong>、<strong>层叠</strong>；</p> <ul><li>继承规则：每个子节点均默认继承父节点样式属性，若父节点中没有找到，则采用浏览器默认样式 <code>UserAgent样式</code>；</li> <li>层叠规则：<u>CSS 最大特点在于它的层叠性，也即最终样式取决于各个属性共同作用的效果</u>；</li> <li>注意：在计算完样式之后，所有样式值会被挂在到 <code>window.getComputedStyle</code> 当中，故可通过 JS 来获取计算后的样式；</li></ul> <h5 id="_6-2-3、生成布局树"><a href="#_6-2-3、生成布局树" class="header-anchor">#</a> 6-2-3、生成布局树</h5> <p>布局过程即：利用前面的 <strong><u>DOM 树</u></strong> 和 <strong><u>DOM 样式</u></strong> ，排除 <code>script、meta</code> 等功能化、非视觉节点，排除 <code>display: none</code> 的节点，并通过浏览器的布局系统 <u>计算元素位置信息</u>、<u>确定元素位置</u>，构建一棵只包含可见元素的 <strong><u>布局树(Layout Tree)</u></strong>；</p> <img src="/Image/Chromium/20.png" align="" style="zoom:50%;"> <ul><li>遍历生成的 <strong><u>DOM 树</u></strong> 节点，并将它们添加到 <strong><u>布局树</u></strong> 中；</li> <li>计算 <strong><u>布局树</u></strong> 节点的坐标位置；</li> <li>注意：<strong><u>布局树</u></strong>  包含可见元素，设置<code>display: none</code>的元素和 <code>head</code> 等功能标签，将不会被放入其中；</li> <li>注意：现在 Chrome 团队已经做了大量重构，已经没有生成 <strong><u>渲染树(Render Tree)</u></strong> 的过程(布局树的信息已非常完善，完全拥有 Render Tree 的功能)；</li> <li>补充：<a href="https://www.rrfed.com/2017/02/26/chrome-layout/" target="_blank" rel="noopener noreferrer">从Chrome源码看浏览器如何layout布局<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</li></ul> <img src="/Image/Chromium/9.png" align="" style="zoom:50%;"> <h4 id="_6-3、渲染相关"><a href="#_6-3、渲染相关" class="header-anchor">#</a> 6-3、渲染相关</h4> <p>渲染分为几个步骤：</p> <ul><li><strong><u>建立 图层树(Layer Tree)</u></strong></li> <li><strong><u>生成 绘制列表</u></strong></li> <li><strong><u>生成 图块 并 栅格化(生成位图)</u></strong></li> <li><strong><u>显示器显示内容</u></strong></li></ul> <h5 id="_6-3-1、建图层树-分层树-layer-tree"><a href="#_6-3-1、建图层树-分层树-layer-tree" class="header-anchor">#</a> 6-3-1、建图层树/分层树(Layer Tree)</h5> <p>​	解析阶段得到 DOM节点、样式、位置信息，但还不足以开始绘制页面，因还需考虑页面中的复杂效果与场景，比如复杂 3D 动画变换效果、页面滚动、元素含层叠上下文时的显示与隐藏、使用 z-indexing 做 z 轴排序等；而为更加方便地实现这些效果，在浏览器在构建完 <strong><u>布局树</u></strong> 后(解析阶段最后一步)，渲染引擎还需为特定的节点生成专用图层，构建一棵 <strong><u>图层树(Layer Tree)</u></strong>；</p> <img src="/Image/Chromium/21.png" style="zoom:50%;"> <p>​	图层树通过显示隐式合成构建，一般情况下，节点的图层会默认属于父节点的图层(<strong>亦称合成层</strong>)，某些条件会触发将 <strong><u>多个合成层</u></strong> 提升为 <strong><u>单独合成层</u></strong>，可分两种情况讨论：<strong>显式合成</strong>、<strong>隐式合成</strong></p> <h5 id="_6-3-1-1、显式合成"><a href="#_6-3-1-1、显式合成" class="header-anchor">#</a> 6-3-1-1、显式合成</h5> <ul><li><p>拥有 <u>层叠上下文</u> 属性的元素会单独提升为单独一层：层叠上下文是 HTML 元素的三维概念，这些 HTML 元素在一条假想的、相对于面向视窗或用户的 z 轴上延伸，HTML 元素依据其自身属性，按照优先级顺序占用层叠上下文空间；</p> <ul><li><strong>根元素(HTML)</strong> 本身就具有层叠上下文；</li> <li>元素的 <strong>filter</strong> 值不为 none；</li> <li>元素的 <strong>clip-path</strong> 值不为 none；</li> <li>元素的 <strong>transform</strong> 值不为 none；</li> <li>元素的 <strong>perspective</strong> 值不为 none；</li> <li>元素的 <strong>mix-blend-mode</strong> 值不为 normal；</li> <li>元素的 <strong>z-index</strong> 值不为 auto，且为 flex 子项；</li> <li>元素的 <strong>z-index</strong> 值不为 auto，且为 grid 子项；</li> <li>元素的 <strong>z-index</strong> 值不为 auto，且为绝对/相对定位元素；</li> <li>元素的 <strong>mask</strong>、<strong>mask-image</strong>、<strong>mask-border</strong> 不为 none；</li> <li>元素的 <strong>isolation</strong> 值是 isolate；</li> <li>元素的 <strong>-webkit-overflow-scrolling</strong> 值是 touch；</li> <li>元素的 <strong>contain</strong> 值是 layout、paint、strict、content；</li> <li>元素的 <strong>opacity</strong> 值是小于 1；(the specification for opacity)</li> <li>元素的 **will-change ** 值是指定的任意属性；(<a href="https://dev.opera.com/articles/css-will-change-property/" target="_blank" rel="noopener noreferrer">详看<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> )</li></ul></li> <li><p>需要 <u>剪裁</u> 的地方也会被创建为图层：</p> <ul><li>比如某个翠存放巨量文字的 100 * 100 像素大小的 DIV，超出的文字部分就需要被剪裁；若出现滚动条，则滚动条会被单独提升为一个图层；</li></ul></li></ul> <h5 id="_6-3-1-2、隐式合成"><a href="#_6-3-1-2、隐式合成" class="header-anchor">#</a> 6-3-1-2、隐式合成</h5> <p><u>层叠等级低</u> 的节点被提升为单独图层后，则 <u>所有层叠等级比它高</u> 的节点 **都会 **成为一个单独的图层；</p> <ul><li>注意：隐式合成隐藏巨大风险：若在一个大型应用中，当某个<code>z-index</code> 比较低的元素，被提升为单独图层后，层叠在它上面的元素统统都会被提升为单独的图层，此时瞬间可能会增加上千个图层，大大增加内存压力，甚至直接让页面崩溃；此乃 <strong><u>层爆炸</u></strong> 原理，<a href="https://segmentfault.com/a/1190000014520786" target="_blank" rel="noopener noreferrer">例子在此<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>；</li> <li>注意：但当需要 <code>repaint</code> 时，只需 <code>repaint</code> 本身，而不会影响到其他的层；</li></ul> <h5 id="_6-3-2、生成绘制列表"><a href="#_6-3-2、生成绘制列表" class="header-anchor">#</a> 6-3-2、生成绘制列表</h5> <p>然后渲染引擎会将图层的绘制拆分成一个个绘制指令；比如先画背景、再描绘边框等，然后将这些指令按顺序组合成一个 <strong><u>待绘制列表</u></strong>，相当于制作一份绘制操作任务清单，可在 Chrome 开发者工具中的<code>Layers</code>面板观察绘制列表:</p> <img src="/Image/Chromium/11.png" style="zoom:50%;"> <h5 id="_6-3-3、生成图块并栅格化-生成位图"><a href="#_6-3-3、生成图块并栅格化-生成位图" class="header-anchor">#</a> 6-3-3、生成图块并栅格化(生成位图)</h5> <p>实际上在渲染进程中，绘制操作由专门的线程—<strong><u>合成线程</u></strong> 来完成：</p> <ul><li>首先，当绘制列表准备好后，<strong><u>渲染进程的主线程</u></strong> 会给 <strong><u>合成线程</u></strong> 发送 <code>commit</code> 消息，将 <strong><u>绘制列表</u></strong> 提交给 <strong><u>合成线程</u></strong>；</li> <li>然后，为避免：<u>在有限视口内一次性绘制所有页面</u> 而造成的性能浪费，<strong><u>合成线程</u></strong> 需要先将图层 <strong>分块</strong>；
<ul><li>注意：分块大小规格一般为 256 * 256 或 512 * 512 ，以加速页面首屏展示；</li> <li>注意：图块数据要进入 GPU 内存，而将数据从浏览器内存上传到 GPU 内存的操作较慢(即使绘制一部分图块也可能会耗费大量时间)，为解决此问题，Chrome 采用如下策略：首次合成图块时只采用一个 <u>低分辨率的图片</u> ，故首屏展示时只是展示此图片，继续进行合成操作，当正常图块内容绘制完毕后，才将当前低分辨率的图块内容替换；此亦 Chrome 底层优化首屏加载速度的一个手段；</li></ul></li> <li>然后，<strong><u>合成线程</u></strong> 会选择视口附近的 <strong>图块</strong>，优先将其交给 <strong><u>栅格化线程池</u></strong> 来生成位图；
<ul><li>注意：渲染进程中专门维护一个 <strong><u>栅格化线程池</u></strong>，负责将 <strong>图块</strong> 转换为 <strong>位图数据</strong>；</li> <li>注意：生成位图的过程实际上都会使用 GPU 进行加速，生成的位图最后发送给 <strong><u>合成线程</u></strong>；</li></ul></li></ul> <h5 id="_6-3-4、显示器显示内容"><a href="#_6-3-4、显示器显示内容" class="header-anchor">#</a> 6-3-4、显示器显示内容</h5> <p>生成图块并栅格化操作完成后，<strong><u>合成线程</u></strong> 会生成一个绘制命令—<code>DrawQuad</code>，并发送给浏览器进程的 <strong><u>viz组件</u></strong>，组件根据这个命令，将页面内容绘制到内存(缓冲)，然后把这部分内存数据发送给显卡；所以，当某个动画大量占用内存时，浏览器生成图像的速度变慢，图像传送显卡数据不及时，而显示器还是以不变频率刷新，因此会出现卡顿，出现明显的掉帧现象；</p> <ul><li>注意：无论是 PC 显示器还是手机屏幕，都有一个固定的刷新频率，一般是 60 HZ(60 帧、每秒更新60张图，停留 16.7 ms/图)，而每次更新的图片均来自于显卡的 <strong><u>前缓冲区</u></strong>；当显卡接收到浏览器进程传来的新的页面后，会合成相应的新图像，并将新图像保存到  <u><strong>后缓冲区</strong></u>；然后系统自动将 <strong><u>前缓冲区</u></strong> 和  <strong><u>后缓冲区</u></strong> 对换位置，如此循环更新；</li></ul> <img src="/Image/Chromium/10.png" style="zoom:50%;"> <h4 id="_6-4、重排、重绘、合成"><a href="#_6-4、重排、重绘、合成" class="header-anchor">#</a> 6-4、重排、重绘、合成</h4> <p>回顾渲染流水线：</p> <img src="/Image/Chromium/12.png" align="" style="zoom:50%;"> <ul><li>重绘是：当节点需要更改外观而不会影响布局的，比如改变 <code>color</code> 就叫称为重绘；</li> <li>回流是：布局或几何属性需要改变就称为回流；</li></ul> <h5 id="_6-4-1、重排-回流"><a href="#_6-4-1、重排-回流" class="header-anchor">#</a> 6-4-1、重排/回流</h5> <p>对 DOM 修改导致元素的尺寸或位置发生变化时，浏览器需要重新计算渲染树，触发重排/回流；</p> <ul><li>触发条件：对 DOM 结构的修改引发 DOM 几何尺寸变化时，会导致 <strong><u>重排(reflow)</u></strong>；
<ul><li>页面初次渲染；</li> <li>元素字体大小变化；</li> <li>浏览器窗口大小改变；</li> <li>激活 CSS 伪类；比如 :hover；</li> <li>DOM 元素的几何属性变化，常见的比如：<code>width</code>、<code>height</code>、<code>padding</code>、<code>margin</code>、<code>left</code>、<code>top</code>、<code>border</code> 等；</li> <li>元素尺寸、位置、内容发生改变；</li> <li>使 DOM 节点发生 <code>增减</code> 或 <code>移动</code>；</li> <li>读写 <code>offset</code> 族、<code>scroll</code>族、<code>client</code> 族属性时，浏览器为获取这些值，需要进行回流操作；</li> <li>查询某些属性或调用某些方法
<ul><li>clientWidth、clientHeight、clientTop、clientLeft</li> <li>offsetWidth、offsetHeight、offsetTop、offsetLeft</li> <li>scrollWidth、scrollHeight、scrollTop、scrollLeft</li> <li>getComputedStyle()</li> <li>getBoundingClientRect()</li> <li>scrollTo()</li></ul></li></ul></li> <li>回流过程：依照下面的渲染流水线，触发重排/回流时，若 DOM 结构发生改变，则重新渲染 DOM 树，然后将后续流程(含主线程外的任务)全部走一遍；相当于将解析和合成的过程重新又走了一篇，开销巨大；</li></ul> <img src="/Image/Chromium/13.png" align="" style="zoom:50%;"> <h5 id="_6-4-2、重绘"><a href="#_6-4-2、重绘" class="header-anchor">#</a> 6-4-2、重绘</h5> <p>DOM 修改导致样式发生变化，但无影响其几何属性，触发重绘，而不触发回流；而由于 DOM 位置信息无需更新，省去布局过程，性能上优于回流；</p> <ul><li><p>触发条件：当 DOM 的修改导致样式变化，且没有影响几何属性时，会导致 <strong><u>重绘(repaint)</u></strong>；</p></li> <li><p>重绘过程：由于没有导致 DOM 几何属性变化，故元素的位置信息无需更新，从而省去布局与建图层树过程，然后继续进行分块、生成位图等后面系列操作；</p></li></ul> <img src="/Image/Chromium/14.png" align="" style="zoom:50%;"> <ul><li>注意：重排跳过了 <u>生成布局树</u> 和 <u>建图层树</u> 阶段，直接生成绘制列表，然后继续进行分块、生成位图等后面一系列操作；</li> <li>注意：重绘不一定导致回流，但回流一定发生了重绘；</li> <li>注意：<strong><u><em>回流比重绘的代价要更高</em></u></strong>；有时即使仅仅回流一个单一的元素，其父元素及任何跟随它的元素也会产生回流；为避免频繁回流导致的性能问题，现代浏览器会对频繁的回流或重绘操作进行**<u><em>优化</em></u><strong>：浏览器会维护一个 flush 队列，以存放触发回流与重绘的任务，若队列中任务数量或时间间隔达到一个阈值时，浏览器就会将此队列任务一次性出队清空，进行一次批处理，如此可将多次回流和重绘变成一次；</strong><u><em>但当</em></u>**访问一些即使属性时，为获得此时此刻的、最准确的属性值，浏览器会提前将 flush 队列的任务出队：clientwidth、clientHeight、clientTop、clientLeftoffsetwidth、offsetHeight、offsetTop、offsetLeftscrollwidth、scrollHeight、scrollTop、scrollLeftwidth、heightgetComputedStyle()、getBoundingClientRect()</li></ul> <h5 id="_6-4-3、合成"><a href="#_6-4-3、合成" class="header-anchor">#</a> 6-4-3、合成</h5> <p>直接合成，比如利用 CSS3 的 <code>transform</code>、<code>opacity</code>、<code>filter</code> 等属性可实现合成效果，即  <strong><u>GPU加速</u></strong>；</p> <p>补充：GPU加速即：在使用<code>CSS3</code>中的<code>transform</code>、<code>opacity</code>、<code>filter</code>属性时，跳过布局和绘制流程，直接进入非主线处理的部分，即交给合成线程；</p> <ul><li>GPU 加速原因：在合成的情况下，会直接跳过布局和绘制流程，直接进入<code>非主线程</code>处理的部分，即直接交给 <strong><u>合成线程</u></strong> 处理：
<ul><li>充分发挥 GPU 优势：<strong><u>合成线程</u></strong> 生成位图的过程中：会调用线程池，并在其中使用 GPU 进行加速生成，而 GPU 是擅长处理位图数据；</li> <li><strong><u><em>无占用主线程资源</em></u></strong>：即使主线程卡住，但效果依然能够流畅地展示；</li></ul></li> <li>GPU 使用注意：GPU 渲染字体会导致字体模糊，过多 GPU 处理会导致内存问题；</li></ul> <h5 id="_6-4-4、注意事项"><a href="#_6-4-4、注意事项" class="header-anchor">#</a> 6-4-4、注意事项</h5> <p><strong>回流必定触发重绘，重绘不一定触发回流；重绘的开销较小，回流的代价较高</strong>；改变父节点里的子节点很可能会导致父节点的一系列回流；</p> <h5 id="_6-4-4-1、最佳实践"><a href="#_6-4-4-1、最佳实践" class="header-anchor">#</a> 6-4-4-1、最佳实践</h5> <p>CSS：</p> <ul><li>避免使用多层内联样式；</li> <li>避免使用 CSS 表达式，比如 <code>clac()</code>；</li> <li>CSS 选择符 <u>从右往左</u> 匹配查找，避免节点层级过多；</li> <li>使用 <code>visibility</code> 替换 <code>display: none</code>，前者只引起重绘，后者则触发回流；</li> <li>避免使用 <code>table</code> 布局，可能很小的一个小改动会造成整个 <code>table</code> 的重新布局；</li> <li>使用 <code>transform</code> 替代 <code>top</code>，<code>transform</code> 和 <code>opacity</code> 效果，不会触发 <code>layout</code> 和 <code>repaint;</code></li> <li>动画效果/动画元素，可使用绝对定位使其脱离文档流；减少频繁地触发回流重绘；
<ul><li>比如：将动画效果应用到 <code>position</code>  属性为 <code>absolute</code> 或 <code>fixed</code> 元素上；</li></ul></li></ul> <p>JavaScript：</p> <ul><li><p>避免频繁操作样式，可汇总后统一 <u>一次修改</u>；</p></li> <li><p>避免频繁使用 <code>style</code>，而采用修改 <code>class</code> 方式；</p></li> <li><p>极限优化时，修改样式可将其 <code>display: none</code> 后修改；</p></li> <li><p>使用 <code>resize</code>、<code>scroll</code>  时进行防抖和节流处理，减少回流次数；</p></li> <li><p>避免频繁读取会引发回流重绘的属性，若需多次使用则可考虑缓存；</p></li> <li><p>避免频繁操作 DOM，减少 <code>dom</code>的增删次数，可使用 <u>字符串</u> 或 <code>documentFragment</code> 一次性插入；</p> <ul><li>比如：使用 <code>createDocumentFragment</code> 进行批量 DOM 操作，修改完毕后，再放入文档流；</li> <li>比如：先使用 <code>display:none</code> 避开回流重绘，操作结束后再显示；</li></ul></li> <li><p>避免多次触发上面提到的那些会触发回流的方法，可使用变量将查询结果缓存，避免多次查询；</p></li> <li><p>动画实现的速度的选择，动画速度越快，回流次数越多，也可选择使用 <code>requestAnimationFrame;</code></p></li> <li><p>将频繁重绘或者回流的节点提升为合成层，图层能够阻止该节点的渲染行为影响别的节点；比如对于 <code>video</code> 标签来说，浏览器会自动将该节点变为图层；</p> <ul><li>设置节点为图层的方式有很多，我们可以通过以下几个常用属性可以生成新图层：</li> <li><code>will-change</code></li> <li><code>video</code>、<code>iframe</code> 标签</li></ul></li> <li><p>添加 <code>will-change: tranform</code>：让渲染引擎为节点单独实现一图层；在变换发生时，仅利用 <strong><u>合成线程</u></strong> 去处理这些变换而不牵扯主线程，提高渲染效率；</p> <ul><li><p>注意：值并非限制 tranform，任何可实现合成效果的 CSS 属性均可使用 <code>will-change</code> 来声明；<a href="https://juejin.im/post/5da52531518825094e373372" target="_blank" rel="noopener noreferrer">使用例子<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>；</p></li> <li><p>注意：通俗说即利用 CSS3 的<code>transform</code>、<code>opacity</code>、<code>filter</code> 这些属性，以实现合成的效果，即<code>GPU</code>加速；</p></li> <li><div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">#divId</span> <span class="token punctuation">{</span>
  <span class="token property">will-change</span><span class="token punctuation">:</span> transform<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul></li></ul> <h5 id="_6-4-4-2、优化检测"><a href="#_6-4-4-2、优化检测" class="header-anchor">#</a> 6-4-4-2、优化检测</h5> <p>当发生 <code>DOMContentLoaded</code> 事件后，就会生成渲染树，生成渲染树就可以进行渲染了，这一过程更大程度上和硬件有关系：</p> <img src="/Image/Chromium/23.png" style="zoom:50%;"> <h5 id="_6-4-5、与eventloop关系"><a href="#_6-4-5、与eventloop关系" class="header-anchor">#</a> 6-4-5、与EventLoop关系</h5> <ul><li>首先，当 Eventloop 执行完 Microtasks 后，会判断 <code>document</code> 是否需要更新，因为浏览器是 60Hz 的刷新率，每 16.6ms 才会更新一次；</li> <li>然后，判断是否有 <code>resize</code> 或者 <code>scroll</code> 事件，有则触发，所以 <code>resize</code> 和 <code>scroll</code> 事件也是至少 16ms 才会触发一次，并且自带节流功能；</li> <li>然后，判断是否触发了 media query；</li> <li>然后，更新动画并且发送事件；</li> <li>然后，判断是否有全屏操作事件；</li> <li>然后，执行 <code>requestAnimationFrame</code> 回调；</li> <li>然后，执行 <code>IntersectionObserver</code> 回调，该方法用于判断元素是否可见，可用于懒加载，但兼容性不好；</li> <li>最后，更新界面；</li> <li>注意：以上是一帧中可能会做的事情；若在一帧中有空闲时间，就会去执行 <code>requestIdleCallback</code> 回调；<a href="https://html.spec.whatwg.org/multipage/webappapis.html#event-loop-processing-model" target="_blank" rel="noopener noreferrer">详看<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul> <h4 id="_6-x、实际问题"><a href="#_6-x、实际问题" class="header-anchor">#</a> 6-X、实际问题</h4> <h5 id="_6-x-1、dom-操作性能问题"><a href="#_6-x-1、dom-操作性能问题" class="header-anchor">#</a> 6-X-1、DOM 操作性能问题</h5> <p>原因：因为 DOM 是属于渲染引擎中的东西，而 JS 又是 JS 引擎中的东西；通过 JS 操作 DOM 时，涉及到两个线程间的通信，势必会带来一些性能上的损耗。操作 DOM 次数一多，也就等同于一直在进行线程间的通信，且操作 DOM 可能还会带来重绘回流的情况，所以也就导致了性能上的问题；</p> <p>改进：</p> <ul><li><code>requestAnimationFrame</code>  方式去循环的插入 DOM；</li> <li>虚拟滚动 (virtualized scroller)：只渲染可视区域内的内容，非可见区域的完全不渲染，当用户在滚动的时就实时去替换渲染的内容  <a href="https://github.com/bvaughn/react-virtualized" target="_blank" rel="noopener noreferrer">react-virtualized<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>；</li></ul> <h5 id="_6-x-2、渲染阻塞问题"><a href="#_6-x-2、渲染阻塞问题" class="header-anchor">#</a> 6-X-2、渲染阻塞问题</h5> <ul><li>首先，渲染的前提是生成渲染树，故 HTML 和 CSS 势必会阻塞渲染；
<ul><li>优化：若想渲染快，可降低初始所需的渲染的文件 大小，并且扁平层级，优化选择器；</li> <li>注意：CSS 由单独的下载线程异步下载，由于 DOM 树的解析和构建此步与 css 并无关系，故并不会影响 DOM 解析，但最终布局树需要 DOM 树和 DOM 样式的，因此 CSS 会阻塞布局树的建立；</li></ul></li> <li>然后，当浏览器在解析到  <code>script</code> 标签时，会暂停构建 DOM，完成后才会从暂停的地方重新开始(即 script 会阻塞页面渲染)；
<ul><li>注意：因为 JS属于单线程，在加载 <code>script</code> 标签内容时，渲染线程会被暂停，因 <code>script</code>标签中内容可能会操作<code>DOM</code>，若加载<code>script</code>标签的同时渲染页面就会产生冲突，渲染线程(<code>GUI</code>)和 JS 引擎线程是互斥的；</li> <li>优化：若想首屏渲染快，一般而言不应在首屏时就加载 JS 文件，而将 <code>script</code> 标签放在 <code>body</code> 标签底部；</li> <li>优化：若想首屏渲染快，亦可给 <code>script</code> 标签添加 <code>defer</code> 或 <code>async</code> 属性：
<ul><li><code>defer</code> 属性表示该 JS 文件会并行下载，但会放到 HTML 解析完成后顺序执行，此时的 <code>script</code> 标签可放在任意位置；</li> <li>对于没有任何依赖的 JS 文件可以加上 <code>async</code> 属性，表示 JS 文件下载和解析不会阻塞渲染；</li> <li>注意：一般脚本与 DOM 元素和其它脚本间的依赖关系不强时会选用 async；当脚本依赖于 DOM 元素和其它脚本的执行结果时会选用 defer；</li></ul></li></ul></li></ul> <h5 id="_6-x-2-1、script-引入方式"><a href="#_6-x-2-1、script-引入方式" class="header-anchor">#</a> 6-X-2-1、script 引入方式</h5> <ul><li><p>JS 动态插入 <code>&lt;script&gt;</code></p></li> <li><p>HTML 静态引入 <code>&lt;script&gt;</code></p> <ul><li><code>&lt;script defer&gt;</code>：延迟加载，元素解析完成后执行；</li> <li><code>&lt;script async&gt;</code>：异步加载，但执行时会阻塞元素渲染；</li></ul></li></ul> <h5 id="_6-x-3、关键渲染路径问题"><a href="#_6-x-3、关键渲染路径问题" class="header-anchor">#</a> 6-X-3、关键渲染路径问题</h5> <p>不考虑缓存和优化网络协议，只考虑可以通过哪些方式来最快的渲染页面：</p> <ul><li>从文件大小：前略；</li> <li>从 <code>script</code> 标签使用：前略；</li> <li>从 CSS、HTML 的代码书写：前略；</li> <li>从需要下载的内容是否需要在首屏使用：前略；</li></ul> <h3 id="x、打开页面需要启动的进程-简略"><a href="#x、打开页面需要启动的进程-简略" class="header-anchor">#</a> X、打开页面需要启动的进程-简略</h3> <p>浏览器从关闭状态进行启动，然后新开 1 个页面至少需要 1 个网络进程、1 个浏览器进程、1 个 GPU 进程以及 1 个渲染进程，共 4 个进程；</p> <p>后续再新开标签页，浏览器、网络进程、GPU进程是共享的，不会重新启动，若 2 个页面属于同一站点的话，并且从a页面中打开的b页面，则他们也会共用一个渲染进程，否则新开一个渲染进程；</p> <p>最新的 Chrome 浏览器包括：1 个浏览器（Browser）主进程、1 个 GPU 进程、1 个网络（NetWork）进程、多个渲染进程和多个插件进程：</p> <ul><li>浏览器进程：主要负责界面显示、用户交互、子进程管理，同时提供存储等功能；</li> <li>渲染进程：核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下；</li> <li>GPU 进程：其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程；</li> <li>网络进程：主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程；</li> <li>插件进程：主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响；</li></ul> <h3 id="y、浏览器架构"><a href="#y、浏览器架构" class="header-anchor">#</a> Y、浏览器架构</h3> <ul><li>用户界面</li> <li>主进程</li> <li>内核
<ul><li>渲染引擎</li> <li>JS 引擎
<ul><li>执行栈</li></ul></li> <li>事件触发线程
<ul><li>消息队列
<ul><li>微任务</li> <li>宏任务</li></ul></li></ul></li> <li>网络异步线程</li> <li>定时器线程</li></ul></li></ul> <p>https://juejin.im/post/5e11cd225188253a73288212</p> <p>https://juejin.im/post/5e572a34518825490f722b9e#heading-2</p></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/docs/assets/js/app.cda475f7.js" defer></script><script src="/docs/assets/js/2.c902c426.js" defer></script><script src="/docs/assets/js/58.d994c1a9.js" defer></script>
  </body>
</html>
