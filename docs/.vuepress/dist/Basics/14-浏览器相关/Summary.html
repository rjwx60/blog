<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>总结 | Leibnize 个人学习笔记</title>
    <meta name="generator" content="VuePress 1.5.4">
    
    <meta name="description" content="整理自网络">
    <link rel="preload" href="/assets/css/0.styles.a3549ad8.css" as="style"><link rel="preload" href="/assets/js/app.f95d0077.js" as="script"><link rel="preload" href="/assets/js/3.49babee5.js" as="script"><link rel="preload" href="/assets/js/1.269e4bda.js" as="script"><link rel="preload" href="/assets/js/135.a7c3e822.js" as="script"><link rel="prefetch" href="/assets/js/10.6aa86c9d.js"><link rel="prefetch" href="/assets/js/100.2d552503.js"><link rel="prefetch" href="/assets/js/101.380eba67.js"><link rel="prefetch" href="/assets/js/102.4bd44e2f.js"><link rel="prefetch" href="/assets/js/103.c3ba7b95.js"><link rel="prefetch" href="/assets/js/104.93048938.js"><link rel="prefetch" href="/assets/js/105.640b5e1a.js"><link rel="prefetch" href="/assets/js/106.703adc14.js"><link rel="prefetch" href="/assets/js/107.991cb147.js"><link rel="prefetch" href="/assets/js/108.f2bd0aec.js"><link rel="prefetch" href="/assets/js/109.1d937267.js"><link rel="prefetch" href="/assets/js/11.a1d51055.js"><link rel="prefetch" href="/assets/js/110.332390f4.js"><link rel="prefetch" href="/assets/js/111.71635c45.js"><link rel="prefetch" href="/assets/js/112.2ac200df.js"><link rel="prefetch" href="/assets/js/113.46405151.js"><link rel="prefetch" href="/assets/js/114.58fa21b5.js"><link rel="prefetch" href="/assets/js/115.fa6a329a.js"><link rel="prefetch" href="/assets/js/116.37141fb0.js"><link rel="prefetch" href="/assets/js/117.d001fc73.js"><link rel="prefetch" href="/assets/js/118.217b3c9e.js"><link rel="prefetch" href="/assets/js/119.c8e2d03c.js"><link rel="prefetch" href="/assets/js/12.a5c78b74.js"><link rel="prefetch" href="/assets/js/120.f21f9f6d.js"><link rel="prefetch" href="/assets/js/121.610858f8.js"><link rel="prefetch" href="/assets/js/122.5e106cb5.js"><link rel="prefetch" href="/assets/js/123.83e9e543.js"><link rel="prefetch" href="/assets/js/124.fe964328.js"><link rel="prefetch" href="/assets/js/125.48103cb8.js"><link rel="prefetch" href="/assets/js/126.9f3a9a43.js"><link rel="prefetch" href="/assets/js/127.53393403.js"><link rel="prefetch" href="/assets/js/128.718bab74.js"><link rel="prefetch" href="/assets/js/129.94bb906d.js"><link rel="prefetch" href="/assets/js/13.6b06e1eb.js"><link rel="prefetch" href="/assets/js/130.f3cb1be6.js"><link rel="prefetch" href="/assets/js/131.b4e741b6.js"><link rel="prefetch" href="/assets/js/132.dbf75e28.js"><link rel="prefetch" href="/assets/js/133.0f2404ed.js"><link rel="prefetch" href="/assets/js/134.d17dc9c2.js"><link rel="prefetch" href="/assets/js/136.2401894d.js"><link rel="prefetch" href="/assets/js/137.6b5d51b3.js"><link rel="prefetch" href="/assets/js/138.46e98d9d.js"><link rel="prefetch" href="/assets/js/139.080c5130.js"><link rel="prefetch" href="/assets/js/14.1f5e418e.js"><link rel="prefetch" href="/assets/js/140.d7deb0d2.js"><link rel="prefetch" href="/assets/js/141.21a0a960.js"><link rel="prefetch" href="/assets/js/142.fe31183f.js"><link rel="prefetch" href="/assets/js/143.8adbd910.js"><link rel="prefetch" href="/assets/js/144.2ad689e4.js"><link rel="prefetch" href="/assets/js/145.95a4a1d7.js"><link rel="prefetch" href="/assets/js/146.45bec800.js"><link rel="prefetch" href="/assets/js/147.93101868.js"><link rel="prefetch" href="/assets/js/148.b534d0a2.js"><link rel="prefetch" href="/assets/js/149.b1d993db.js"><link rel="prefetch" href="/assets/js/15.f2f6dc7a.js"><link rel="prefetch" href="/assets/js/150.e7147d10.js"><link rel="prefetch" href="/assets/js/151.4ef25d94.js"><link rel="prefetch" href="/assets/js/152.e5d9d094.js"><link rel="prefetch" href="/assets/js/153.6b6e0642.js"><link rel="prefetch" href="/assets/js/154.25250e56.js"><link rel="prefetch" href="/assets/js/155.34ae60ca.js"><link rel="prefetch" href="/assets/js/156.26b776db.js"><link rel="prefetch" href="/assets/js/157.ac214951.js"><link rel="prefetch" href="/assets/js/158.8160576b.js"><link rel="prefetch" href="/assets/js/159.87970e93.js"><link rel="prefetch" href="/assets/js/16.f38d5aa1.js"><link rel="prefetch" href="/assets/js/160.cb31f27b.js"><link rel="prefetch" href="/assets/js/161.63da7c1d.js"><link rel="prefetch" href="/assets/js/162.d6265c5a.js"><link rel="prefetch" href="/assets/js/163.00e98ea9.js"><link rel="prefetch" href="/assets/js/164.489d3ece.js"><link rel="prefetch" href="/assets/js/165.14a0ac69.js"><link rel="prefetch" href="/assets/js/17.47f92d25.js"><link rel="prefetch" href="/assets/js/18.939679b9.js"><link rel="prefetch" href="/assets/js/19.4b5e11ca.js"><link rel="prefetch" href="/assets/js/20.e4c5a5c1.js"><link rel="prefetch" href="/assets/js/21.886994a9.js"><link rel="prefetch" href="/assets/js/22.6848ca70.js"><link rel="prefetch" href="/assets/js/23.6685f31e.js"><link rel="prefetch" href="/assets/js/24.6ffcbee7.js"><link rel="prefetch" href="/assets/js/25.b468ab2a.js"><link rel="prefetch" href="/assets/js/26.ae4ec095.js"><link rel="prefetch" href="/assets/js/27.d68ba8c4.js"><link rel="prefetch" href="/assets/js/28.77526965.js"><link rel="prefetch" href="/assets/js/29.b51bc369.js"><link rel="prefetch" href="/assets/js/30.f34ad8ea.js"><link rel="prefetch" href="/assets/js/31.ea5d0968.js"><link rel="prefetch" href="/assets/js/32.266fe651.js"><link rel="prefetch" href="/assets/js/33.9f3a4b59.js"><link rel="prefetch" href="/assets/js/34.92302c41.js"><link rel="prefetch" href="/assets/js/35.258e2870.js"><link rel="prefetch" href="/assets/js/36.7b3f62cb.js"><link rel="prefetch" href="/assets/js/37.91e68fdc.js"><link rel="prefetch" href="/assets/js/38.35c7427c.js"><link rel="prefetch" href="/assets/js/39.565f94d6.js"><link rel="prefetch" href="/assets/js/4.ea3b0bd5.js"><link rel="prefetch" href="/assets/js/40.1df5e2f3.js"><link rel="prefetch" href="/assets/js/41.5b364c9b.js"><link rel="prefetch" href="/assets/js/42.bc29f49d.js"><link rel="prefetch" href="/assets/js/43.2c830543.js"><link rel="prefetch" href="/assets/js/44.db617450.js"><link rel="prefetch" href="/assets/js/45.6d82cbe7.js"><link rel="prefetch" href="/assets/js/46.f36ad277.js"><link rel="prefetch" href="/assets/js/47.11cd07e6.js"><link rel="prefetch" href="/assets/js/48.e03a4e77.js"><link rel="prefetch" href="/assets/js/49.b08b0835.js"><link rel="prefetch" href="/assets/js/5.97a7c0dc.js"><link rel="prefetch" href="/assets/js/50.c4648d27.js"><link rel="prefetch" href="/assets/js/51.e983cd13.js"><link rel="prefetch" href="/assets/js/52.16e738d5.js"><link rel="prefetch" href="/assets/js/53.bd8c1968.js"><link rel="prefetch" href="/assets/js/54.3e19ee76.js"><link rel="prefetch" href="/assets/js/55.b8ad26cd.js"><link rel="prefetch" href="/assets/js/56.311bfbe6.js"><link rel="prefetch" href="/assets/js/57.0f045ba5.js"><link rel="prefetch" href="/assets/js/58.239e8404.js"><link rel="prefetch" href="/assets/js/59.7b687abb.js"><link rel="prefetch" href="/assets/js/6.8e992509.js"><link rel="prefetch" href="/assets/js/60.4e343674.js"><link rel="prefetch" href="/assets/js/61.db6e32e6.js"><link rel="prefetch" href="/assets/js/62.fc3fc01f.js"><link rel="prefetch" href="/assets/js/63.fa9e1bd1.js"><link rel="prefetch" href="/assets/js/64.994d7527.js"><link rel="prefetch" href="/assets/js/65.267b048d.js"><link rel="prefetch" href="/assets/js/66.8c5f0b3d.js"><link rel="prefetch" href="/assets/js/67.74a9ded5.js"><link rel="prefetch" href="/assets/js/68.dd40f558.js"><link rel="prefetch" href="/assets/js/69.00fccbea.js"><link rel="prefetch" href="/assets/js/7.159745e4.js"><link rel="prefetch" href="/assets/js/70.ef8c338c.js"><link rel="prefetch" href="/assets/js/71.25a9bd58.js"><link rel="prefetch" href="/assets/js/72.0959ee8f.js"><link rel="prefetch" href="/assets/js/73.e154307b.js"><link rel="prefetch" href="/assets/js/74.76863de9.js"><link rel="prefetch" href="/assets/js/75.6978bd97.js"><link rel="prefetch" href="/assets/js/76.4a2f4182.js"><link rel="prefetch" href="/assets/js/77.0f06f3c0.js"><link rel="prefetch" href="/assets/js/78.66c253a1.js"><link rel="prefetch" href="/assets/js/79.6c37b127.js"><link rel="prefetch" href="/assets/js/8.eaef2fb9.js"><link rel="prefetch" href="/assets/js/80.2dda282c.js"><link rel="prefetch" href="/assets/js/81.cd9437e7.js"><link rel="prefetch" href="/assets/js/82.c5a84712.js"><link rel="prefetch" href="/assets/js/83.b8a2f734.js"><link rel="prefetch" href="/assets/js/84.ede1cd7a.js"><link rel="prefetch" href="/assets/js/85.e649a4e5.js"><link rel="prefetch" href="/assets/js/86.38274fa9.js"><link rel="prefetch" href="/assets/js/87.472635cc.js"><link rel="prefetch" href="/assets/js/88.cf02af57.js"><link rel="prefetch" href="/assets/js/89.03ef81d7.js"><link rel="prefetch" href="/assets/js/9.ee3f327d.js"><link rel="prefetch" href="/assets/js/90.4a497f88.js"><link rel="prefetch" href="/assets/js/91.7271b82b.js"><link rel="prefetch" href="/assets/js/92.cd04960f.js"><link rel="prefetch" href="/assets/js/93.342921b6.js"><link rel="prefetch" href="/assets/js/94.f5d3d498.js"><link rel="prefetch" href="/assets/js/95.940fefe6.js"><link rel="prefetch" href="/assets/js/96.fdbcc350.js"><link rel="prefetch" href="/assets/js/97.73aba549.js"><link rel="prefetch" href="/assets/js/98.937f6a6d.js"><link rel="prefetch" href="/assets/js/99.bcd70353.js">
    <link rel="stylesheet" href="/assets/css/0.styles.a3549ad8.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container" data-v-dad8a512><div data-v-dad8a512><div id="loader-wrapper" class="loading-wrapper" data-v-d48f4d20 data-v-dad8a512 data-v-dad8a512><div class="loader-main" data-v-d48f4d20><div data-v-d48f4d20></div><div data-v-d48f4d20></div><div data-v-d48f4d20></div><div data-v-d48f4d20></div></div> <!----> <!----></div> <div class="password-shadow password-wrapper-out" style="display:none;" data-v-64685f0e data-v-dad8a512 data-v-dad8a512><h3 class="title" style="display:none;" data-v-64685f0e data-v-64685f0e>Leibnize 个人学习笔记</h3> <!----> <label id="box" class="inputBox" style="display:none;" data-v-64685f0e data-v-64685f0e><input type="password" value="" data-v-64685f0e> <span data-v-64685f0e>Konck! Knock!</span> <button data-v-64685f0e>OK</button></label> <div class="footer" style="display:none;" data-v-64685f0e data-v-64685f0e><span data-v-64685f0e><i class="iconfont reco-theme" data-v-64685f0e></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-64685f0e>vuePress-theme-reco</a></span> <span data-v-64685f0e><i class="iconfont reco-copyright" data-v-64685f0e></i> <a data-v-64685f0e><span data-v-64685f0e>Leibnize 个人学习笔记</span>
            
          <!---->
          2020
        </a></span></div></div> <div class="hide" data-v-dad8a512><header class="navbar" data-v-dad8a512><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Leibnize 个人学习笔记</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="https://github.com/rjwx60" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont undefined"></i>
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-dad8a512></div> <aside class="sidebar" data-v-dad8a512><div class="personal-info-wrapper" data-v-ca798c94 data-v-dad8a512><!----> <h3 class="name" data-v-ca798c94>
    Leibnize 个人学习笔记
  </h3> <div class="num" data-v-ca798c94><div data-v-ca798c94><h3 data-v-ca798c94>0</h3> <h6 data-v-ca798c94>Article</h6></div> <div data-v-ca798c94><h3 data-v-ca798c94>0</h3> <h6 data-v-ca798c94>Tag</h6></div></div> <hr data-v-ca798c94></div> <nav class="nav-links"><div class="nav-item"><a href="https://github.com/rjwx60" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont undefined"></i>
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav> <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><a href="/Basics/" class="sidebar-heading clickable router-link-active open"><span>前端专题</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/Basics/01-前端基础" class="sidebar-heading clickable"><span>01-前端基本</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/Basics/02-前端性能" class="sidebar-heading clickable"><span>02-前端性能</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/Basics/03-前端工程" class="sidebar-heading clickable"><span>03-前端工程</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/Basics/04-前端异步" class="sidebar-heading clickable"><span>04-前端异步</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/Basics/05-前端设计" class="sidebar-heading clickable"><span>05-前端设计</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/Basics/06-前端数据" class="sidebar-heading clickable"><span>06-前端数据</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/Basics/07-前端安全" class="sidebar-heading clickable"><span>07-前端安全</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/Basics/08-前端概念" class="sidebar-heading clickable"><span>08-前端概念</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/Basics/09-前端实现" class="sidebar-heading clickable"><span>09-前端实现</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/Basics/10-前端新标" class="sidebar-heading clickable"><span>10-前端新标</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/Basics/11-前端会话" class="sidebar-heading clickable"><span>11-前端会话</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/Basics/12-前端框架" class="sidebar-heading clickable"><span>12-前端框架</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/Basics/14-浏览器相关" class="sidebar-heading clickable open"><span>14-浏览器相关</span> <span class="arrow down"></span></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/Basics/14-浏览器相关/浏览器基本.html" class="sidebar-link">一、浏览器基本</a></li><li><a href="/Basics/14-浏览器相关/浏览器缓存.html" class="sidebar-link">二、浏览器缓存</a></li><li><a href="/Basics/14-浏览器相关/浏览器存储.html" class="sidebar-link">三、浏览器存储</a></li><li><a href="/Basics/14-浏览器相关/浏览器跨域.html" class="sidebar-link">四、浏览器跨域</a></li><li><a href="/Basics/14-浏览器相关/浏览器应用.html" class="sidebar-link">五、浏览器应用</a></li><li><a href="/Basics/14-浏览器相关/输入URL展示.html" class="sidebar-link">六、输入URL展示</a></li><li><a href="/Basics/14-浏览器相关/Summary.html" class="active sidebar-link">七、Summary</a></li></ul></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/Basics/15-前端核心" class="sidebar-heading clickable"><span>15-前端核心</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/Basics/16-前端Node" class="sidebar-heading clickable"><span>16-前端Node</span> <span class="arrow right"></span></a> <!----></section></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/NetWork/" class="sidebar-heading clickable"><span>网络专题</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/NetWork/20-前端网络" class="sidebar-heading clickable open"><span>20-前端网络</span> <span class="arrow down"></span></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/NetWork/20-前端网络/base.html" class="sidebar-link">一、基本</a></li><li><a href="/NetWork/20-前端网络/ip.html" class="sidebar-link">二、IP</a></li><li><a href="/NetWork/20-前端网络/tcp.html" class="sidebar-link">三、TCP</a></li><li><a href="/NetWork/20-前端网络/dns.html" class="sidebar-link">四、DNS</a></li><li><a href="/NetWork/20-前端网络/http.html" class="sidebar-link">五、HTTP</a></li><li><a href="/NetWork/20-前端网络/websocket.html" class="sidebar-link">六、Websocket</a></li><li><a href="/NetWork/20-前端网络/Summary.html" class="sidebar-link">七、Summary</a></li></ul></section></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/Algorithm/" class="sidebar-heading clickable"><span>算法专题</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/Algorithm/30-前端算法" class="sidebar-heading clickable open"><span>30-前端算法</span> <span class="arrow down"></span></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/Algorithm/30-前端算法/排序.html" class="sidebar-link">X、排序</a></li><li><a href="/Algorithm/30-前端算法/Summary.html" class="sidebar-link">X、Summary</a></li></ul></section></li></ul></section></li></ul> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-64685f0e data-v-dad8a512><h3 class="title" style="display:none;" data-v-64685f0e data-v-64685f0e></h3> <!----> <label id="box" class="inputBox" style="display:none;" data-v-64685f0e data-v-64685f0e><input type="password" value="" data-v-64685f0e> <span data-v-64685f0e>Konck! Knock!</span> <button data-v-64685f0e>OK</button></label> <div class="footer" style="display:none;" data-v-64685f0e data-v-64685f0e><span data-v-64685f0e><i class="iconfont reco-theme" data-v-64685f0e></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-64685f0e>vuePress-theme-reco</a></span> <span data-v-64685f0e><i class="iconfont reco-copyright" data-v-64685f0e></i> <a data-v-64685f0e><span data-v-64685f0e>Leibnize 个人学习笔记</span>
            
          <!---->
          2020
        </a></span></div></div> <div data-v-dad8a512><main class="page"><div class="page-title" style="display:none;"><h1>总结</h1> <div data-v-3b7f5bdf><i class="iconfont reco-account" data-v-3b7f5bdf><span data-v-3b7f5bdf>Leibnize 个人学习笔记</span></i> <!----> <!----> <!----></div></div> <div class="theme-reco-content content__default" style="display:none;"><h1 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h1> <h2 id="一、基础"><a href="#一、基础" class="header-anchor">#</a> 一、基础</h2> <p>关于浏览器架构相关的，比如 WebKit 内核，需要 C++ 知识…2020末研究方向之一</p> <h2 id="二、缓存"><a href="#二、缓存" class="header-anchor">#</a> 二、缓存</h2> <p>主要有三个板块：强缓存、协商缓存、缓存位置(DiskCache、MemoryCache)</p> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200908001813.png" align="" style="zoom:50%;"> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200908001815.png" align="" style="zoom:50%;"> <ul><li>地址输入栏：先查找 Disk Cache 是否有匹配，否则发送请求；</li> <li>普通 F5 刷新：优先使用 Memory Cache，其次是 Disk Cache；</li> <li>强制 CtrlF5 刷新：浏览器不使用缓存</li></ul> <p>每当打开一个页面或请求一个资源时，<strong><u>首先</u></strong> 会检查强缓存(通过检查字段来实现，又可细分为 HTTP1.0 和 HTTP1.1 的字段)，会先从 Memory Cache 查找资源引用，然后根据引用从 Disk Cache 获取资源，然后检查与资源过期相关的字段：</p> <ul><li>Expires(服务端最初返回此内容时，标记上的字段，表示过期时间—缺点明显—服务客户两端时间不一致)</li> <li>Cache-control 下的 max-age 键—客户端接收后开始计算，资源的最长存活时间；它还有很多 key !!!
<ul><li><strong>public</strong>：客户端、中间代理服务器均允许缓存资源；</li> <li><strong>private</strong>：只有客户端能缓存，中间代理服务器不能缓存；</li> <li><strong>no-cache</strong>：跳过当前强缓存检查阶段，直接发送 HTTP 请求，即直接进入协商缓存阶段；</li> <li><strong>no-store</strong>：不进行任何形式的缓存；</li> <li><strong>s-max-age</strong>：作用同 max-age，但针对对象是代理服务器；</li></ul></li></ul> <p><strong><u>然后</u></strong>，若强缓存失效，即资源缓存超时，浏览器在请求头中携带相应的 <u>缓存 Tag</u> 来向服务器发请求，服务器根据此 Tag，来告知浏览器是否继续使用缓存；缓存 Tag 有两种：Last-Modified、 ETag：</p> <ul><li>注意：若协商请求是跨域请求，则还会发生简单/非简单请求，而在此之前，还会发生 DNS 查询获取 IP，然后才发起 HTTP 请求，协议处理，再封装 TCP，TCP 请求，三次握手、长连接…每一次回车确认，都会发生上述反应，在获取资源后系统和浏览器还会进行系列处理，可谓相当厉害了…扯远了，回来回来=。=</li> <li>注意：实际上这两个缓存 Tag 是在接收资源那一刻获取到的，前者意为资源最后修改的时间，后者是服务器为资源生成的唯一 标识，一旦文件有更新或修改，这个标识就会发生变化(服务器重新计算生成)；当浏览器需要发起协商请求时，会将这两个 Tag 分别放在 If-Modified-Sine 和 If-None-Match 中，然后随请求报文传送；服务器收到后，查找该资源，并判断这两个资源是否发生了变化(对比前后 Last-Modified 和 ETag )，若不一致，则说明资源已更新，服务端返回新资源，与常规 HTTP 请求响应流程一致；否则返回 304 状态码，告诉浏览器直接用缓存；精度上，ETag 由于 LastModified，服务器也会优先考虑(原因如下)；但性能上不如 LastModified；
<ul><li>**<u>不该重新请求时，重新请求：</u>**编辑文件，但实际上文件内容并无变更，服务端并不清楚文件是否真正改变，仍通过最后编辑时间进行判断，此时资源再次被请求时，会被当做新资源处理，缓存作用失效；</li> <li>**<u>该重新请求时，无重新请求：</u>**Last-Modified 能感知的最小单位时间是秒，若文件在 1 秒内发生多次改变则无法表现出修改，具有局限性；</li></ul></li></ul> <p><strong><u><em>最后</em></u></strong>，关于缓存位置，按优先级从高到低排列：Service Worker、Memory Cache、Disk Cache、Push Cache、网络请求，上图吧：</p> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200923165034.png" alt="截屏2020-09-23 下午4.50.31" style="zoom:50%;"> <p><strong><u>注意</u></strong>：实际场景中：</p> <ul><li>对于频繁变动的资源使用：<code>Cache-Control: no-cache</code>；</li> <li>对于不频繁变动的资源使用：<code>Cache-Control: max-age=31536000</code>；</li> <li>此外，为解决文件及时更新问题()，可通过 webpack 的文件指纹策略，为文件名添加 <code>hash</code>、版本号等动态字段，以实现更改 <u>引用URL</u> 目的(实现更新内容-重新请求资源)；</li></ul> <h2 id="三、存储"><a href="#三、存储" class="header-anchor">#</a> 三、存储</h2> <p>主要在于：Cookie、SessionStorage (区别：会话层级区别)、IndexedDB</p> <p><strong><u>Cookie</u></strong> 设计之初并非用于本地存储，而是为弥补 HTTP 在状态管理上的不足(无状态协议，服务端无法辨别每次请求的客户端的具体情况—只能通过头部信息识别连接对象，无法确认上下文)；</p> <p>Cookie 本质是浏览器中存储的一个很小的、内容以键值对形式存储的文本文件，每次向同一域名发送请求，均会自动携带相同Cookie(这点被 CSRF 利用，可设置 Samesite：Strict 禁止随同发送；或使用 Token—毕竟不会自携带 Token)；服务器拿到 Cookie 后进行解析，即可获取客户端状态(Cookie 多用于存储用户状态，所以被 XSS 利用，可利用 Cookie: HttpOnly 字段禁止 JS 读取)；即 Cookie 用于 <u>状态存储</u>，但缺点也很多：</p> <ul><li>容量缺陷：体积上限只有<code>4KB</code>，只能存储少量信息；</li> <li>性能缺陷：Cookie 紧跟域名发送而不管是否真正需要，随着请求数增多性能浪费越严重——请求携带不必要数据；</li> <li>安全缺陷：Cookie 纯文本形式，在飞行途中很容易被非法用户截获篡改，在有效期内发送给服务器更是危险操作；</li></ul> <p><strong><u>SessionStorage</u></strong>：与 Cookie 区别是不随请求发送、容量大、接口友好，细分为 Session 与 Local，两者差别在于生命周期，前者会话级别，后者持久化；注意使用时，存储对象需要调用 <code>JSON.stringify</code>方法，并且用 <code>JSON.parse</code> 来解析成对象；</p> <p><strong><u>IndexedDB</u></strong>：这个相当少用了，理论容量无上限，为大型数据的存储提供了接口；</p> <p>具有数据库特性：支持事务，存储二进制数据，还有其他特殊特性：</p> <ul><li>键值对存储：内部采用 <u>对象仓库</u> 存放数据，在此仓库中数据采用 <u>键值对</u> 形式存储；</li> <li>异步操作：数据库的读写属于 I/O 操作，浏览器中对异步 I/O 提供了支持；</li> <li>受同源策略限制，无法访问跨域的数据库；</li></ul> <p>但问题是如果前端需要存储这么多的信息，估计需要考虑前后衔接，甚至是软件设计问题了；现提倡云开发，而非本地；</p> <h2 id="四、跨域"><a href="#四、跨域" class="header-anchor">#</a> 四、跨域</h2> <p>主要是同源策略引发的跨域拦截、以及跨域方案(CORS、JSONP、Nginx 等)</p> <h3 id="_4-1、跨域原理"><a href="#_4-1、跨域原理" class="header-anchor">#</a> 4-1、跨域原理</h3> <p>浏览器具有 <strong><u>同源策略</u></strong>：协议、主机-host、端口；同源策略限制了非同源网站的 DOM 操作、Cookie、SessionStorage、IndexedDB、XMLHttpRequest 操作；而若某次请求不符合同源策略，就会产生跨域问题，跨域报错；</p> <p><strong><u>浏览器跨域</u></strong>，其实是浏览器自身的一个安全防控行为；不管跨域与否，假设每个请求都能到达服务器，又假设服务器、网络没问题，响应返回后，经浏览器检测后，若发现是跨域请求，就会被拦截并警告；因为其不符合浏览器的同源策略；</p> <p><strong><u>可以说跨域问题源自于同源策略，而跨域拦截的实现是通过进程通信 IPC 实现；</u></strong></p> <p><strong><u>为何会有跨域拦截行为</u></strong>，为何又会有同源策略?? 假设没有跨域拦截，也即没有同源策略，这样的后果是相当恐怖的：非同源的响应数据能肆意修改 DOM，发送 cookie，获取用户状态，如果配合 XSS 漏洞，注入非法代码，那攻击者就可以为所欲为了；互联网的思想是开放的，但更多的时候，需要用某些规章制度，来约束/限制这种极其容易泛滥的行为，所以就有了同源策略，有了不符合同源策略的跨域拦截，以保证用户信息安全，防止恶意网站窃取数据；<strong><u>此外</u></strong>，我还将其理解为，跨域问题，是浏览器检测到了非同源请求的响应数据，浏览器无法确定这段响应信息是否安全(除非配置 CSP 白名单等)，从安全防范角度，将其拦截是最合适的处理方式；</p> <p><strong><u>跨域拦截实现</u></strong>：</p> <ul><li>1、浏览器是多进程的(渲染进程、网络进程、主进程等)，而 WebKit 渲染引擎 和 V8 引擎 都在渲染进程当中；</li> <li>2、 <code>xhr.send</code> 被调用时(即请求准备发送时)，尚在渲染进程的处理；沙箱中的渲染进程无法发送网络请求(只能通过网络进程来发送)，故需 <strong><u>进程间通信(IPC，Inter Process Communication)</u></strong>， 来将数据传递给浏览器主进程，主进程接收到后，才(通知网络进程)真正地发出相应网络请求；
<ul><li>注意：为防止黑客通过脚本触碰系统资源，浏览器将每一<u>渲染进程分配进沙箱</u>，同时为防止 CPU 芯片一直存在的 <u>Spectre</u> 和  <u>Meltdown</u> 漏洞，采取 <u>站点隔离</u>  的手段，给每一<u>不同站点(一级域名不同)分配沙箱</u>，使其互不干扰；<a href="https://www.youtube.com/watch?v=dBuykrdhK-A&amp;feature=emb_logo" target="_blank" rel="noopener noreferrer">YouTube上Chromium安全团队的演讲视频<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>；</li> <li>注意：chromium  中进程间通信的源码调用顺序如下：<a href="https://chromium.googlesource.com/chromium/src/+/refs/heads/master/ipc/" target="_blank" rel="noopener noreferrer">IPC源码地址<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>、<a href="https://blog.csdn.net/Luoshengyang/article/details/47822689" target="_blank" rel="noopener noreferrer">Chromium IPC源码解析文章<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>；</li> <li>总结：利用 <code>Unix Domain Socket</code>套接字，配合事件驱动的高性能网络并发库  <code>libevent</code> 完成进程通信 IPC 过程；</li></ul></li></ul> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200908001818.png" style="zoom:50%;"> <ul><li>3、服务端处理完并将响应返回，主进程检查到跨域行为，且无配置 CORS 响应头，遂将响应体全部丢弃，上报错误日志输出；而不会发往渲染进程，实现了拦截数据的目的；</li></ul> <h3 id="_4-2、跨域实现"><a href="#_4-2、跨域实现" class="header-anchor">#</a> 4-2、跨域实现</h3> <p>主要是 CORS 的简单非简单请求、JSONP；</p> <h3 id="_4-2-1、cors"><a href="#_4-2-1、cors" class="header-anchor">#</a> 4-2-1、CORS</h3> <p>CORS 跨域资源共享、W3C 标准；</p> <p>CORS 允许浏览器向跨源服务器，发出 <code>XMLHttpRequest</code> 或 <code>Fetch</code> 请求，整个 <code>CORS</code> 通信过程均由浏览器自动完成；</p> <p><strong><u>CORS 前提：1、浏览器支持此功能 IE10+、2、服务器须同意跨域请求(即须附加特定响应头(以供浏览器&quot;放行&quot;))：</u></strong></p> <ul><li>Access-Control-Allow-Origin：表示可允许请求的源；可填具体源名，亦可填 <code>*</code> 表示允许任意源请求；</li> <li>Access-Control-Max-Age：表示预检请求的有效期，在此期间，不必发出另外一条预检请求；</li> <li>Access-Control-Allow-Headers：表示允许发送的请求头字段；</li> <li>Access-Control-Allow-Methods：表示允许的请求方法列表；</li> <li>Access-Control-Allow-Credentials：表示是否允许发送 Cookie，对于跨域请求，浏览器默认值设为 false，否则需要设置为 true，前端也需设置 <code>withCredentials</code> 属性：<code>xhr.withCredentials = true;</code></li></ul> <p><strong><u>基本流程</u></strong>：只管看跨域请求即可：</p> <p>首先，客户端先根据同源策略，对前端请求 URL 与后台交互地址 API 做匹配：</p> <ul><li>若同源则直接发送数据请求；</li> <li>若不同源，则发送跨域请求；</li> <li>然后，服务器收到客户端跨域请求后，根据自身配置返回相应文件头：
<ul><li>若未配置允许跨域，则文件头不包含 <code>Access-Control-Allow-origin</code> 字段；</li> <li>若已配置跨域允许，则返回 <code>Access-Control-Allow-origin + 相应配置规则中的域名的方式</code>；</li></ul></li> <li>最后，浏览器根据与接收到的响应头中的 <code>Access-Control-Allow-origin</code> 字段匹配：
<ul><li>若无该字段，则说明不允许跨域，抛出错误；</li> <li>若有该字段，则将 <u>字段内容</u> 同 <u>当前域名</u> 做比对，
<ul><li>若同源，则说明可跨域，浏览器接受该响应；</li> <li>若不同源，则说明该域名不可跨域，浏览器不接受该响应，并抛出错误；</li></ul></li></ul></li></ul> <p>浏览器根据跨域请求方法和跨域请求头的特定字段，将跨域请求分为两类，凡满足下面条件的属于 <strong><u>简单请求</u></strong>，否则为 <strong><u>非简单请求</u></strong>；</p> <ul><li>请求方法为 GET、POST、HEAD 之一；</li> <li>请求头取值范围：<code>Accept</code>、<code>Accept-Language</code>、<code>Content-Language</code>、<code>Content-Type</code>、<code>DPR</code>、<code>Downlink</code>、<code>Save-Data</code>、<code>Viewport-Width</code>、<code>Width</code> <ul><li>注意：<code>Content-Type</code> 仅限3值：<code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>、<code>text/plain</code></li></ul></li> <li>请求中的任意 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequestUpload" target="_blank" rel="noopener noreferrer">XMLHttpRequestUpload<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 对象均无注册任何事件监听器；<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequestUpload" target="_blank" rel="noopener noreferrer">XMLHttpRequestUpload<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 对象可使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/upload" target="_blank" rel="noopener noreferrer">XMLHttpRequest.upload<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 属性访问；</li> <li>请求中没有使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/ReadableStream" target="_blank" rel="noopener noreferrer">ReadableStream<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 对象；</li></ul> <p><strong><u>简单跨域请求</u></strong>：只是单纯的请求；流程同上面的基本流程神似：</p> <p>请求发出前，浏览器会自动为请求头中，添加字段 <code>Origin</code>，用以说明请求来源；当服务器拿到请求并回应时，会相应地添加字段 <code>Access-Control-Allow-Origin</code>，并设置字段值(或请求 Origin 值，或别值)；然后，当浏览器收到时，若发现 <code>Origin</code> 值不在此字段范围内时，就会将响应拦截；所以**<u>字段 <code>Access-Control-Allow-Origin</code> 是服务器用来决定浏览器是否拦截此响应的必需字段</u>**；</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> Koa <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'koa'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Koa</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token parameter">ctx<span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// 关键之处:</span>
  ctx<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">&quot;Access-Control-Allow-Origin&quot;</span><span class="token punctuation">,</span> ctx<span class="token punctuation">.</span>header<span class="token punctuation">.</span>origin<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">await</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>ctx<span class="token punctuation">.</span>path <span class="token operator">===</span> <span class="token string">'/api/corsname'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'server 8080...'</span><span class="token punctuation">)</span>
app<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">8080</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p><strong><u>非简单跨域请求</u></strong>：浏览器则会先使用 <code>OPTIONS</code> 方法，自动发起预检请求到服务器，以获知服务器是否允许该实际请求，避免跨域请求对服务器的用户数据产生未预期的影响；主要体现在两方面：<strong><u>预检请求</u></strong>、<strong><u>响应字段</u></strong>，主流程是：</p> <p>首先，客户端先发送 <u><strong>预检请求(而非实际请求)</strong></u>，用以告知服务器接下来的 CORS 请求的具体信息(方法、请求头)；</p> <ul><li>Access-Control-Request-Method：指出 (接下来的)CORS 请求用到哪个 HTTP 方法；</li> <li>Access-Control-Request-Headers：指出 (接下来的)CORS 请求将要加上什么请求头；</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 以非简单请求 PUT 方法为例</span>
<span class="token keyword">var</span> url <span class="token operator">=</span> <span class="token string">'http://xxx.com'</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> xhr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
xhr<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">'PUT'</span><span class="token punctuation">,</span> url<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
xhr<span class="token punctuation">.</span><span class="token function">setRequestHeader</span><span class="token punctuation">(</span><span class="token string">'X-Custom-Header'</span><span class="token punctuation">,</span> <span class="token string">'xxx'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
xhr<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 预检请求请求头 - 代码执行后浏览器随即自动发送 预检请求</span>
<span class="token comment">// 预检请求方法为 OPTIONS</span>
<span class="token constant">OPTIONS</span> <span class="token operator">/</span> <span class="token constant">HTTP</span><span class="token operator">/</span><span class="token number">1.1</span>
Origin<span class="token operator">:</span> 源地址
Host<span class="token operator">:</span> xxx<span class="token punctuation">.</span>com <span class="token operator">-</span> 目的地址
Access<span class="token operator">-</span>Control<span class="token operator">-</span>Request<span class="token operator">-</span>Method<span class="token operator">:</span> <span class="token constant">PUT</span> <span class="token operator">-</span> 非简单请求标志之一
Access<span class="token operator">-</span>Control<span class="token operator">-</span>Request<span class="token operator">-</span>Headers<span class="token operator">:</span> <span class="token constant">X</span><span class="token operator">-</span>Custom<span class="token operator">-</span>Header <span class="token operator">-</span> 非简单请求标志之一
</code></pre></div><p>然后，服务端接收并返回 <u><strong>预检请求的响应</strong></u>，客户端检查此响应：</p> <ul><li>若 CORS 请求不满足预检请求响应头的条件，则触发 <code>XMLHttpRequest</code> 的 <code>onerror</code>方法，后续真正 CORS 请求不发出；</li> <li>若 CORS 请求满足，则发出真正 CORS 请求；</li></ul> <div class="language-http extra-class"><pre class="language-http"><code>// 预检请求响应头
<span class="token response-status">HTTP/1.1 <span class="token property">200 OK</span></span>
<span class="token header-name keyword">Access-Control-Allow-Origin:</span> *
<span class="token header-name keyword">Access-Control-Allow-Methods:</span> GET, POST, PUT
<span class="token header-name keyword">Access-Control-Allow-Headers:</span> X-Custom-Header
<span class="token header-name keyword">Access-Control-Allow-Credentials:</span> true
<span class="token header-name keyword">Access-Control-Max-Age:</span> 1728000
<span class="token header-name keyword">Content-Type:</span> text/html; charset=utf-8
<span class="token header-name keyword">Content-Encoding:</span> gzip
<span class="token header-name keyword">Content-Length:</span> 0
</code></pre></div><p>最后，若一切允许，则客户端发送真正的 CORS 跨域请求：流程同简单请求：客户端自动加上 <code>Origin</code> 字段，服务端返回  <code>Access-Control-Allow-Origin</code>；</p> <p><strong><u>非简单跨域请求优化</u></strong>：</p> <ul><li>尽量发出简单请求；</li> <li>服务端设置 <code>Access-Control-Max-Age</code> 字段：在有效时间内浏览器无需再为同一请求发送预检请求；局限性：只能为同一请求缓存，无法针对整个域或模糊匹配 URL 做缓存；</li></ul> <h3 id="_4-2-2、jsonp"><a href="#_4-2-2、jsonp" class="header-anchor">#</a> 4-2-2、JSONP</h3> <p>原理主要是利用 <code>script</code> 标签 <code>src</code> 属性没有跨域限制，通过 src 填上目标地址发出 GET 请求，由服务端返回一个预先定义好的 JS 函数调用，并将服务器数据以该函数参数形式响应；JSONP 需要前后端配合完成；最大优势是兼容性好(兼容 IE 低版本)，但缺点明显：只支持 GET 请求；执行过程如下：</p> <ul><li>首先，前端定义一个解析函数；比如： <code>jsonpCallback = function (res) {}</code></li> <li>然后，通过 <code>params</code>  的形式包装 <code>script</code> 标签的请求参数，并声明为上述执行函数名；比如：<code>cb=jsonpCallback</code>；</li> <li>然后，后端获取到前端声明的执行函数(<code>jsonpCallback</code>)，并以带上参数且调用执行函数的方式传递给前端</li> <li>最后，前端在 <code>script</code> 标签请求返回资源时就会去执行 <code>jsonpCallback</code>，并通过回调的方式拿到数据；</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 1、创建全局函数，等待执行</span>
<span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">'text/javascript'</span><span class="token operator">&gt;</span>
window<span class="token punctuation">.</span><span class="token function-variable function">jsonpCallback</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">res</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
<span class="token comment">// 2、通过下方代码 jsonp 构建的请求脚本，写入 html 后便等待请求内容返回</span>
<span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">'http://localhost:8080/api/jsonp?id=1&amp;cb=jsonpCallback'</span> type<span class="token operator">=</span><span class="token string">'text/javascript'</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
<span class="token comment">// 3、服务端拿到 URL 参数，处理请求，最后在响应体中写入 jsonpCallback(...)，并将处理后的内容以函数参数形式传入</span>
<span class="token comment">// 4、前端拿到后台内容并执行，执行调用全局函数，并将参数传入函数中执行；</span>
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 1、前端</span>
<span class="token keyword">function</span> <span class="token constant">JSONP</span><span class="token punctuation">(</span><span class="token punctuation">{</span> url<span class="token punctuation">,</span> params <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> callbackKey <span class="token operator">=</span> <span class="token string">&quot;cb&quot;</span><span class="token punctuation">,</span> callback <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 定义本地的唯一 callbackId，若是没有的话则初始化为 1</span>
  <span class="token constant">JSONP</span><span class="token punctuation">.</span>callbackId <span class="token operator">=</span> <span class="token constant">JSONP</span><span class="token punctuation">.</span>callbackId <span class="token operator">||</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> callbackId <span class="token operator">=</span> <span class="token constant">JSONP</span><span class="token punctuation">.</span>callbackId<span class="token punctuation">;</span>
  <span class="token comment">// 把要执行的回调加入到 JSON 对象中，避免污染 window</span>
  <span class="token constant">JSONP</span><span class="token punctuation">.</span>callbacks <span class="token operator">=</span> <span class="token constant">JSONP</span><span class="token punctuation">.</span>callbacks <span class="token operator">||</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token constant">JSONP</span><span class="token punctuation">.</span>callbacks<span class="token punctuation">[</span>callbackId<span class="token punctuation">]</span> <span class="token operator">=</span> callback<span class="token punctuation">;</span>
  <span class="token comment">// 把这个名称加入到参数中: 'cb=JSONP.callbacks[1]'</span>
  params<span class="token punctuation">[</span>callbackKey<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">JSONP.callbacks[</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>callbackId<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">]</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
  <span class="token comment">// 得到'id=1&amp;cb=JSONP.callbacks[1]'</span>
  <span class="token keyword">const</span> paramString <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>params<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">key</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  	<span class="token keyword">return</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>key<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">=</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token function">encodeURIComponent</span><span class="token punctuation">(</span>params<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">&quot;&amp;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 创建 script 标签</span>
  <span class="token keyword">const</span> script <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">&quot;script&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  script<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span><span class="token string">&quot;src&quot;</span><span class="token punctuation">,</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>url<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">?</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>paramString<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>script<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// id 自增，保证唯一</span>
  <span class="token constant">JSONP</span><span class="token punctuation">.</span>callbackId<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token constant">JSONP</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  url<span class="token operator">:</span> <span class="token string">&quot;http://localhost:8080/api/jsonps&quot;</span><span class="token punctuation">,</span>
  params<span class="token operator">:</span> <span class="token punctuation">{</span>
    a<span class="token operator">:</span> <span class="token string">&quot;2&amp;b=3&quot;</span><span class="token punctuation">,</span>
    b<span class="token operator">:</span> <span class="token string">&quot;4&quot;</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  callbackKey<span class="token operator">:</span> <span class="token string">&quot;cb&quot;</span><span class="token punctuation">,</span>
  <span class="token function">callback</span><span class="token punctuation">(</span><span class="token parameter">res</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token constant">JSONP</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  url<span class="token operator">:</span> <span class="token string">&quot;http://localhost:8080/api/jsonp&quot;</span><span class="token punctuation">,</span>
  params<span class="token operator">:</span> <span class="token punctuation">{</span> id<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
  callbackKey<span class="token operator">:</span> <span class="token string">&quot;cb&quot;</span><span class="token punctuation">,</span>
  <span class="token function">callback</span><span class="token punctuation">(</span><span class="token parameter">res</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 注意: encodeURI 和 encodeURIComponent 区别：</span>
<span class="token comment">// 前者不会对本身属于 URI 的特殊字符进行编码，例如冒号、正斜杠、问号和井字号；</span>
<span class="token comment">// 后者则会对它发现的任何非标准字符进行编码</span>
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 2、后端</span>
<span class="token keyword">const</span> Koa <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'koa'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Koa</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> items <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">{</span> id<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> title<span class="token operator">:</span> <span class="token string">'title1'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> id<span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span> title<span class="token operator">:</span> <span class="token string">'title2'</span> <span class="token punctuation">}</span><span class="token punctuation">]</span>

app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token parameter">ctx<span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>ctx<span class="token punctuation">.</span>path <span class="token operator">===</span> <span class="token string">'/api/jsonp'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token punctuation">{</span> cb<span class="token punctuation">,</span> id <span class="token punctuation">}</span> <span class="token operator">=</span> ctx<span class="token punctuation">.</span>query<span class="token punctuation">;</span>
    <span class="token keyword">const</span> title <span class="token operator">=</span> items<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token parameter">item</span> <span class="token operator">=&gt;</span> item<span class="token punctuation">.</span>id <span class="token operator">==</span> id<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token string">'title'</span><span class="token punctuation">]</span>
    ctx<span class="token punctuation">.</span>body <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>cb<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">(</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span><span class="token punctuation">{</span>title<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">)</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>ctx<span class="token punctuation">.</span>path <span class="token operator">===</span> <span class="token string">'/api/jsonps'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token punctuation">{</span> cb<span class="token punctuation">,</span> a<span class="token punctuation">,</span> b <span class="token punctuation">}</span> <span class="token operator">=</span> ctx<span class="token punctuation">.</span>query<span class="token punctuation">;</span>
    ctx<span class="token punctuation">.</span>body <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>cb<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">(</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span><span class="token punctuation">{</span> a<span class="token punctuation">,</span> b <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">)</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'listen 8080...'</span><span class="token punctuation">)</span>
app<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">8080</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="_4-2-3、nginx"><a href="#_4-2-3、nginx" class="header-anchor">#</a> 4-2-3、Nginx</h3> <p>正向代理服务器是帮助 <strong>客户端</strong>，访问自身无法访问的服务器并将结果返回客户端；</p> <p>反向代理服务器是帮助其他 <strong>服务器</strong>，获取到客户端发送请求并转交服务器；</p> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200908001819.png" align="" style="zoom:40%;"> <p>Nginx 是一种高性能的反向代理服务器，可解决跨域问题：</p> <div class="language-nginx extra-class"><pre class="language-nginx"><code><span class="token keyword">server</span> <span class="token punctuation">{</span>
  <span class="token keyword">listen</span>  <span class="token number">80</span><span class="token punctuation">;</span>
  <span class="token keyword">server_name</span>  client<span class="token punctuation">.</span>com<span class="token punctuation">;</span>
  <span class="token keyword">location</span> <span class="token operator">/</span>api <span class="token punctuation">{</span>
    <span class="token keyword">proxy_pass</span> <span class="token keyword">server</span><span class="token punctuation">.</span>com<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>Nginx 相当于是一个跳板机，域名是 <code>client.com</code>，客户端首先访问 <code>client.com/api</code>，然后 Nginx 服务器作为反向代理，将请求转发给 <code>server.com</code>，当响应返回时又将响应给到客户端，完成整个跨域请求；</p> <h2 id="五、应用"><a href="#五、应用" class="header-anchor">#</a> 五、应用</h2> <p>图片懒加载、WebWorker，详看实现章节；</p> <h2 id="六、输入url到展示"><a href="#六、输入url到展示" class="header-anchor">#</a> 六、输入URL到展示</h2> <p>这题目太难了，往深还可挖：输入设备历史、输出设备历史、浏览器历史、计算机系统历史、编译原理…</p> <p>同为 2020年研究方向之一，加油吧；</p> <h3 id="_6-1、基本流程"><a href="#_6-1、基本流程" class="header-anchor">#</a> 6-1、基本流程</h3> <p>强缓存检查(命中则使用)、DNS 解析(DNS缓存)、协商缓存或直接获取数据，TCP建立连接、HTTP发起请求—HTTP(头部含 Connection:Keep-Alive 则保持长连接—TCP连接不关闭—多个HTTP请求复用同一 TCP 连接)、TCP—IP 寻址—服务器处理并响应；</p> <p>浏览器获取相关资源文件，若响应头 Content-Type 为 gzip 则先解压，若为 text/html 则进入解析渲染过程；</p> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200908001821.png" style="zoom:50%;"> <ul><li>解析1：浏览器无法识别 HTML，须先将 HTML内容转换为能被理解的 <strong><u>DOM 树(本质是一以 document 为根节点的多叉树)</u></strong>；
<ul><li><u>字节数据</u> 0100101110—&gt; <u>HTML 字符串</u>—&gt;<u>Token</u> (通过词法分析转换为 标记；标记化—Tokenization；标记还是字符串，是构成代码的最小单位)—&gt; <u>Node</u> —&gt;根据不同 Node 之前的联系构建 <u>DOM 树</u>；解析算法如下：
<ul><li>1-1、标记化算法—词法分析：算法输入为 <u>HTML文本</u>，输出为 <u>HTML标记</u>，故亦称 <u><strong>标记生成器</strong></u>；标记打开-标记名称状态-数据状态-标记打开-.....</li> <li>1-2、建树算法—语法分析；首先，<u><strong>解析器</strong></u> 会创建一个 <code>document</code> 对象 (作为 <strong><u>DOM 树</u></strong> 的根节点)；随后，<u><strong>标记生成器</strong></u> 会将每个标记的信息发送给 <strong><u>建树器</u></strong>，<strong><u>建树器</u></strong>  接收到相应的标记时，会 <strong>创建对应的 DOM 对象</strong>，在创建这个 <code>DOM对象</code> 后会做两件事：将 <code>DOM对象</code> 加入 <strong><u>DOM 树</u></strong> 中、将对应标记，压入存放 <strong>开放(与<u>闭合标签</u>意思对应)元素</strong> 的栈中；</li></ul></li></ul></li> <li>解析2：渲染引擎将 CSS 样式表转化为浏览器可理解的 styleSheets，计算出 DOM 节点的样式；
<ul><li>CSSOM 树(同步进行)：格式化、标准化、并根据继承与层叠规则计算节点具体样式；</li> <li>格式化：浏览器无法直接识别 CSS 样式文本，因此渲染引擎收到 CSS 文本后须将其转化为结构化的对象： <strong><u>styleSheets</u></strong>；(可通过 <code>document.styleSheets</code> 查看)，结构包含 3 种 CSS 来源：link/style/内嵌style；</li> <li>标准化：有些 CSS 样式的数值不容易被渲染引擎所理解，在计算样式前需将其标准化；比如 em-&gt;px；</li> <li>计算每个节点的具体样式信息：遵从两个规则：继承、层叠；计算完样式后，所有样式值会被挂在到 <code>window.getComputedStyle</code> 中，可通过 JS 来获取计算后的样式；</li></ul></li> <li>解析3：创建 <strong><u>布局树</u></strong>，并计算元素的布局信息；
<ul><li>利用前面的 <strong><u>DOM 树</u></strong> 和 <strong><u>DOM 样式</u></strong> ，排除 <code>script、meta</code> 等功能化、非视觉节点，排除 <code>display: none</code> 的节点，并通过浏览器的布局系统 <u>计算元素位置信息</u>、<u>确定元素位置</u>，构建一棵只包含可见元素的 <strong><u>布局树(Layout Tree)</u></strong>；1、遍历生成的 <strong><u>DOM 树</u></strong> 节点，并将它们添加到 <strong><u>布局树</u></strong> 中；2、计算 <strong><u>布局树</u></strong> 节点的坐标位置；3-1、注意：<strong><u>布局树</u></strong>  包含可见元素，设置 <code>display: none</code>的元素和 <code>head</code> 等功能标签，将不会被放入其中；3-2、注意：现在 Chrome 团队已经做了大量重构，已无生成 <strong><u>渲染树(Render Tree)</u></strong> 的过程(布局树的信息已非常完善，完全拥有 Render Tree 的功能)；</li> <li><img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200908001824.png" align="" style="zoom:50%;"></li></ul></li> <li>渲染1：对布局树进行分层，并生成 <strong><u>分层树</u></strong>；
<ul><li>解析阶段得到 DOM节点/样式/位置信息，但不足以开始绘制页面，因还需考虑页面中的复杂效果与场景，比如复杂 3D 动画变换效果、页面滚动、元素含层叠上下文时的显示与隐藏、使用 z-indexing 做 z 轴排序等；而为更加方便地实现这些效果，在浏览器在构建完 <strong><u>布局树</u></strong> 后，渲染引擎还需为特定节点生成专用图层，构建一棵 <strong><u>图层树(Layer Tree)</u></strong>；</li> <li>Layer Tree 通过显式合成及隐式合成来进行合成的条件；前者会对含有特殊 CSS 属性的节点提升为单独一层(z-index/filter/根元素/will-change/transform/opacity等)；后者则将<u>层叠等级低</u> 的节点被提升为单独图层后，则 <u>所有层叠等级比它高</u> 的节点 **都会 **成为一个单独的图层；</li></ul></li> <li>渲染2：为每个图层生成 <strong><u>绘制列表</u></strong>；
<ul><li>渲染引擎会将图层的绘制拆分成一个个绘制指令；比如先画背景、再描绘边框等，然后将这些指令按顺序组合成一个 <strong><u>待绘制列表</u></strong>，相当于制作一份绘制操作任务清单，可在 Chrome 开发者工具中的<code>Layers</code>面板观察绘制列表:</li></ul></li> <li>渲染3：<strong><u>渲染进程的主线程</u></strong> 会给 <strong><u>合成线程</u></strong> 发送 <code>commit</code> 消息，将 <strong><u>绘制列表</u></strong> 提交给 <strong><u>合成线程</u></strong>；合成线程将图层分块(避免<u>在有限视口内一次性绘制所有页面</u> 而造成的性能浪费)，即选择视口附近的 <strong>图块</strong>，优先将其交给 <strong><u>栅格化线程池</u></strong> 来生成位图；
<ul><li>注意：渲染进程中专门维护一个 <strong><u>栅格化线程池</u></strong>，负责将 <strong>图块</strong> 转换为 <strong>位图数据</strong>；</li> <li>注意：生成位图的过程实际上都会使用 GPU 进行加速，生成的位图最后发送给 <strong><u>合成线程</u></strong>；</li></ul></li> <li>渲染4：合成线程发送绘制图块命令给浏览器进程，浏览器进程根据指令生成页面，并显示到显示器上；
<ul><li><p>生成图块并栅格化操作完成后，<strong><u>合成线程</u></strong> 会生成一个绘制命令—<code>DrawQuad</code>，并发送给浏览器进程的 <strong><u>viz组件</u></strong>，组件根据这个命令，将页面内容绘制到内存(缓冲)，然后把这部分内存数据发送给显卡；所以，当某个动画大量占用内存时，浏览器生成图像的速度变慢，图像传送显卡数据不及时，而显示器还是以不变频率刷新，因此会出现卡顿，出现明显的掉帧现象；</p></li> <li><p>注意：无论是 PC 显示器还是手机屏幕，都有一个固定的刷新频率，一般是 60 HZ(60 帧、每秒更新60张图，停留 16.7 ms/图)，而每次更新的图片均来自于显卡的 <strong><u>前缓冲区</u></strong>；当显卡接收到浏览器进程传来的新的页面后，会合成相应的新图像，并将新图像保存到  <u><strong>后缓冲区</strong></u>；然后系统自动将 <strong><u>前缓冲区</u></strong> 和  <strong><u>后缓冲区</u></strong> 对换位置，如此循环更新；</p></li></ul></li></ul> <p><strong><u>解析过程：解析DOM、解析CSS、布局树；</u></strong></p> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200908001825.png" align="" style="zoom:50%;"> <p><u><strong>渲染过程：分层树、绘制列表、生成图块并栅格化、显示内容</strong>；</u></p> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200908001828.png" style="zoom:50%;"> <h3 id="_6-2、重排-重绘-合成"><a href="#_6-2、重排-重绘-合成" class="header-anchor">#</a> 6-2、重排/重绘/合成</h3> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200908001829.png" align="" style="zoom:50%;"> <p><strong><u>重排</u></strong>：对 DOM 修改导致元素的尺寸或位置发生变化时，浏览器需要重新计算渲染树，触发重排/回流；</p> <ul><li><strong><u>重排触发条件</u></strong>：对 DOM 结构的修改引发 DOM 几何尺寸变化时，会导致 <strong><u>重排(reflow)</u></strong>；
<ul><li>页面初次渲染；</li> <li>元素字体大小变化；</li> <li>浏览器窗口大小改变；</li> <li>激活 CSS 伪类；比如 :hover；</li> <li>DOM 元素的几何属性变化，常见的比如：<code>width</code>、<code>height</code>、<code>padding</code>、<code>margin</code>、<code>left</code>、<code>top</code>、<code>border</code> 等；</li> <li>元素尺寸、位置、内容发生改变；</li> <li>使 DOM 节点发生 <code>增减</code> 或 <code>移动</code>；</li> <li>读写 <code>offset</code> 族、<code>scroll</code>族、<code>client</code> 族属性时，浏览器为获取这些值，需要进行回流操作；</li> <li>查询某些属性或调用某些方法
<ul><li>clientWidth、clientHeight、clientTop、clientLeft</li> <li>offsetWidth、offsetHeight、offsetTop、offsetLeft</li> <li>scrollWidth、scrollHeight、scrollTop、scrollLeft</li> <li>getComputedStyle()</li> <li>getBoundingClientRect()</li> <li>scrollTo()</li></ul></li></ul></li> <li><strong><u>重排过程</u></strong>：依照下面的渲染流水线，触发重排/回流时，若 DOM 结构发生改变，则重新渲染 DOM 树，然后将后续流程(含主线程外的任务)全部走一遍；相当于将解析和合成的过程重新又走了一篇，开销巨大；</li></ul> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200908001830.png" align="" style="zoom:50%;"> <p><strong><u>重绘</u></strong>：DOM 修改导致样式发生变化，但无影响其几何属性，触发重绘，而不触发回流；而由于 DOM 位置信息无需更新，省去布局过程，性能上优于回流；</p> <ul><li><p><strong><u>重绘触发条件</u></strong>：当 DOM 的修改导致样式变化，且没有影响几何属性时，会导致 <strong><u>重绘(repaint)</u></strong>；</p></li> <li><p><strong><u>重绘过程</u></strong>：由于没有导致 DOM 几何属性变化，故元素的位置信息无需更新，从而省去布局与建图层树过程，然后继续进行分块、生成位图等后面系列操作；</p></li></ul> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200908001831.png" align="" style="zoom:50%;"> <ul><li>注意：重绘跳过了 <u>生成布局树</u> 和 <u>建图层树</u> 阶段，直接生成绘制列表，然后继续进行分块、生成位图等后面一系列操作；</li> <li>注意：重绘不一定导致重排，但重排一定发生了重绘；</li> <li>注意：<strong><u><em>重排比重绘的代价要更高</em></u></strong>；有时即使仅仅重排一个单一的元素，其父元素及任何跟随它的元素也会产生重排；为避免频繁重排导致的性能问题，现代浏览器会对频繁的重排或重绘操作进行**<u><em>优化</em></u><strong>：浏览器会维护一个 flush 队列，以存放触发重排与重绘的任务，若队列中任务数量或时间间隔达到一个阈值时，浏览器就会将此队列任务一次性出队清空，进行一次批处理，如此可将多次重排和重绘变成一次；</strong><u><em>但当</em></u>**访问一些即使属性时，为获得此时此刻的、最准确的属性值，浏览器会提前将 flush 队列的任务出队：clientwidth、clientHeight、clientTop、clientLeftoffsetwidth、offsetHeight、offsetTop、offsetLeftscrollwidth、scrollHeight、scrollTop、scrollLeftwidth、heightgetComputedStyle()、getBoundingClientRect()</li></ul> <p><strong><u>合成</u></strong>：直接合成，比如利用 CSS3 的 <code>transform</code>、<code>opacity</code>、<code>filter</code> 等属性可实现合成效果，即  <strong><u>GPU加速</u></strong>；</p> <p>补充：GPU加速即：在使用<code>CSS3</code>中的<code>transform</code>、<code>opacity</code>、<code>filter</code>属性时，跳过布局和绘制流程，直接进入非主线处理的部分，即交给合成线程；</p> <ul><li>GPU 加速原因：在合成的情况下，会直接跳过布局和绘制流程，直接进入<code>非主线程</code>处理的部分，即直接交给 <strong><u>合成线程</u></strong> 处理：
<ul><li>充分发挥 GPU 优势：<strong><u>合成线程</u></strong> 生成位图的过程中：会调用线程池，并在其中使用 GPU 进行加速生成，而 GPU 是擅长处理位图数据；</li> <li><strong><u><em>无占用主线程资源</em></u></strong>：即使主线程卡住，但效果依然能够流畅地展示；</li></ul></li> <li>GPU 使用注意：GPU 渲染字体会导致字体模糊，过多 GPU 处理会导致内存问题；</li></ul> <p><strong><u>最佳实践</u></strong>：</p> <p>CSS：</p> <ul><li>避免使用多层内联样式；</li> <li>避免使用 CSS 表达式，比如 <code>clac()</code>；</li> <li>CSS 选择符 <u>从右往左</u> 匹配查找，避免节点层级过多；</li> <li>使用 <code>visibility</code> 替换 <code>display: none</code>，前者只引起重绘，后者则触发回流；</li> <li>避免使用 <code>table</code> 布局，可能很小的一个小改动会造成整个 <code>table</code> 的重新布局；</li> <li>使用 <code>transform</code> 替代 <code>top</code>，<code>transform</code> 和 <code>opacity</code> 效果，不会触发 <code>layout</code> 和 <code>repaint;</code></li> <li>动画效果/动画元素，可使用绝对定位使其脱离文档流；减少频繁地触发回流重绘；
<ul><li>比如：将动画效果应用到 <code>position</code>  属性为 <code>absolute</code> 或 <code>fixed</code> 元素上；</li></ul></li></ul> <p>JavaScript：</p> <ul><li><p>避免频繁操作样式，可汇总后统一 <u>一次修改</u>；</p></li> <li><p>避免频繁使用 <code>style</code>，而采用修改 <code>class</code> 方式；</p></li> <li><p>极限优化时，修改样式可将其 <code>display: none</code> 后修改；</p></li> <li><p>使用 <code>resize</code>、<code>scroll</code>  时进行防抖和节流处理，减少回流次数；</p></li> <li><p>避免频繁读取会引发回流重绘的属性，若需多次使用则可考虑缓存；</p></li> <li><p>避免频繁操作 DOM，减少 <code>dom</code>的增删次数，可使用 <u>字符串</u> 或 <code>documentFragment</code> 一次性插入；</p> <ul><li>比如：使用 <code>createDocumentFragment</code> 进行批量 DOM 操作，修改完毕后，再放入文档流；</li> <li>比如：先使用 <code>display:none</code> 避开回流重绘，操作结束后再显示；</li></ul></li> <li><p>避免多次触发上面提到的那些会触发回流的方法，可使用变量将查询结果缓存，避免多次查询；</p></li> <li><p>动画实现的速度的选择，动画速度越快，回流次数越多，也可选择使用 <code>requestAnimationFrame;</code></p></li> <li><p>将频繁重绘或者回流的节点提升为合成层，图层能够阻止该节点的渲染行为影响别的节点；比如对于 <code>video</code> 标签来说，浏览器会自动将该节点变为图层；</p> <ul><li>设置节点为图层的方式有很多，我们可以通过以下几个常用属性可以生成新图层：</li> <li><code>will-change</code></li> <li><code>video</code>、<code>iframe</code> 标签</li></ul></li> <li><p>添加 <code>will-change: tranform</code>：让渲染引擎为节点单独实现一图层；在变换发生时，仅利用 <strong><u>合成线程</u></strong> 去处理这些变换而不牵扯主线程，提高渲染效率；</p> <ul><li><p>注意：值并非限制 tranform，任何可实现合成效果的 CSS 属性均可使用 <code>will-change</code> 来声明；<a href="https://juejin.im/post/5da52531518825094e373372" target="_blank" rel="noopener noreferrer">使用例子<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>；</p></li> <li><p>注意：通俗说即利用 CSS3 的<code>transform</code>、<code>opacity</code>、<code>filter</code> 这些属性，以实现合成的效果，即<code>GPU</code>加速；</p></li> <li><div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">#divId</span> <span class="token punctuation">{</span>  <span class="token property">will-change</span><span class="token punctuation">:</span> transform<span class="token punctuation">;</span> <span class="token punctuation">}</span>
</code></pre></div></li></ul></li></ul> <h3 id="_6-3、实际问题"><a href="#_6-3、实际问题" class="header-anchor">#</a> 6-3、实际问题</h3> <p><strong><u>DOM 操作性能问题</u></strong></p> <p>原因：跨线程操作；DOM 属于渲染引擎、脚本属于 JS 引擎；通过 JS 操作 DOM 就涉及两线程通信问题；操作 DOM 次数多，跨线程间通信频繁，且操作 DOM 可能带来重排情况，导致性能问题；改进：</p> <ul><li><code>requestAnimationFrame</code>  方式去循环的插入 DOM；</li> <li>虚拟滚动 (virtualized scroller)：只渲染可视区域内的内容，非可见区域的完全不渲染，当用户在滚动时实时去替换渲染内容  <a href="https://github.com/bvaughn/react-virtualized" target="_blank" rel="noopener noreferrer">react-virtualized<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>；</li></ul> <p><strong><u>渲染阻塞问题</u></strong></p> <p>首先，渲染前提是生成分层树，故 HTML 和 CSS 势必会阻塞渲染；</p> <ul><li>优化：若想渲染快，可降低初始所需的渲染的文件 大小，并且扁平层级，优化选择器；</li> <li>注意：CSS 由单独的下载线程异步下载，由于 DOM 树的解析和构建此步与 css 并无关系，故并不会影响 DOM 解析，但最终布局树需要 DOM 树和 DOM 样式的，因此 CSS 会阻塞布局树的建立；</li></ul> <p>然后，当浏览器在解析到  <code>script</code> 标签时，会暂停构建 DOM，完成后才会从暂停的地方重新开始(即 script 会阻塞页面渲染)；</p> <ul><li>因为：JS属于单线程，在加载 <code>script</code> 标签内容时，渲染线程会被暂停，因 <code>script</code>标签中内容可能会操作<code>DOM</code>，若加载<code>script</code>标签的同时渲染页面就会产生冲突，渲染线程(<code>GUI</code>)和 JS 引擎线程是互斥的；</li> <li>优化：若想首屏渲染快，一般而言不应在首屏时就加载 JS 文件，而将 <code>script</code> 标签放在 <code>body</code> 标签底部；</li> <li>优化：若想首屏渲染快，亦可给 <code>script</code> 标签添加 <code>defer</code> 或 <code>async</code> 属性：
<ul><li><code>defer</code> 属性：表示该 JS 文件会并行下载，但会放到 HTML 解析完成后顺序执行，此时 <code>script</code> 标签可放在任意位置；</li> <li><code>async</code> 属性：对于没有任何依赖的 JS 文件可加上此属性 ，表示 JS 文件下载和解析不会阻塞渲染；</li> <li>注意：一般脚本与 DOM 元素和其它脚本间的依赖关系不强时会选用 async；当脚本依赖于 DOM 元素和其它脚本的执行结果时会选用 defer；</li></ul></li></ul> <p><strong><u>关键渲染路径问题</u></strong></p> <p>不考虑缓存和优化网络协议，只考虑可以通过哪些方式来最快的渲染页面：</p> <ul><li>从文件大小：前略；</li> <li>从 <code>script</code> 标签使用：前略；</li> <li>从 CSS、HTML 的代码书写：前略；</li> <li>从需要下载的内容是否需要在首屏使用：前略；</li></ul> <p><strong><u>DOM 树的构建是文档加载何时开始：</u></strong></p> <ul><li>构建 <code>DOM</code> 树是一渐进过程，为达到更好用户体验，渲染引擎会尽快将内容显示在屏幕上，而不必等到整个 <code>HTML</code> 文档解析完后才开始构建与布局；</li></ul> <p><u><strong>三树构建顺序关系：</strong></u></p> <ul><li>三个过程在实际进行的时候并不是完全独立的，而是交叉，一边加载，一边解析，一边渲染；</li></ul></div> <footer class="page-edit" style="display:none;"><!----> <div class="last-updated"><span class="prefix">Last Updated: </span> <span class="time">9/29/2020, 4:19:55 PM</span></div></footer> <!----> <!----> <!----></main> <!----></div></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div></div></div>
    <script src="/assets/js/app.f95d0077.js" defer></script><script src="/assets/js/3.49babee5.js" defer></script><script src="/assets/js/1.269e4bda.js" defer></script><script src="/assets/js/135.a7c3e822.js" defer></script>
  </body>
</html>
