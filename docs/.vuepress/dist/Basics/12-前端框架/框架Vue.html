<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>一、整体流程 | Leibnize 个人学习笔记</title>
    <meta name="generator" content="VuePress 1.5.4">
    
    <meta name="description" content="整理自网络">
    <link rel="preload" href="/assets/css/0.styles.a3549ad8.css" as="style"><link rel="preload" href="/assets/js/app.f95d0077.js" as="script"><link rel="preload" href="/assets/js/3.49babee5.js" as="script"><link rel="preload" href="/assets/js/1.269e4bda.js" as="script"><link rel="preload" href="/assets/js/133.0f2404ed.js" as="script"><link rel="prefetch" href="/assets/js/10.6aa86c9d.js"><link rel="prefetch" href="/assets/js/100.2d552503.js"><link rel="prefetch" href="/assets/js/101.380eba67.js"><link rel="prefetch" href="/assets/js/102.4bd44e2f.js"><link rel="prefetch" href="/assets/js/103.c3ba7b95.js"><link rel="prefetch" href="/assets/js/104.93048938.js"><link rel="prefetch" href="/assets/js/105.640b5e1a.js"><link rel="prefetch" href="/assets/js/106.703adc14.js"><link rel="prefetch" href="/assets/js/107.991cb147.js"><link rel="prefetch" href="/assets/js/108.f2bd0aec.js"><link rel="prefetch" href="/assets/js/109.1d937267.js"><link rel="prefetch" href="/assets/js/11.a1d51055.js"><link rel="prefetch" href="/assets/js/110.332390f4.js"><link rel="prefetch" href="/assets/js/111.71635c45.js"><link rel="prefetch" href="/assets/js/112.2ac200df.js"><link rel="prefetch" href="/assets/js/113.46405151.js"><link rel="prefetch" href="/assets/js/114.58fa21b5.js"><link rel="prefetch" href="/assets/js/115.fa6a329a.js"><link rel="prefetch" href="/assets/js/116.37141fb0.js"><link rel="prefetch" href="/assets/js/117.d001fc73.js"><link rel="prefetch" href="/assets/js/118.217b3c9e.js"><link rel="prefetch" href="/assets/js/119.c8e2d03c.js"><link rel="prefetch" href="/assets/js/12.a5c78b74.js"><link rel="prefetch" href="/assets/js/120.f21f9f6d.js"><link rel="prefetch" href="/assets/js/121.610858f8.js"><link rel="prefetch" href="/assets/js/122.5e106cb5.js"><link rel="prefetch" href="/assets/js/123.83e9e543.js"><link rel="prefetch" href="/assets/js/124.fe964328.js"><link rel="prefetch" href="/assets/js/125.48103cb8.js"><link rel="prefetch" href="/assets/js/126.9f3a9a43.js"><link rel="prefetch" href="/assets/js/127.53393403.js"><link rel="prefetch" href="/assets/js/128.718bab74.js"><link rel="prefetch" href="/assets/js/129.94bb906d.js"><link rel="prefetch" href="/assets/js/13.6b06e1eb.js"><link rel="prefetch" href="/assets/js/130.f3cb1be6.js"><link rel="prefetch" href="/assets/js/131.b4e741b6.js"><link rel="prefetch" href="/assets/js/132.dbf75e28.js"><link rel="prefetch" href="/assets/js/134.d17dc9c2.js"><link rel="prefetch" href="/assets/js/135.a7c3e822.js"><link rel="prefetch" href="/assets/js/136.2401894d.js"><link rel="prefetch" href="/assets/js/137.6b5d51b3.js"><link rel="prefetch" href="/assets/js/138.46e98d9d.js"><link rel="prefetch" href="/assets/js/139.080c5130.js"><link rel="prefetch" href="/assets/js/14.1f5e418e.js"><link rel="prefetch" href="/assets/js/140.d7deb0d2.js"><link rel="prefetch" href="/assets/js/141.21a0a960.js"><link rel="prefetch" href="/assets/js/142.fe31183f.js"><link rel="prefetch" href="/assets/js/143.8adbd910.js"><link rel="prefetch" href="/assets/js/144.2ad689e4.js"><link rel="prefetch" href="/assets/js/145.95a4a1d7.js"><link rel="prefetch" href="/assets/js/146.45bec800.js"><link rel="prefetch" href="/assets/js/147.93101868.js"><link rel="prefetch" href="/assets/js/148.b534d0a2.js"><link rel="prefetch" href="/assets/js/149.b1d993db.js"><link rel="prefetch" href="/assets/js/15.f2f6dc7a.js"><link rel="prefetch" href="/assets/js/150.e7147d10.js"><link rel="prefetch" href="/assets/js/151.4ef25d94.js"><link rel="prefetch" href="/assets/js/152.e5d9d094.js"><link rel="prefetch" href="/assets/js/153.6b6e0642.js"><link rel="prefetch" href="/assets/js/154.25250e56.js"><link rel="prefetch" href="/assets/js/155.34ae60ca.js"><link rel="prefetch" href="/assets/js/156.26b776db.js"><link rel="prefetch" href="/assets/js/157.ac214951.js"><link rel="prefetch" href="/assets/js/158.8160576b.js"><link rel="prefetch" href="/assets/js/159.87970e93.js"><link rel="prefetch" href="/assets/js/16.f38d5aa1.js"><link rel="prefetch" href="/assets/js/160.cb31f27b.js"><link rel="prefetch" href="/assets/js/161.63da7c1d.js"><link rel="prefetch" href="/assets/js/162.d6265c5a.js"><link rel="prefetch" href="/assets/js/163.00e98ea9.js"><link rel="prefetch" href="/assets/js/164.489d3ece.js"><link rel="prefetch" href="/assets/js/165.14a0ac69.js"><link rel="prefetch" href="/assets/js/17.47f92d25.js"><link rel="prefetch" href="/assets/js/18.939679b9.js"><link rel="prefetch" href="/assets/js/19.4b5e11ca.js"><link rel="prefetch" href="/assets/js/20.e4c5a5c1.js"><link rel="prefetch" href="/assets/js/21.886994a9.js"><link rel="prefetch" href="/assets/js/22.6848ca70.js"><link rel="prefetch" href="/assets/js/23.6685f31e.js"><link rel="prefetch" href="/assets/js/24.6ffcbee7.js"><link rel="prefetch" href="/assets/js/25.b468ab2a.js"><link rel="prefetch" href="/assets/js/26.ae4ec095.js"><link rel="prefetch" href="/assets/js/27.d68ba8c4.js"><link rel="prefetch" href="/assets/js/28.77526965.js"><link rel="prefetch" href="/assets/js/29.b51bc369.js"><link rel="prefetch" href="/assets/js/30.f34ad8ea.js"><link rel="prefetch" href="/assets/js/31.ea5d0968.js"><link rel="prefetch" href="/assets/js/32.266fe651.js"><link rel="prefetch" href="/assets/js/33.9f3a4b59.js"><link rel="prefetch" href="/assets/js/34.92302c41.js"><link rel="prefetch" href="/assets/js/35.258e2870.js"><link rel="prefetch" href="/assets/js/36.7b3f62cb.js"><link rel="prefetch" href="/assets/js/37.91e68fdc.js"><link rel="prefetch" href="/assets/js/38.35c7427c.js"><link rel="prefetch" href="/assets/js/39.565f94d6.js"><link rel="prefetch" href="/assets/js/4.ea3b0bd5.js"><link rel="prefetch" href="/assets/js/40.1df5e2f3.js"><link rel="prefetch" href="/assets/js/41.5b364c9b.js"><link rel="prefetch" href="/assets/js/42.bc29f49d.js"><link rel="prefetch" href="/assets/js/43.2c830543.js"><link rel="prefetch" href="/assets/js/44.db617450.js"><link rel="prefetch" href="/assets/js/45.6d82cbe7.js"><link rel="prefetch" href="/assets/js/46.f36ad277.js"><link rel="prefetch" href="/assets/js/47.11cd07e6.js"><link rel="prefetch" href="/assets/js/48.e03a4e77.js"><link rel="prefetch" href="/assets/js/49.b08b0835.js"><link rel="prefetch" href="/assets/js/5.97a7c0dc.js"><link rel="prefetch" href="/assets/js/50.c4648d27.js"><link rel="prefetch" href="/assets/js/51.e983cd13.js"><link rel="prefetch" href="/assets/js/52.16e738d5.js"><link rel="prefetch" href="/assets/js/53.bd8c1968.js"><link rel="prefetch" href="/assets/js/54.3e19ee76.js"><link rel="prefetch" href="/assets/js/55.b8ad26cd.js"><link rel="prefetch" href="/assets/js/56.311bfbe6.js"><link rel="prefetch" href="/assets/js/57.0f045ba5.js"><link rel="prefetch" href="/assets/js/58.239e8404.js"><link rel="prefetch" href="/assets/js/59.7b687abb.js"><link rel="prefetch" href="/assets/js/6.8e992509.js"><link rel="prefetch" href="/assets/js/60.4e343674.js"><link rel="prefetch" href="/assets/js/61.db6e32e6.js"><link rel="prefetch" href="/assets/js/62.fc3fc01f.js"><link rel="prefetch" href="/assets/js/63.fa9e1bd1.js"><link rel="prefetch" href="/assets/js/64.994d7527.js"><link rel="prefetch" href="/assets/js/65.267b048d.js"><link rel="prefetch" href="/assets/js/66.8c5f0b3d.js"><link rel="prefetch" href="/assets/js/67.74a9ded5.js"><link rel="prefetch" href="/assets/js/68.dd40f558.js"><link rel="prefetch" href="/assets/js/69.00fccbea.js"><link rel="prefetch" href="/assets/js/7.159745e4.js"><link rel="prefetch" href="/assets/js/70.ef8c338c.js"><link rel="prefetch" href="/assets/js/71.25a9bd58.js"><link rel="prefetch" href="/assets/js/72.0959ee8f.js"><link rel="prefetch" href="/assets/js/73.e154307b.js"><link rel="prefetch" href="/assets/js/74.76863de9.js"><link rel="prefetch" href="/assets/js/75.6978bd97.js"><link rel="prefetch" href="/assets/js/76.4a2f4182.js"><link rel="prefetch" href="/assets/js/77.0f06f3c0.js"><link rel="prefetch" href="/assets/js/78.66c253a1.js"><link rel="prefetch" href="/assets/js/79.6c37b127.js"><link rel="prefetch" href="/assets/js/8.eaef2fb9.js"><link rel="prefetch" href="/assets/js/80.2dda282c.js"><link rel="prefetch" href="/assets/js/81.cd9437e7.js"><link rel="prefetch" href="/assets/js/82.c5a84712.js"><link rel="prefetch" href="/assets/js/83.b8a2f734.js"><link rel="prefetch" href="/assets/js/84.ede1cd7a.js"><link rel="prefetch" href="/assets/js/85.e649a4e5.js"><link rel="prefetch" href="/assets/js/86.38274fa9.js"><link rel="prefetch" href="/assets/js/87.472635cc.js"><link rel="prefetch" href="/assets/js/88.cf02af57.js"><link rel="prefetch" href="/assets/js/89.03ef81d7.js"><link rel="prefetch" href="/assets/js/9.ee3f327d.js"><link rel="prefetch" href="/assets/js/90.4a497f88.js"><link rel="prefetch" href="/assets/js/91.7271b82b.js"><link rel="prefetch" href="/assets/js/92.cd04960f.js"><link rel="prefetch" href="/assets/js/93.342921b6.js"><link rel="prefetch" href="/assets/js/94.f5d3d498.js"><link rel="prefetch" href="/assets/js/95.940fefe6.js"><link rel="prefetch" href="/assets/js/96.fdbcc350.js"><link rel="prefetch" href="/assets/js/97.73aba549.js"><link rel="prefetch" href="/assets/js/98.937f6a6d.js"><link rel="prefetch" href="/assets/js/99.bcd70353.js">
    <link rel="stylesheet" href="/assets/css/0.styles.a3549ad8.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container" data-v-dad8a512><div data-v-dad8a512><div id="loader-wrapper" class="loading-wrapper" data-v-d48f4d20 data-v-dad8a512 data-v-dad8a512><div class="loader-main" data-v-d48f4d20><div data-v-d48f4d20></div><div data-v-d48f4d20></div><div data-v-d48f4d20></div><div data-v-d48f4d20></div></div> <!----> <!----></div> <div class="password-shadow password-wrapper-out" style="display:none;" data-v-64685f0e data-v-dad8a512 data-v-dad8a512><h3 class="title" style="display:none;" data-v-64685f0e data-v-64685f0e>Leibnize 个人学习笔记</h3> <!----> <label id="box" class="inputBox" style="display:none;" data-v-64685f0e data-v-64685f0e><input type="password" value="" data-v-64685f0e> <span data-v-64685f0e>Konck! Knock!</span> <button data-v-64685f0e>OK</button></label> <div class="footer" style="display:none;" data-v-64685f0e data-v-64685f0e><span data-v-64685f0e><i class="iconfont reco-theme" data-v-64685f0e></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-64685f0e>vuePress-theme-reco</a></span> <span data-v-64685f0e><i class="iconfont reco-copyright" data-v-64685f0e></i> <a data-v-64685f0e><span data-v-64685f0e>Leibnize 个人学习笔记</span>
            
          <!---->
          2020
        </a></span></div></div> <div class="hide" data-v-dad8a512><header class="navbar" data-v-dad8a512><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Leibnize 个人学习笔记</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="https://github.com/rjwx60" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont undefined"></i>
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-dad8a512></div> <aside class="sidebar" data-v-dad8a512><div class="personal-info-wrapper" data-v-ca798c94 data-v-dad8a512><!----> <h3 class="name" data-v-ca798c94>
    Leibnize 个人学习笔记
  </h3> <div class="num" data-v-ca798c94><div data-v-ca798c94><h3 data-v-ca798c94>0</h3> <h6 data-v-ca798c94>Article</h6></div> <div data-v-ca798c94><h3 data-v-ca798c94>0</h3> <h6 data-v-ca798c94>Tag</h6></div></div> <hr data-v-ca798c94></div> <nav class="nav-links"><div class="nav-item"><a href="https://github.com/rjwx60" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont undefined"></i>
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav> <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><a href="/Basics/" class="sidebar-heading clickable router-link-active open"><span>前端专题</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/Basics/01-前端基础" class="sidebar-heading clickable"><span>01-前端基本</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/Basics/02-前端性能" class="sidebar-heading clickable"><span>02-前端性能</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/Basics/03-前端工程" class="sidebar-heading clickable"><span>03-前端工程</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/Basics/04-前端异步" class="sidebar-heading clickable"><span>04-前端异步</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/Basics/05-前端设计" class="sidebar-heading clickable"><span>05-前端设计</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/Basics/06-前端数据" class="sidebar-heading clickable"><span>06-前端数据</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/Basics/07-前端安全" class="sidebar-heading clickable"><span>07-前端安全</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/Basics/08-前端概念" class="sidebar-heading clickable"><span>08-前端概念</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/Basics/09-前端实现" class="sidebar-heading clickable"><span>09-前端实现</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/Basics/10-前端新标" class="sidebar-heading clickable"><span>10-前端新标</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/Basics/11-前端会话" class="sidebar-heading clickable"><span>11-前端会话</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/Basics/12-前端框架" class="sidebar-heading clickable open"><span>12-前端框架</span> <span class="arrow down"></span></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/Basics/12-前端框架/框架Vue.html" class="active sidebar-link">一、框架Vue</a></li><li><a href="/Basics/12-前端框架/框架Angular.html" class="sidebar-link">二、框架Angular</a></li><li><a href="/Basics/12-前端框架/框架React.html" class="sidebar-link">三、框架React</a></li><li><a href="/Basics/12-前端框架/Summary.html" class="sidebar-link">四、Summary</a></li></ul></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/Basics/14-浏览器相关" class="sidebar-heading clickable"><span>14-浏览器相关</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/Basics/15-前端核心" class="sidebar-heading clickable"><span>15-前端核心</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/Basics/16-前端Node" class="sidebar-heading clickable"><span>16-前端Node</span> <span class="arrow right"></span></a> <!----></section></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/NetWork/" class="sidebar-heading clickable"><span>网络专题</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/NetWork/20-前端网络" class="sidebar-heading clickable open"><span>20-前端网络</span> <span class="arrow down"></span></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/NetWork/20-前端网络/base.html" class="sidebar-link">一、基本</a></li><li><a href="/NetWork/20-前端网络/ip.html" class="sidebar-link">二、IP</a></li><li><a href="/NetWork/20-前端网络/tcp.html" class="sidebar-link">三、TCP</a></li><li><a href="/NetWork/20-前端网络/dns.html" class="sidebar-link">四、DNS</a></li><li><a href="/NetWork/20-前端网络/http.html" class="sidebar-link">五、HTTP</a></li><li><a href="/NetWork/20-前端网络/websocket.html" class="sidebar-link">六、Websocket</a></li><li><a href="/NetWork/20-前端网络/Summary.html" class="sidebar-link">七、Summary</a></li></ul></section></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/Algorithm/" class="sidebar-heading clickable"><span>算法专题</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/Algorithm/30-前端算法" class="sidebar-heading clickable open"><span>30-前端算法</span> <span class="arrow down"></span></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/Algorithm/30-前端算法/排序.html" class="sidebar-link">X、排序</a></li><li><a href="/Algorithm/30-前端算法/Summary.html" class="sidebar-link">X、Summary</a></li></ul></section></li></ul></section></li></ul> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-64685f0e data-v-dad8a512><h3 class="title" style="display:none;" data-v-64685f0e data-v-64685f0e></h3> <!----> <label id="box" class="inputBox" style="display:none;" data-v-64685f0e data-v-64685f0e><input type="password" value="" data-v-64685f0e> <span data-v-64685f0e>Konck! Knock!</span> <button data-v-64685f0e>OK</button></label> <div class="footer" style="display:none;" data-v-64685f0e data-v-64685f0e><span data-v-64685f0e><i class="iconfont reco-theme" data-v-64685f0e></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-64685f0e>vuePress-theme-reco</a></span> <span data-v-64685f0e><i class="iconfont reco-copyright" data-v-64685f0e></i> <a data-v-64685f0e><span data-v-64685f0e>Leibnize 个人学习笔记</span>
            
          <!---->
          2020
        </a></span></div></div> <div data-v-dad8a512><main class="page"><div class="page-title" style="display:none;"><h1>一、整体流程</h1> <div data-v-3b7f5bdf><i class="iconfont reco-account" data-v-3b7f5bdf><span data-v-3b7f5bdf>Leibnize 个人学习笔记</span></i> <!----> <!----> <!----></div></div> <div class="theme-reco-content content__default" style="display:none;"><h1 id="一、整体流程"><a href="#一、整体流程" class="header-anchor">#</a> 一、整体流程</h1> <p>分析对象为 Vue2.x 完整版(Runtime+Compiler)；</p> <ul><li><strong><u><em>完整版</em></u></strong> ：运行时版 + Compiler (将字符串模板 template 编译为 render 函数)；
<ul><li>entry-runtime-with-compiler，挂载前需做编译处理，所以其重写了 Vue.prototype.$mount 方法，并添加了 Vue.compile 全局API；</li> <li>使用完整版，允许在代码运行的时现场编译模板，在不配合构建工具的情况下可直接使用，但包体积偏大；</li></ul></li> <li><strong><u><em>运行时版</em></u></strong>：将编译步骤(Compiler)交给构建工具处理(在脚手架配置 vue-loader )的版本；
<ul><li>entry-runtime，最后直接输出 Vue 实例，编译部分交由构建工具处理、可减少包体积 30%；</li></ul></li></ul> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200927100917.png" alt="截屏2020-09-27 上午10.09.10" style="zoom:50%;"> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200908132749.png" style="zoom:50%;"> <p><strong><u><em>构建流程</em></u></strong>：</p> <ul><li><u>初始化前</u>，创建 Vue 实例对象</li> <li><u>初始化-init</u>，初始化生命周期、事件中心和渲染、执行 <code>beforeCreate</code> 钩子、初始化 <code>data</code>、<code>props</code>、<code>computed</code>、<code>watcher</code>、执行 <code>created</code> 钩子等
<ul><li>注意：初始化阶段涉及的数据绑定过程略过，请看响应式过程；</li> <li>注意：初始化阶段为 Vue 原型添加属性和方法，即实例属性和实例方法，并添加全局的API，也就是静态的方法和属性：
<ul><li>初始化原型链属性 sateMixin：<code>$data(只读属性)、$props(只读属性)、$set、$delete、$watch</code>；</li> <li>初始化原型链方法(事件) eventsMixin：<code>$on、$once、$off、$emit</code>；</li> <li>初始化原型链方法(生命周期) lifecycleMixin：<code>_update、$forceUpdate、$destory</code>；</li> <li>初始化(渲染函数) renderMixin、nextTick：<code>installRenderHelpers、_render、nextTick</code>；</li> <li>在 Vue 构造函数上添加全局 API(initGlobalAPI)，类似整理 Vue.prototype 上的属性和方法：
<ul><li>比如：get(只读)、util(独立、非公共API)、set、util、set、delete、nextTick、options；</li> <li>比如：Vue.use(initUse)、Vue.component+Vue.directive+Vue.filter(initAssetRegisters)、Vue.mixin(initMixin)、Vue.extend(initExtend)；</li> <li>总结：即 Vue 构造函数相关的2个文件：core/instance/index.js，即其父级文件：core/index.js：
<ul><li>前者：定义 Vue 构造函数，并对其原型添加属性和方法，即实例属性和实例方法，是 Vue 构造函数的定义文件；</li> <li>后者：为 Vue 添加全局的API，也就是静态的方法和属性；</li></ul></li></ul></li> <li>设置平台化的 Vue.config；
<ul><li>Vue.options：混合2个指令(directives)：model、show；</li> <li>Vue.options：混合2个组件(components)：Transition、TransitionGroup；</li> <li>Vue.prototype：2个方法：<code>__patch__</code>、$mount；</li></ul></li> <li>补充：比较 entry-runtime-with-compiler 与 entry-runtime：
<ul><li>后者运行时直接导出 Vue(交给构建工具的编译器编译，所以直接输出Vue)；</li> <li>前者包含 compiler，挂载前需要做编译处理，故其重写 Vue.prototype.$mount 方法，并添加了 Vue.compile 全局API，最后通过 compilerToFunctions 编译；</li></ul></li> <li>补充：mergeOptions：涉及处理太多，不一展开，只大概叙述下：
<ul><li>校验组件名字(checkComponents)；</li> <li>规范化参数(normalize)，统一数组和对象形式为对象；</li> <li>对于 el、propsData 选项，使用默认的合并策略 defaultStrat(只要子选项不是 <em>undefined</em> 就使用子选项，否则使用父选项)；</li> <li>对于 data 选项，使用 mergeDataOrFn 函数进行处理，最终结果是 data 选项将变成一个函数，且该函数的执行结果为真正的数据对象；</li> <li>对于 生命周期钩子 选项，将合并成数组，使得父子选项中的钩子函数都能够被执行；</li> <li>对于 directives、filters 以及 components 等资源选项，父子选项将以原型链的形式被处理，所以才能在任何地方都使用内置组件&amp;指令等；</li> <li>对于 watch 选项的合并处理，类似于生命周期钩子，若父子选项都有相同的观测字段，将被合并为数组，这样观察者都将被执行；</li> <li>对于 props、methods、inject、computed 选项，父选项始终可用，但是子选项会覆盖同名的父选项字段；</li> <li>对于 provide 选项，其合并策略使用与 data 选项相同的 mergeDataOrFn 函数；</li> <li>最后，以上没有提及到的选项都将使默认选项 defaultStrat(只要子选项不是 <em>undefined</em> 就使用子选项，否则使用父选项)</li></ul></li></ul></li></ul></li> <li><u>初始化后</u>，调用 <code>$mount</code> 方法对 Vue 实例进行挂载(挂载的核心过程包括：<strong><u>模板编译、渲染、更新</u></strong>  三个过程)；</li> <li><u>编译</u>：若无在 Vue 实例上定义 <code>render</code> 方法而定义 <code>template</code>，则需经历编译阶段：先将 <code>template字符串</code> 编译成 <code>render function</code>；编译如下：
<ul><li>首先，<code>parse</code> 正则解析 <code>template</code> 字符串形成 AST(抽象语法树，源代码的抽象语法结构的树状表现形式)</li> <li>然后，<code>optimize</code> 标记静态节点跳过 Diff 算法 (Diff 算法是逐层进行比对，只有同层级的节点进行比对，因此时间的复杂度只有 O(n)；</li> <li>最后，<code>generate</code> 将 AST 转化成 <code>render function</code> 字符串；</li></ul></li> <li><u>渲染</u>，编译成 <code>render函数</code> 后，调用 <code>$mount</code> 的 <code>mountComponent</code> 方法：其先执行 <code>beforeMount</code> 钩子，然后实例化一个 <code>渲染Watcher</code> (方法核心)，在其回调函数(初始化时执行，及组件实例中监测到数据发生变化时执行)中，调用 <code>updateComponent</code> 方法(此法调用 <code>render</code> 方法将 <code>render函数</code> 生成 <code>虚拟Node</code>，最终调用 <code>update</code> 方法更新 DOM，见下方 <u>更新</u> 部分)；
<ul><li>补充：<code>render</code> 方法参一是 <code>createElement</code> (或说是 <code>h</code> 函数)；</li> <li>注意：真实 DOM 元素庞大，而浏览器标准将 DOM 设计地十分复杂；若频繁操作 DOM 会有性能问题；而 <code>虚拟DOM</code> 是用原生 JS 对象去描述 DOM 节点，故其比创建 DOM 代价要小，且便于修改属性、对比差异、还能实现跨平台方案；</li></ul></li> <li><u>更新</u>，生成 <code>虚拟DOM树</code> 后，需要将 <code>虚拟DOM树</code> 转化成 <code>真实DOM节点</code>，此时需要调用 <code>update</code> 方法，<code>update</code>方法会调用 <code>pacth</code> 方法将 <code>虚拟DOM</code> 转换成 真正DOM 节点；(注意上图忽略了新建真实 DOM 的情况—若无旧的虚拟 Node，则可直接通过 <code>createElm</code> 创建真实 DOM 节点)，而此处重点分析在已有虚拟 Node 的情况下，会通过 <code>sameVnode</code> 判断当前需要更新的 Node节点，是否与旧的 Node 节点相同(比如若设置的 <code>key</code> 属性发生了变化，则节点显然不同—所以 key 作用在于节点的最大化复用)，若节点不同则利用新节点替换旧节点，若相同且存在子节点，则需调用 <code>patchVNode</code> 方法执行 Diff 算法更新 DOM，从而提升 DOM 操作的性能；</li></ul> <p><strong><u><em>响应式流程总结</em></u></strong>：</p> <ul><li>在 <code>Init</code> 初始化过程中，Vue 会遍历 data 选项属性，并利用  <code>Object.defineProperty</code> 方法(IE9+)(利用 JS 对象访问器属性 <code>Get/Set</code>，Vue3 中则使用 ES6 <code>Proxy</code> 来优化)，(重新定义 data 中的所有属性)以监听 Vue 实例的响应式数据的变化，从而实现 <u>数据劫持</u> 能力；</li> <li>然后，在初始化流程中的编译阶段，当 <code>render function</code> 被渲染时，会读取 Vue 实例中和视图相关的响应式数据，此时触发 <code>Getter</code>  函数进行 <u>依赖收集</u> (将当前组件观察者 <code>Watcher</code> 对象存放到当前闭包的订阅者 <code>Dep</code> 的 <code>subs</code> 中，进行依赖收集还有 computed watcher,user watcher实例)，此时数据劫持功能和 <u>发布订阅模式</u>，就实现了一 MVVM 模式中的  <u>Binder</u>，之后就是正常的渲染和更新流程；</li> <li>然后，当数据属性发生变化或视图导致的数据发生变化时，触发数据劫持的 <code>Setter</code> 函数，<code>Setter</code> 会通知初始化时 <u>收集的依赖</u> 中的 <code>Dep</code> 中的与视图相应的 <code>Watcher</code>，<code>Wather</code> 就会再次通过 <code>update</code> 方法来更新视图，从而使它关联的组件重新渲染；</li> <li>注意：可发现只要视图中添加监听事件(Get/Set+处理函数)，自动变更对应的数据变化时，就可实现数据和视图的双向绑定；</li></ul> <p><strong><u>响应式流程实现要点：</u></strong></p> <p>监听器 Observer：</p> <ul><li>对数据对象进行遍历(含子属性对象属性)，利用 Object.defineProperty 为属性添加 Get/Set，定义依赖收集和派发更新行为；</li></ul> <p>解析器 Compile：</p> <ul><li>解析 Vue 模板，将模板中的变量，替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数(原生事件—关键)，添
加监听数据的订阅者，一旦数据变化(原生触发)，触发收到通知，调用更新函数进行数据更新；</li></ul> <p>订阅者 Watcher：</p> <ul><li>Watcher 是前两者间的通信桥梁，主要负责：订阅 Observer 中的属性值变化消息，当收到属性值变化消息时，触发解析器 Compile 中对应的更新函数；实际上 Watcher 实例分为渲染 watcher (render watcher)、计算属性 watcher (computed watcher)、侦听器 watcher (user watcher)三种；
<ul><li>initState 时，对 computed 属性初始化时触发 computed watcher 依赖收集；</li> <li>initState 时，对侦听属性初始化时，触发 user watcher 依赖收集；</li> <li>render   时，触发 render watcher 依赖收集；</li> <li>re-render 时，vm.render 再次执行，会移除所有 subs 中的 watcer 的订阅，重新赋值；</li></ul></li></ul> <p>订阅器 Dep：</p> <ul><li>订阅器采用发布订阅模式(即观察者基础之上增加一调度管理器)，用来收集订阅者 Watcher，以对监听器 Observer 和订阅者 Watcher 进行统一管理(每个响应式对象包括子对象，都拥有一个 Dep 实例(里面的 subs 是存放 Watcher 实例的数组)，当数据有变更时，会通过 dep.notify 通知各个 watcher)；</li></ul> <p>上述两者关系：</p> <ul><li><p>Dep 是 Observer 与 Watcher 间的调度器，负责更好地、统一地管理 Watcher；</p></li> <li><p>Watcher 中实例化了 dep 并向 dep.subs 中添加了订阅者 watcher，而 dep 通过 notify 遍历了 dep.subs 通知每个 watcher 更新，最后调用每一个 watcher 的 update 方法；</p></li></ul> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200908132750.png" style="zoom:50%;"> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200908132751.png" style="zoom:50%;"> <h1 id="二、vue相关"><a href="#二、vue相关" class="header-anchor">#</a> 二、Vue相关</h1> <h2 id="_2-1、双绑-v-model"><a href="#_2-1、双绑-v-model" class="header-anchor">#</a> 2-1、双绑—v-model</h2> <p>本质是语法糖，可看成 value + input 方法组合；可通过 model 属性的 prop 和 event 属性来进行自定义；</p> <p>v-model，多用于表单 input、textarea、 select 等元素；</p> <p>v-model，会根据标签的不同生成不同的事件和属性；</p> <ul><li>text、textarea元素使用 value 属性和 input 事件；</li> <li>checkbox、radio使用 checked 属性和 change 事件；</li> <li>select 字段将 value 作为 prop 并将 change 作为事件；</li></ul> <div class="language-html extra-class"><pre class="language-html"><code>// 1、表单元素 input
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">*v-model*</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span> something<span class="token punctuation">'</span></span><span class="token punctuation">&gt;</span></span>
// 相当于
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name"><span class="token namespace">*v-bind:</span>*</span> <span class="token attr-name">*va*</span> <span class="token attr-name">*lue*</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>something<span class="token punctuation">&quot;</span></span> <span class="token attr-name"><span class="token namespace">*v-on:</span>*</span> <span class="token attr-name">*input*</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>something = $event. target.value<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>

// 2、自定义组件，v-model 默认会利用名为 value 的 prop 和 input 事件
// 父组件:
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>*ModelChild*</span> <span class="token attr-name">*v-mode*</span> <span class="token attr-name">*l*</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>message<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>*ModelChild*</span><span class="token punctuation">&gt;</span></span>
// 子组件:
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>{{value}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
props:{
	value: *String*
}
methods: {
	test1(){
	this. $emit('input', 'TLP')
},
</code></pre></div><h2 id="_2-2、双绑-数组与对象监听"><a href="#_2-2、双绑-数组与对象监听" class="header-anchor">#</a> 2-2、双绑—数组与对象监听</h2> <p>问题：由于 JS 限制，Vue 不能检测到以下数组操作改动：</p> <ul><li>利用索引直接设置一个数组项时，比如：<code>vm. items[indexOfItem] = newValue</code></li> <li>修改数组长度时，比如：<code>vm.items.length = newLength</code></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 解决问题1：</span>
<span class="token comment">// Vue.set</span>
Vue<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>items<span class="token punctuation">,</span> index0fItem<span class="token punctuation">,</span> newValue<span class="token punctuation">)</span>
<span class="token comment">// vm.$set, Vue.setá)- ↑5I5</span>
vm<span class="token punctuation">.</span><span class="token function">$set</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>items<span class="token punctuation">,</span> index0fItem<span class="token punctuation">,</span> newValue<span class="token punctuation">)</span>
<span class="token comment">// Array.prototype.splice</span>
vm<span class="token punctuation">.</span>items<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>indexOfItem<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> newValue<span class="token punctuation">)</span>

<span class="token comment">// 解决问题2：splice</span>
<span class="token comment">// Array.prototype. splice</span>
vm<span class="token punctuation">.</span>items<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>newlength<span class="token punctuation">)</span>
<span class="token comment">// 数组长度没有 Set/Get</span>
<span class="token comment">// 因为：若知道数组长度，理论上可以预先给所有的索引设置 Set/Get，但实际场景中往往并不知道数组长度(不固定)；</span>
<span class="token comment">// 此时：预加 Set/Get 成本过大；可通过 Proxy 改进</span>
</code></pre></div><p>Vue 通过遍历数组/对象(若数组/对象中包含着引用类型， 则会对其中的引用类型再次递归遍历)，从而实现对数组和对象内部属性数据进行监听；</p> <p>但对于数组操作的监听，则通过重写数组方法(原型链重写/劫持)：push、pop、shift、unshift、splice、sort、reverse；使之监听得到更新；</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">const</span> arrayProto <span class="token operator">=</span> <span class="token builtin">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> arrayMethods <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>arrayProto<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> methodsToPatch <span class="token operator">=</span> <span class="token punctuation">[</span>
  <span class="token string">&quot;push&quot;</span><span class="token punctuation">,</span>
  <span class="token string">&quot;pop&quot;</span><span class="token punctuation">,</span>
  <span class="token string">&quot;shift&quot;</span><span class="token punctuation">,</span>
  <span class="token string">&quot;unshift&quot;</span><span class="token punctuation">,</span>
  <span class="token string">&quot;splice&quot;</span><span class="token punctuation">,</span>
  <span class="token string">&quot;sort&quot;</span><span class="token punctuation">,</span>
  <span class="token string">&quot;reverse&quot;</span>
<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token comment">/**
* Intercept mutating methods and emit events
*/</span>
methodsToPatch<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>method<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// cache original method</span>
  <span class="token keyword">const</span> original <span class="token operator">=</span> arrayProto<span class="token punctuation">[</span>method<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token function">def</span><span class="token punctuation">(</span>arrayMethods<span class="token punctuation">,</span> method<span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token function">mutator</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token function">original</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> ob <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>ob<span class="token punctuation">;</span>
    <span class="token keyword">let</span> inserted<span class="token punctuation">;</span>
    <span class="token keyword">switch</span>
    <span class="token punctuation">(</span>method<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">case</span> <span class="token string">&quot;push&quot;</span><span class="token operator">:</span>
      <span class="token keyword">case</span> <span class="token string">&quot;unshift&quot;</span><span class="token operator">:</span>
        inserted <span class="token operator">=</span> args<span class="token punctuation">;</span>
        <span class="token keyword">break</span>
      <span class="token keyword">case</span> <span class="token string">&quot;splice&quot;</span><span class="token operator">:</span>
        inserted <span class="token operator">=</span> args<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>inserted<span class="token punctuation">)</span> ob<span class="token punctuation">.</span><span class="token function">observeArray</span><span class="token punctuation">(</span>inserted<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// notify change</span>
    ob<span class="token punctuation">.</span>dep<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/**
* Observe a list of Array item
*/</span>
Observer<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">observeArray</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">observeArray</span><span class="token punctuation">(</span>items<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> l <span class="token operator">=</span> items<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> l<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">observe</span><span class="token punctuation">(</span>items<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// ...</span>

<span class="token comment">// Observe a list of Array items.</span>
<span class="token function">observeArray</span><span class="token punctuation">(</span>items<span class="token operator">:</span> <span class="token builtin">Array</span><span class="token operator">&lt;</span><span class="token builtin">any</span><span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">(</span>l <span class="token operator">=</span> items<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">,</span> i <span class="token operator">&lt;</span> l<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">observe</span><span class="token punctuation">(</span>items<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// observe 功能为监测数据的变化</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 对属性进行递归遍历</span>
<span class="token keyword">let</span> child0b <span class="token operator">=</span> <span class="token operator">!</span>shallow <span class="token operator">&amp;&amp;</span> <span class="token function">observe</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// observe 功能为监测数据的变化</span>

<span class="token comment">// ...</span>
</code></pre></div><h2 id="_2-3、双绑-vue-set"><a href="#_2-3、双绑-vue-set" class="header-anchor">#</a> 2-3、双绑—<u>Vue.$set</u></h2> <p>Vue.set == vm.$set，而其内部，还是会通过 splice 实现变更检测；</p> <ul><li>若目标是数组，使用 vue 实现的数组重载方法 splice 实现响应式(所以本质还是通过 splice)；</li> <li>若目标是对象，判断属性存在，若存在即为响应式，直接赋值；</li> <li>若目标非响应式，则直接赋值；</li> <li>若目标属性非响应式，则调用 defineReactive 方法进行响应式处理；</li></ul> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token keyword">set</span><span class="token punctuation">(</span>target<span class="token operator">:</span> <span class="token builtin">Array</span><span class="token operator">&lt;</span><span class="token builtin">any</span><span class="token operator">&gt;</span> <span class="token operator">|</span> Object<span class="token punctuation">,</span> key<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">,</span> val<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">any</span> <span class="token punctuation">{</span>
  <span class="token comment">// 若 target 为数组</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token builtin">Array</span><span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isValidArrayIndex</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 修改数组的长度，避免索引&gt;数组长度导致 splcie 执行有误</span>
    target<span class="token punctuation">.</span>length <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>target<span class="token punctuation">.</span>length<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
    <span class="token comment">// 利用数组的 splice 变异方法触发响应式</span>
    target<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> val<span class="token punctuation">)</span>
    <span class="token keyword">return</span> val
  <span class="token punctuation">}</span>
  <span class="token comment">// 若 key 已存在，则直接修改属性值</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token keyword">in</span> target <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span>key <span class="token keyword">in</span> object<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    target<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> val
    <span class="token keyword">return</span> va1
  <span class="token punctuation">}</span>
  <span class="token keyword">const</span> ob <span class="token operator">=</span> <span class="token punctuation">(</span>target<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__ob__
  <span class="token comment">// 若 target 非响应式数据，则直接赋值</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ob<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    target<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> val
    <span class="token keyword">return</span> val
  <span class="token punctuation">}</span>
  <span class="token comment">// 对属性进行响应式处理</span>
  <span class="token function">defineReactive</span><span class="token punctuation">(</span>ob<span class="token punctuation">.</span>value<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val<span class="token punctuation">)</span>
  ob<span class="token punctuation">.</span>dep<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> val
<span class="token punctuation">}</span>
</code></pre></div><h2 id="_2-4、路由-router"><a href="#_2-4、路由-router" class="header-anchor">#</a> 2-4、路由—Router</h2> <p><strong><u><em>基本介绍</em></u></strong>：</p> <p>Vue-router 有3种路由模式：hash、history、 abstract：</p> <ul><li>hash：使用 URL hash 值来作路由；支持所有浏览器，包括不支持 H5 History Api 的浏览器；
<ul><li>依靠 <code>onhashchange</code> 事件(监听<code>location.hash</code>的改变)；</li></ul></li> <li>history：依赖 H5 History API 和服务器配置；
<ul><li>依靠的<code>H5 history</code> 新增的两个方法：pushState() 改变 url 地址且不会发送请求；replaceState() 可读取历史记录栈，还可对浏览器记录进行修改；</li></ul></li> <li>abstract：支持所有 JS 运行环境，如 Node.js 服务器端；若发现没有浏览器的API，则会自动强制进入此模式；</li></ul> <p><u>hash 模式的实现原理</u>
早期前端路由的实现就是基于 location.hash，location.hash 值即 URL 中 # 后面的内容(含符号#)；hash 路由模式实现基于以下几个特性</p> <ul><li>URL 中 hash值只是客户端的一种状态，也即当向服务器端发出请求时，hash 部分不会被发送；</li> <li>hash 值的改变，都会在浏览器访问历史中增加记录；因此能通过浏览器回退、前进按钮控制 hash 的切换；</li> <li>可通过 a 标签，并设置 href 属性，当用户点击标签后，URL 的 hash 值就会发生改变；</li> <li>或可通过 JS 来对 loaction.hash 进行赋值，改变 URL 的 hash值；</li> <li>可使用 hashchange 事件来监听 hash 值变化，从而对页面进行跳转(渲染)；</li></ul> <p><u>history 模式的实现原理</u>
H5 提供 History API 来实现 URL 变化；其中最主要的API有：historv.pushState()—新增历史记录、historv.repalceState()—直接替换当前的历史记录；此两个 API 可在不进行刷新的情况下，操作浏览器的历史纪录；history 路由模式实现基于以下几个特性：</p> <ul><li>pushState 和 repalceState 操作实现 URL 变化；</li> <li>使用 popstate 事件来监听 url 变化，从而对页面进行跳转(渲染)；</li> <li>注意：history.pushState() 或 history.replaceState() 不会触发 popstate 事件，所以需要手动触发页面跳转(渲染)；</li></ul> <div class="language-js extra-class"><pre class="language-js"><code>window<span class="token punctuation">.</span>history<span class="token punctuation">.</span><span class="token function">pushState</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">;</span>
window<span class="token punctuation">.</span>history<span class="token punctuation">.</span><span class="token function">replaceState</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p><strong><u><em>实现原理</em></u></strong>：</p> <p>根据浏览器功能选择 hash/historyRouter；不管通过 routerLink组件触发还是通过内部 this.router.push/replace 等触发，触发原生事件，hash 触发 onhashchange/popstate，H5 触发 popstate 事件；事件触发后，Router 实例获取当前变化 url 与 router 配置的 url，对比获知要更新的组件，随后获取相关组件相关系列钩子(被销毁组件钩子与新创建组件钩子)、依次执行，然后执行 beforeRouteEnter，然后执行 history.transitionTo 回调 onComplete，渲染，并替换 url；</p> <ul><li>挂载：获取 newVue({ router })，并挂载到 Vue 根组件 <code>this.$options</code> 中，然后通过 Vue.use 安装插件，加载 VueRouter install 方法，mixin，beforeCreate，router 实例的 init 方法；使用 Vue.util.defineReactive(..this.router.history.current) 响应触发更新，然后 registerInstance(this,this) 实现对 router-view 的挂载操作(router-view 定义 registerRouterInstance 函数，此方法主要用于 render 操作)；设置代理：this.$router == this._routerRoot.router；使用 Vue.component 注册 RouterLink、RouterView；最后合并钩子；</li> <li>初始：即实例化 Router，此步发生在挂载前(只有实例化后才能调用 init 方法)，类似 new Router({mode:'history', route: [{}...]})，constructor 中会有一根据环境能力选用合适路由模式——mode，选用顺序为 history、hash、最后才是非浏览器环境下的 abstract；然后根据 mode 实例化相应对象；</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">switch</span> <span class="token punctuation">(</span>mode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">case</span> <span class="token string">'history'</span><span class="token operator">:</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>history <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HTML5History</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> options<span class="token punctuation">.</span>base<span class="token punctuation">)</span>
    <span class="token keyword">break</span>
  <span class="token keyword">case</span> <span class="token string">'hash'</span><span class="token operator">:</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>history <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashHistory</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> options<span class="token punctuation">.</span>base<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>fallback<span class="token punctuation">)</span>
    <span class="token keyword">break</span>
  <span class="token keyword">case</span> <span class="token string">'abstract'</span><span class="token operator">:</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>history <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AbstractHistory</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> options<span class="token punctuation">.</span>base<span class="token punctuation">)</span>
    <span class="token keyword">break</span>
  <span class="token keyword">default</span><span class="token operator">:</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE__ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">assert</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">invalid mode: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>mode<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>实现：通过 history.transitionTo 确定路由的切换操作；通过 history.listen 注册路由变化的响应回调：this.app.forEach(app =&gt; app._route = route)</li> <li>Hash模式：使用 HashHistory 作为演示例子；HashHistory 继承自 History 类，判断(保证 / 开头)，并获取 # 后部分内容；</li> <li>history.transitionTo：
<ul><li>通过 this.router.match 创建匹配定义 URL 的 router 对象：通过目标路径匹配定义 route 数据，根据匹配到的记录，进行 _createRoute 操作，操作最后返回 router 对象；然后，得到对象后，通过 comfirmTransition 进行跳转操作；confirmTransition 函数：
<ul><li>confirmTransition 函数内部判断是否是需要跳转，若无需跳转，则直接中断返回；若需要跳转，则先得到钩子函数的任务队列 queue；
<ul><li>即将被销毁组件的 beforeRouteLeave 钩子：extractLeaveGuards ( deactivated)；</li> <li>全局 router before hooks：this.router.beforeHooks；</li> <li>组件 updated 钩子：extractUpdateHooks (updated)；</li> <li>将要更新的路由的beforeEnter 钩子：activated.map(m =&gt; m. beforeEnter)；</li> <li>异步组件：resolveAsyncComponents (activated)</li></ul></li> <li>通过 runQueue 函数来批次执行任务队列中的每个方法；注意：在执行 queue 中钩子时，通过 iterator 来构造迭代器由用户传入 next 方法，确定执行过程(即等待上一钩子执行完才执行下一个)；队列执行完后，处理完成后的回调；回调主要是接入路由组件后期的钩子函数beforeRouteEnter、beforeResolve，并进行队列执行；一切处理完后，执行 transitionTo 回调 onComplete；</li></ul></li> <li>onComplete 回调中，会调用 updateRoute 方法(因先前进行了双绑，所以会触发渲染)，ensureURL(更新浏览器URL)，readyCbs；</li></ul></li> <li>H5History模式：同样调用 history.transitionTo，只是监听方法只是使用 popstate 事件，而 hash模式依靠 onhashchange/popstate (支持度)监听；</li> <li>补充：router 实例调用的 push 实际是 history 方法，通过 mode 来确定匹配 history 的实现方案，从代码可知：
<ul><li>push 调用了 src/util/push-state.js 中被改写过的 pushState 方法，改写过的方法会根据传入的参数 replace?: boolean 来进行判断调用 pushState 还是 replaceState ，同时做了错误捕获；如果 history 无刷新修改访问路径失败，则调用 window.location.replace(url) ,有刷新的切换用户访问地址；同理 pushState 也是这样；这里的 transitionTo 方法主要的作用是：做视图的跟新及路由跳转监测，若 url 没有变化(访问地址切换失败的情况)，在 transitionTo 方法内部还会调用一个 ensureURL 方法，来修改 url；</li></ul></li> <li>注意：this.router.push 等路由方法，最后还是会调用 this.transitionTo；任何形式的路由相关操作，routerLink 组件还是 this.router.push，最后都会通过 history 触发变更，Vue Router 事件监听后，再进行相关操作(渲染、改变URL)；比如 routerLInk 组件，在 install 注册，在 render 时通过创建 a 标签并绑定相关原生方法，最后调用 router.replace、router.push 方法；</li></ul> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200929083404.png" alt="截屏2020-09-29 上午8.33.58" style="zoom:50%;"> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200929083435.png" alt="截屏2020-09-29 上午8.34.30" style="zoom:67%;"> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200929083452.png" alt="截屏2020-09-29 上午8.34.46" style="zoom:50%;"> <h2 id="_2-5、状态-vuex"><a href="#_2-5、状态-vuex" class="header-anchor">#</a> 2-5、状态—Vuex</h2> <p>Duck 不必看源码实现，很多细节内容，了解流程即可(我给你们浓缩了还看，而且那些内容只是截取版，强行看会懵的一愣一愣的!!)</p> <p><strong><u><em>基本介绍与用法与疑问：</em></u></strong></p> <ul><li>State：定义应用状态的数据结构，可在这里设置默认的初始状态；
<ul><li>注意：Vuex 的单一状态与模块化并不冲突；前者表明实例单一，后者只是独立，但共用此实例；</li> <li>注意：可通过 mapState 将全局 state 和 getters 映射到当前组件的 computed 计算属性中；</li></ul></li> <li>Getter：允许组件从 Store 中获取数据，类似 vue 计算属性，主用来过滤数据；
<ul><li>注意：可通过 mapGetters 辅助函数仅将 store 中的 getter 映射到局部计算属性；</li> <li>注意：改变 state 中状态的唯一途径：显式地提交(commit) mutation，便于跟踪每一个状态变化；</li></ul></li> <li>Mutation：唯一能更改 store 中数据状态的方法，须是同步函数；</li> <li>Action：可理解为：通过将 mutations 中，处理数据的方法变为可异步的处理数据的方法，即异步操作数据；view 层通过 store.dispath 来分发 action；</li> <li>Module：允许将单一 Store 拆分为多个 store 且同时保存在单一的状态树中；</li></ul> <p>疑问：开发时，改变数组或对象的数据，但是页面没有更新如何解决？</p> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200908132753.png" style="zoom:70%;"> <p>**<u><em>基本原理：</em></u>**Vuex 即 Vue 专用的状态管理库(多用于组件通信及作为数据中心集中式存储数据)；单例形式存放，利用 Vue 自身响应式机制实现(运行依赖于 Vue 内部数据双向绑定机制)；本质是存放多个对象的仓库；State 存放响应数据(各组件共享的数据中心—从而实现跨组件通讯，数据又完全与各自组件独立)；Vue 组件从 Store 读取数据，若 store 中数据发生改变，依赖数据的组件也会发生更新；<u>个人理解</u>：Vuex 是独立于应用 Vue实例的小型 Vue 实例，初始化时搜集 Store、Action、Mutation 等内容，在组件注入时将 State 绑定到 computed，当数据变化时，dispatch、commit、mutation[type]，并通过内部响应式变化通知订阅者，订阅者监听到变动，数据反映到 computed 中的 State 上，触发渲染；</p> <p>大致流程：首先，在全局通过 State 存放数据，而所有修改 State 的操作，均须通过 Mutation 进行(Mutation 通过 Action)，同时其还提供订阅者模式以供外部插件调用获取 State 数据更新；然后，所有异步接口均须通过 Action 操作 (常见于调用后端接口异步获取更新数据)；最后根据 State 变化，渲染到视图；</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 引入: import、提供 store，注入 Vue 实例；</span>
Vue<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>Vuex<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 将 store 放入 Vue 创建时的 option 中</span>
<span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    el<span class="token operator">:</span> <span class="token string">'#app'</span><span class="token punctuation">,</span>
    store
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>安装：三方插件统一通过 Vue.use 安装(单例模式避免重复安装)，其会调用插件 install 方法，Vuex.install 中会将 VuexInit 混合进 Vue 钩子中；注意：版本1直接将 VuexInit 放入 init 方法中，版本2则将 VuexInit mixin 进 beforeCreate 钩子中；而 VuexInit 会将 store 注入到 Vue 实例中；同时确保所有组件都公用了全局的同一份 store(根节点执行或使用 store，子组件则直接从父组件中获取 $store)；</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// Vuex 的 init 钩子，会存入每一个 Vue 实例等钩子列表</span>
<span class="token keyword">function</span> <span class="token function">vuexInit</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> options <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$options
  <span class="token comment">// store injection</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>options<span class="token punctuation">.</span>store<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 存在 store 其实代表的就是 Root 节点，直接执行 store(function时) 或使用 store(非function)</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>$store <span class="token operator">=</span> <span class="token keyword">typeof</span> options<span class="token punctuation">.</span>store <span class="token operator">===</span> <span class="token string">'function'</span>
      <span class="token operator">?</span> options<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token operator">:</span> options<span class="token punctuation">.</span>store
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>options<span class="token punctuation">.</span>parent <span class="token operator">&amp;&amp;</span> options<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>$store<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 子组件直接从父组件中获取 $store，以保证了所有组件都公用了全局的同一份 store</span>
    <span class="token comment">// 如此便可以在每一个组件中通过 this.$store 访问全局的 Store 实例</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>$store <span class="token operator">=</span> options<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>$store
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>构建：store 即 Store 实例；Store 构造类初始化内部变量，并主要执行 installModule (初始化module) 以及 resetStoreVM (通过 VM 使 store &quot;响应式&quot;)</p> <ul><li><p>installModule 作用是用为 module 加上 namespace名字空间后，注册 mutation、action 及 getter，同时递归安装所有子 module；</p></li> <li><p>resetStoreVM 通过 vm 重设 store，新建 Vue 对象使用 Vue 内部的响应式实现注册 state 及 computed，关键是 Vuex 内部又 new 了一个 Vue 实例，来实现数据的&quot;响应式化&quot;，运用 Vue 内部提供的数据双向绑定功能来实现 store 的数据与视图的同步更新；</p> <ul><li><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//  存放之前的 vm 对象 </span>
<span class="token keyword">const</span> oldVm <span class="token operator">=</span> store<span class="token punctuation">.</span>_vm 

<span class="token comment">// bind store public getters</span>
store<span class="token punctuation">.</span>getters <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">const</span> wrappedGetters <span class="token operator">=</span> store<span class="token punctuation">.</span>_wrappedGetters
<span class="token keyword">const</span> computed <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token comment">// 遍历 wrappedGetters，使用 Object.defineProperty 方法为每一个 getter 绑定上get方法</span>
<span class="token comment">// 如此在组件里访问 this.$store.getter.test 就等同于访问 store._vm.test，也即 Vue 对象的 computed 属性 </span>
<span class="token function">forEachValue</span><span class="token punctuation">(</span>wrappedGetters<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span> key</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// use computed to leverage its lazy-caching mechanism</span>
  computed<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">fn</span><span class="token punctuation">(</span>store<span class="token punctuation">)</span>
  Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>store<span class="token punctuation">.</span>getters<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token function-variable function">get</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> store<span class="token punctuation">.</span>_vm<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">,</span>
    enumerable<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token comment">// for local getters</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">//  Vue.config.silent 暂时设置为 true，原因是 new 一个 Vue 实例过程中不会报出一切警告 </span>
<span class="token keyword">const</span> silent <span class="token operator">=</span> Vue<span class="token punctuation">.</span>config<span class="token punctuation">.</span>silent
Vue<span class="token punctuation">.</span>config<span class="token punctuation">.</span>silent <span class="token operator">=</span> <span class="token boolean">true</span>

<span class="token comment">// 此时访问 store._vm.test 也即访问 Vue 实例中的属性</span>
store<span class="token punctuation">.</span>_vm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  data<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token operator">?</span>state<span class="token operator">:</span> state
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  computed
<span class="token punctuation">}</span><span class="token punctuation">)</span>
Vue<span class="token punctuation">.</span>config<span class="token punctuation">.</span>silent <span class="token operator">=</span> silent

<span class="token comment">// enable strict mode for new vm</span>
<span class="token comment">//  使能严格模式，保证修改 store 只能通过 mutation </span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>store<span class="token punctuation">.</span>strict<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">enableStrictMode</span><span class="token punctuation">(</span>store<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">if</span> <span class="token punctuation">(</span>oldVm<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">//  解除旧 vm 的 state 的引用，及销毁旧 Vue 对象 </span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>hot<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// dispatch changes in all subscribed watchers</span>
    <span class="token comment">// to force getter re-evaluation for hot reloading.</span>
    store<span class="token punctuation">.</span><span class="token function">_withCommit</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      oldVm<span class="token punctuation">.</span>_data<span class="token punctuation">.</span><span class="token operator">?</span>state <span class="token operator">=</span> <span class="token keyword">null</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span>
   Vue<span class="token punctuation">.</span><span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> oldVm<span class="token punctuation">.</span><span class="token function">$destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// ...</span>
<span class="token comment">// 上述两步完成后，即可通过 this.$store.getter.test 访问 vm 中的 test 属性</span>
</code></pre></div></li></ul></li> <li><p>单向保证：Store 中 option 有 strict 参数，可控制使用严格模式；resetStoreVM 的 enableStrictMode 即此作用；此时所有 state 修改操作均须通过 mutation 实现，否则会抛出错误；即全局标志位判断；只有正确方法调用标志位才会放开，从而实现 Vuex 单向数据流；</p> <ul><li><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">enableStrictMode</span> <span class="token punctuation">(</span><span class="token parameter">store</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// Vuex 利用 vm 的 $watch 方法来观察 ?state，也即 Store 的 state，在它被修改时进入回调</span>
  <span class="token comment">// 回调中用 assert 断言来检测 store._committing，当 store._committing 为 false 时触发断言，抛出异常</span>
  store<span class="token punctuation">.</span>_vm<span class="token punctuation">.</span><span class="token function">$watch</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_data<span class="token punctuation">.</span><span class="token operator">?</span>state <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 检测 store 中的 _committing 值，若是 true 代表不是通过 mutation 方法修改</span>
      <span class="token function">assert</span><span class="token punctuation">(</span>store<span class="token punctuation">.</span>_committing<span class="token punctuation">,</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Do not mutate vuex store state outside mutation handlers.</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> deep<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> sync<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// Store 的 commit 方法中，执行 mutation 的语句</span>
<span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">_withCommit</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  entry<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">commitIterator</span> <span class="token punctuation">(</span><span class="token parameter">handler</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">handler</span><span class="token punctuation">(</span>payload<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token function">_withCommit</span> <span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 调用 withCommit 修改 state 值时，会将 store 的 committing 值置为 true，内部会有断言检查该值</span>
  <span class="token comment">// 在严格模式下只允许使用 mutation 来修改 store 中值，而不允许直接修改 store 的数值</span>

  <span class="token comment">// 通过 commit（mutation）修改 state 数据时，会再调用 mutation 方法之前将 committing 置为 true，</span>
  <span class="token comment">// 然后再通过 mutation 函数修改 state 中数据，此时触发 $watch 中的回调断言 committing 是不会抛出异常的（此时committing为true）</span>
  <span class="token comment">// 而当直接修改 state 数据时，触发 $watch 的回调执行断言，此时 committing 为 false，则会抛出异常</span>
  <span class="token keyword">const</span> committing <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_committing
  <span class="token keyword">this</span><span class="token punctuation">.</span>_committing <span class="token operator">=</span> <span class="token boolean">true</span>
  <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>_committing <span class="token operator">=</span> committing
<span class="token punctuation">}</span>
</code></pre></div></li></ul></li></ul> <p>方法：commit、dispatch、等方法；</p> <ul><li>commit事件：commit 方法会根据 type 找到并调用 _mutations 中的所有 type 对应的 mutation 方法，然后会执行 _subscribers 中的所有订阅者；</li> <li>dispatch方法：调用 action 的 dispatch 方法，实则调用 dispatch 方法；
<ul><li>在初始化，registerAction 时，会将推入进 _actions 队列的 action 进行一层封装(wrappedActionHandler)(所以在进行 dispatch 时能够在参数1获取 state、commit 等方法)；封装方法的执行结果 res，会被判断是否是 Promise，不是则进行 Promise 封装；</li> <li>在真正调用时，dispatch 方法会从 _actions 中取出 type 对应的 ation，只有一个时则直接返回，否则用 Promise.all 处理再返回；</li></ul></li> <li>watch方法：实则 return this._watcherVM.$watch(() =&gt; getter(this.state, this.getters), cb, options)
<ul><li>观察 getter 方法、_watcherVM 是一 Vue 实例，故 watch 就可直接采用 Vue 内部的 watch 特性观察数据 getter 变动；</li></ul></li> <li>其他 un/registerModule：注册一个动态 module，当业务进行异步加载时，可通过该接口进行注册动态 module；</li></ul> <h2 id="_2-6、解析-compiler"><a href="#_2-6、解析-compiler" class="header-anchor">#</a> 2-6、解析—Compiler</h2> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200908132806.png" align="" style="zoom:50%;"> <p>模板解析这种事，本质是将数据转化为一段html，最开始出现在后端，经过各种处理吐给前端；但随着各种 mv* 兴起，模板解析交由前端处理；</p> <p>1、Vue complier 将 template 转化成一个 render 函数字符串，编译过程如下：</p> <ul><li>parse函数：负责解析 template，利用正则生成 AST；</li> <li>optimize 函数：负责优化静态节点(AST上)(标记无需每次都更新的内容，DIFF 会直接跳过静态节点，以减少比较过程，优化 patch 性能)；</li> <li>generate 函数：将前两步生成完善的 AST 组装成 render 函数字符串；</li> <li>render 函数：非转换步骤，但函数字符串需转换成函数才可执行，<code>render = new Function(render)，vm.$options.render</code></li></ul> <p>2、调用 new Watcher 函数，监听数据的变化，当数据发生变化时，Render 函数执行生成 vnode 对象；</p> <p>3、调用 patch 方法，对比新旧 vnode 对象，通过DOM diff 算法添加、修改、删除真正的 DOM 元素；</p> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200923124159.png" align="" style="zoom:50%;"> <h2 id="_2-7、渲染-domdiff"><a href="#_2-7、渲染-domdiff" class="header-anchor">#</a> 2-7、渲染—DOMDIFF</h2> <p>Vue 渲染 redner 就是构建虚拟 DOM，然后才构建到真实 DOM 上去，真实 DOM 与 虚拟 DOM 比对如下：</p> <p><strong><u>真实 DOM：</u></strong></p> <p>浏览器渲染引擎流程大致分5步：创建  <code>DOM</code> 树 —&gt; 创建 <code>Style Rules</code> -&gt; 构建 <code>Render</code> 树 —&gt; 布局 <code>Layout</code> -—&gt; 绘制 <code>Painting</code>：</p> <ul><li>第一步，构建 DOM 树：用 HTML 分析器，分析 HTML 元素，构建一棵 DOM 树；</li> <li>第二步，生成样式表：用 CSS 分析器，分析 CSS 文件和元素上的 inline 样式，生成页面的样式表；</li> <li>第三步，构建 Render 树：将 DOM 树和样式表关联，构建 Render 树(Attachment)；
<ul><li>每个 DOM 节点都有 attach 方法，接受样式信息，返回一个 render 对象，这些对象最终会被构建成一棵 Render 树；</li></ul></li> <li>第四步，确定节点坐标：根据 Render 树结构，为每个 Render 树上节点确定一个在显示屏上出现的精确坐标；</li> <li>第五步，绘制页面：根据 Render 树和节点显示坐标，然后调用每个节点的 paint 方法，将它们绘制出来；</li></ul> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200923124057.png" style="zoom:50%;"> <p><strong><u>虚拟 DOM：</u></strong></p> <p>本质是用一原生的 JS 对象去描述一个 DOM 节点(对原生的抽象—性能提升(内存处理/频繁重排避免)、跨平台、无需操作DOM)(借鉴snabbdom、inferno)；</p> <p>能应对绝大部分应用性能需求，但在某些性能要求极高的应用，虚拟DOM <u>无法进行针对性极致优化</u>；然后当变化产生时，比较虚拟DOM树差异，最后将之应用到真正 DOM 上；(初次渲染或更新时用 JS 对象将 DOM 化为虚拟 DOM，若为更新则按照一定规则(DIff)比对前后虚拟DOM树变化，随后将变化结果应用到真正DOM树上)；</p> <p><strong><u><em>VueDIFF过程：</em></u></strong></p> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200923124105.png" align="" style="zoom:50%;"> <p>当数据发生改变时，set 方法会触发 Dep.notify 方法，通知所有订阅者 Watcher，订阅者就会调用 patch 给真实 DOM 打补丁，更新相应视图：</p> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200923124106.png" align="" style="zoom:50%;"> <p>首先，正常情况下，Diff 两个树的时间复杂度是 O(n^3)—(旧树、新树、真实树)， 可实际中很少进行跨层级 DOM 移动，故 Vue 将这一流程进行了优化(看下方流程)，将时间复杂度降至 O(n)；Vue 版本与 DOMDIFF 关系：</p> <ul><li>Vue2 DIFF 采用双端比较(新旧比较)的算法：同时从新旧 children 两端开始进行比较，并借助 key 值找到可复用节点，再进行相关操作；</li> <li>Vue3 借鉴 ivi 算法和 inferno 算法：创建 VNode 时就确定其类型，在 mount/patch 过程中采用位运算来判断 VNode 类型，并利用动态规划的思想求解最长递归子序列，最后才再配合双端比较的算法，进一步提升性能；</li></ul> <p>然后，Vue2 虚拟DOM 映射到真实DOM 要经过 VNode 的 create、diff 、patch 等阶段；Vue.init 初始化，vm.$mounnt 挂载 -&gt; return mountCompent(this, el, …) -&gt; 实例化 Watcher，然后再在里面调用 <u>updateComponent</u> -&gt; vm.render 将实例渲染为 VNode(使用 createElement 创建 VNode) -&gt; vm.update (vnode, …) -&gt; <code>vm.__patch__</code>(核心方法：完成 preVnode 与 vnode 的 DIFF 并按需为 vdom 节点 patch)，最后生成新的真实 DOM 以完成视图更新操作；</p> <ul><li><p><code>vm.__patch__</code>：先用 sameVnode 比对新旧 Vnode 基本属性，若同则认为发生局部更新，然后 DIFF；否则直接跳过 DIFF，根据 vnode 新建真实 DOM，同时删除旧 dom 节点；DIFF：Vue2 Diff 实现主要通过两个方法：patchVnode(oldVnode, vnode)(及其 updateChildren 方法)：</p></li> <li><p>patchVnode如下：</p> <ul><li><p>首先，若新旧树存在节点，且 if (oldVnode === vnode)，引用一致，无变化；</p></li> <li><p>然后，若新旧树存在节点，节点相同且为文本节点，则先进行文本节点判断，oldVnode.text !== vnode.text，不同则通过 Node.textContent = vnode.text 更换；</p></li> <li><p>然后，若新旧树存在节点，节点相同且非文本节点，若含有子节点且不相同，if( oldCh &amp;&amp; ch &amp;&amp; oldCh !== ch)，则进入子节点 DIFF(DIFF核心)，即调用 updateChildren 比较；即同级比较(只有两个新旧节点是相同节点时，才会去比较各自子节点)(优点也是缺点，前因省去大量比较，后因省去底层比较，浪费严重(分情况讨论))；也即只更新差异部分的 DOM，以减少更新量，提升效率；</p> <ul><li><p>updateChildren 首先会通过判断两节点的 key、tag、isComment、data同时定义或不定义，及当标签类型为 input 时 type 类型来确定两节点是否相同；若不是则将新节点替换旧节点，若相同则进入 pathVNode，如此迭代下去；</p></li> <li><p>updateChildren 比较流程(夹逼法)：oldCh 和 newCh 各有两个头尾的变量 oldStartIndex、oldEndIndex &amp; newStartIndex、newEndIndex 之间两两相互比较，变量会往中间靠拢，一旦 Startldx &gt; Endldx 则表明 oldCh 和 newCh 至少有一个已遍历完，就会结束比较；</p></li> <li><p>优化：通过模版编译时的静态标记来跳过静态节点比较；</p></li> <li><p>优化：通过 key 尽可能的复用DOM元素(同级且父节点一致才可复用)；key 是 vnode 的唯一标记， 通过 key，有助于 DIFF 过程高效准确：</p> <ul><li><p>更准确：新旧 children 中的节点只有顺序是不同时，最佳操作应是通过移动元素位置来实现更新目的；(DIFF 比较是为了在新旧节点中找到相同节点，所以增加 Key 有利于节点复用，以快速找到相同节点而无需递归查找)；</p></li> <li><p>更快速：利用 key 的唯一性，在新旧 children 节点中保存映射关系 Map，以便能够在旧 children 节点中快速找到可复用节点；</p></li> <li><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">createKeyToOldIdx</span> <span class="token punctuation">(</span><span class="token parameter">children<span class="token punctuation">,</span> beginIdx<span class="token punctuation">,</span> endIdx</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> i<span class="token punctuation">,</span> key
	<span class="token keyword">const</span> map <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> beginIdx<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> endIdx<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		key <span class="token operator">=</span> children <span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>key
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> map<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> i
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> map 
<span class="token punctuation">}</span>
</code></pre></div></li></ul></li></ul></li> <li><p>然后，若新树存在旧树没有的节点，则调用 createEle(vnode)，vnode.el 已引用了老的 dom节点，故方法会在老 DOM 节点上添加子节点；</p></li> <li><p>最后，若新树不存在旧树子节点，则删除 elm 真实节点下的 oldVnode 子节点；</p></li></ul></li></ul> <p>最后，应用到真实 DOM 上；DIFF 最终目的是为修改 DOM 树：页面 DOM 树、旧 VNode 树、新 Vnode 树；</p> <ul><li>页面 DOM 树与旧 VNode  树节点一一对应，而新 Vnode 树则是表示更新后页面 DOM 树 该有的样子；
<ul><li>注意：在旧 Vnode 树与新 Vnode 树 进行比较过程中：不会对此两棵 Vode 树进行修改，而是以比较的结果，直接对真实 DOM 进行修改；</li> <li>比如：旧 Vnode 树同一层中，找到与新 Vnode 树中一样但位置不同的节点，此时需要移动节点，但不是移动旧树中节点，而是直接移动 DOM；</li> <li>即新旧 Vnode 树是拿来比较，最后只用比较结果对页面 DOM 树进行修改；</li></ul></li></ul> <p>所以，Vue DOMDIFF 体现了：</p> <ul><li>首先，找到 不需要移动的相同节点(文本节点)，消耗最小；</li> <li>然后，再找相同但是需要移动的节点，消耗次小；</li> <li>最后，找不到才会去新建/删除节点，兜底处理；</li></ul> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200923124107.png" align="" style="zoom:50%;"> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200923124108.png" align="" style="zoom:50%;"> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200908132803.png" style="zoom:50%;"> <p><strong><u><em>DOM Diff 比较示例</em></u></strong>：</p> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200923124112.png" align="" style="zoom:50%;"> <p>首轮，父节点相同，符合规则，进行子节点比较，进行第一流程：先找无需移动的相同节点，找到节点 2，根据比较结果，无需修改 DOM，则保留原位置；</p> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200923124113.png" align="" style="zoom:50%;"> <p>二轮，再无<u>相同且无需移动的节点</u>，进行第二流程：找<u>相同但是需要移动的节点</u>，找到节点 5，根据比较结果，需要移动 DOM；</p> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200923124114.png" align="" style="zoom:50%;"> <p>三轮，无相同节点，进行流程三，新建或删除节点，在旧 Vnode 中，若新 Vnode 不存在的节点要删除，在新 Vnode 中，旧 Vnode 不存在节点要新建；</p> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200923124115.png" align="" style="zoom:50%;"> <p>最后，页面更新完毕；</p> <h2 id="_2-8、钩子-生命周期"><a href="#_2-8、钩子-生命周期" class="header-anchor">#</a> 2-8、钩子—生命周期</h2> <p>Vue 实例有一个完整的生命周期，也即从开始创建、初始化数据、编译模版、挂载DOM-&gt;渲染、更新-&gt;渲染、卸载等一系列过程，称之为 Vue 的生命周期；</p> <p>创建前/后：</p> <ul><li>beforeCreate：vue 实例的挂载元素 <code>$el</code> 和数据对象 data 都是 undefined，尚未初始化；</li> <li>created：完成 data 数据初始化，但 <code>$el</code> 还未初始化；</li></ul> <p>载入前/后：</p> <ul><li>beforeMount：vue 实例的 <code>$el</code> 和 data 均已初始化，相关 render 函数首次被调用；实例已完成以下配置：编译模板，将 data里的数据和模板生成html；但注意此时还未挂载 html 到页面上；</li> <li>mounted：<code>el</code> 被新创建的 <code>vm.$el</code> 替换，并挂载到实例上后调用；实例已完成以下配置：用上面编译好的 html 内容替换 <code>el</code> 属性指向的 DOM 对象；完成将模板中的 html 渲染到 html 页面；此过程中进行 ajax 交互；</li></ul> <p>更新前/后：</p> <ul><li>beforeUpdate：在数据更新前调用，发生在虚拟 DOM 重新渲染和打补丁前；可在此钩子中进一步地更改状态，且不会触发额外的重渲染过程；</li> <li>updated：在由于数据更改导致的虚拟 DOM 重新渲染和打补丁后调用；调用时，组件 DOM 已更新，故可执行依赖于 DOM 的操作；但注意：大多数情况下，应避免在此期间更改状态，因可能会导致更新无限循环(使用 this.$nextTick 缓解)；该钩子在服务器端渲染期间不被调用；</li></ul> <p>销毁前/后：</p> <ul><li>beforeDestroy：在实例销毁前调用；实例仍然完全可用；</li> <li>destroyed：在实例销毁后调用；调用后所有的事件监听器会被移除，所有子实例也会被销毁；该钩子在服务器端渲染期间不被调用；</li></ul> <table><thead><tr><th>生命周期</th> <th>描述</th></tr></thead> <tbody><tr><td>beforeCreate</td> <td>组件实例被创建之初，组件的属性生效前</td></tr> <tr><td>Reated</td> <td>组件实例已经完全创建，属性也绑定，但真实dom还没有生成，<code>$el</code> 还不可用</td></tr> <tr><td>beforeMount</td> <td>在挂载开始之前被调用：相关的 render 函数首次被调用</td></tr> <tr><td>mounted</td> <td>el 被新创建的 vm.$el 替换，并挂载到实例上，之后调用该钩子</td></tr> <tr><td>beforeUpdate</td> <td>组件数据更新之前调用，发生在虚拟 DOM 打补丁前</td></tr> <tr><td>update</td> <td>组件数据更新之后</td></tr> <tr><td>activited</td> <td>keep-alive 专属，组件被激活时调用</td></tr> <tr><td>deactivated</td> <td>keep-alive 专属，组件被销毁时调用</td></tr> <tr><td>beforeDestory</td> <td>组件销毁前调用</td></tr> <tr><td>destoryed</td> <td>组件销毁后调用</td></tr></tbody></table> <ul><li><u>发起异步请求时机</u>：可在钩子函数 created、beforeMount、 mounted 中进行调用，这三个钩子中，data 已经创建，可将服务端端返回的数据进行赋值；而在 created 钩子中调用异步请求还有以下优点：
<ul><li>更快获取到服务端数据，减少页面 loading 时间；</li> <li>ssr不支持 beforeMount、mounted 钩子函数，放在 created 有助于确保一致性；</li></ul></li> <li><u>操作 DOM 时机</u>：在钩子函数 mounted 被调用前，Vue 已将编译好的模板挂载到页面上，故在 mounted 中即可访问操作 DOM；</li></ul> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200908132752.png" style="zoom:50%;"> <p><strong><u><em>父子组件生命周期执行顺序</em></u></strong>：Vue 父组件和子组件生命周期钩子函数执行顺序可为以下 4 部分：</p> <ul><li>加载渲染过程：父beforeCreate -&gt;父created -&gt;父beforeMount -&gt;子beforeCreate -&gt;子created -&gt;子beforeMount -&gt;子mounted -&gt;父mounted；</li> <li>子组件更新过程：父beforeUpdate -&gt;子beforeUpdate -&gt;子updated -&gt;父updated；</li> <li>父组件更新过程：父beforeUpdate -&gt;父updated；</li> <li>销毁过程：父beforeDestroy -&gt;子beforeDestroy -&gt;子destroyed -&gt;父destroyed</li></ul> <p>总即：组件调用顺序是：先父后子，渲染完成顺序是：先子后父；</p> <p>总即：组件销毁顺序是：先父后子，销毁完成顺序是：先子后父；</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 注意：父组件监听子组件生命钩子调用方式：</span>
<span class="token comment">// 方式1: 通过 $emit 触发父组件事件</span>
<span class="token comment">// Parent.vue</span>
<span class="token operator">&lt;</span>Child @mounted<span class="token operator">=</span><span class="token string">&quot;doSomething&quot;</span><span class="token operator">/</span><span class="token operator">&gt;</span>
<span class="token comment">// Child. vue</span>
<span class="token function">mounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span>&quot;mounted”<span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span>

             
<span class="token comment">// 方式2: 在父组件引用子组件时, 通过 @hook 监听</span>
<span class="token comment">// Parent. vue</span>
<span class="token operator">&lt;</span>Child @hook <span class="token operator">:</span>mounted<span class="token operator">=</span><span class="token string">&quot;doSomething&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>Child<span class="token operator">&gt;</span>
<span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">// ... B</span>
<span class="token punctuation">}</span>
<span class="token comment">// Child. vue</span>
<span class="token function">mounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token comment">// ... A</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token comment">// 以上输出顺序为: A -&gt; B</span>
<span class="token comment">// @hook 方法不仅可监听 mounted, 还可监听其它生命周期事件，比如 created, updated 等</span>
</code></pre></div><h2 id="_2-9、其他-cwm"><a href="#_2-9、其他-cwm" class="header-anchor">#</a> 2-9、其他—CWM</h2> <p>即 computed/watch/methods；</p> <p><strong><u><em>computed浓缩：</em></u></strong></p> <p>computed 计算就是调用设置的 get 函数，然后得到返回值；其能控制缓存的重要一点是它的属性：脏数据标志位 dirty；</p> <ul><li>当 dirty 为 true 时，读取 computed 会重新计算</li> <li>当 dirty 为 false 时，读取 computed 会使用缓存</li></ul> <p>1、开始每个 computed 新建自己的 watcher 时，会设置 watcher.dirty = true，以便于 computed 被使用时，会计算得到值；</p> <p>2、当依赖数据发生变化后，通知 computed 时，会设置 watcher.dirty = true，以便于其他地方重新渲染、重新读取 computed 时，computed 重新计算</p> <p>3、当 computed 计算完成后，会设置 watcher.dirty = false，以便于其他地方再次读取时，使用缓存，免于计算；</p> <ul><li><p>data C 开始变化后.......</p></li> <li><p>通知 computed B watcher 更新，并只重置脏数据标志位 dirty = true，而不会计算值；</p></li> <li><p>通知 页面 A watcher 进行更新渲染，进而重新读取 computed B ，然后 computed B 开始重新计算；</p></li></ul> <p>为什么 data C 能通知 页面 A：因为 data C 的依赖收集器会同时收集到 computed B 和 页面 A 的 watcher</p> <p>为什么 data C 能收集到 页面A 的watcher：因为 computed 在 页面 A 在读取 computed B 时，data C 就会收集到页面A watcher</p> <p>为什么 computed 能够更新：因为被依赖通知更新后，computed 重置了脏数据标志位(放开权限)，允许页面读取 computed 时再更新值；</p> <p><strong><u><em>computed流程：</em></u></strong></p> <p><u>初始化时</u>：init—&gt;initComputed—&gt;页面初次渲染，此时 Dep.target 为页面 Watcher—&gt;触发用 createComputed包装的 get 函数 createComputedGetter，createComputedGetter 主要执行了：<code>if (watcher.dirty) { watcher.evaluate(); }</code>、<code>if (Dep.target) { watcher.depend(); }</code></p> <ul><li><p>前者：执行前者；此时 watcher.dirty = true，因使用的是 lazy 的初始值 (initComputed 中 <code>new Watcher(vm, getter, { lazy: true });</code>)，所以 <code>watcher.evaluted</code> 可以被调用 (注意：调用完毕就要设置 dirty 为 false，此后除非与 computed 相关 data  发生变化，否则不会触发，即此值控制着缓存，是 computed 的核心实现)，随即 <code>computed.watcher.get</code> 被调用，进行 <code>pushTarget</code>，导致 <code>Dep.target</code> 被修改为 computed-watcher，而原来的值(页面 Watcher)会先被缓存到 targetStack 中；同时，computed 的计算会读取 data，因为双绑机制，此时 data 就能收集到 computed-watcher，即computed-watcher 也会保存到 data 的依赖收集器 dep.subs 中；随后，computed 计算完毕，执行 popTarget，释放 Dep.target，并将 Dep.target 恢复上一个 watcher(页面watcher)；</p></li> <li><p>后者，执行后者；即 <code>watcher.depend</code>，即执行 <code>dep.addSub(Dep.target)</code>，目的是让 data 再收集一次 Dep.target， 即收集页面 watcher；</p></li> <li><p>此时，<code>data 的依赖收集器 = [ computed-watcher, 页面-watcher]</code></p></li></ul> <p><u>数据更新时</u>：即 computed 所依赖的 data 更新时，触发 <code>dep.nodify</code>，依次触发依赖数组下的每一watcher：</p> <ul><li>先执行 computed-watcher 计算值(调用了 <code>watcher.update</code>，而其中包含了 <code>if (this.lazy) this.dirty = true;</code>，但注意此时尚未计算结果，只是控制计算的阀门打开，计算行为由 <code>watcher.evaluate()</code> 负责，而此方法在 <code>get:createComputedGetter(key),</code>，注意 get，所以 get 时，也即页面渲染时，读取值时才做真正计算 )；</li> <li>再执行页面-watcher 渲染页面做真正计算；</li> <li>即 data 改变，正序遍历通知，computed 先更新，页面再更新，所以页面才能读取到最新的 computed 值；</li></ul> <p><u>最后总结</u>：由双绑控制变化的触发，值相等则不触发，值不等才触发 watcher.update，而平时的刷新渲染不会触发 computed 的计算求值，因为 watcher.dirty 为 false，但 watcher 监听属性则会随着页面刷新而触发，即使它所绑定的值未发生值变化，因为它没有设置 watcher.dirty 变量去阻止；所以可以理解为 computed 计算属性是带有 dirty 标记的 watch，也正因为通过此标记，才能阻止不随页面刷新而计算；</p> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200923124201.png" align="" style="zoom:50%;"> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200923124202.png" align="" style="zoom:50%;"> <p><strong><u><em>三者的对比：</em></u></strong></p> <p>computed：计算属性，依赖其它属性值，有缓存性，只有所依赖属性值发生改变，下一次获取 computed 时才会重新计算新值；</p> <ul><li>本质是一个惰性求值的观察者，其内部实现了一个具有缓存功能的 watcher，也即 computed watcher，watcher 不会立刻求值，同时其持有一个 dep 实例；实例内部通过 this.dirty 属性标记计算属性是否需要重新求值；然后，当 computed 的依赖状态发生改变时，就会通知这个惰性的 watcher；然后，computed watcher 通过  this.dep.subs.length 判断有没有订阅者：
<ul><li>若有则会重新计算，然后对比新旧值，有变化就会重新渲染；注意：Vue 想确保不仅是计算属性依赖的值发生变化就触发渲染，而是当计算属性最终计算的值发生变化，才会触发渲染 watcher 重新渲染，本质上是一种优化；</li> <li>若无则仅将 this.dirty = true；注意：当计算属性依赖于其他数据时，属性并不会立即重新计算，只有之后其他地方需要读取属性时，它才会真正计算，即具备 lazy 特性；</li></ul></li> <li>注意：computed 是在 DOM加载后马上执行，比如赋值操作；</li> <li>注意：计算属性计算时所依赖的属性一定是响应式依赖，否则计算属性不会执行；</li> <li>注意：计算属性是基于依赖进行缓存，若依赖无更新，调用计算属性并不会重新计算，因此可减少开销，只有在其依赖的属性值改变后的下一次获取computed 值时才会重新调用对应的 getter 来计算出相应新值；</li></ul> <p>watch：侦听器，多起观察作用，无缓存性，可以监听某些数据执行回调，每当监听的数据变化时，都会执行回调进行后续操作；</p> <ul><li>注意：当需要进行深度监听对象中属性时，可打开 deep: true 选项，这样便会对对象中的每一项进行监听，虽会带来性能问题，但可使用字符串形式监听来优化；此外如果没有写到组件中，需要注意使用 unWatch 手动注销；</li></ul> <p>methods：方法，无缓存性，不像 computed 在 DOM 加载后可自动执行，必须有一定触发条件才被执行，如点击事件等；</p> <ul><li>区别：与 computed 区别在于：前者必须有一定的触发条件才能执行，比如重渲染，异步绑定事件等；而后者则基于它的依赖进行缓存，若多次访问的时候(值不变情况下)，计算属性会立即返回数据，而不必再次执行函数，另外还可自动执行(依赖变化且被读取)；</li></ul> <p><strong><u><em>三者使用场景对比:</em></u></strong></p> <ul><li>当数值计算并依赖于其它数据、计算耗性能的计算场景、模板表达式过于复杂时、复杂渲染数据的计算、不必重新计算数值，可利用 computed 缓存特性，避免每次获取值时都重新计算；</li> <li>当需要在数据变化时执行异步或开销较大操作时，可使用 watch，注意限制执行该操作的频率，并在得到最终结果前，设置中间状态；</li> <li>注意：能使用 watch 属性的场景基本上都可使用 computed 属性，且 computed 属性开销小性能高，故因尽量使用 computed 属性，除非要执行异步或昂贵的操作以响应不断变化的数据；</li> <li>比如：点击搜索按钮的时候才进行数据的响应和操作，使用 computed；获取当前时间，使用 methods；</li></ul> <h2 id="_2-10、其他-nexttick"><a href="#_2-10、其他-nexttick" class="header-anchor">#</a> 2-10、其他—NextTick</h2> <p>官方描述：在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM；(nextTick 在下次DOM更新循环结束后执行延迟回调；主要使用了宏&amp;微任务，并根据环境分别尝试使用 Promise、MutationObserver、setlmmediate、setTimeout)</p> <p>个人理解：Vue 向外暴露的接口，通过微任务实现渲染后的即时数据操作，但为了兼容性考虑，甚至使用宏任务去向下降级；</p> <p>Vue 并非每次数据变化即进行页面的渲染更新操作，而是通过异步来实现 DOM 更新；</p> <p>首先，只要观察到数据变化，Vue 就会开启一个队列，并缓冲在同一事件循环中发生的所有数据改变；若同个 watcher 被多次触发，则最好只会被推入一次，以减少不必要的计算和 DOM 操作；</p> <p>然后，在下一事件循环 tick 中，Vue 刷新队列并执行相关方法；</p> <ul><li><p>microtask 因其高优先级特性，能确保队列中的微任务在一次事件循环前被执行完毕；</p></li> <li><p>回顾：主线程的执行过程就是一个 tick，而所有的异步结果都是通过&quot;任务队列&quot;来调度；比如消息队列中存放的是一个个的任务 (task)；规范中规定 task 分为两大类，分别是 macro task(宏) 和 micro task(微)，且每个 macro task 结束后，都要清空所有的 micro task；</p></li> <li><p>Vue 内部对异步队列，会依次尝试使用原生 Promise.then、MutationObserver、setlmmediate，若执行环境均不支持，则会采用 setTimeout(fn, 0)代替；在 vue2.5 源码中，macrotask 降级的方案依次是：setlmmediate、 MessageChannel、 setTimeout；</p></li></ul> <p>比如：vm.someData = 'new value' 后，在同一事件循环内，组件不会立即渲染；而是在队列刷新时，组件才会在事件循环队列清空时的下一 &quot;tick&quot; 更新；</p> <p>问题：难以在 DOM 状态更新后立即做某些处理；</p> <p>解决：为实现上述场景，可在数据变化后立即使用 Vue.nextTick(callback)；如此回调会在 DOM 更新完成后立即调用；</p> <p>注意：Vue 在版本2.4—2.6中，对 <code>nextTick</code> 的反复改动，是浏览器对微任务的兼容性问题影响、宏微任务特点衡量的结果；</p> <ul><li>若 Vue 使用<u>宏任务函数</u>，则势必要等待UI渲染完成后的下一个<u>宏任务</u>执行；</li> <li>若 Vue 使用<u>微任务函数</u>，则无需等待UI渲染完成即可进行 nextTick 回调；</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 修改数据</span>
vm<span class="token punctuation">.</span>msg <span class="token operator">=</span> <span class="token string">'Hello'</span>
<span class="token comment">// DOM 还没有更新</span>
Vue<span class="token punctuation">.</span><span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// DOM 更新了</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// 作为一个 Promise 使用 (2.1.0 起新增，详见接下来的提示)</span>
Vue<span class="token punctuation">.</span><span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
 <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// DOM 更新了</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">// 2.1.0 起新增：若无提供回调且在支持 Promise 的环境中，则返回一个 Promise；</span>
<span class="token comment">// 注意 Vue 不自带 Promise 的 polyfill，所以若目标浏览器不原生支持 Promise，得自己提供 polyfill... =。=</span>
</code></pre></div><img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200923124203.png" align="" style="zoom:50%;"> <h2 id="_2-11、keepalive"><a href="#_2-11、keepalive" class="header-anchor">#</a> 2-11、KeepAlive</h2> <p>keep-alive 是 Vue内置的一个组件，可使被包含的组件保留状态，避免重新渲染，一般结合路由和动态组件一起使用，用于缓存组件：</p> <p>keep-alive 可实现组件缓存，在组件切换时不会对当前组件进行卸载 (即将组件包含在 keep-alive 元素，组件就会被缓存，在组件切换时就不会重新渲染而是直接使用，响应速度也更快)；常用的两个属性 include/exclude 允许组件有条件的进行缓存，两者都支持字符串或正则表达式</p> <ul><li><p>include 表示只有名称匹配的组件会被缓存；</p></li> <li><p>exclude 表示任何名称匹配的组件都不会被缓存，其中 exclude 优先级比 include 高；</p></li> <li><p>两个钩子 activated/deactivated，用来得知当前组件是否处于活跃状态；当组件被激活时，触发钩子 activated，当组件被移除时，触发 deactivated；</p></li></ul> <p><strong><u><em>KeepAlive 实现原理与缓存策略</em></u></strong>：</p> <ul><li>首先，获取 keep-alive 包裹着的第一个子组件对象及其组件名：getFirstComponentChild；</li> <li>然后，根据设定的 include/exclude 进行条件匹配，决定是否缓存；不匹配，则直接返回组件实例；</li> <li>然后，根据组件 ID 和 tag 生成缓存 Key，并在缓存对象中查找是否已缓存过该组件实例；
<ul><li>若存在，则直接取出缓存值并更新该 key 在 this.keys 中的位置 (更新 key 的位置是实现 LRU 置换策略的关键)</li></ul></li> <li>然后，在 this.cache 对象中存储该组件实例并保存 key 值；</li> <li>然后，检查缓存的实例数量是否超过 max 设置值，若超过则根据 LRU 置换策略删除最近最久未使用的实例(即是下标为0的那个key)；
<ul><li>LRU(Least recently used)，缓存淘汰算法，根据数据历史访问记录来进行淘汰数据，核心思想是&quot;若数据最近被访问过，则将来被访问的几率也更高&quot;</li> <li>keep-alive 的实现正是利用了 LRU 策略，将最近访问的组件 push 到 this.keys 末尾，this.keys[0] 也即最久没被访问的组件；</li></ul></li> <li>最后，将组件实例的 keepAlive 属性设置为 true，此在渲染和执行被包裹组件的钩子函数会用到；</li></ul> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200908132805.png" align="" style="zoom:50%;"></div> <footer class="page-edit" style="display:none;"><!----> <div class="last-updated"><span class="prefix">Last Updated: </span> <span class="time">9/29/2020, 4:19:55 PM</span></div></footer> <!----> <!----> <!----></main> <!----></div></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div></div></div>
    <script src="/assets/js/app.f95d0077.js" defer></script><script src="/assets/js/3.49babee5.js" defer></script><script src="/assets/js/1.269e4bda.js" defer></script><script src="/assets/js/133.0f2404ed.js" defer></script>
  </body>
</html>
