<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>一、基本 | Leibnize 个人学习笔记</title>
    <meta name="generator" content="VuePress 1.5.4">
    
    <meta name="description" content="整理自网络">
    <link rel="preload" href="/docs/assets/css/0.styles.2f643d57.css" as="style"><link rel="preload" href="/docs/assets/js/app.cda475f7.js" as="script"><link rel="preload" href="/docs/assets/js/2.c902c426.js" as="script"><link rel="preload" href="/docs/assets/js/56.388173c5.js" as="script"><link rel="prefetch" href="/docs/assets/js/10.418fecbd.js"><link rel="prefetch" href="/docs/assets/js/11.e2c998bf.js"><link rel="prefetch" href="/docs/assets/js/12.b627468b.js"><link rel="prefetch" href="/docs/assets/js/13.682b9b92.js"><link rel="prefetch" href="/docs/assets/js/14.0880e743.js"><link rel="prefetch" href="/docs/assets/js/15.4a6c4027.js"><link rel="prefetch" href="/docs/assets/js/16.200e0299.js"><link rel="prefetch" href="/docs/assets/js/17.1c6394bc.js"><link rel="prefetch" href="/docs/assets/js/18.c0560a2b.js"><link rel="prefetch" href="/docs/assets/js/19.f63607cc.js"><link rel="prefetch" href="/docs/assets/js/20.d56d802e.js"><link rel="prefetch" href="/docs/assets/js/21.52c3ae8e.js"><link rel="prefetch" href="/docs/assets/js/22.b47add39.js"><link rel="prefetch" href="/docs/assets/js/23.a8a40e53.js"><link rel="prefetch" href="/docs/assets/js/24.a0e2af55.js"><link rel="prefetch" href="/docs/assets/js/25.1fb24116.js"><link rel="prefetch" href="/docs/assets/js/26.068130b1.js"><link rel="prefetch" href="/docs/assets/js/27.6cb72d75.js"><link rel="prefetch" href="/docs/assets/js/28.d99e5701.js"><link rel="prefetch" href="/docs/assets/js/29.4848d9ba.js"><link rel="prefetch" href="/docs/assets/js/3.be11a00a.js"><link rel="prefetch" href="/docs/assets/js/30.92ed4a03.js"><link rel="prefetch" href="/docs/assets/js/31.de402b39.js"><link rel="prefetch" href="/docs/assets/js/32.b5ca6564.js"><link rel="prefetch" href="/docs/assets/js/33.c3d91abd.js"><link rel="prefetch" href="/docs/assets/js/34.b868c98b.js"><link rel="prefetch" href="/docs/assets/js/35.4128bd9f.js"><link rel="prefetch" href="/docs/assets/js/36.8e4b22b8.js"><link rel="prefetch" href="/docs/assets/js/37.090897e6.js"><link rel="prefetch" href="/docs/assets/js/38.f8d5752b.js"><link rel="prefetch" href="/docs/assets/js/39.f949333a.js"><link rel="prefetch" href="/docs/assets/js/4.64176cb5.js"><link rel="prefetch" href="/docs/assets/js/40.39833f40.js"><link rel="prefetch" href="/docs/assets/js/41.a12c7b96.js"><link rel="prefetch" href="/docs/assets/js/42.a5e6d9e8.js"><link rel="prefetch" href="/docs/assets/js/43.28874788.js"><link rel="prefetch" href="/docs/assets/js/44.8d4042e3.js"><link rel="prefetch" href="/docs/assets/js/45.b148e845.js"><link rel="prefetch" href="/docs/assets/js/46.91062fd6.js"><link rel="prefetch" href="/docs/assets/js/47.2026c6cc.js"><link rel="prefetch" href="/docs/assets/js/48.b0f3d68f.js"><link rel="prefetch" href="/docs/assets/js/49.9d81175e.js"><link rel="prefetch" href="/docs/assets/js/5.1d876c62.js"><link rel="prefetch" href="/docs/assets/js/50.1a00f734.js"><link rel="prefetch" href="/docs/assets/js/51.b16e53d7.js"><link rel="prefetch" href="/docs/assets/js/52.831b9cca.js"><link rel="prefetch" href="/docs/assets/js/53.4ce4ac34.js"><link rel="prefetch" href="/docs/assets/js/54.6d7ca762.js"><link rel="prefetch" href="/docs/assets/js/55.2bb32bbd.js"><link rel="prefetch" href="/docs/assets/js/57.cd784d78.js"><link rel="prefetch" href="/docs/assets/js/58.d994c1a9.js"><link rel="prefetch" href="/docs/assets/js/59.0665a00b.js"><link rel="prefetch" href="/docs/assets/js/6.bc091efc.js"><link rel="prefetch" href="/docs/assets/js/60.12f3479d.js"><link rel="prefetch" href="/docs/assets/js/61.679d1273.js"><link rel="prefetch" href="/docs/assets/js/62.04ef0d26.js"><link rel="prefetch" href="/docs/assets/js/63.70e8cd2b.js"><link rel="prefetch" href="/docs/assets/js/64.c7956833.js"><link rel="prefetch" href="/docs/assets/js/65.0304095c.js"><link rel="prefetch" href="/docs/assets/js/66.f16304a7.js"><link rel="prefetch" href="/docs/assets/js/67.d0a945f4.js"><link rel="prefetch" href="/docs/assets/js/68.26e1c58d.js"><link rel="prefetch" href="/docs/assets/js/69.ac162984.js"><link rel="prefetch" href="/docs/assets/js/7.255d7d5f.js"><link rel="prefetch" href="/docs/assets/js/70.5408bf05.js"><link rel="prefetch" href="/docs/assets/js/8.2117996a.js"><link rel="prefetch" href="/docs/assets/js/9.e855c324.js">
    <link rel="stylesheet" href="/docs/assets/css/0.styles.2f643d57.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/docs/" class="home-link router-link-active"><!----> <span class="site-name">Leibnize 个人学习笔记</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="https://github.com/rjwx60" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="https://github.com/rjwx60" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span></span> <span class="arrow down"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="一、基本"><a href="#一、基本" class="header-anchor">#</a> 一、基本</h2> <p>Vue</p> <p><strong>特点</strong>：<strong>响应式</strong>和<strong>组件化</strong>。</p> <ul><li><strong>响应式</strong>：通过 MVVM 思想实现数据双向绑定，通过虚拟 DOM 来让数据来操作DOM，而不必去操作真实 DOM，提升性能；让开发者将重心放在业务逻辑；</li> <li><strong>组件化</strong>：将单页应用中的各个模块拆分到一个个组件当中，或将一些公共部分抽离出来做成一个可复用组件；提高开发效率&amp;可维护性，方便重复使用；</li></ul> <p><strong>缺点</strong>：</p> <ul><li>不利于seo；</li> <li>初次加载时耗时多；</li> <li>基于对象配置文件的写法，也就是 options 写法，开发时不利于对一个属性的查找；</li> <li>导航不可用，如果一定要导航需要自行实现前进、后退(单页面不能用浏览器的前进后退功能，要自己建立堆栈管理)；</li></ul> <h3 id="_1-1、基本内容"><a href="#_1-1、基本内容" class="header-anchor">#</a> 1-1、基本内容</h3> <h3 id="_1-2、生命周期"><a href="#_1-2、生命周期" class="header-anchor">#</a> 1-2、生命周期</h3> <h4 id="_1-2-1、vue"><a href="#_1-2-1、vue" class="header-anchor">#</a> 1-2-1、Vue</h4> <h4 id="_1-2-2、angular"><a href="#_1-2-2、angular" class="header-anchor">#</a> 1-2-2、Angular</h4> <h3 id="_1-3、路由机制"><a href="#_1-3、路由机制" class="header-anchor">#</a> 1-3、路由机制</h3> <h4 id="_1-3-1、vue"><a href="#_1-3-1、vue" class="header-anchor">#</a> 1-3-1、Vue</h4> <p>Vue 路由的 hash 模式 与 history 模式：</p> <p>hash 模式的 URL 中会夹杂着#号，而 history 没有；Vue 底层实现有别：</p> <ul><li><code>hash</code> 模式是依靠 <code>onhashchange</code> 事件(监听<code>location.hash</code>的改变)；</li> <li><code>history</code> 模式是依靠的<code>H5 history</code> 新增的两个方法：
<ul><li><code>pushState()</code>改变 <code>url</code> 地址且不会发送请求；</li> <li><code>replaceState()</code>可读取历史记录栈，还可对浏览器记录进行修改；</li></ul></li></ul> <p>当真正需要通过<code>URL</code>向后端发送<code>HTTP</code>请求时，比如常见的用户手动输入<code>URL</code>后回车，或刷新(重启)浏览器，此时 <code>history</code> 模式需要后端的支持；</p> <p>因为<code>history</code>模式下，前端的<code>URL</code>须和实际向后端发送请求的<code>URL</code>一致，例如有一个<code>URL</code>是带有路径<code>path</code>的(例如<code>www.lindaidai.wang/blogs/id</code>)，如果后端没有对这个路径做处理的话，就会返回<code>404</code>错误。所以需要后端增加一个覆盖所有情况的候选资源，一般会配合前端给出的一个<code>404</code>页面；</p> <div class="language-js extra-class"><pre class="language-js"><code>window<span class="token punctuation">.</span><span class="token function-variable function">onhashchange</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token comment">// location.hash获取到的是包括#号的，如&quot;#heading-3&quot;</span>
  <span class="token comment">// 所以可以截取一下</span>
  <span class="token keyword">let</span> hash <span class="token operator">=</span> location<span class="token punctuation">.</span>hash<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>详看：<a href="https://juejin.im/post/6844903615283363848#heading-4" target="_blank" rel="noopener noreferrer">文章<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h4 id="_1-3-2、angular"><a href="#_1-3-2、angular" class="header-anchor">#</a> 1-3-2、Angular</h4> <p>Angular 程序是一棵组件树，有一些组件，如根组件，在整个程序中位置不变。<strong>然而，我们需要动态渲染组件，其中一种方式是使用路由器</strong>。通过使用路由模块的 <strong><a href="https://link.zhihu.com/?target=https%3A//angular.io/api/router/RouterOutlet" target="_blank" rel="noopener noreferrer">router-outlet 指令<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></strong>，可以根据当前 url 在程序中某个位置渲染一些组件；</p> <p>路由内部会把这些<em>可被路由</em>的组件称为路由状态，路由器会把程序中可被路由的组件作为 <strong><a href="https://link.zhihu.com/?target=https%3A//github.com/angular/angular/blob/7.1.3/packages/router/src/router_state.ts" target="_blank" rel="noopener noreferrer">一棵路由状态树<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></strong>；</p> <p><strong>路由的核心功能是可以在程序内进行组件导航，并且需要路由器在页面的某个出口处渲染组件，url 还得随渲染状态进行对应的修改</strong>。为此路由器需要把相关 url 和加载的组件绑定到一起，它通过让开发者自定义路由状态，根据指定 url 来渲染对应的组件。</p> <p>通过在程序内导入 <strong><a href="https://link.zhihu.com/?target=https%3A//angular.io/api/router/RouterModule" target="_blank" rel="noopener noreferrer">RouterModule<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></strong> 并在 <strong>forRoot</strong> 方法内定义 <strong><a href="https://link.zhihu.com/?target=https%3A//github.com/angular/angular/blob/7.1.3/packages/router/src/config.ts%23L372-L398" target="_blank" rel="noopener noreferrer">Route<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></strong> 对象数组，来定义路由状态；</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> RouterModule<span class="token punctuation">,</span> Route <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@angular/router'</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> <span class="token constant">ROUTES</span><span class="token operator">:</span> Route<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>
  <span class="token punctuation">{</span> path<span class="token operator">:</span> <span class="token string">'home'</span><span class="token punctuation">,</span> component<span class="token operator">:</span> HomeComponent <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">{</span> path<span class="token operator">:</span> <span class="token string">'notes'</span><span class="token punctuation">,</span>
    children<span class="token operator">:</span> <span class="token punctuation">[</span>
      <span class="token punctuation">{</span> path<span class="token operator">:</span> <span class="token string">''</span><span class="token punctuation">,</span> component<span class="token operator">:</span> NotesComponent <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token punctuation">{</span> path<span class="token operator">:</span> <span class="token string">':id'</span><span class="token punctuation">,</span> component<span class="token operator">:</span> NoteComponent <span class="token punctuation">}</span>
    <span class="token punctuation">]</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">]</span><span class="token punctuation">;</span>

@<span class="token function">NgModule</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  imports<span class="token operator">:</span> <span class="token punctuation">[</span>
    RouterModule<span class="token punctuation">.</span><span class="token function">forRoot</span><span class="token punctuation">(</span><span class="token constant">ROUTES</span><span class="token punctuation">)</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><h5 id="_1-3-2-1、路由配置"><a href="#_1-3-2-1、路由配置" class="header-anchor">#</a> 1-3-2-1、路由配置</h5> <ul><li><strong>RouterModule</strong> 有一个 <strong>forChild</strong> 方法，也可以传入 <strong>Route</strong> 对象数组，然而尽管 <strong>forChild</strong> 和 <strong>forRoot</strong> 方法都包含路由指令和配置，但是 <strong>forRoot</strong> 可以返回 <strong>Router</strong> 对象，由于 <strong>Router</strong> 服务会改变 <strong><a href="https://link.zhihu.com/?target=https%3A//developer.mozilla.org/zh-CN/docs/Web/API/Location" target="_blank" rel="noopener noreferrer">浏览器 location 对象<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></strong>，而 location 对象又是一个全局单例对象，<strong><a href="https://link.zhihu.com/?target=https%3A//blog.angularindepth.com/avoiding-common-confusions-with-modules-in-angular-ada070e6891f" target="_blank" rel="noopener noreferrer">所以 Router 服务对象也必须全局单例<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></strong>。这就是你必须在根模块中只使用一次 <strong>forRoot</strong> 方法的原因，特性模块中应当使用 <strong>forChild</strong> 方法；</li> <li>当匹配到路由路径时，路由状态 <strong>component</strong> 属性定义的组件会被渲染在 <strong><a href="https://link.zhihu.com/?target=https%3A//angular.io/api/router/RouterOutlet" target="_blank" rel="noopener noreferrer">router-outlet 指令<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></strong> 挂载的地方，即渲染激活组件的动态元素。被渲染的组件会作为 <strong>router-outlet</strong> 元素的兄弟节点而不是子节点，<strong>router-outlet</strong> 元素也可以层层嵌套，形成父子路由关系。</li></ul> <blockquote><p>注：<strong><a href="https://link.zhihu.com/?target=https%3A//github.com/angular/angular/blob/7.1.3/packages/common/src/location/index.ts" target="_blank" rel="noopener noreferrer">@angular/common/src/location<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></strong> 提供了更高层级的抽象，不单单针对浏览器平台，提供了很多好用的 API，并暴露了 <strong><a href="https://link.zhihu.com/?target=https%3A//github.com/angular/angular/blob/7.1.3/packages/common/src/location/platform_location.ts%23L32-L48" target="_blank" rel="noopener noreferrer">PlatformLocation<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></strong> 接口供不同平台具体实现；针对具体的浏览器平台，<strong><a href="https://link.zhihu.com/?target=https%3A//github.com/angular/angular/blob/7.1.3/packages/platform-browser/src/browser/location/browser_platform_location.ts" target="_blank" rel="noopener noreferrer">BrowserPlatformLocation<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></strong> 实现了该接口，并在程序初始化时针对浏览器平台 <strong><a href="https://link.zhihu.com/?target=https%3A//github.com/angular/angular/blob/7.1.3/packages/platform-browser/src/browser.ts%23L29" target="_blank" rel="noopener noreferrer">指定对应的 PlatformLocation 实现<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></strong></p></blockquote> <p><strong>程序内部导航时，路由器对象会捕捉导航的 url，并与路由状态树中的某个路由状态进行匹配</strong></p> <p><strong>任意时刻，当前 url 表示当前程序激活路由状态的序列化形式</strong>。路由状态的改变会触发 url 的改变，同时，url 的改变也会触发当前激活路由状态的改变，它们表示的是同一个东西；<strong><a href="https://link.zhihu.com/?target=https%3A//blog.angularindepth.com/angular-routing-series-pillar-1-router-states-and-url-matching-12520e62d0fc" target="_blank" rel="noopener noreferrer">路由器对象根据路径匹配路由的内部算法<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></strong>，是使用最先匹配策略，内部实现采用的是第一层级搜索，匹配 url 的第一个路径。</p> <h5 id="_1-3-2-2、路由生命周期"><a href="#_1-3-2-2、路由生命周期" class="header-anchor">#</a> 1-3-2-2、路由生命周期</h5> <p>与组件生命周期相同，路由器在每一次路由状态切换时也存在生命周期：</p> <img src="/Image/Frame/Angular/23.png" align="" style="zoom:50%;"> <p><strong>在每一次导航周期内，路由器会触发一系列事件</strong>。路由器对象也提供了监听路由事件的 observable 对象，用来定义一些自定义逻辑，如加载动画，或辅助调试路由。值得关注的事件有： <em>NavigationStart：表示导航周期的开始。</em> NavigationCancel：表示取消本次导航，比如，路由守卫拒绝导航到特定的路由。 <em>RoutesRecognized：当 url 匹配到对应的路由。</em> NavigationEnd：导航成功结束</p> <div class="language- extra-class"><pre class="language-text"><code>const ROUTES: Route[] = [
  { path: 'home', component: HomeComponent },
  { path: 'notes',
    children: [
      { path: '', component: NotesComponent },
      { path: ':id', component: NoteComponent }
    ]
  },
];
</code></pre></div><p>根据上面定义的路由状态，当 url 导航到 <strong>http://localhost:4200/notes/42</strong>，看看发生什么有趣的事情。总体上来说主要包括以下几步： <em>第一步，任何重定向会被优先处理。因为只有将最终稳定的 url 匹配到路由状态才有意义，而本示例中没有重定向，所以 url <strong>http://localhost:4200/notes/42</strong> 就是最终稳定的。</em> 第二步，路由器使用最先匹配策略来匹配 url 和路由状态。本示例中，会优先匹配 <strong>path:'notes'</strong>，然后就是 <strong>path:':id'</strong>，匹配的路由组件是 <strong>NoteComponent</strong>。 <em>第三步，由于匹配到了路由状态，所以路由器会检查该路由状态是否存在阻止导航的路由守卫。比如，只有登录用户才能看到笔记列表，而本示例中，没有路由守卫。同时，也没有定义 <strong><a href="https://link.zhihu.com/?target=https%3A//angular.cn/guide/router%23emresolveem-pre-fetching-component-data" target="_blank" rel="noopener noreferrer">resolvers<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></strong> 预先获取数据，所以路由器会继续执行导航。</em> 第四步，路由器会激活该路由状态的路由组件。 * 第五步，路由器完成导航。然后它会等待下一次路由状态的改变，重复以上过程。</p> <p>可以通过在 <strong>forRoot</strong> 方法内开启 <strong>enableTrace: true</strong> 选项，这样可以在浏览器控制台里看到打印的事件：</p> <div class="language-ts extra-class"><pre class="language-ts"><code>RouterModule<span class="token punctuation">.</span><span class="token function">forRoot</span><span class="token punctuation">(</span><span class="token punctuation">[</span>
  <span class="token constant">ROUTES</span><span class="token punctuation">,</span>
  <span class="token punctuation">{</span>
    enableTracing<span class="token operator">:</span> <span class="token boolean">true</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
</code></pre></div><p>同理，组件可以通过注入路由器对象来访问到路由事件流，并订阅**<a href="https://link.zhihu.com/?target=https%3A//github.com/angular/angular/blob/7.1.3/packages/router/src/router.ts%23L242" target="_blank" rel="noopener noreferrer">该事件流<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>**：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">constructor</span><span class="token punctuation">(</span><span class="token keyword">private</span> router<span class="token operator">:</span> Router<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>router<span class="token punctuation">.</span>events<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span> <span class="token punctuation">(</span>event<span class="token operator">:</span> RouterEvent<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h5 id="_1-3-2-3、路由组件懒加载"><a href="#_1-3-2-3、路由组件懒加载" class="header-anchor">#</a> 1-3-2-3、路由组件懒加载</h5> <p>Angular 路由器系列第三部分是有关<strong>懒加载模块</strong>。随着程序越来越大，很多功能会被封装在单独的特性模块中，比如，一个卖书的网站可能包括书籍、用户等模块。<strong>问题是程序首次加载时不需要展示所有数据，所以没必要在主模块中包含所有模块</strong>。否则这会导致主模块文件膨胀，并导致程序加载时加载时间过长。最好的解决方案是当用户导航到某些模块时再按需加载这些模块，而 Angular 路由器的懒加载功能就可以做到这一点。</p> <p>懒加载模块的示例如下：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">// from the Angular docs https://angular.io/guide/lazy-loading-ngmodules#routes-at-the-app-level</span>
<span class="token punctuation">{</span>
  path<span class="token operator">:</span> <span class="token string">'customers'</span><span class="token punctuation">,</span>
  loadChildren<span class="token operator">:</span> <span class="token string">'app/customers/customers.module#CustomersModule'</span>
<span class="token punctuation">}</span>
</code></pre></div><p>传给 <strong>loadChildren</strong> 属性的值类型是字符串，而不是组件对象引用。在导入模块时，注意避免引用任何懒加载模块，否则会在编译时依赖该模块，导致 Angular 不得不在主代码包中把它编译进来，破坏了懒加载目的。</p> <p>路由器在导航周期的重定向和 url 匹配阶段内，会开始加载懒加载模块：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">/**
 * Returns the `UrlTree` with the redirection applied.
 *
 * Lazy modules are loaded along the way.
 */</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">applyRedirects</span><span class="token punctuation">(</span>
    moduleInjector<span class="token operator">:</span> Injector<span class="token punctuation">,</span> configLoader<span class="token operator">:</span> RouterConfigLoader<span class="token punctuation">,</span> urlSerializer<span class="token operator">:</span> UrlSerializer<span class="token punctuation">,</span>
    urlTree<span class="token operator">:</span> UrlTree<span class="token punctuation">,</span> config<span class="token operator">:</span> Routes<span class="token punctuation">)</span><span class="token operator">:</span> Observable<span class="token operator">&lt;</span>UrlTree<span class="token operator">&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ApplyRedirects</span><span class="token punctuation">(</span>moduleInjector<span class="token punctuation">,</span> configLoader<span class="token punctuation">,</span> urlSerializer<span class="token punctuation">,</span> urlTree<span class="token punctuation">,</span> config<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>正如源码文件 <strong><a href="https://link.zhihu.com/?target=https%3A//github.com/angular/angular/blob/7.1.3/packages/router/src/config.ts%23L259-L261" target="_blank" rel="noopener noreferrer">config.ts<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></strong> 所描述的：</p> <blockquote><p>The router will use registered NgModuleFactoryLoader to fetch an NgModule associated with 'team'.Then it will extract the set of routes defined in that NgModule, and will transparently add those routes to the main configuration.
路由器会使用注册的 <strong>NgModuleFactoryLoader</strong> 来加载与 'team' 相关的模块，并把该懒加载模块中定义的路由集合，添加到主配置里。</p></blockquote> <p>在懒加载模块中定义的路由会被加载到主配置里，从而可以进行路由匹配。本系列将会稍后大量聊聊懒加载。</p> <p>参考：https://zhuanlan.zhihu.com/p/98516062</p> <h3 id="_1-4、数据绑定"><a href="#_1-4、数据绑定" class="header-anchor">#</a> 1-4、数据绑定</h3> <h4 id="_1-4-1、vue"><a href="#_1-4-1、vue" class="header-anchor">#</a> 1-4-1、Vue</h4> <p>Vue2 数据绑定依靠 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" rel="noopener noreferrer">Object.defineProperty<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <img src="/Image/Frame/Vue/1.png" align="" style="zoom:50%;"> <h5 id="_1-4-1-1、initdata"><a href="#_1-4-1-1、initdata" class="header-anchor">#</a> 1-4-1-1、initData</h5> <p>首先，initData，获取 data 的 key，并获取 props，并确保 props 优先，不能与 data 重复，并判断是否保留字段，并将 data 属性代理到 vm 实例上(this.key == this.data.key)，随后进行 observer(data) - 数据绑定操作；</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">initData</span> <span class="token punctuation">(</span><span class="token parameter">vm<span class="token operator">:</span> Component</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">/* 获取 data */</span>
  <span class="token keyword">let</span> data <span class="token operator">=</span> vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>data
  data <span class="token operator">=</span> vm<span class="token punctuation">.</span>_data <span class="token operator">=</span> <span class="token keyword">typeof</span> data <span class="token operator">===</span> <span class="token string">'function'</span>
    <span class="token operator">?</span> <span class="token function">getData</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> vm<span class="token punctuation">)</span>
    <span class="token operator">:</span> data <span class="token operator">||</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

  <span class="token comment">/* data 是否为对象 */</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isPlainObject</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    data <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span> <span class="token operator">&amp;&amp;</span> <span class="token function">warn</span><span class="token punctuation">(</span>
      <span class="token string">'data functions should return an object:\n'</span> <span class="token operator">+</span>
      <span class="token string">'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function'</span><span class="token punctuation">,</span>
      vm
    <span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// proxy data on instance</span>
  <span class="token comment">/* 获取 props */</span>
  <span class="token keyword">const</span> keys <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>
  <span class="token keyword">const</span> props <span class="token operator">=</span> vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>props
  <span class="token keyword">let</span> i <span class="token operator">=</span> keys<span class="token punctuation">.</span>length

 	<span class="token comment">/* 遍历对象 data 的键值进行处理 */</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">/* 确保 data 的键值 key 不与 props 键值重复，props 优先*/</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>props <span class="token operator">&amp;&amp;</span> <span class="token function">hasOwn</span><span class="token punctuation">(</span>props<span class="token punctuation">,</span> keys<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span> <span class="token operator">&amp;&amp;</span> <span class="token function">warn</span><span class="token punctuation">(</span>
        <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">The data property &quot;</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>keys<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">&quot; is already declared as a prop. </span><span class="token template-punctuation string">`</span></span> <span class="token operator">+</span>
        <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Use prop default value instead.</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span>
        vm
      <span class="token punctuation">)</span>
    <span class="token comment">// 如果不是保留字段，则继续进行代理操作，将 data 上的属性代理到 vm 实例上，即实现：vm.key == vm._data.key</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isReserved</span><span class="token punctuation">(</span>keys<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">proxy</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">_data</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span> keys<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// observe data</span>
  <span class="token comment">// observe: 开始对数据进行绑定，asRootData，表示此步作为数据的最初操作，后续会进行递归 observe 从而实现对深层对象的绑定</span>
  <span class="token function">observe</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token boolean">true</span> <span class="token comment">/* asRootData */</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>






<span class="token comment">// Proxy - 负责代代理 - 通过 Object.defineProperty 实现</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">proxy</span> <span class="token punctuation">(</span><span class="token parameter">target<span class="token operator">:</span> Object<span class="token punctuation">,</span> sourceKey<span class="token operator">:</span> string<span class="token punctuation">,</span> key<span class="token operator">:</span> string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  sharedPropertyDefinition<span class="token punctuation">.</span><span class="token function-variable function">get</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">proxyGetter</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">[</span>sourceKey<span class="token punctuation">]</span><span class="token punctuation">[</span>key<span class="token punctuation">]</span>
  <span class="token punctuation">}</span>
  sharedPropertyDefinition<span class="token punctuation">.</span><span class="token function-variable function">set</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">proxySetter</span> <span class="token punctuation">(</span><span class="token parameter">val</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">[</span>sourceKey<span class="token punctuation">]</span><span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> val
  <span class="token punctuation">}</span>
  Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> sharedPropertyDefinition<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h5 id="_1-4-1-2、observe"><a href="#_1-4-1-2、observe" class="header-anchor">#</a> 1-4-1-2、observe</h5> <p>observe 作用是防止 Observer 的重复绑定</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/**
 * Attempt to create an observer instance for a value,
 * returns the new observer if successfully observed,
 * or the existing observer if the value already has one.
 */</span>
<span class="token comment">// 尝试创建一个 Observer 实例（__ob__），若成功创建 Observer 实例则返回新的 Observer 实例，若已有 Observer 实例则返回现有的 Observer 实例</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">observe</span> <span class="token punctuation">(</span><span class="token parameter">value<span class="token operator">:</span> any<span class="token punctuation">,</span> asRootData<span class="token operator">:</span> <span class="token operator">?</span>boolean</span><span class="token punctuation">)</span><span class="token operator">:</span> Observer <span class="token operator">|</span> <span class="token keyword">void</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isObject</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token punctuation">}</span>
  <span class="token keyword">let</span> ob<span class="token operator">:</span> Observer <span class="token operator">|</span> <span class="token keyword">void</span>

  <span class="token comment">// 若已有 Observer 实例则直接返回该实例，若没有则会新建一个 Observer 实例并赋值给 __ob__ 属性</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">hasOwn</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> <span class="token string">'__ob__'</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> value<span class="token punctuation">.</span>__ob__ <span class="token keyword">instanceof</span> <span class="token class-name">Observer</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    ob <span class="token operator">=</span> value<span class="token punctuation">.</span>__ob__
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>
    <span class="token comment">// 确保 value 是单纯的对象，而非函数或是Regexp等情况。*/</span>
    observerState<span class="token punctuation">.</span>shouldConvert <span class="token operator">&amp;&amp;</span>
    <span class="token operator">!</span><span class="token function">isServerRendering</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
    <span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">isPlainObject</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
    Object<span class="token punctuation">.</span><span class="token function">isExtensible</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
    <span class="token operator">!</span>value<span class="token punctuation">.</span>_isVue
  <span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ob 存放 Observer 实例/该属性的观察器，防止重复绑定</span>
    ob <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Observer</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>asRootData <span class="token operator">&amp;&amp;</span> ob<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 若为根数据则计数，后面 Observer 中的 observe 的 asRootData 均为 false 则不计数</span>
    ob<span class="token punctuation">.</span>vmCount<span class="token operator">++</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> ob
<span class="token punctuation">}</span>
</code></pre></div><h5 id="_1-4-1-3、observer"><a href="#_1-4-1-3、observer" class="header-anchor">#</a> 1-4-1-3、Observer</h5> <p>Observer 作用是遍历对象的所有属性将其进行双向绑定—walk 方法—针对数组/对象处理+赋值操作 <code>data.__ob__ = Observer 实例</code>；</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/**
 * Observer class that are attached to each observed
 * object. Once attached, the observer converts target
 * object's property keys into getter/setters that
 * collect dependencies and dispatches updates.
 */</span>
<span class="token keyword">export</span> <span class="token keyword">class</span>  <span class="token punctuation">{</span>
  value<span class="token operator">:</span> any<span class="token punctuation">;</span>
  dep<span class="token operator">:</span> Dep<span class="token punctuation">;</span>
  vmCount<span class="token operator">:</span> number<span class="token punctuation">;</span> <span class="token comment">// number of vms that has this object as root $data</span>

  <span class="token function">constructor</span> <span class="token punctuation">(</span><span class="token parameter">value<span class="token operator">:</span> any</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value
    <span class="token comment">// 含有 id &amp; subs 用于管理 watchers</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>dep <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dep</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>vmCount <span class="token operator">=</span> <span class="token number">0</span>

    <span class="token comment">// 将 Observer 实例绑定到 data 的 __ob__ 属性上，前面的 observe 方法就是检测这个属性：data.__ob__</span>
    <span class="token function">def</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> <span class="token string">'__ob__'</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span>
    
    <span class="token comment">// 若值为数组，则利用被劫持的数组方法，实现对数组操作的监听(重写push、pop、shift、unshift、splice、sort、reverse)</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 若当前浏览器支持 __proto__ 属性，则直接覆盖当前数组对象原型上的原生数组方法(直接覆盖该属性则使数组对象具有了重写后的数组方法)</span>
      <span class="token comment">// 若不支持该属性，则通过遍历 def 所有需要重写的数组方法(arrayMethods 中有调用 def，显然前者效率更高，优先使用前者)</span>
      <span class="token keyword">const</span> augment <span class="token operator">=</span> hasProto
        <span class="token operator">?</span> protoAugment  <span class="token comment">// 直接覆盖原型的方法来修改目标对象</span>
        <span class="token operator">:</span> copyAugment   <span class="token comment">// 定义（覆盖）目标对象或数组的某一个方法</span>
      <span class="token function">augment</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> arrayMethods<span class="token punctuation">,</span> arrayKeys<span class="token punctuation">)</span>
     	<span class="token comment">// 对每一个数组成员进行 observe</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">observeArray</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>
      
    <span class="token comment">// 若是对象则直接利用 walk 进行绑定</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">walk</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token comment">/**
   * Walk through each property and convert them into
   * getter/setters. This method should only be called when
   * value type is Object.
   */</span>
  <span class="token function">walk</span> <span class="token punctuation">(</span><span class="token parameter">obj<span class="token operator">:</span> Object</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> keys <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>

    <span class="token comment">// walk 方法会遍历对象的每一个属性进行 defineReactive 绑定</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> keys<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">defineReactive</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> keys<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> obj<span class="token punctuation">[</span>keys<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token comment">/**
   * Observe a list of Array items.
   */</span>
  <span class="token function">observeArray</span> <span class="token punctuation">(</span><span class="token parameter">items<span class="token operator">:</span> Array<span class="token operator">&lt;</span>any<span class="token operator">&gt;</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> l <span class="token operator">=</span> items<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> l<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">observe</span><span class="token punctuation">(</span>items<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>






<span class="token comment">// arrayMethods</span>
<span class="token comment">/*
 * not type checking this file because flow doesn't play well with
 * dynamically accessing methods on Array prototype
 */</span>

<span class="token keyword">import</span> <span class="token punctuation">{</span> def <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'../util/index'</span>

<span class="token comment">// 原生数组的原型</span>
<span class="token keyword">const</span> arrayProto <span class="token operator">=</span> <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype
<span class="token comment">// 数组对象，劫持 7 个原生数组方法</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> arrayMethods <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>arrayProto<span class="token punctuation">)</span>
<span class="token comment">/**
 * Intercept mutating methods and emit events
 */</span>
<span class="token comment">// 在保证不污染原生数组原型的情况下重写数组方法，截获数组的成员发生的变化，执行原生数组操作的同时 dep 通知关联的所有观察者进行响应式处理</span>
<span class="token punctuation">;</span><span class="token punctuation">[</span>
  <span class="token string">'push'</span><span class="token punctuation">,</span>
  <span class="token string">'pop'</span><span class="token punctuation">,</span>
  <span class="token string">'shift'</span><span class="token punctuation">,</span>
  <span class="token string">'unshift'</span><span class="token punctuation">,</span>
  <span class="token string">'splice'</span><span class="token punctuation">,</span>
  <span class="token string">'sort'</span><span class="token punctuation">,</span>
  <span class="token string">'reverse'</span>
<span class="token punctuation">]</span>
<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">method</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 缓存原生数组方法</span>
  <span class="token keyword">const</span> original <span class="token operator">=</span> arrayProto<span class="token punctuation">[</span>method<span class="token punctuation">]</span>
  <span class="token function">def</span><span class="token punctuation">(</span>arrayMethods<span class="token punctuation">,</span> method<span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token function">mutator</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// avoid leaking arguments:</span>
    <span class="token comment">// http://jsperf.com/closure-with-arguments</span>
    <span class="token keyword">let</span> i <span class="token operator">=</span> arguments<span class="token punctuation">.</span>length
    <span class="token keyword">const</span> args <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      args<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arguments<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 调用原生的数组方法执行结果</span>
    <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token function">original</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span>

		<span class="token comment">// 通过 ob 属性获取 Observer 实例</span>
    <span class="token keyword">const</span> ob <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>__ob__
    <span class="token keyword">let</span> inserted
    <span class="token keyword">switch</span> <span class="token punctuation">(</span>method<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">case</span> <span class="token string">'push'</span><span class="token operator">:</span>
        inserted <span class="token operator">=</span> args
        <span class="token keyword">break</span>
      <span class="token keyword">case</span> <span class="token string">'unshift'</span><span class="token operator">:</span>
        inserted <span class="token operator">=</span> args
        <span class="token keyword">break</span>
      <span class="token keyword">case</span> <span class="token string">'splice'</span><span class="token operator">:</span>
        inserted <span class="token operator">=</span> args<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
        <span class="token keyword">break</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 数组新插入元素需重新进行 observe</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>inserted<span class="token punctuation">)</span> ob<span class="token punctuation">.</span><span class="token function">observeArray</span><span class="token punctuation">(</span>inserted<span class="token punctuation">)</span>

    <span class="token comment">// notify change</span>
    <span class="token comment">// dep 通知所有注册的观察者进行响应式处理 </span>
    ob<span class="token punctuation">.</span>dep<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> result
    <span class="token comment">// arrayMethods 做了两件事:</span>
    <span class="token comment">// 一是通知所有注册的观察者进行响应式处理</span>
    <span class="token comment">// 二是若是添加成员的操作，需要对新成员进行 observe</span>
    <span class="token comment">// 注意：修改了数组的原生方法后，还是没法像原生数组一样直接通过数组的下标或者设置 length 来修改数组，但 Vue 提供了 $set() 及 $remove()方法弥补</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><h5 id="_1-4-1-4、definereactive"><a href="#_1-4-1-4、definereactive" class="header-anchor">#</a> 1-4-1-4、defineReactive</h5> <p>defineReactive 作用是通过 Object.defineProperty 为数据定义上 getter\setter 方法，进行依赖收集后闭包中的 Deps 会存放 Watcher 对象。触发 setter 改变数据的时候会通知 Deps 订阅者通知所有的 Watcher 观察者对象进行试图的更新；</p> <ul><li>补充：defineReactive 接收整一个 data 对象，并每一个 key 与与之对应的 value</li> <li>补充：关键理解 Dep，每一个 key 都有自己的 Dep 对象实例，此实例在 getSet 使用；</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/**
 * Define a reactive property on an Object.
 */</span>
<span class="token comment">// defineReactive(obj, keys[i], obj[keys[i]])</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">defineReactive</span> <span class="token punctuation">(</span>
  <span class="token parameter">obj<span class="token operator">:</span> Object<span class="token punctuation">,</span>
  key<span class="token operator">:</span> string<span class="token punctuation">,</span>
  val<span class="token operator">:</span> any<span class="token punctuation">,</span>
  customSetter<span class="token operator">?</span><span class="token operator">:</span> Function</span>
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 获取 Dep 实例</span>
  <span class="token comment">// 关键理解 Dep，每一个 key 都有自己的 Dep 对象实例，此实例在 getSet 使用</span>
  <span class="token keyword">const</span> dep <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dep</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

  <span class="token keyword">const</span> property <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">getOwnPropertyDescriptor</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>property <span class="token operator">&amp;&amp;</span> property<span class="token punctuation">.</span>configurable <span class="token operator">===</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span>
  <span class="token punctuation">}</span>
	<span class="token comment">// 若先前该对象已预设 getter 或 setter 函数则将其取出，并在新定义的 getter/setter 中执行，从而避免发生覆盖 </span>
  <span class="token keyword">const</span> getter <span class="token operator">=</span> property <span class="token operator">&amp;&amp;</span> property<span class="token punctuation">.</span>get
  <span class="token keyword">const</span> setter <span class="token operator">=</span> property <span class="token operator">&amp;&amp;</span> property<span class="token punctuation">.</span>set

  <span class="token comment">// 将当前键值进行 observe 并获取其返回值 new Observer 实例</span>
  <span class="token comment">// 注意：只在 val 为对象时才如此: observe: if (!isObject(value)) { return }</span>
  <span class="token comment">// 注意：new Observer 实例化时，执行了 walk 方法，即对 val 的子属性进行 defineReactive，并实例了一个 dep = new Dep</span>
  <span class="token keyword">let</span> childOb <span class="token operator">=</span> <span class="token function">observe</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span>
  
  Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    enumerable<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    configurable<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token function-variable function">get</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token function">reactiveGetter</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 执行原本对象拥有的 getter 方法</span>
      <span class="token keyword">const</span> value <span class="token operator">=</span> getter <span class="token operator">?</span> <span class="token function">getter</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token operator">:</span> val
      
      <span class="token comment">// 1、执行 new Vue 时，进行 data 代理，data 下的属性的绑定 Observer，此时 Dep.target 也即 Watcher 仍为被实例化，为 undefined</span>
      <span class="token comment">// 2、随后进行 vue.mount 时，执行了 new Watcher...，此时 Dep.target 不为 undefined，也就在此时进行依赖的收集</span>
      <span class="token comment">// 3、Dep.target 是全局 watcher 对象</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>Dep<span class="token punctuation">.</span>target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 进行依赖收集 - 通过闭包传递 dep/watcher 对象</span>
        <span class="token comment">// 即 Dep.target.addDep(this/dep) -&gt; Watcher.addDep(this/dep) -&gt; dep.addSub(this/watcher) -&gt; this/dep.subs.push(watcher)</span>
        <span class="token comment">// 通过闭包获取必要参数：watcher 想要 dep，dep 想要 watcher</span>
        dep<span class="token punctuation">.</span><span class="token function">depend</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        
        <span class="token comment">// 子对象也进行依赖收集，实际就是将同一个 watcher 观察者实例放进了两 dep.subs 中，一个是正在本身闭包中的 dep.subs，另一个是子元素的 dep.subs</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>childOb<span class="token punctuation">)</span> <span class="token punctuation">{</span> childOb<span class="token punctuation">.</span>dep<span class="token punctuation">.</span><span class="token function">depend</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
        
        <span class="token comment">// 数组类型则对每一成员进行依赖收集，若数组的成员还是数组，则递归处理</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">dependArray</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">return</span> value
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    
    
    <span class="token function-variable function">set</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token function">reactiveSetter</span> <span class="token punctuation">(</span><span class="token parameter">newVal</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// getter 方法获取当前值</span>
      <span class="token comment">// 并与新值进行比较，一致则不需要执行下面的操作</span>
      <span class="token keyword">const</span> value <span class="token operator">=</span> getter <span class="token operator">?</span> <span class="token function">getter</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token operator">:</span> val
      <span class="token comment">/* eslint-disable no-self-compare */</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>newVal <span class="token operator">===</span> value <span class="token operator">||</span> <span class="token punctuation">(</span>newVal <span class="token operator">!==</span> newVal <span class="token operator">&amp;&amp;</span> value <span class="token operator">!==</span> value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token punctuation">}</span>
      
 
      <span class="token comment">/* eslint-enable no-self-compare */</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span> <span class="token operator">&amp;&amp;</span> customSetter<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">customSetter</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
      
      <span class="token comment">// 若原本对象拥有 setter 方法则执行</span>
      val <span class="token operator">=</span> setter <span class="token operator">?</span> <span class="token function">setter</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> newVal<span class="token punctuation">)</span> <span class="token operator">:</span> newVal

      <span class="token comment">// 新值需要重新进行 observe，保证数据响应式</span>
      childOb <span class="token operator">=</span> <span class="token function">observe</span><span class="token punctuation">(</span>newVal<span class="token punctuation">)</span>

      <span class="token comment">// dep 对象通知所有的观察者</span>
      <span class="token comment">// 即 subs[i].update() -&gt; watcher.run()</span>
      dep<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h5 id="_1-4-1-5、dep"><a href="#_1-4-1-5、dep" class="header-anchor">#</a> 1-4-1-5、Dep</h5> <p>Dep 是一个发布者，可订阅多个观察者，依赖收集之后，Deps中会存在一或多个 Watcher 对象，在数据变更时通知所有 Watcher；</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/**
 * A dep is an observable that can have multiple
 * directives subscribing to it.
 */</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">class</span> <span class="token class-name">Dep</span> <span class="token punctuation">{</span>
  <span class="token keyword">static</span> target<span class="token operator">:</span> <span class="token operator">?</span>Watcher<span class="token punctuation">;</span>
  id<span class="token operator">:</span> number<span class="token punctuation">;</span>
  subs<span class="token operator">:</span> Array<span class="token operator">&lt;</span>Watcher<span class="token operator">&gt;</span><span class="token punctuation">;</span>

  <span class="token function">constructor</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> uid<span class="token operator">++</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>subs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 添加一个观察者对象</span>
  <span class="token function">addSub</span> <span class="token punctuation">(</span><span class="token parameter">sub<span class="token operator">:</span> Watcher</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>subs<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>sub<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 移除一个观察者对象</span>
  <span class="token function">removeSub</span> <span class="token punctuation">(</span><span class="token parameter">sub<span class="token operator">:</span> Watcher</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>subs<span class="token punctuation">,</span> sub<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 依赖收集，当存在 Dep.target 时添加观察者对象</span>
  <span class="token function">depend</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>Dep<span class="token punctuation">.</span>target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// Watcher.addDep</span>
      Dep<span class="token punctuation">.</span>target<span class="token punctuation">.</span><span class="token function">addDep</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 通知所有订阅者</span>
  <span class="token function">notify</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// stabilize the subscriber list first</span>
    <span class="token keyword">const</span> subs <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>subs<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> l <span class="token operator">=</span> subs<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> l<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// Watcher.update()</span>
      subs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// the current target watcher being evaluated.</span>
<span class="token comment">// this is globally unique because there could be only one</span>
<span class="token comment">// watcher being evaluated at any time.</span>
Dep<span class="token punctuation">.</span>target <span class="token operator">=</span> <span class="token keyword">null</span>
<span class="token comment">// 依赖收集完需要将 Dep.target 设为 null，防止后面重复添加依赖</span>
</code></pre></div><h5 id="_1-4-1-6、watcher"><a href="#_1-4-1-6、watcher" class="header-anchor">#</a> 1-4-1-6、Watcher</h5> <p>Watcher 是一个观察者对象，依赖收集后 Watcher 对象会被保存在 Deps 中，数据变动时 Deps 会通知 Watcher 实例，然后由实例回调进行视图更新；</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">class</span> <span class="token class-name">Watcher</span> <span class="token punctuation">{</span>
  vm<span class="token operator">:</span> Component<span class="token punctuation">;</span>
  expression<span class="token operator">:</span> string<span class="token punctuation">;</span>
  cb<span class="token operator">:</span> Function<span class="token punctuation">;</span>
  id<span class="token operator">:</span> number<span class="token punctuation">;</span>
  deep<span class="token operator">:</span> boolean<span class="token punctuation">;</span>
  user<span class="token operator">:</span> boolean<span class="token punctuation">;</span>
  lazy<span class="token operator">:</span> boolean<span class="token punctuation">;</span>
  sync<span class="token operator">:</span> boolean<span class="token punctuation">;</span>
  dirty<span class="token operator">:</span> boolean<span class="token punctuation">;</span>
  active<span class="token operator">:</span> boolean<span class="token punctuation">;</span>
  deps<span class="token operator">:</span> Array<span class="token operator">&lt;</span>Dep<span class="token operator">&gt;</span><span class="token punctuation">;</span>
  newDeps<span class="token operator">:</span> Array<span class="token operator">&lt;</span>Dep<span class="token operator">&gt;</span><span class="token punctuation">;</span>
  depIds<span class="token operator">:</span> ISet<span class="token punctuation">;</span>
  newDepIds<span class="token operator">:</span> ISet<span class="token punctuation">;</span>
  getter<span class="token operator">:</span> Function<span class="token punctuation">;</span>
  value<span class="token operator">:</span> any<span class="token punctuation">;</span>

  <span class="token function">constructor</span> <span class="token punctuation">(</span>
    <span class="token parameter">vm<span class="token operator">:</span> Component<span class="token punctuation">,</span>
    expOrFn<span class="token operator">:</span> string <span class="token operator">|</span> Function<span class="token punctuation">,</span>
    cb<span class="token operator">:</span> Function<span class="token punctuation">,</span>
    options<span class="token operator">?</span><span class="token operator">:</span> Object</span>
  <span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>vm <span class="token operator">=</span> vm
    <span class="token comment">// watchers 存放订阅者实例</span>
    vm<span class="token punctuation">.</span>_watchers<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
    <span class="token comment">// options</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>options<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>deep <span class="token operator">=</span> <span class="token operator">!</span><span class="token operator">!</span>options<span class="token punctuation">.</span>deep
      <span class="token keyword">this</span><span class="token punctuation">.</span>user <span class="token operator">=</span> <span class="token operator">!</span><span class="token operator">!</span>options<span class="token punctuation">.</span>user
      <span class="token keyword">this</span><span class="token punctuation">.</span>lazy <span class="token operator">=</span> <span class="token operator">!</span><span class="token operator">!</span>options<span class="token punctuation">.</span>lazy
      <span class="token keyword">this</span><span class="token punctuation">.</span>sync <span class="token operator">=</span> <span class="token operator">!</span><span class="token operator">!</span>options<span class="token punctuation">.</span>sync
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>deep <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>user <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lazy <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>sync <span class="token operator">=</span> <span class="token boolean">false</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>cb <span class="token operator">=</span> cb
    <span class="token comment">// uid for batching</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> <span class="token operator">++</span>uid
    <span class="token keyword">this</span><span class="token punctuation">.</span>active <span class="token operator">=</span> <span class="token boolean">true</span>
    <span class="token comment">// for lazy watchers</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>dirty <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lazy 
    <span class="token comment">// Note</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>deps <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>newDeps <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>depIds <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>newDepIds <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>expression <span class="token operator">=</span> process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span>
      <span class="token operator">?</span> expOrFn<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token operator">:</span> <span class="token string">''</span>
    <span class="token comment">// parse expression for getter</span>
    <span class="token comment">// 将表达式 expOrFn 解析成 getter</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> expOrFn <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>getter <span class="token operator">=</span> expOrFn
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>getter <span class="token operator">=</span> <span class="token function">parsePath</span><span class="token punctuation">(</span>expOrFn<span class="token punctuation">)</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>getter<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">getter</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
        process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span> <span class="token operator">&amp;&amp;</span> <span class="token function">warn</span><span class="token punctuation">(</span>
          <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Failed watching path: &quot;</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>expOrFn<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">&quot; </span><span class="token template-punctuation string">`</span></span> <span class="token operator">+</span>
          <span class="token string">'Watcher only accepts simple dot-delimited paths. '</span> <span class="token operator">+</span>
          <span class="token string">'For full control, use a function instead.'</span><span class="token punctuation">,</span>
          vm
        <span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lazy
      <span class="token operator">?</span> <span class="token keyword">undefined</span>
      <span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token comment">/**
   * Evaluate the getter, and re-collect dependencies.
   */</span>
   <span class="token comment">// 获得 getter 的值并且重新进行依赖收集</span>
  <span class="token function">get</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 将自身 watcher 观察者实例设置给 Dep.target，用以依赖收集</span>
    <span class="token function">pushTarget</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
    <span class="token keyword">let</span> value
    <span class="token keyword">const</span> vm <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>vm

		<span class="token comment">// 执行了 getter 操作，看似执行了渲染操作，其实是执行了依赖收集; 在将 Dep.target 设置为自生观察者实例以后，执行 getter 操作;</span>
    <span class="token comment">// 比如: data 中可能有 a、b、c三个数据，getter 渲染需要依赖 a &amp; c，则在执行 getter 时就会触发 a &amp; c 两个数据的 getter 函数，在 getter 函数中即可判断 Dep.target是否存在然后完成依赖收集，将该观察者对象放入闭包中的 Dep 的 subs 中去。</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>user<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">try</span> <span class="token punctuation">{</span>
        value <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getter</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> vm<span class="token punctuation">)</span>
      <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">handleError</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> vm<span class="token punctuation">,</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">getter for watcher &quot;</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>expression<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">&quot;</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      value <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getter</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> vm<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// &quot;touch&quot; every property so they are all tracked as</span>
    <span class="token comment">// dependencies for deep watching</span>
    <span class="token comment">// 如果存在 deep，则触发每个深层对象的依赖，追踪其变化</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>deep<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 递归每一个对象或者数组，触发它们的 getter，使得对象或数组的每一个成员都被依赖收集，形成一个 &quot;深(deep)&quot; 依赖关系</span>
      <span class="token function">traverse</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 将观察者实例从 target 栈中取出并设置给 Dep.target</span>
    <span class="token function">popTarget</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">cleanupDeps</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> value
  <span class="token punctuation">}</span>

  <span class="token comment">/**
   * Add a dependency to this directive.
   */</span>
   <span class="token comment">// 添加一个依赖关系到 Deps 集合中</span>
  <span class="token function">addDep</span> <span class="token punctuation">(</span><span class="token parameter">dep<span class="token operator">:</span> Dep</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> id <span class="token operator">=</span> dep<span class="token punctuation">.</span>id
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>newDepIds<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>newDepIds<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>newDeps<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>dep<span class="token punctuation">)</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>depIds<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        dep<span class="token punctuation">.</span><span class="token function">addSub</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token comment">/**
   * Clean up for dependency collection.
   */</span>
   <span class="token comment">// 清理依赖收集</span>
  <span class="token function">cleanupDeps</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 移除所有观察者对象</span>
    <span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>deps<span class="token punctuation">.</span>length
    <span class="token keyword">while</span> <span class="token punctuation">(</span>i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> dep <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>deps<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>newDepIds<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>dep<span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        dep<span class="token punctuation">.</span><span class="token function">removeSub</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">let</span> tmp <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>depIds
    <span class="token keyword">this</span><span class="token punctuation">.</span>depIds <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>newDepIds
    <span class="token keyword">this</span><span class="token punctuation">.</span>newDepIds <span class="token operator">=</span> tmp
    <span class="token keyword">this</span><span class="token punctuation">.</span>newDepIds<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    tmp <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>deps
    <span class="token keyword">this</span><span class="token punctuation">.</span>deps <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>newDeps
    <span class="token keyword">this</span><span class="token punctuation">.</span>newDeps <span class="token operator">=</span> tmp
    <span class="token keyword">this</span><span class="token punctuation">.</span>newDeps<span class="token punctuation">.</span>length <span class="token operator">=</span> <span class="token number">0</span>
  <span class="token punctuation">}</span>

  <span class="token comment">/**
   * Subscriber interface.
   * Will be called when a dependency changes.
   */</span>
  <span class="token comment">// 调度者接口，当依赖发生改变的时候进行回调</span>
  <span class="token function">update</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">/* istanbul ignore else */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>lazy<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>dirty <span class="token operator">=</span> <span class="token boolean">true</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>sync<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 同步则执行 run 直接渲染视图</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token comment">// 异步推送到观察者队列中，由调度者调用</span>
      <span class="token function">queueWatcher</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token comment">/**
   * Scheduler job interface.
   * Will be called by the scheduler.
   */</span>
	<span class="token comment">// 调度者工作接口，将被调度者回调</span>
  <span class="token function">run</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>active<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> value <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>
        value <span class="token operator">!==</span> <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">||</span>
        <span class="token comment">// Deep watchers and watchers on Object/Arrays should fire even</span>
        <span class="token comment">// when the value is the same, because the value may</span>
        <span class="token comment">// have mutated.</span>
        <span class="token comment">// 即便值相同，拥有 Deep 属性的观察者以及在对象／数组上的观察者应该被触发更新，因它们的值可能发生改变。</span>
        <span class="token function">isObject</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token operator">||</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>deep
      <span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// set new value</span>
        <span class="token keyword">const</span> oldValue <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>value
        <span class="token comment">// 设置新的值</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value

        <span class="token comment">// 触发回调渲染视图</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>user<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">cb</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>vm<span class="token punctuation">,</span> value<span class="token punctuation">,</span> oldValue<span class="token punctuation">)</span>
          <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">handleError</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>vm<span class="token punctuation">,</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">callback for watcher &quot;</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>expression<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">&quot;</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
          <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
          <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">cb</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>vm<span class="token punctuation">,</span> value<span class="token punctuation">,</span> oldValue<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token comment">/**
   * Evaluate the value of the watcher.
   * This only gets called for lazy watchers.
   */</span>
   <span class="token comment">/*获取观察者的值*/</span>
  <span class="token function">evaluate</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>dirty <span class="token operator">=</span> <span class="token boolean">false</span>
  <span class="token punctuation">}</span>

  <span class="token comment">/**
   * Depend on all deps collected by this watcher.
   */</span>
  <span class="token comment">// 收集该 watcher 的所有 deps 依赖</span>
  <span class="token function">depend</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>deps<span class="token punctuation">.</span>length
    <span class="token keyword">while</span> <span class="token punctuation">(</span>i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>deps<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">depend</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token comment">/**
   * Remove self from all dependencies' subscriber list.
   */</span>
  <span class="token comment">// 将自身从所有依赖收集订阅列表删除</span>
  <span class="token function">teardown</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>active<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// remove self from vm's watcher list</span>
      <span class="token comment">// this is a somewhat expensive operation so we skip it</span>
      <span class="token comment">// if the vm is being destroyed.</span>
      <span class="token comment">/*从vm实例的观察者列表中将自身移除，由于该操作比较耗费资源，所以如果vm实例正在被销毁则跳过该步骤。*/</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>vm<span class="token punctuation">.</span>_isBeingDestroyed<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>vm<span class="token punctuation">.</span>_watchers<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>deps<span class="token punctuation">.</span>length
      <span class="token keyword">while</span> <span class="token punctuation">(</span>i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>deps<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">removeSub</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>active <span class="token operator">=</span> <span class="token boolean">false</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h5 id="_1-4-1-7、dom-diff"><a href="#_1-4-1-7、dom-diff" class="header-anchor">#</a> 1-4-1-7、DOM Diff</h5> <h5 id="_1-4-1-7-1、real-dom"><a href="#_1-4-1-7-1、real-dom" class="header-anchor">#</a> 1-4-1-7-1、Real DOM</h5> <p><code>webkit</code> 渲染引擎工作流程图：</p> <img src="/Image/Frame/Vue/32.png" style="zoom:50%;"> <p>所有的浏览器渲染引擎工作流程大致分为5步：创建  <code>DOM</code> 树 —&gt; 创建 <code>Style Rules</code> -&gt; 构建 <code>Render</code> 树 —&gt; 布局 <code>Layout</code> -—&gt; 绘制 <code>Painting</code>：</p> <ul><li>第一步，构建 DOM 树：用 HTML 分析器，分析 HTML 元素，构建一棵 DOM 树；</li> <li>第二步，生成样式表：用 CSS 分析器，分析 CSS 文件和元素上的 inline 样式，生成页面的样式表；</li> <li>第三步，构建 Render 树：将 DOM 树和样式表关联起来，构建一棵 Render 树（Attachment）。每个 DOM 节点都有 attach 方法，接受样式信息，返回一个 render 对象（又名 renderer），这些 render 对象最终会被构建成一棵 Render 树；</li> <li>第四步，确定节点坐标：根据 Render 树结构，为每个 Render 树上的节点确定一个在显示屏上出现的精确坐标；</li> <li>第五步，绘制页面：根据 Render 树和节点显示坐标，然后调用每个节点的 paint 方法，将它们绘制出来。
<ul><li>注意：DOM 树的构建是文档加载完成开始的？
<ul><li>构建 <code>DOM</code> 树是一个渐进过程，为达到更好的用户体验，渲染引擎会尽快将内容显示在屏幕上，它不必等到整个 <code>HTML</code> 文档解析完成之后才开始构建 <code>render</code> 树和布局；</li></ul></li> <li>注意：Render 树是 <code>DOM</code> 树和 <code>CSS</code> 样式表构建完毕后才开始构建的？
<ul><li>这三个过程在实际进行的时候并不是完全独立的，而是会有交叉，会一边加载，一边解析，以及一边渲染。</li></ul></li> <li>注意：CSS 的解析注意点？
<ul><li><code>CSS</code> 的解析是从右往左逆向解析的，嵌套标签越多，解析越慢；</li></ul></li> <li>注意：JS 操作真实 <code>DOM</code> 的代价？
<ul><li>用传统的开发模式，原生 <code>JS</code> 或 <code>JQ</code> 操作 <code>DOM</code> 时，浏览器会从构建 DOM 树开始从头到尾执行一遍流程；</li> <li>比如：在一次操作中，需要更新 10 个 <code>DOM</code> 节点，浏览器收到第一个 <code>DOM</code> 请求后并不知道还有 9 次更新操作，因此会马上执行流程，最终执行10 次</li> <li>第一次计算完，紧接着下一个 <code>DOM</code> 更新请求，这个节点的坐标值就变了，前一次计算为无用功；计算 <code>DOM</code> 节点坐标值等都是白白浪费的性能。即使计算机硬件一直在迭代更新，操作 <code>DOM</code> 的代价仍旧是昂贵的，频繁操作还是会出现页面卡顿，影响用户体验；</li></ul></li></ul></li></ul> <h5 id="_1-4-1-7-2、virtual-dom"><a href="#_1-4-1-7-2、virtual-dom" class="header-anchor">#</a> 1-4-1-7-2、Virtual DOM</h5> <p><strong><u><em>虚拟DOM本质</em></u></strong>：是用一原生的 JS 对象去描述一个 DOM 节点；对真实 DOM 的一层抽象；</p> <p>在浏览器中 DOM 的操作昂贵，而频繁操作 DOM，更会产生性能问题，虚拟 DOM 的这层抽象，能将多次变化尽可能地一次性更新到真实 DOM 中；</p> <p>此外虚拟 DOM 能很好的跨平台，因为其本质只是一个 JS 对象；<code>Vue2.x</code>中的虚拟<code>DOM</code>主要是借鉴了<code>snabbdom.js</code>，<code>Vue3</code>中借鉴<code>inferno.js</code>算法进行优化</p> <p><strong><u><em>虚拟 DOM 诞生意义</em></u></strong>：就是为了解决浏览器性能问题而被设计出来；</p> <ul><li>比如，若一次操作中有 10 次更新 <code>DOM</code> 的动作，虚拟 <code>DOM</code> 不会立即操作 <code>DOM</code>，而是将这 10 次更新的 <code>diff</code> 内容保存到本地一个 <code>JS</code> 对象中，最终将这个 <code>JS</code> 对象一次性 <code>attch</code> 到 <code>DOM</code> 树上，再进行后续操作，避免大量无谓的计算量；</li> <li>所以，用 <code>JS</code> 对象模拟 <code>DOM</code> 节点的好处是，页面更新可先全部反映在 <code>JS</code> 对象(虚拟 <code>DOM</code> )上，操作内存中的 <code>JS</code> 对象的速度显然要更快，等更新完成后，再将最终的 <code>JS</code> 对象映射成真实的 <code>DOM</code>，交由浏览器去绘制；</li></ul> <p><strong><u><em>虚拟 DOM 算法实现：</em></u></strong></p> <ul><li><p><strong><u><em>1、用 JS 对象模拟 DOM 树</em></u></strong>，并渲染用此对象表示的 DOM 树：</p> <ul><li><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 伪码</span>
<span class="token keyword">var</span> el <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&quot;./element.js&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> ul <span class="token operator">=</span> <span class="token function">el</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span><span class="token punctuation">{</span>id<span class="token operator">:</span><span class="token string">'virtual-dom'</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">[</span>
  <span class="token function">el</span><span class="token punctuation">(</span><span class="token string">'p'</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token string">'Virtual DOM'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token function">el</span><span class="token punctuation">(</span><span class="token string">'ul'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> id<span class="token operator">:</span> <span class="token string">'list'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>
	<span class="token function">el</span><span class="token punctuation">(</span><span class="token string">'li'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token keyword">class</span><span class="token operator">:</span> <span class="token string">'item'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'Item 1'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	<span class="token function">el</span><span class="token punctuation">(</span><span class="token string">'li'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token keyword">class</span><span class="token operator">:</span> <span class="token string">'item'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'Item 2'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	<span class="token function">el</span><span class="token punctuation">(</span><span class="token string">'li'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token keyword">class</span><span class="token operator">:</span> <span class="token string">'item'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'Item 3'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
  <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token function">el</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token string">'Hello World'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">]</span><span class="token punctuation">)</span> 

<span class="token comment">// 伪码</span>
<span class="token class-name">Element</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">render</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> el <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>tagName<span class="token punctuation">)</span>
    <span class="token keyword">var</span> props <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props
    <span class="token comment">// 设置节点的 DOM 属性</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> propName <span class="token keyword">in</span> props<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> propValue <span class="token operator">=</span> props<span class="token punctuation">[</span>propName<span class="token punctuation">]</span>
        el<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span>propName<span class="token punctuation">,</span> propValue<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">var</span> children <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>children <span class="token operator">||</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    children<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">child</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> childEl <span class="token operator">=</span> <span class="token punctuation">(</span>child <span class="token keyword">instanceof</span> <span class="token class-name">Element</span><span class="token punctuation">)</span>
            <span class="token operator">?</span> child<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 若子节点也是虚拟DOM，则递归构建</span>
            <span class="token operator">:</span> document<span class="token punctuation">.</span><span class="token function">createTextNode</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span> <span class="token comment">// 若字符串，只构建文本节点</span>
        el<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>childEl<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> el
<span class="token punctuation">}</span> 
</code></pre></div></li></ul></li> <li><p><strong><u><em>2、通过 Diff 算法比较两棵虚拟 DOM 树差异</em></u></strong></p> <ul><li><p>注意：完全比较复杂度会达到 O(n^3)，而前端中很少会跨越层级地移动 <code>DOM</code> 元素，故 <code>Virtual DOM</code> 只对同一层级元素进行对比，可将复杂度降至 O(n)</p></li> <li><p><strong><u><em>首先</em></u></strong>，深度优先遍历，记录差异：</p> <ul><li><p>对新旧两棵树进行一个深度优先的遍历，这样每个节点都会有一个唯一的标记；</p></li> <li><p>在深度优先遍历的时候，每遍历到一个节点就把该节点和新的的树进行对比；若有差异的话就记录到一个对象中</p></li> <li><img src="/Image/Frame/Vue/33.png" align="" style="zoom:50%;"></li> <li><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// diff 函数，对比两棵树</span>
<span class="token keyword">function</span> <span class="token function">diff</span><span class="token punctuation">(</span><span class="token parameter">oldTree<span class="token punctuation">,</span> newTree</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> index <span class="token operator">=</span> <span class="token number">0</span> <span class="token comment">// 当前节点的标志</span>
  <span class="token keyword">var</span> patches <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// 用来记录每个节点差异的对象</span>
  <span class="token function">dfsWalk</span><span class="token punctuation">(</span>oldTree<span class="token punctuation">,</span> newTree<span class="token punctuation">,</span> index<span class="token punctuation">,</span> patches<span class="token punctuation">)</span>
  <span class="token keyword">return</span> patches
<span class="token punctuation">}</span>

<span class="token comment">// 对两棵树进行深度优先遍历</span>
<span class="token keyword">function</span> <span class="token function">dfsWalk</span><span class="token punctuation">(</span><span class="token parameter">oldNode<span class="token punctuation">,</span> newNode<span class="token punctuation">,</span> index<span class="token punctuation">,</span> patches</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> currentPatch <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token punctuation">(</span>oldNode<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">&quot;string&quot;</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">typeof</span> <span class="token punctuation">(</span>newNode<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">&quot;string&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 文本内容改变</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>newNode <span class="token operator">!==</span> oldNode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      currentPatch<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span> type<span class="token operator">:</span> patch<span class="token punctuation">.</span><span class="token constant">TEXT</span><span class="token punctuation">,</span> content<span class="token operator">:</span> newNode <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>newNode<span class="token operator">!=</span><span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> oldNode<span class="token punctuation">.</span>tagName <span class="token operator">===</span> newNode<span class="token punctuation">.</span>tagName <span class="token operator">&amp;&amp;</span> oldNode<span class="token punctuation">.</span>key <span class="token operator">===</span> newNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 节点相同，比较属性</span>
    <span class="token keyword">var</span> propsPatches <span class="token operator">=</span> <span class="token function">diffProps</span><span class="token punctuation">(</span>oldNode<span class="token punctuation">,</span> newNode<span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>propsPatches<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      currentPatch<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span> type<span class="token operator">:</span> patch<span class="token punctuation">.</span><span class="token constant">PROPS</span><span class="token punctuation">,</span> props<span class="token operator">:</span> propsPatches <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 比较子节点，如果子节点有'ignore'属性，则不需要比较</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isIgnoreChildren</span><span class="token punctuation">(</span>newNode<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">diffChildren</span><span class="token punctuation">(</span>
        oldNode<span class="token punctuation">.</span>children<span class="token punctuation">,</span>
        newNode<span class="token punctuation">.</span>children<span class="token punctuation">,</span>
        index<span class="token punctuation">,</span>
        patches<span class="token punctuation">,</span>
        currentPatch
      <span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>newNode <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">// 新节点和旧节点不同，用 replace 替换</span>
    currentPatch<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span> type<span class="token operator">:</span> patch<span class="token punctuation">.</span><span class="token constant">REPLACE</span><span class="token punctuation">,</span> node<span class="token operator">:</span> newNode <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>currentPatch<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    patches<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> currentPatch
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span> 
</code></pre></div></li></ul></li> <li><p><strong><u><em>然后</em></u></strong>，差异类型：DOM 操作导致的差异类型包括以下几种：</p> <ul><li><p>节点替换：节点改变了，例如将上面的 <code>div</code> 换成 <code>h1</code>;</p></li> <li><p>顺序互换：移动、删除、新增子节点，例如上面 <code>div</code> 的子节点，把 <code>p</code> 和 <code>ul</code> 顺序互换；</p></li> <li><p>属性更改：修改了节点的属性，例如把上面 <code>li</code> 的 <code>class</code> 样式类删除；</p></li> <li><p>文本改变：改变文本节点的文本内容，例如将上面 <code>p</code> 节点的文本内容更改为 “<code>Real Dom</code>”；</p></li> <li><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token constant">REPLACE</span> <span class="token operator">=</span> <span class="token number">0</span> <span class="token comment">// 替换原先的节点</span>
<span class="token keyword">var</span> <span class="token constant">REORDER</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token comment">// 重新排序</span>
<span class="token keyword">var</span> <span class="token constant">PROPS</span> <span class="token operator">=</span> <span class="token number">2</span> <span class="token comment">// 修改了节点的属性</span>
<span class="token keyword">var</span> <span class="token constant">TEXT</span> <span class="token operator">=</span> <span class="token number">3</span> <span class="token comment">// 文本内容改变 </span>
</code></pre></div></li></ul></li> <li><p><strong><u><em>然后</em></u></strong>，列表对比算法</p> <ul><li>比如：<code>p, ul, div</code> 顺序换成了 <code>div, p, ul</code>；若按同层级进行顺序对比，则都会被替换掉；这样 DOM 开销非常大；而实际上是不需要替换的节点，而只需要经过节点移动就可达到，即只需知道怎么进行移动；</li> <li>解决：问题可抽象为：字符串的最小编辑距离问题 (<code>Edition Distance</code>)，最常见解决方法是： <code>Levenshtein Distance</code> ；其是一个度量两个字符序列之间差异的字符串度量标准，两个单词间的 <code>Levenshtein Distance</code> 是将一个单词转换为另一个单词所需的单字符编辑(插入、删除或替换)的最小数量。<code>Levenshtein Distance</code> 是1965 年由苏联数学家 Vladimir Levenshtein 发明；<code>Levenshtein Distance</code> 也被称为编辑距离（<code>Edit Distance</code>），通过动态规划求解，时间复杂度为 <code>O(M*N)</code>；</li> <li>比如：对于两个字符串 <code>a、b</code>，则他们的 <code>Levenshtein Distance</code> 为：
<ul><li><img src="/Image/Frame/Vue/35.png" align="" style="zoom:50%;"></li></ul></li> <li>示例：字符串 <code>a</code> 和 <code>b</code>，<code>a=“abcde” ，b=“cabef”</code>，根据上面给出的计算公式，则他们的 <code>Levenshtein Distance</code> 的计算过程如下：
<ul><li><img src="/Image/Frame/Vue/34.png" align="" style="zoom:50%;"></li></ul></li></ul></li> <li><p><strong><u><em>最后</em></u></strong>，实例输出</p> <ul><li><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 伪码</span>
<span class="token comment">// 其中 ul1 表示原有的虚拟 DOM 树，ul2 表示改变后的虚拟 DOM 树</span>
<span class="token keyword">var</span> ul1 <span class="token operator">=</span> <span class="token function">el</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span><span class="token punctuation">{</span>id<span class="token operator">:</span><span class="token string">'virtual-dom'</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">[</span>
  <span class="token function">el</span><span class="token punctuation">(</span><span class="token string">'p'</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token string">'Virtual DOM'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token function">el</span><span class="token punctuation">(</span><span class="token string">'ul'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> id<span class="token operator">:</span> <span class="token string">'list'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>
	<span class="token function">el</span><span class="token punctuation">(</span><span class="token string">'li'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token keyword">class</span><span class="token operator">:</span> <span class="token string">'item'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'Item 1'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	<span class="token function">el</span><span class="token punctuation">(</span><span class="token string">'li'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token keyword">class</span><span class="token operator">:</span> <span class="token string">'item'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'Item 2'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	<span class="token function">el</span><span class="token punctuation">(</span><span class="token string">'li'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token keyword">class</span><span class="token operator">:</span> <span class="token string">'item'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'Item 3'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
  <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token function">el</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token string">'Hello World'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">]</span><span class="token punctuation">)</span> 
<span class="token keyword">var</span> ul2 <span class="token operator">=</span> <span class="token function">el</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span><span class="token punctuation">{</span>id<span class="token operator">:</span><span class="token string">'virtual-dom'</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">[</span>
  <span class="token function">el</span><span class="token punctuation">(</span><span class="token string">'p'</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token string">'Virtual DOM'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token function">el</span><span class="token punctuation">(</span><span class="token string">'ul'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> id<span class="token operator">:</span> <span class="token string">'list'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>
	<span class="token function">el</span><span class="token punctuation">(</span><span class="token string">'li'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token keyword">class</span><span class="token operator">:</span> <span class="token string">'item'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'Item 21'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	<span class="token function">el</span><span class="token punctuation">(</span><span class="token string">'li'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token keyword">class</span><span class="token operator">:</span> <span class="token string">'item'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'Item 23'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
  <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token function">el</span><span class="token punctuation">(</span><span class="token string">'p'</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token string">'Hello World'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">]</span><span class="token punctuation">)</span> 
<span class="token keyword">var</span> patches <span class="token operator">=</span> <span class="token function">diff</span><span class="token punctuation">(</span>ul1<span class="token punctuation">,</span>ul2<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'patches:'</span><span class="token punctuation">,</span>patches<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><img src="/Image/Frame/Vue/36.png" align="" style="zoom:50%;"></li></ul></li></ul></li> <li><p><strong><u><em>3、通过 patch 将两个虚拟 DOM 对象的差异应用到真正的 DOM 树</em></u></strong></p> <ul><li><p>首先，深度优先遍历 DOM 树</p> <ul><li><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 伪码</span>
<span class="token keyword">function</span> <span class="token function">patch</span> <span class="token punctuation">(</span><span class="token parameter">node<span class="token punctuation">,</span> patches</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> walker <span class="token operator">=</span> <span class="token punctuation">{</span>index<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">}</span>
  <span class="token function">dfsWalk</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> walker<span class="token punctuation">,</span> patches<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">dfsWalk</span> <span class="token punctuation">(</span><span class="token parameter">node<span class="token punctuation">,</span> walker<span class="token punctuation">,</span> patches</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 从patches拿出当前节点的差异</span>
  <span class="token keyword">var</span> currentPatches <span class="token operator">=</span> patches<span class="token punctuation">[</span>walker<span class="token punctuation">.</span>index<span class="token punctuation">]</span>

  <span class="token keyword">var</span> len <span class="token operator">=</span> node<span class="token punctuation">.</span>childNodes
    <span class="token operator">?</span> node<span class="token punctuation">.</span>childNodes<span class="token punctuation">.</span>length
    <span class="token operator">:</span> <span class="token number">0</span>
  <span class="token comment">// 深度遍历子节点</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> child <span class="token operator">=</span> node<span class="token punctuation">.</span>childNodes<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
    walker<span class="token punctuation">.</span>index<span class="token operator">++</span>
    <span class="token function">dfsWalk</span><span class="token punctuation">(</span>child<span class="token punctuation">,</span> walker<span class="token punctuation">,</span> patches<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 对当前节点进行DOM操作</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>currentPatches<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">applyPatches</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> currentPatches<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span> 
</code></pre></div></li></ul></li> <li><p>然后，对原有 DOM 树进行 DOM 操作</p> <ul><li><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 伪码</span>
<span class="token keyword">function</span> <span class="token function">applyPatches</span> <span class="token punctuation">(</span><span class="token parameter">node<span class="token punctuation">,</span> currentPatches</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  currentPatches<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">currentPatch</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">switch</span> <span class="token punctuation">(</span>currentPatch<span class="token punctuation">.</span>type<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">case</span> <span class="token constant">REPLACE</span><span class="token operator">:</span>
        <span class="token keyword">var</span> newNode <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> currentPatch<span class="token punctuation">.</span>node <span class="token operator">===</span> <span class="token string">'string'</span><span class="token punctuation">)</span>
          <span class="token operator">?</span> document<span class="token punctuation">.</span><span class="token function">createTextNode</span><span class="token punctuation">(</span>currentPatch<span class="token punctuation">.</span>node<span class="token punctuation">)</span>
          <span class="token operator">:</span> currentPatch<span class="token punctuation">.</span>node<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        node<span class="token punctuation">.</span>parentNode<span class="token punctuation">.</span><span class="token function">replaceChild</span><span class="token punctuation">(</span>newNode<span class="token punctuation">,</span> node<span class="token punctuation">)</span>
        <span class="token keyword">break</span>
      <span class="token keyword">case</span> <span class="token constant">REORDER</span><span class="token operator">:</span>
        <span class="token function">reorderChildren</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> currentPatch<span class="token punctuation">.</span>moves<span class="token punctuation">)</span>
        <span class="token keyword">break</span>
      <span class="token keyword">case</span> <span class="token constant">PROPS</span><span class="token operator">:</span>
        <span class="token function">setProps</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> currentPatch<span class="token punctuation">.</span>props<span class="token punctuation">)</span>
        <span class="token keyword">break</span>
      <span class="token keyword">case</span> <span class="token constant">TEXT</span><span class="token operator">:</span>
        node<span class="token punctuation">.</span>textContent <span class="token operator">=</span> currentPatch<span class="token punctuation">.</span>content
        <span class="token keyword">break</span>
      <span class="token keyword">default</span><span class="token operator">:</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'Unknown patch type '</span> <span class="token operator">+</span> currentPatch<span class="token punctuation">.</span>type<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span> 
</code></pre></div></li></ul></li> <li><p>最后，DOM 结构改变</p></li></ul></li></ul> <h5 id="_1-4-1-7-3、vnode-created"><a href="#_1-4-1-7-3、vnode-created" class="header-anchor">#</a> 1-4-1-7-3、VNode Created</h5> <p>Vue 中，Virtual DOM 是用 VNode 这个 Class 去描述，实际上 <code>Vue.js</code> 中 <code>Virtual DOM</code> 是借鉴了一个开源库  <a href="https://github.com/snabbdom/snabbdom" target="_blank" rel="noopener noreferrer">snabbdom<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> ，然后加入自身的一些特性实现：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">class</span> <span class="token class-name">VNode</span> <span class="token punctuation">{</span>
  tag<span class="token operator">:</span> string <span class="token operator">|</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
  data<span class="token operator">:</span> VNodeData <span class="token operator">|</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
  children<span class="token operator">:</span> <span class="token operator">?</span>Array<span class="token operator">&lt;</span>VNode<span class="token operator">&gt;</span><span class="token punctuation">;</span>
  text<span class="token operator">:</span> string <span class="token operator">|</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
  elm<span class="token operator">:</span> Node <span class="token operator">|</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
  ns<span class="token operator">:</span> string <span class="token operator">|</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
  context<span class="token operator">:</span> Component <span class="token operator">|</span> <span class="token keyword">void</span><span class="token punctuation">;</span> <span class="token comment">// rendered in this component's scope</span>
  key<span class="token operator">:</span> string <span class="token operator">|</span> number <span class="token operator">|</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
  componentOptions<span class="token operator">:</span> VNodeComponentOptions <span class="token operator">|</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
  componentInstance<span class="token operator">:</span> Component <span class="token operator">|</span> <span class="token keyword">void</span><span class="token punctuation">;</span> <span class="token comment">// component instance</span>
  parent<span class="token operator">:</span> VNode <span class="token operator">|</span> <span class="token keyword">void</span><span class="token punctuation">;</span> <span class="token comment">// component placeholder node</span>

  <span class="token comment">// strictly internal</span>
  raw<span class="token operator">:</span> boolean<span class="token punctuation">;</span> <span class="token comment">// contains raw HTML? (server only)</span>
  isStatic<span class="token operator">:</span> boolean<span class="token punctuation">;</span> <span class="token comment">// hoisted static node</span>
  isRootInsert<span class="token operator">:</span> boolean<span class="token punctuation">;</span> <span class="token comment">// necessary for enter transition check</span>
  isComment<span class="token operator">:</span> boolean<span class="token punctuation">;</span> <span class="token comment">// empty comment placeholder?</span>
  isCloned<span class="token operator">:</span> boolean<span class="token punctuation">;</span> <span class="token comment">// is a cloned node?</span>
  isOnce<span class="token operator">:</span> boolean<span class="token punctuation">;</span> <span class="token comment">// is a v-once node?</span>
  asyncFactory<span class="token operator">:</span> Function <span class="token operator">|</span> <span class="token keyword">void</span><span class="token punctuation">;</span> <span class="token comment">// async component factory function</span>
  asyncMeta<span class="token operator">:</span> Object <span class="token operator">|</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
  isAsyncPlaceholder<span class="token operator">:</span> boolean<span class="token punctuation">;</span>
  ssrContext<span class="token operator">:</span> Object <span class="token operator">|</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
  fnContext<span class="token operator">:</span> Component <span class="token operator">|</span> <span class="token keyword">void</span><span class="token punctuation">;</span> <span class="token comment">// real context vm for functional nodes</span>
  fnOptions<span class="token operator">:</span> <span class="token operator">?</span>ComponentOptions<span class="token punctuation">;</span> <span class="token comment">// for SSR caching</span>
  devtoolsMeta<span class="token operator">:</span> <span class="token operator">?</span>Object<span class="token punctuation">;</span> <span class="token comment">// used to store functional render context for devtools</span>
  fnScopeId<span class="token operator">:</span> <span class="token operator">?</span>string<span class="token punctuation">;</span> <span class="token comment">// functional scope id support</span>

  <span class="token function">constructor</span> <span class="token punctuation">(</span>
    <span class="token parameter">tag<span class="token operator">?</span><span class="token operator">:</span> string<span class="token punctuation">,</span>
    data<span class="token operator">?</span><span class="token operator">:</span> VNodeData<span class="token punctuation">,</span>
    children<span class="token operator">?</span><span class="token operator">:</span> <span class="token operator">?</span>Array<span class="token operator">&lt;</span>VNode<span class="token operator">&gt;</span><span class="token punctuation">,</span>
    text<span class="token operator">?</span><span class="token operator">:</span> string<span class="token punctuation">,</span>
    elm<span class="token operator">?</span><span class="token operator">:</span> Node<span class="token punctuation">,</span>
    context<span class="token operator">?</span><span class="token operator">:</span> Component<span class="token punctuation">,</span>
    componentOptions<span class="token operator">?</span><span class="token operator">:</span> VNodeComponentOptions<span class="token punctuation">,</span>
    asyncFactory<span class="token operator">?</span><span class="token operator">:</span> Function</span>
  <span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>tag <span class="token operator">=</span> tag
    <span class="token keyword">this</span><span class="token punctuation">.</span>data <span class="token operator">=</span> data
    <span class="token keyword">this</span><span class="token punctuation">.</span>children <span class="token operator">=</span> children
    <span class="token keyword">this</span><span class="token punctuation">.</span>text <span class="token operator">=</span> text
    <span class="token keyword">this</span><span class="token punctuation">.</span>elm <span class="token operator">=</span> elm
    <span class="token keyword">this</span><span class="token punctuation">.</span>ns <span class="token operator">=</span> <span class="token keyword">undefined</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>context <span class="token operator">=</span> context
    <span class="token keyword">this</span><span class="token punctuation">.</span>fnContext <span class="token operator">=</span> <span class="token keyword">undefined</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>fnOptions <span class="token operator">=</span> <span class="token keyword">undefined</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>fnScopeId <span class="token operator">=</span> <span class="token keyword">undefined</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> data <span class="token operator">&amp;&amp;</span> data<span class="token punctuation">.</span>key
    <span class="token keyword">this</span><span class="token punctuation">.</span>componentOptions <span class="token operator">=</span> componentOptions
    <span class="token keyword">this</span><span class="token punctuation">.</span>componentInstance <span class="token operator">=</span> <span class="token keyword">undefined</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>parent <span class="token operator">=</span> <span class="token keyword">undefined</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>raw <span class="token operator">=</span> <span class="token boolean">false</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>isStatic <span class="token operator">=</span> <span class="token boolean">false</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>isRootInsert <span class="token operator">=</span> <span class="token boolean">true</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>isComment <span class="token operator">=</span> <span class="token boolean">false</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>isCloned <span class="token operator">=</span> <span class="token boolean">false</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>isOnce <span class="token operator">=</span> <span class="token boolean">false</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>asyncFactory <span class="token operator">=</span> asyncFactory
    <span class="token keyword">this</span><span class="token punctuation">.</span>asyncMeta <span class="token operator">=</span> <span class="token keyword">undefined</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>isAsyncPlaceholder <span class="token operator">=</span> <span class="token boolean">false</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li><code>text</code> 属性是文本属性；</li> <li><code>children</code> 属性是<code>vnode</code>的子节点；</li> <li><code>tag</code> 属性即这个<code>vnode</code>的标签属性；</li> <li><code>elm</code> 属性为这个<code>vnode</code>对应的真实<code>dom</code>节点；</li> <li><code>key</code> 属性是<code>vnode</code>的标记，在<code>diff</code>过程中可以提高<code>diff</code>的效率；</li> <li><code>data</code> 属性包含了最后渲染成真实<code>dom</code>节点后，节点上的<code>class</code>，<code>attribute</code>，<code>style</code>以及绑定的事件；</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 1、初始化 Vue</span>
<span class="token keyword">function</span> <span class="token function">Vue</span> <span class="token punctuation">(</span><span class="token parameter">options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span> <span class="token operator">&amp;&amp;</span>
    <span class="token operator">!</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token keyword">instanceof</span> <span class="token class-name">Vue</span><span class="token punctuation">)</span>
  <span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">warn</span><span class="token punctuation">(</span><span class="token string">'Vue is a constructor and should be called with the `new` keyword'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">_init</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// ... </span>

<span class="token comment">// 2、通过 $mount 实例方法去挂载 dom，$mount 会调用原型上的方法</span>
<span class="token class-name">Vue</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">_init</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">options<span class="token operator">?</span><span class="token operator">:</span> Object</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> vm<span class="token operator">:</span> Component <span class="token operator">=</span> <span class="token keyword">this</span>

  <span class="token comment">// ....</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>el<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'vm.$options.el:'</span><span class="token punctuation">,</span>vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>el<span class="token punctuation">)</span><span class="token punctuation">;</span>
    vm<span class="token punctuation">.</span><span class="token function">$mount</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>el<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// ... </span>

<span class="token keyword">const</span> mount <span class="token operator">=</span> <span class="token class-name">Vue</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>$mount
<span class="token class-name">Vue</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">$mount</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>
  <span class="token parameter">el<span class="token operator">?</span><span class="token operator">:</span> string <span class="token operator">|</span> Element<span class="token punctuation">,</span>
  hydrating<span class="token operator">?</span><span class="token operator">:</span> boolean</span>
<span class="token punctuation">)</span><span class="token operator">:</span> Component <span class="token punctuation">{</span>
  el <span class="token operator">=</span> el <span class="token operator">&amp;&amp;</span> <span class="token function">query</span><span class="token punctuation">(</span>el<span class="token punctuation">)</span>
  
   <span class="token comment">// ...</span>
  <span class="token keyword">return</span> <span class="token function">mount</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> el<span class="token punctuation">,</span> hydrating<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// ...</span>

<span class="token comment">// 3、$mount 方法实际上会去调用 mountComponent 方法，而 mountComponent 核心就是: </span>
<span class="token comment">// 先实例化一个渲染 Watcher，在其回调函数中会调用 updateComponent 方法，在此方法中调用 vm._render 方法先生成虚拟 Node，最终调用 vm._update 更新 DOM</span>
<span class="token class-name">Vue</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">$mount</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>
  <span class="token parameter">el<span class="token operator">?</span><span class="token operator">:</span> string <span class="token operator">|</span> Element<span class="token punctuation">,</span>
  hydrating<span class="token operator">?</span><span class="token operator">:</span> boolean</span>
<span class="token punctuation">)</span><span class="token operator">:</span> Component <span class="token punctuation">{</span>
  el <span class="token operator">=</span> el <span class="token operator">&amp;&amp;</span> inBrowser <span class="token operator">?</span> <span class="token function">query</span><span class="token punctuation">(</span>el<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">undefined</span>
  <span class="token keyword">return</span> <span class="token function">mountComponent</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> el<span class="token punctuation">,</span> hydrating<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">mountComponent</span> <span class="token punctuation">(</span>
  <span class="token parameter">vm<span class="token operator">:</span> Component<span class="token punctuation">,</span>
  el<span class="token operator">:</span> <span class="token operator">?</span>Element<span class="token punctuation">,</span>
  hydrating<span class="token operator">?</span><span class="token operator">:</span> boolean</span>
<span class="token punctuation">)</span><span class="token operator">:</span> Component <span class="token punctuation">{</span>
  vm<span class="token punctuation">.</span>$el <span class="token operator">=</span> el

  <span class="token comment">// ...</span>
  
  <span class="token keyword">let</span> updateComponent
  <span class="token comment">/* istanbul ignore if */</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span> <span class="token operator">&amp;&amp;</span> config<span class="token punctuation">.</span>performance <span class="token operator">&amp;&amp;</span> mark<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function-variable function">updateComponent</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token comment">// 生成虚拟 VNode   </span>
      <span class="token keyword">const</span> vnode <span class="token operator">=</span> vm<span class="token punctuation">.</span><span class="token function">_render</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token comment">// 更新 DOM</span>
      vm<span class="token punctuation">.</span><span class="token function">_update</span><span class="token punctuation">(</span>vnode<span class="token punctuation">,</span> hydrating<span class="token punctuation">)</span>
     
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token function-variable function">updateComponent</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      vm<span class="token punctuation">.</span><span class="token function">_update</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span><span class="token function">_render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> hydrating<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 实例化一个渲染 Watcher，在它的回调函数中会调用 updateComponent 方法  </span>
  <span class="token keyword">new</span> <span class="token class-name">Watcher</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> updateComponent<span class="token punctuation">,</span> noop<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token function">before</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>vm<span class="token punctuation">.</span>_isMounted <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>vm<span class="token punctuation">.</span>_isDestroyed<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">callHook</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token string">'beforeUpdate'</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token boolean">true</span> <span class="token comment">/* isRenderWatcher */</span><span class="token punctuation">)</span>
  hydrating <span class="token operator">=</span> <span class="token boolean">false</span>

  <span class="token keyword">return</span> vm
<span class="token punctuation">}</span>

<span class="token comment">// ...</span>

<span class="token comment">// 4、创建 VNode</span>
<span class="token comment">// Vue 的 _render 方法是实例的一个私有方法，它用来把实例渲染成一个虚拟 Node</span>
<span class="token comment">// Vue 利用 _createElement 方法创建 VNode</span>
<span class="token class-name">Vue</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">_render</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> VNode <span class="token punctuation">{</span>
  <span class="token keyword">const</span> vm<span class="token operator">:</span> Component <span class="token operator">=</span> <span class="token keyword">this</span>
  <span class="token keyword">const</span> <span class="token punctuation">{</span> render<span class="token punctuation">,</span> _parentVnode <span class="token punctuation">}</span> <span class="token operator">=</span> vm<span class="token punctuation">.</span>$options
  <span class="token keyword">let</span> vnode
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
    currentRenderingInstance <span class="token operator">=</span> vm
    <span class="token comment">// 调用 createElement 方法来返回 vnode</span>
    vnode <span class="token operator">=</span> <span class="token function">render</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>_renderProxy<span class="token punctuation">,</span> vm<span class="token punctuation">.</span>$createElement<span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">handleError</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> vm<span class="token punctuation">,</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">render</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// set parent</span>
  vnode<span class="token punctuation">.</span>parent <span class="token operator">=</span> _parentVnode
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;vnode...:&quot;</span><span class="token punctuation">,</span>vnode<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> vnode
<span class="token punctuation">}</span>

<span class="token comment">// _createElement 方法有 5 个参数</span>
<span class="token comment">// context 表示 VNode 的上下文环境，它是 Component 类型；</span>
<span class="token comment">// tag 表示标签，它可以是一个字符串，也可以是一个 Component；</span>
<span class="token comment">// data 表示 VNode 的数据，它是一个 VNodeData 类型；</span>
<span class="token comment">// children 表示当前 VNode 的子节点，它是任意类型的，需要被规范为标准的 VNode 数组；</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">_createElement</span> <span class="token punctuation">(</span>
  <span class="token parameter">context<span class="token operator">:</span> Component<span class="token punctuation">,</span>
  tag<span class="token operator">?</span><span class="token operator">:</span> string <span class="token operator">|</span> Class<span class="token operator">&lt;</span>Component<span class="token operator">&gt;</span> <span class="token operator">|</span> Function <span class="token operator">|</span> Object<span class="token punctuation">,</span>
  data<span class="token operator">?</span><span class="token operator">:</span> VNodeData<span class="token punctuation">,</span>
  children<span class="token operator">?</span><span class="token operator">:</span> any<span class="token punctuation">,</span>
  normalizationType<span class="token operator">?</span><span class="token operator">:</span> number</span>
<span class="token punctuation">)</span><span class="token operator">:</span> VNode <span class="token operator">|</span> Array<span class="token operator">&lt;</span>VNode<span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    
  <span class="token comment">// ...</span>
  
  <span class="token keyword">if</span> <span class="token punctuation">(</span>normalizationType <span class="token operator">===</span> <span class="token constant">ALWAYS_NORMALIZE</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 场景是 render 函数不是编译生成的</span>
    children <span class="token operator">=</span> <span class="token function">normalizeChildren</span><span class="token punctuation">(</span>children<span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>normalizationType <span class="token operator">===</span> <span class="token constant">SIMPLE_NORMALIZE</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 场景是 render 函数是编译生成的</span>
    children <span class="token operator">=</span> <span class="token function">simpleNormalizeChildren</span><span class="token punctuation">(</span>children<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">let</span> vnode<span class="token punctuation">,</span> ns
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> tag <span class="token operator">===</span> <span class="token string">'string'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> Ctor
    ns <span class="token operator">=</span> <span class="token punctuation">(</span>context<span class="token punctuation">.</span>$vnode <span class="token operator">&amp;&amp;</span> context<span class="token punctuation">.</span>$vnode<span class="token punctuation">.</span>ns<span class="token punctuation">)</span> <span class="token operator">||</span> config<span class="token punctuation">.</span><span class="token function">getTagNamespace</span><span class="token punctuation">(</span>tag<span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>config<span class="token punctuation">.</span><span class="token function">isReservedTag</span><span class="token punctuation">(</span>tag<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 创建虚拟 VNode</span>
      vnode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VNode</span><span class="token punctuation">(</span>
        config<span class="token punctuation">.</span><span class="token function">parsePlatformTagName</span><span class="token punctuation">(</span>tag<span class="token punctuation">)</span><span class="token punctuation">,</span> data<span class="token punctuation">,</span> children<span class="token punctuation">,</span>
        <span class="token keyword">undefined</span><span class="token punctuation">,</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span> context
      <span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">!</span>data <span class="token operator">||</span> <span class="token operator">!</span>data<span class="token punctuation">.</span>pre<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isDef</span><span class="token punctuation">(</span>Ctor <span class="token operator">=</span> <span class="token function">resolveAsset</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span>$options<span class="token punctuation">,</span> <span class="token string">'components'</span><span class="token punctuation">,</span> tag<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// component</span>
      vnode <span class="token operator">=</span> <span class="token function">createComponent</span><span class="token punctuation">(</span>Ctor<span class="token punctuation">,</span> data<span class="token punctuation">,</span> context<span class="token punctuation">,</span> children<span class="token punctuation">,</span> tag<span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      vnode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VNode</span><span class="token punctuation">(</span>
        tag<span class="token punctuation">,</span> data<span class="token punctuation">,</span> children<span class="token punctuation">,</span>
        <span class="token keyword">undefined</span><span class="token punctuation">,</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span> context
      <span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    vnode <span class="token operator">=</span> <span class="token function">createComponent</span><span class="token punctuation">(</span>tag<span class="token punctuation">,</span> data<span class="token punctuation">,</span> context<span class="token punctuation">,</span> children<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>vnode<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> vnode
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>vnode<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>ns<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">applyNS</span><span class="token punctuation">(</span>vnode<span class="token punctuation">,</span> ns<span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">registerDeepBindings</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>
    <span class="token keyword">return</span> vnode
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">createEmptyVNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>


<span class="token comment">// 5、效果演示</span>
<span class="token keyword">var</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  el<span class="token operator">:</span> <span class="token string">'#app'</span><span class="token punctuation">,</span>
  <span class="token function-variable function">render</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">createElement</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
      attrs<span class="token operator">:</span> <span class="token punctuation">{</span>
        id<span class="token operator">:</span> <span class="token string">'app'</span><span class="token punctuation">,</span>
        <span class="token keyword">class</span><span class="token operator">:</span> <span class="token string">&quot;class_box&quot;</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>message<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  data<span class="token operator">:</span> <span class="token punctuation">{</span>
    message<span class="token operator">:</span> <span class="token string">'Hello Vue!'</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><img src="/Image/Frame/Vue/28.png" align="" style="zoom:50%;"> <h5 id="_1-4-1-7-4、diff-process"><a href="#_1-4-1-7-4、diff-process" class="header-anchor">#</a> 1-4-1-7-4、Diff Process</h5> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 1、change -&gt; dep.notify -&gt; updateComponent(视图更新)</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">mountComponent</span> <span class="token punctuation">(</span>
  <span class="token parameter">vm<span class="token operator">:</span> Component<span class="token punctuation">,</span>
  el<span class="token operator">:</span> <span class="token operator">?</span>Element<span class="token punctuation">,</span>
  hydrating<span class="token operator">?</span><span class="token operator">:</span> boolean</span>
<span class="token punctuation">)</span><span class="token operator">:</span> Component <span class="token punctuation">{</span>
  vm<span class="token punctuation">.</span>$el <span class="token operator">=</span> el
  <span class="token comment">// ...</span>
  <span class="token keyword">let</span> updateComponent
  <span class="token comment">/* istanbul ignore if */</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span> <span class="token operator">&amp;&amp;</span> config<span class="token punctuation">.</span>performance <span class="token operator">&amp;&amp;</span> mark<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function-variable function">updateComponent</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token comment">// 生成虚拟 VNode   </span>
      <span class="token keyword">const</span> vnode <span class="token operator">=</span> vm<span class="token punctuation">.</span><span class="token function">_render</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token comment">// 更新 DOM</span>
      vm<span class="token punctuation">.</span><span class="token function">_update</span><span class="token punctuation">(</span>vnode<span class="token punctuation">,</span> hydrating<span class="token punctuation">)</span>
     
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token function-variable function">updateComponent</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      vm<span class="token punctuation">.</span><span class="token function">_update</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span><span class="token function">_render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> hydrating<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 实例化一个渲染Watcher，在它的回调函数中会调用 updateComponent 方法  </span>
  <span class="token keyword">new</span> <span class="token class-name">Watcher</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> updateComponent<span class="token punctuation">,</span> noop<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token function">before</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>vm<span class="token punctuation">.</span>_isMounted <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>vm<span class="token punctuation">.</span>_isDestroyed<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">callHook</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token string">'beforeUpdate'</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token boolean">true</span> <span class="token comment">/* isRenderWatcher */</span><span class="token punctuation">)</span>
  hydrating <span class="token operator">=</span> <span class="token boolean">false</span>

  <span class="token keyword">return</span> vm
<span class="token punctuation">}</span>

<span class="token comment">// 2、完成视图的更新工作事实上就是调用了 vm._update 方法，方法接收的第一个参数是刚生成的 Vnode</span>
<span class="token comment">// 关键是 vm.__patch__ 方法，此亦整个 virtual-dom 中最为核心方法，主要完成了 prevVnode 和 vnode 的 diff 过程并根据需要操作的 vdom 节点打 patch，最后生成新的真实 dom 节点并完成视图的更新工作</span>
<span class="token class-name">Vue</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">_update</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">vnode<span class="token operator">:</span> VNode<span class="token punctuation">,</span> hydrating<span class="token operator">?</span><span class="token operator">:</span> boolean</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> vm<span class="token operator">:</span> Component <span class="token operator">=</span> <span class="token keyword">this</span>
  <span class="token keyword">const</span> prevEl <span class="token operator">=</span> vm<span class="token punctuation">.</span>$el
  <span class="token keyword">const</span> prevVnode <span class="token operator">=</span> vm<span class="token punctuation">.</span>_vnode
  <span class="token keyword">const</span> restoreActiveInstance <span class="token operator">=</span> <span class="token function">setActiveInstance</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span>
  vm<span class="token punctuation">.</span>_vnode <span class="token operator">=</span> vnode
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>prevVnode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 第一个参数为真实的 node 节点，则为初始化</span>
    vm<span class="token punctuation">.</span>$el <span class="token operator">=</span> vm<span class="token punctuation">.</span><span class="token function">__patch__</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>$el<span class="token punctuation">,</span> vnode<span class="token punctuation">,</span> hydrating<span class="token punctuation">,</span> <span class="token boolean">false</span> <span class="token comment">/* removeOnly */</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// 若需要 diff 的 prevVnode 存在，则对 prevVnode 和 vnode 进行 diff</span>
    vm<span class="token punctuation">.</span>$el <span class="token operator">=</span> vm<span class="token punctuation">.</span><span class="token function">__patch__</span><span class="token punctuation">(</span>prevVnode<span class="token punctuation">,</span> vnode<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token function">restoreActiveInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token comment">// update __vue__ reference</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>prevEl<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    prevEl<span class="token punctuation">.</span>__vue__ <span class="token operator">=</span> <span class="token keyword">null</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>vm<span class="token punctuation">.</span>$el<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    vm<span class="token punctuation">.</span>$el<span class="token punctuation">.</span>__vue__ <span class="token operator">=</span> vm
  <span class="token punctuation">}</span>
  <span class="token comment">// if parent is an HOC, update its $el as well</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>vm<span class="token punctuation">.</span>$vnode <span class="token operator">&amp;&amp;</span> vm<span class="token punctuation">.</span>$parent <span class="token operator">&amp;&amp;</span> vm<span class="token punctuation">.</span>$vnode <span class="token operator">===</span> vm<span class="token punctuation">.</span>$parent<span class="token punctuation">.</span>_vnode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    vm<span class="token punctuation">.</span>$parent<span class="token punctuation">.</span>$el <span class="token operator">=</span> vm<span class="token punctuation">.</span>$el
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>


<span class="token comment">// patch 过程中会调用 sameVnode 方法来对传入的2个 vnode 进行基本属性的比较，只有当基本属性相同的情况下才认为这个2个 vnode 只是局部发生了更新，然后才会对这 2 个 vnode 进行 diff，若 vnode 的基本属性存在不一致的情况，则直接跳过 diff 过程，进而依据 vnode 新建一个真实的 dom，同时删除老的 dom节点</span>
<span class="token keyword">function</span> <span class="token function">patch</span> <span class="token punctuation">(</span><span class="token parameter">oldVnode<span class="token punctuation">,</span> vnode<span class="token punctuation">,</span> hydrating<span class="token punctuation">,</span> removeOnly</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ......</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isUndef</span><span class="token punctuation">(</span>oldVnode<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 当 oldVnode 不存在时，创建新的节点</span>
      isInitialPatch <span class="token operator">=</span> <span class="token boolean">true</span>
      <span class="token function">createElm</span><span class="token punctuation">(</span>vnode<span class="token punctuation">,</span> insertedVnodeQueue<span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token comment">// 对 oldVnode 和 vnode 进行 diff，并对 oldVnode 打 patch  </span>
      <span class="token keyword">const</span> isRealElement <span class="token operator">=</span> <span class="token function">isDef</span><span class="token punctuation">(</span>oldVnode<span class="token punctuation">.</span>nodeType<span class="token punctuation">)</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isRealElement <span class="token operator">&amp;&amp;</span> <span class="token function">sameVnode</span><span class="token punctuation">(</span>oldVnode<span class="token punctuation">,</span> vnode<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// patch existing root node</span>
        <span class="token function">patchVnode</span><span class="token punctuation">(</span>oldVnode<span class="token punctuation">,</span> vnode<span class="token punctuation">,</span> insertedVnodeQueue<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> removeOnly<span class="token punctuation">)</span>
      <span class="token punctuation">}</span> 
	<span class="token comment">// ......</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">sameVnode</span> <span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    a<span class="token punctuation">.</span>key <span class="token operator">===</span> b<span class="token punctuation">.</span>key <span class="token operator">&amp;&amp;</span>
    a<span class="token punctuation">.</span>tag <span class="token operator">===</span> b<span class="token punctuation">.</span>tag <span class="token operator">&amp;&amp;</span>
    a<span class="token punctuation">.</span>isComment <span class="token operator">===</span> b<span class="token punctuation">.</span>isComment <span class="token operator">&amp;&amp;</span>
    <span class="token function">isDef</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>data<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token function">isDef</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>data<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
    <span class="token function">sameInputType</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// 3、diff 过程中主要是通过调用 patchVnode 方法进行</span>
<span class="token comment">// diff 过程中又分了好几种情况: oldCh 为 oldVnode 的子节点，ch 为 Vnode 的子节点：</span>
<span class="token comment">// 首先, 进行文本节点的判断，若 oldVnode.text !== vnode.text，则直接进行文本节点的替换；</span>
<span class="token comment">// 然后, 在 vnode 没有文本节点情况下，进入子节点的 diff；</span>
<span class="token comment">// 	当 oldCh 和 ch 都存在且不相同的情况下，调用 updateChildren 对子节点进行 diff；</span>
<span class="token comment">// 	若 oldCh 不存在，ch 存在，首先清空 oldVnode 的文本节点，同时调用 addVnodes 方法将 ch 添加到 elm 真实 dom 节点当中；</span>
<span class="token comment">// 	若 oldCh 存在，ch不存在，则删除 elm 真实节点下的 oldCh 子节点；</span>
<span class="token comment">// 	若 oldVnode 有文本节点，而 vnode 没有，那么就清空这个文本节点。</span>
<span class="token keyword">function</span> <span class="token function">patchVnode</span> <span class="token punctuation">(</span><span class="token parameter">oldVnode<span class="token punctuation">,</span> vnode<span class="token punctuation">,</span> insertedVnodeQueue<span class="token punctuation">,</span> ownerArray<span class="token punctuation">,</span> index<span class="token punctuation">,</span> removeOnly</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...... </span>
  <span class="token keyword">const</span> elm <span class="token operator">=</span> vnode<span class="token punctuation">.</span>elm <span class="token operator">=</span> oldVnode<span class="token punctuation">.</span>elm
  <span class="token keyword">const</span> oldCh <span class="token operator">=</span> oldVnode<span class="token punctuation">.</span>children
  <span class="token keyword">const</span> ch <span class="token operator">=</span> vnode<span class="token punctuation">.</span>children
  <span class="token comment">// 若 vnode 没有文本节点</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isUndef</span><span class="token punctuation">(</span>vnode<span class="token punctuation">.</span>text<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 若 oldVnode 的 children 属性存在且 vnode 的 children 属性也存在  </span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>oldCh<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isDef</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// updateChildren，对子节点进行 diff  </span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCh <span class="token operator">!==</span> ch<span class="token punctuation">)</span> <span class="token function">updateChildren</span><span class="token punctuation">(</span>elm<span class="token punctuation">,</span> oldCh<span class="token punctuation">,</span> ch<span class="token punctuation">,</span> insertedVnodeQueue<span class="token punctuation">,</span> removeOnly<span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">checkDuplicateKeys</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
      <span class="token comment">// 若 oldVnode 的 text 存在，则首先清空 text 内容, 然后将 vnode 的 children 添加进去  </span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>oldVnode<span class="token punctuation">.</span>text<span class="token punctuation">)</span><span class="token punctuation">)</span> nodeOps<span class="token punctuation">.</span><span class="token function">setTextContent</span><span class="token punctuation">(</span>elm<span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span>
      <span class="token function">addVnodes</span><span class="token punctuation">(</span>elm<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> ch<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> ch<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> insertedVnodeQueue<span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>oldCh<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 删除 elm 下的 oldchildren</span>
      <span class="token function">removeVnodes</span><span class="token punctuation">(</span>elm<span class="token punctuation">,</span> oldCh<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> oldCh<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>oldVnode<span class="token punctuation">.</span>text<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// oldVnode 有子节点，而 vnode 没有，则清空这个节点  </span>
      nodeOps<span class="token punctuation">.</span><span class="token function">setTextContent</span><span class="token punctuation">(</span>elm<span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldVnode<span class="token punctuation">.</span>text <span class="token operator">!==</span> vnode<span class="token punctuation">.</span>text<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 若 oldVnode 和 vnode 文本属性不同，则直接更新真实 dom 节点的文本元素</span>
    nodeOps<span class="token punctuation">.</span><span class="token function">setTextContent</span><span class="token punctuation">(</span>elm<span class="token punctuation">,</span> vnode<span class="token punctuation">.</span>text<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// ......</span>
<span class="token punctuation">}</span>


<span class="token keyword">function</span> <span class="token function">updateChildren</span> <span class="token punctuation">(</span><span class="token parameter">parentElm<span class="token punctuation">,</span> oldCh<span class="token punctuation">,</span> newCh<span class="token punctuation">,</span> insertedVnodeQueue<span class="token punctuation">,</span> removeOnly</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 为 oldCh 和 newCh 分别建立索引，为之后遍历的依据</span>
  <span class="token comment">// 开始遍历 diff 前，首先给 oldCh 和 newCh 分别分配一个 startIndex 和 endIndex 来作为遍历的索引</span>
  <span class="token keyword">let</span> oldStartIdx <span class="token operator">=</span> <span class="token number">0</span>
  <span class="token keyword">let</span> newStartIdx <span class="token operator">=</span> <span class="token number">0</span>
  <span class="token keyword">let</span> oldEndIdx <span class="token operator">=</span> oldCh<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span>
  <span class="token keyword">let</span> oldStartVnode <span class="token operator">=</span> oldCh<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
  <span class="token keyword">let</span> oldEndVnode <span class="token operator">=</span> oldCh<span class="token punctuation">[</span>oldEndIdx<span class="token punctuation">]</span>
  <span class="token keyword">let</span> newEndIdx <span class="token operator">=</span> newCh<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span>
  <span class="token keyword">let</span> newStartVnode <span class="token operator">=</span> newCh<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
  <span class="token keyword">let</span> newEndVnode <span class="token operator">=</span> newCh<span class="token punctuation">[</span>newEndIdx<span class="token punctuation">]</span>
  <span class="token keyword">let</span> oldKeyToIdx<span class="token punctuation">,</span> idxInOld<span class="token punctuation">,</span> vnodeToMove<span class="token punctuation">,</span> refElm

  <span class="token comment">// 直到 oldCh 或 newCh 被遍历完后跳出循环</span>
  <span class="token comment">// 当 oldCh 或 newCh 遍历完后(遍历完的条件就是 oldCh 或 newCh 的 startIndex &gt;= endIndex)，就停止 oldCh 和 newCh 的 diff 过程</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>oldStartIdx <span class="token operator">&lt;=</span> oldEndIdx <span class="token operator">&amp;&amp;</span> newStartIdx <span class="token operator">&lt;=</span> newEndIdx<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isUndef</span><span class="token punctuation">(</span>oldStartVnode<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      oldStartVnode <span class="token operator">=</span> oldCh<span class="token punctuation">[</span><span class="token operator">++</span>oldStartIdx<span class="token punctuation">]</span> <span class="token comment">// Vnode has been moved left</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isUndef</span><span class="token punctuation">(</span>oldEndVnode<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      oldEndVnode <span class="token operator">=</span> oldCh<span class="token punctuation">[</span><span class="token operator">--</span>oldEndIdx<span class="token punctuation">]</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">sameVnode</span><span class="token punctuation">(</span>oldStartVnode<span class="token punctuation">,</span> newStartVnode<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">patchVnode</span><span class="token punctuation">(</span>oldStartVnode<span class="token punctuation">,</span> newStartVnode<span class="token punctuation">,</span> insertedVnodeQueue<span class="token punctuation">,</span> newCh<span class="token punctuation">,</span> newStartIdx<span class="token punctuation">)</span>
      oldStartVnode <span class="token operator">=</span> oldCh<span class="token punctuation">[</span><span class="token operator">++</span>oldStartIdx<span class="token punctuation">]</span>
      newStartVnode <span class="token operator">=</span> newCh<span class="token punctuation">[</span><span class="token operator">++</span>newStartIdx<span class="token punctuation">]</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">sameVnode</span><span class="token punctuation">(</span>oldEndVnode<span class="token punctuation">,</span> newEndVnode<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">patchVnode</span><span class="token punctuation">(</span>oldEndVnode<span class="token punctuation">,</span> newEndVnode<span class="token punctuation">,</span> insertedVnodeQueue<span class="token punctuation">,</span> newCh<span class="token punctuation">,</span> newEndIdx<span class="token punctuation">)</span>
      oldEndVnode <span class="token operator">=</span> oldCh<span class="token punctuation">[</span><span class="token operator">--</span>oldEndIdx<span class="token punctuation">]</span>
      newEndVnode <span class="token operator">=</span> newCh<span class="token punctuation">[</span><span class="token operator">--</span>newEndIdx<span class="token punctuation">]</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">sameVnode</span><span class="token punctuation">(</span>oldStartVnode<span class="token punctuation">,</span> newEndVnode<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// Vnode moved right</span>
      <span class="token function">patchVnode</span><span class="token punctuation">(</span>oldStartVnode<span class="token punctuation">,</span> newEndVnode<span class="token punctuation">,</span> insertedVnodeQueue<span class="token punctuation">,</span> newCh<span class="token punctuation">,</span> newEndIdx<span class="token punctuation">)</span>
      canMove <span class="token operator">&amp;&amp;</span> nodeOps<span class="token punctuation">.</span><span class="token function">insertBefore</span><span class="token punctuation">(</span>parentElm<span class="token punctuation">,</span> oldStartVnode<span class="token punctuation">.</span>elm<span class="token punctuation">,</span> nodeOps<span class="token punctuation">.</span><span class="token function">nextSibling</span><span class="token punctuation">(</span>oldEndVnode<span class="token punctuation">.</span>elm<span class="token punctuation">)</span><span class="token punctuation">)</span>
      oldStartVnode <span class="token operator">=</span> oldCh<span class="token punctuation">[</span><span class="token operator">++</span>oldStartIdx<span class="token punctuation">]</span>
      newEndVnode <span class="token operator">=</span> newCh<span class="token punctuation">[</span><span class="token operator">--</span>newEndIdx<span class="token punctuation">]</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">sameVnode</span><span class="token punctuation">(</span>oldEndVnode<span class="token punctuation">,</span> newStartVnode<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// Vnode moved left</span>
      <span class="token function">patchVnode</span><span class="token punctuation">(</span>oldEndVnode<span class="token punctuation">,</span> newStartVnode<span class="token punctuation">,</span> insertedVnodeQueue<span class="token punctuation">,</span> newCh<span class="token punctuation">,</span> newStartIdx<span class="token punctuation">)</span>
      canMove <span class="token operator">&amp;&amp;</span> nodeOps<span class="token punctuation">.</span><span class="token function">insertBefore</span><span class="token punctuation">(</span>parentElm<span class="token punctuation">,</span> oldEndVnode<span class="token punctuation">.</span>elm<span class="token punctuation">,</span> oldStartVnode<span class="token punctuation">.</span>elm<span class="token punctuation">)</span>
      oldEndVnode <span class="token operator">=</span> oldCh<span class="token punctuation">[</span><span class="token operator">--</span>oldEndIdx<span class="token punctuation">]</span>
      newStartVnode <span class="token operator">=</span> newCh<span class="token punctuation">[</span><span class="token operator">++</span>newStartIdx<span class="token punctuation">]</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isUndef</span><span class="token punctuation">(</span>oldKeyToIdx<span class="token punctuation">)</span><span class="token punctuation">)</span> oldKeyToIdx <span class="token operator">=</span> <span class="token function">createKeyToOldIdx</span><span class="token punctuation">(</span>oldCh<span class="token punctuation">,</span> oldStartIdx<span class="token punctuation">,</span> oldEndIdx<span class="token punctuation">)</span>
      idxInOld <span class="token operator">=</span> <span class="token function">isDef</span><span class="token punctuation">(</span>newStartVnode<span class="token punctuation">.</span>key<span class="token punctuation">)</span>
        <span class="token operator">?</span> oldKeyToIdx<span class="token punctuation">[</span>newStartVnode<span class="token punctuation">.</span>key<span class="token punctuation">]</span>
      <span class="token operator">:</span> <span class="token function">findIdxInOld</span><span class="token punctuation">(</span>newStartVnode<span class="token punctuation">,</span> oldCh<span class="token punctuation">,</span> oldStartIdx<span class="token punctuation">,</span> oldEndIdx<span class="token punctuation">)</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isUndef</span><span class="token punctuation">(</span>idxInOld<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// New element</span>
        <span class="token function">createElm</span><span class="token punctuation">(</span>newStartVnode<span class="token punctuation">,</span> insertedVnodeQueue<span class="token punctuation">,</span> parentElm<span class="token punctuation">,</span> oldStartVnode<span class="token punctuation">.</span>elm<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> newCh<span class="token punctuation">,</span> newStartIdx<span class="token punctuation">)</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        vnodeToMove <span class="token operator">=</span> oldCh<span class="token punctuation">[</span>idxInOld<span class="token punctuation">]</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">sameVnode</span><span class="token punctuation">(</span>vnodeToMove<span class="token punctuation">,</span> newStartVnode<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token function">patchVnode</span><span class="token punctuation">(</span>vnodeToMove<span class="token punctuation">,</span> newStartVnode<span class="token punctuation">,</span> insertedVnodeQueue<span class="token punctuation">,</span> newCh<span class="token punctuation">,</span> newStartIdx<span class="token punctuation">)</span>
          oldCh<span class="token punctuation">[</span>idxInOld<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">undefined</span>
          canMove <span class="token operator">&amp;&amp;</span> nodeOps<span class="token punctuation">.</span><span class="token function">insertBefore</span><span class="token punctuation">(</span>parentElm<span class="token punctuation">,</span> vnodeToMove<span class="token punctuation">.</span>elm<span class="token punctuation">,</span> oldStartVnode<span class="token punctuation">.</span>elm<span class="token punctuation">)</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
          <span class="token comment">// same key but different element. treat as new element</span>
          <span class="token function">createElm</span><span class="token punctuation">(</span>newStartVnode<span class="token punctuation">,</span> insertedVnodeQueue<span class="token punctuation">,</span> parentElm<span class="token punctuation">,</span> oldStartVnode<span class="token punctuation">.</span>elm<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> newCh<span class="token punctuation">,</span> newStartIdx<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
      newStartVnode <span class="token operator">=</span> newCh<span class="token punctuation">[</span><span class="token operator">++</span>newStartIdx<span class="token punctuation">]</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>oldStartIdx <span class="token operator">&gt;</span> oldEndIdx<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    refElm <span class="token operator">=</span> <span class="token function">isUndef</span><span class="token punctuation">(</span>newCh<span class="token punctuation">[</span>newEndIdx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token keyword">null</span> <span class="token operator">:</span> newCh<span class="token punctuation">[</span>newEndIdx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>elm
    <span class="token function">addVnodes</span><span class="token punctuation">(</span>parentElm<span class="token punctuation">,</span> refElm<span class="token punctuation">,</span> newCh<span class="token punctuation">,</span> newStartIdx<span class="token punctuation">,</span> newEndIdx<span class="token punctuation">,</span> insertedVnodeQueue<span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>newStartIdx <span class="token operator">&gt;</span> newEndIdx<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">removeVnodes</span><span class="token punctuation">(</span>parentElm<span class="token punctuation">,</span> oldCh<span class="token punctuation">,</span> oldStartIdx<span class="token punctuation">,</span> oldEndIdx<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>无 key Diff</li> <li><img src="/Image/Frame/Vue/30.png" align="" style="zoom:50%;"></li> <li>有 key Diff</li> <li><img src="/Image/Frame/Vue/31.png" align="" style="zoom:50%;"></li></ul> <h5 id="_1-4-1-7-5、path-process"><a href="#_1-4-1-7-5、path-process" class="header-anchor">#</a> 1-4-1-7-5、Path Process</h5> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 观察上述代码知，通过 nodeOps 相关的方法对真实 DOM 结构进行操作</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">createElementNS</span> <span class="token punctuation">(</span><span class="token parameter">namespace<span class="token operator">:</span> string<span class="token punctuation">,</span> tagName<span class="token operator">:</span> string</span><span class="token punctuation">)</span><span class="token operator">:</span> Element <span class="token punctuation">{</span>
  <span class="token keyword">return</span> document<span class="token punctuation">.</span><span class="token function">createElementNS</span><span class="token punctuation">(</span>namespaceMap<span class="token punctuation">[</span>namespace<span class="token punctuation">]</span><span class="token punctuation">,</span> tagName<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">createTextNode</span> <span class="token punctuation">(</span><span class="token parameter">text<span class="token operator">:</span> string</span><span class="token punctuation">)</span><span class="token operator">:</span> Text <span class="token punctuation">{</span>
  <span class="token keyword">return</span> document<span class="token punctuation">.</span><span class="token function">createTextNode</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">createComment</span> <span class="token punctuation">(</span><span class="token parameter">text<span class="token operator">:</span> string</span><span class="token punctuation">)</span><span class="token operator">:</span> Comment <span class="token punctuation">{</span>
  <span class="token keyword">return</span> document<span class="token punctuation">.</span><span class="token function">createComment</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">insertBefore</span> <span class="token punctuation">(</span><span class="token parameter">parentNode<span class="token operator">:</span> Node<span class="token punctuation">,</span> newNode<span class="token operator">:</span> Node<span class="token punctuation">,</span> referenceNode<span class="token operator">:</span> Node</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  parentNode<span class="token punctuation">.</span><span class="token function">insertBefore</span><span class="token punctuation">(</span>newNode<span class="token punctuation">,</span> referenceNode<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">removeChild</span> <span class="token punctuation">(</span><span class="token parameter">node<span class="token operator">:</span> Node<span class="token punctuation">,</span> child<span class="token operator">:</span> Node</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  node<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

</code></pre></div><h5 id="_1-4-1-7-x、总结"><a href="#_1-4-1-7-x、总结" class="header-anchor">#</a> 1-4-1-7-X、总结</h5> <img src="/Image/Frame/Vue/29.png" align="" style="zoom:50%;"> <p>当数据发生改变时，set 方法会触发 Dep.notify 方法，通知所有订阅者 Watcher，订阅者就会调用 patch 给真实 DOM 打补丁，更新相应视图：</p> <img src="/Image/Frame/Vue/18.png" align="" style="zoom:50%;"> <p><strong><u><em>patch 过程：涉及 DOM Diff 过程</em></u></strong>：DOM Diff 找到并只更新差异部分的 DOM，以减少更新量，提升效率；</p> <ul><li><strong><u><em>同层比较：Diff 比较基础</em></u></strong>。只有两个新旧节点是相同节点时，才会去比较各自子节点(另：最大的根节点一开始可直接比较)；</li> <li>新旧节点：所有新旧节点均为 VNode 节点，使用此类型节点进行比较而不用 DOM 可无视平台限制，比较完成使用平台方法处理即可；</li> <li>相同父级：只有相同父节点才能进行比较，没有则无法实现：
<ul><li><img src="/Image/Frame/Vue/19.png" align="" style="zoom:50%;"></li> <li><img src="/Image/Frame/Vue/20.png" align="" style="zoom:50%;"></li></ul></li> <li><strong><u><em>节点复用：Diff 比较内核</em></u></strong>。建立在上述基础之上。Diff 比较是为了在新旧节点中找到相同节点，所以节点复用，找到相同节点而非无限递归查找；
<ul><li>不同父节点无法复用：
<ul><li><img src="/Image/Frame/Vue/21.png" align="" style="zoom:50%;"></li> <li><img src="/Image/Frame/Vue/22.png" align="" style="zoom:50%;"></li></ul></li> <li>同级且父节点一致才可复用：
<ul><li><img src="/Image/Frame/Vue/23.png" align="" style="zoom:50%;"></li></ul></li></ul></li></ul> <p><strong><u><em>DOM Diff 比较逻辑：</em></u></strong></p> <ul><li>比较处理流程：
<ul><li>在新旧节点中
<ol><li>首先，找到 不需要移动的相同节点，消耗最小；</li> <li>然后，再找相同但是需要移动的节点，消耗次小；</li> <li>最后，找不到才会去新建/删除节点，保底处理；</li></ol></li></ul></li> <li>比较是为修改 DOM 树：
<ul><li>存在三种树：页面 DOM 树、旧 VNode 树、新 Vnode 树；</li> <li>页面 DOM 树与旧 VNode  树节点一一对应，而新 Vnode 树则是表示更新后页面 DOM 树 该有的样子</li> <li>注意：在旧 Vnode 树与新 Vnode 树 进行比较过程中：不会对此两棵 Vode 树进行修改，而是以比较的结果，直接对真实 DOM 进行修改</li> <li>比如：旧 Vnode 树同一层中，找到和新 Vnode 树 中一样但位置不一样节点，此时需要移动此节点，但不是移动旧 Vnode 树中节点，而是直接移动 DOM</li> <li>总之：新旧 Vnode 树是拿来比较，页面 DOM 树是拿来根据比较结果修改；</li></ul></li></ul> <p><strong><u><em>DOM Diff 比较示例</em></u></strong>：</p> <img src="/Image/Frame/Vue/24.png" align="" style="zoom:50%;"> <p>首轮，父节点相同，符合规则，进行子节点比较，进行第一流程：先找无需移动的相同节点，找到节点 2，根据比较结果，无需修改 DOM，DOM 保留原位置；</p> <img src="/Image/Frame/Vue/25.png" align="" style="zoom:50%;"> <p>二轮，再无<u>相同且无需移动的节点</u>，进行第二流程：找<u>相同但是需要移动的节点</u>，找到节点 5，根据比较结果，需要移动 DOM；</p> <img src="/Image/Frame/Vue/26.png" align="" style="zoom:50%;"> <p>三轮，无相同节点，进行流程三，新建或删除节点，在旧 Vnode 中，若新 Vnode 不存在的节点要删除，在新 Vnode 中，旧 Vnode 不存在节点要新建；</p> <img src="/Image/Frame/Vue/27.png" align="" style="zoom:50%;"> <p>最后，页面更新完毕；</p> <p><strong><u><em>DOM Diff 总结：</em></u></strong></p> <p>关键：一JS 模拟 DOM 树(虚拟DOM)、二比较虚拟DOM树差异，三将差异应用真正DOM上；</p> <p>思想：Vue 虚拟DOM思想，初次渲染或更新都用 JSAST 将 DOM 化为虚拟 DOM 树，若为更新则按照一定规则(DIff)比对前后虚拟DOM树变化，随后将变化结果应用到真正DOM树上；</p> <p>初次流程：vue.init 初始化、vm.$mounnt 挂载-&gt;return mountCompent(this, el, …)-&gt;实例化Watcher，然后再在里面调用 updateComponent -&gt; vm.render 将实例渲染为 VNode(虚拟Node)(使用 createElement 创建 VNode)-&gt; vm.update (vnode, …)-&gt;<code>vm.__patch__</code>(核心方法，完成 preVnode(旧VNode) 与 vnode (新VNode) 的 diff 过程并根据需要操作的 vdom 节点打 patch，最后生成新的真实DOM以完成视图更新操作)；</p> <ul><li><code>vm.__patch__</code>：先用 sameVnode 比对新旧Vnode的基本属性，若相同则认为发生局部更新，然后进行 diff，若不同则直接跳过 diff 过程，根据 vnode 新建一个真实 DOM，同时删除 旧 dom 节点；</li> <li>diff：主要通过调用 patchVNode 进行：</li> <li>首先，进行文本节点的判断，若oldVnode.text !== vnode.text 则直接进行文本节点的替换==&gt;nodeOps.setTextContent(elm, vnode.text)</li> <li>然后，若非文本节点，则进入子节点 diff，</li> <li>其他，若 oldVnode 子节点和 vnode 子节点均存在但不相同时，调用 updateChildren 对子节点进行 diff；</li> <li>其他，若 oldVnode 子节点不存在但 vnode 子节点存在，则清空 oldVnode 文本节点，同时调用 addVnodes 将 vnode 子节点添加到 el 真实 dom 节点中；</li> <li>其他，若 oldVnode 子节点存在，但 vnode 子节点不存在，则删除 elm 真实节点下的 oldVnode 子节点；</li> <li>其他，若 oldVnode 有文本节点，但 vnode 没有，则清空此文本节点；</li></ul> <p>更新流程：调用响应式数据所维护的 dep，随后调用 dep.notify 方法，其中包含 updateComponent…此后流程同上；</p> <p>补充：</p> <p>diff算法过程：</p> <ul><li>先同级比较再比较子节点；</li> <li>首先，判断一方有子节点和一方没有子节点的情况；如果新的一方有子节点，旧的一方没有，相当于新的子节点替代了原来没有的节点；同理，如果新的一方没有子节点，旧的一方有，相当于要把老的节点删除；</li> <li>然后，比较都有子节点的情况，这里是<code>diff</code>的核心。首先会通过判断两个节点的<code>key、tag、isComment、data同时定义或不定义以及当标签类型为input的时候type相不相同</code>来确定两个节点是不是相同的节点，如果不是的话就将新节点替换旧节点。</li> <li>如果是相同节点的话才会进入到<code>patchVNode</code>阶段。在这个阶段核心是采用双端比较的算法，同时从新旧节点的两端进行比较，在这个过程中，会用到模版编译时的静态标记配合<code>key</code>来跳过对比静态节点，如果不是的话再进行其它的比较。</li></ul> <p><code>Vue3.x</code>借鉴了<code>ivi</code>算法和<code>inferno</code>算法。</p> <p>它在创建<code>VNode</code>的时候就确定了其类型，以及在<code>mount/patch</code>的过程中采用<code>位运算</code>来判断一个<code>VNode</code>的类型，在这个基础之上再配合核心的Diff算法，使得性能上较Vue2.x有了提升。</p> <p>diff算法缺点</p> <p>因为采用的是同级比较，所以如果发现本级的节点不同的话就会将新节点之间替换旧节点，不会再去比较其下的子节点是否有相同</p> <h5 id="_1-4-1-x、总结"><a href="#_1-4-1-x、总结" class="header-anchor">#</a> 1-4-1-X、总结</h5> <img src="/Image/Frame/Vue/2.png" align="" style="zoom:50%;"> <p><strong><u><em>首先</em></u></strong>，initData，获取 data 的 key，并获取 props，并确保 props 优先，不能与 data 重复，并判断是否保留字段，并将 data 属性代理到 vm 实例上(即 vm.key == vm._data.key)，随后进行 observer(data) 数据绑定操作；</p> <p>然后，new Observer(data)(对数组方法及数组元素的处理，最终执行 walk 方法)、defineReactive(data, keys, values)、定义数据的 get 和 set 操作：</p> <ul><li><code>Object.defineProperty-get-(dep.depend-&gt;Dep.target.addDep-&gt;this.subs.push(watcher))</code></li> <li><code>Object.defineProperty-set-(dep.notify-&gt;subs[i].update-watcher.run)；</code></li></ul> <p><strong><u><em>然后</em></u></strong>，初次渲染时，DepTarget 不为 undefined，触发 Data 的 get 操作(保证只有视图中需要被用到的 data 才会触发 getter)，进行依赖收集：将组件 watcher (和 data 相关联的 watcher (存疑))添加到变量的 dep 的 subs 容器中；此时 Watcher 与 data 可看成是一种相互绑定状态；</p> <p><strong><u><em>最后</em></u></strong>，data 发生变化，set 被触发时，遍历执行 data.dep.subs 数组下的元素，即执行 watcher.run 方法、执行 render 函数的生成，进入 DOM diff 渲染流程；</p> <p><strong><u><em>注意</em></u></strong>：Vue 在初始化组件数据时，在生命周期 <a href="https://github.com/vuejs/vue/blob/dev/src/core/instance/init.js#L55" target="_blank" rel="noopener noreferrer">beforeCreate<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>与<a href="https://github.com/vuejs/vue/blob/dev/src/core/instance/init.js#L59" target="_blank" rel="noopener noreferrer">created <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>钩子函数间实现了对 <a href="https://github.com/vuejs/vue/blob/dev/src/core/instance/state.js#L43" target="_blank" rel="noopener noreferrer">data、props、computed、methods、events及watch<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 的处理；</p> <p><strong><u><em>补充</em></u></strong>：依赖收集：</p> <ol><li>ObjectdefineProperty - get 时进行收集</li> <li>data 中每个声明的属性，都会有一个 专属的依赖收集器 subs</li> <li>当页面使用到 某个属性时，页面的 watcher 就会被 放到 依赖收集器 subs 中</li> <li>总结即当 页面 A 读取了 name 时，会触发 name 的 get 函数，此时，name 就会保存 页面A 的 watcher；</li></ol> <p><strong><u><em>补充</em></u></strong>：依赖更新：</p> <ol><li>Object.defineProperty - set触发依赖更新</li> <li>总结即当 name 改变时，name 会遍历自身的依赖收集器 subs，逐个通知其中的 watcher，让 watcher 完成更新；</li></ol> <p><strong><u><em>补充</em></u></strong>：稍微总结：</p> <ol><li>Object.defineProperty - get ，用于 依赖收集</li> <li>Object.defineProperty - set，用于 依赖更新</li> <li>每个 data 声明的属性，都拥有一个的专属依赖收集器 subs</li> <li>依赖收集器 subs 保存的依赖是 watcher</li> <li>watcher 可用于 进行视图更新</li></ol> <h5 id="_1-4-1-y、补充"><a href="#_1-4-1-y、补充" class="header-anchor">#</a> 1-4-1-Y、补充</h5> <h5 id="_1-4-1-y-1、数据绑定补充"><a href="#_1-4-1-y-1、数据绑定补充" class="header-anchor">#</a> 1-4-1-Y-1、数据绑定补充</h5> <p><strong><u><em>前期数据处理</em></u></strong>：new Vue -&gt; this._init(options) -&gt; 各种 init 包含 initState -&gt; data属性的各种初始化，比如 initProps、initMethods、initData、initComputed、initWatch，此处重点在 initData，而 initData 中，组件 options 中的 data 会被赋给 vm._data，并进行代理操作，最后会执行 observe(data，true)</p> <p><strong><u><em>依赖收集流程</em></u></strong></p> <ul><li>defineReactive 接收整一个 data 对象，并每一个 key 与与之对应的 value</li> <li><img src="/Image/Frame/Vue/3.png" align="" style="zoom:50%;"></li> <li>Dep.target 在 Watcher 实例化时赋值：Vue实例化 initState 中调用，实例化时调用 this.get，随后调用 pushTarget，即可赋值：</li> <li><img src="/Image/Frame/Vue/4.png" align="" style="zoom:50%;"></li> <li><img src="/Image/Frame/Vue/5.png" align="" style="zoom:50%;"></li> <li><img src="/Image/Frame/Vue/6.png" align="" style="zoom:50%;"></li> <li>回到 Dep.target.addDep(this)，由上述推导即 watcher.addDdep(dep)</li> <li><img src="/Image/Frame/Vue/7.png" align="" style="zoom:50%;"></li> <li><img src="/Image/Frame/Vue/8.png" align="" style="zoom:50%;"></li> <li><img src="/Image/Frame/Vue/9.png" align="" style="zoom:50%;"></li></ul> <p>依赖收集最终：</p> <ul><li>在 watcher.newDeps 中 push了闭包中传过来的 dep 对象；</li> <li>在 dep.subs中push了初始化 Vue 是建立的 Watcher 对象；</li> <li>即：watcher.newDeps.push(dep)、dep.subs.push(Watcher)；</li> <li>而：后者中包含：this.getter = expOrFn，传过来的expOrFn是后期数据更新页面渲染的核心步骤；</li></ul> <p><strong><u><em>组件渲染流程</em></u></strong>：</p> <ul><li>注意：初次依赖收集发生首次渲染时，依赖收集后试图更新时才会双绑响应</li> <li><img src="/Image/Frame/Vue/10.png" align="" style="zoom:50%;"></li></ul> <p><strong><u><em>视图更新流程</em></u></strong>：</p> <ul><li><img src="/Image/Frame/Vue/11.png" align="" style="zoom:50%;"></li> <li><img src="/Image/Frame/Vue/12.png" align="" style="zoom:50%;"></li> <li><img src="/Image/Frame/Vue/13.png" align="" style="zoom:50%;"></li> <li><img src="/Image/Frame/Vue/14.png" align="" style="zoom:50%;"></li> <li><img src="/Image/Frame/Vue/15.png" align="" style="zoom:50%;"></li> <li><img src="/Image/Frame/Vue/16.png" align="" style="zoom:50%;"></li> <li>在上面 Watcher.get 方法中：</li> <li>首先，会调用 <code>pushTarget</code> 函数将 <code>Watcher</code> 对象设为 <code>Dep.target</code>；</li> <li>然后，会调用 getter 函数获取 value，即：调用 <code>updateCompent</code> 方法 —&gt; <code>vm._update(vm._render(), hydrating)</code> —&gt;  <code>compileToFunctions</code> 函数生成的 <code>render</code> 函数；</li> <li>然后，上述 <code>render</code> 函数会返回一个 <code>VNode</code> 对象，同时会去获取模板中所使用到的数据，从而又触发数据 <code>Observer</code> 的 <code>getter</code> (即初次依赖收集通过 <code>mount</code>，后续依赖收集随 get 触发)；</li> <li>最后，后面会调用 <code>vm.__patch__</code> 方法，进而执行虚拟 DOM 的 diff 过程实时的更新界面；</li> <li><img src="/Image/Frame/Vue/17.png" align="" style="zoom:50%;"></li></ul> <p>视图更新流程总结：</p> <p>触发 getter 时，数据的 Dep 对象会将 Watcher 对象收集为依赖，这样就完成了渲染的依赖收集；而每当去修改响应式数据时，setter 就会通过 dep.notify 方法来调用 Watcher 的 update 方法。在 update 调用完 getter 函数后，会通过 popTarget 函数将 Dep.target 置空(途中没有展示)；</p> <h5 id="_1-4-1-z、实现"><a href="#_1-4-1-z、实现" class="header-anchor">#</a> 1-4-1-Z、实现</h5> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/**
 * Vue Minimalist implementation
 * By rjwx60
 */</span>


<span class="token keyword">const</span> <span class="token function-variable function">Observer</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 遍历设置 getSet 方法</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">in</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">defineReactive</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>


<span class="token keyword">const</span> <span class="token function-variable function">defineReactive</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">obj<span class="token punctuation">,</span> key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 局部变量 dep，用于 getSet 内部调用, 发布者，用于管理观察者 watcher</span>
  <span class="token keyword">const</span> dep <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 获取当前值</span>
  <span class="token keyword">let</span> val <span class="token operator">=</span> obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>
  Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token comment">// 设置可被循环</span>
    enumerable<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token comment">// 设置可被修改</span>
    configurable<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>

    <span class="token comment">// 主体</span>
    <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;in get&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">// 调用依赖收集器中的 addSub，用于收集当前属性与 Watcher 中的依赖关系</span>
      dep<span class="token punctuation">.</span><span class="token function">depend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span> val<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">set</span><span class="token punctuation">(</span>newVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>newVal <span class="token operator">===</span> val<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
      
      val <span class="token operator">=</span> newVal<span class="token punctuation">;</span>
      <span class="token comment">// 当值变更时，通知依赖收集器，更新每个需要更新的 Watcher，</span>
      <span class="token comment">// 这里每个需要更新通过什么断定？dep.subs</span>
      dep<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>


<span class="token keyword">const</span> <span class="token function-variable function">observe</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 缺少对依赖重复收集的防御</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Observer</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>


<span class="token keyword">const</span> <span class="token function-variable function">Vue</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> self <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
  <span class="token comment">// 将 data 赋值给 this._data，源码此部分用的 Proxy 实现</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>options <span class="token operator">&amp;&amp;</span> <span class="token keyword">typeof</span> options<span class="token punctuation">.</span>data <span class="token operator">===</span> <span class="token string">&quot;function&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>_data <span class="token operator">=</span> options<span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 挂载函数</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">mount</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 挂载后，Dep.target 才不为 undefined，才可以进行依赖收集</span>
    <span class="token keyword">new</span> <span class="token class-name">Watcher</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> self<span class="token punctuation">.</span>render<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token comment">// 渲染函数</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">render</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">with</span> <span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      _data<span class="token punctuation">.</span>text<span class="token punctuation">;</span>
      <span class="token comment">// _data.text2;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token comment">// 监听 this._data</span>
  <span class="token function">observe</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>_data<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>



<span class="token comment">// 观察者</span>
<span class="token keyword">const</span> <span class="token function-variable function">Watcher</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">vm<span class="token punctuation">,</span> fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> self <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>vm <span class="token operator">=</span> vm<span class="token punctuation">;</span>
  <span class="token comment">// 将当前 Dep.target 指向自身，当 mount 时实例化</span>
  Dep<span class="token punctuation">.</span>target <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
  
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">addDep</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">dep</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 闭包获取遍历 dep, 即调用 dep.addSub 方法，实现当前 Wathcer 的变量传递</span>
    dep<span class="token punctuation">.</span><span class="token function">addSub</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  
  <span class="token comment">// 用于触发 vm._render</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">update</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;Watcher updated&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token comment">// 此处负责首次调用 vm._render，从而触发 text 的 get 从而将当前的 Wathcer 与 Dep 相关联</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 清空 Dep.target，防止 notify 触发时，不停绑定 Watcher 与 Dep 造成死循环</span>
  Dep<span class="token punctuation">.</span>target <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>



<span class="token comment">// 发布者</span>
<span class="token keyword">const</span> <span class="token function-variable function">Dep</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> self <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
  <span class="token comment">// 收集目标</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>target <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token comment">// 存储收集器中需要通知的 Watcher</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>subs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token comment">// 当有目标时，绑定 Dep 与 Wathcer 关系</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">depend</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>Dep<span class="token punctuation">.</span>target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      Dep<span class="token punctuation">.</span>target<span class="token punctuation">.</span><span class="token function">addDep</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token comment">// 为当前收集器添加 Watcher</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">addSub</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">watcher</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    self<span class="token punctuation">.</span>subs<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>watcher<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token comment">// 通知收集器中所的所有 Wathcer，调用其 update 方法</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">notify</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> self<span class="token punctuation">.</span>subs<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      self<span class="token punctuation">.</span>subs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>





<span class="token comment">// 示例1:</span>
<span class="token keyword">const</span> vue1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      text<span class="token operator">:</span> <span class="token string">&quot;hello guys&quot;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

vue1<span class="token punctuation">.</span><span class="token function">mount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// in get</span>
<span class="token comment">// new Vue -&gt; Vue._data = data &amp;&amp; observe(this._data)</span>
<span class="token comment">// 初始化时，即 new Vue 时即进行了 data 的代理、data 下的每一属性的绑定 observer、此时的 DepTarget 为 undefined</span>
<span class="token comment">// -&gt; vue.mount -&gt; new Watcher(Vue.this, Vue.render)</span>
<span class="token comment">// 进行 mount 时，实例化 Watcher, 此时的 Watcher.DepTarget 不为 undefined，并进行首次的依赖收集(this.value = fn()(Vue.render()))</span>
<span class="token comment">// -&gt; this.value = Vue.render() = Vue._data.text, 即触发 get, 完成收集, 核心是 dep.depend(), (收集依赖, 未被依赖的属性值不会 get)</span>
<span class="token comment">// dep.depend 通知 Dep.target(即 watcher).addDep(dep)，再折返给 Dep.dep.addSub(watcher)(来回传值是为了传递 watcher)，最终 dep.subs.push(watcher)</span>
vue1<span class="token punctuation">.</span>_data<span class="token punctuation">.</span>text <span class="token operator">=</span> <span class="token string">&quot;123&quot;</span><span class="token punctuation">;</span> <span class="token comment">// Watcher updated /n in get</span>
<span class="token comment">// 当发生变化时触发 set，即 dep.notify()，进行更新 subs[i].update()也即 watcher.update()，即 Vue.render</span>




<span class="token comment">// 示例2:</span>
<span class="token keyword">const</span> vue2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      text<span class="token operator">:</span> <span class="token string">'hello guys'</span><span class="token punctuation">,</span>
      text2<span class="token operator">:</span> <span class="token string">'hey'</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

vue2<span class="token punctuation">.</span><span class="token function">mount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// in get</span>
<span class="token comment">// vue2._data.text = '456'; // Watcher updated /n in get</span>
vue2<span class="token punctuation">.</span>_data<span class="token punctuation">.</span>text2 <span class="token operator">=</span> <span class="token string">'123'</span><span class="token punctuation">;</span> <span class="token comment">// nothing</span>
<span class="token comment">// 流程与上述类似，但为何 text2 没有打印是因为没有进行依赖收集，render 中只进行了 Vue._data.text</span>
<span class="token comment">// 并无 Vue._data.text2 所以没有触发 text2 的 Observer.get 也即没有收集和后续的相应改变</span>
<span class="token comment">// 即核心关键在于 render 中没有它的身影</span>
</code></pre></div><h4 id="_1-4-2、angular"><a href="#_1-4-2、angular" class="header-anchor">#</a> 1-4-2、Angular</h4> <p>Vue 为数据绑定，Angular 可称为变更检测：</p> <h5 id="_1-4-2-1、变更检测机制"><a href="#_1-4-2-1、变更检测机制" class="header-anchor">#</a> 1-4-2-1、变更检测机制</h5> <p><strong><u><em>Angular 的变更检测</em></u></strong>  要从一个错误说起 <strong><u><em>ExpressionChangedAfterItHasBeenCheckedError</em></u></strong>，一个按钮应用，当发生变化检测时将时间渲染到屏幕上。时间戳的精度是毫秒。点击按钮触发变化监测；组件类中有个名为<code>time</code>的getter，返回当前的时间戳；<a href="https://stackblitz.com/edit/angular-hqbenm?file=src/app/app.component.ts" target="_blank" rel="noopener noreferrer">地址<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <div class="language-ts extra-class"><pre class="language-ts"><code>@<span class="token function">Component</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    selector<span class="token operator">:</span> <span class="token string">'my-app'</span><span class="token punctuation">,</span>
    template<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">
        &lt;h3&gt;Change detection is triggered at: &lt;span [textContent]=&quot;time | date:'hh:mm:ss:SSS'&quot;&gt;&lt;/span&gt;&lt;/h3&gt;
				&lt;!-- Angular 不允许空的表达式，所以在 click 回调中放了一个 0 --&gt;
        &lt;button (click)=&quot;0&quot;&gt;Trigger Change Detection&lt;/button&gt;
    </span><span class="token template-punctuation string">`</span></span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">AppComponent</span> <span class="token punctuation">{</span>
    <span class="token keyword">get</span> <span class="token function">time</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>果然，报错 ExpressionChangedAfterItHasBeenCheckedError
原因：表达式在被 Angular 检查后发生了变化：之前的值：&quot;textContent: 1542375826274&quot;，而现在的值：&quot;textContent: 1542375826275&quot;；
所以，可发现 Angular 对表达式进行了两次计算，并将两次计算结果进行了比较，发现结果不一致，遂报错；</p> <img src="/Image/Frame/Angular/5.png" align="" style="zoom:50%;"> <p><strong><u><em>Angular 的变更检测中有两个主要的构成元素：</em></u></strong></p> <ul><li>一个组件的视图</li> <li>相关的数据绑定</li></ul> <p>Angular 中的每个组件都有一个由 HTML 元素构成的模板；</p> <p>Angular 创建了 DOM 节点以便将模板中的内容渲染到屏幕上，它需要有一个地方存储这些 DOM 节点的引用；为此，在 Angular 内部有一个称为 <strong><u><em>视图</em></u></strong> 的数据结构。<u><em>视图也被用来存储组件实例的引用，以及绑定表达式之前的值</em></u>。组件和视图之间是一对一的关系：</p> <img src="/Image/Frame/Angular/6.png" align="" style="zoom:50%;"> <p>首先，当编译器在分析模板时，它会<u>识别</u>可能需要在变化检测期间被更新的DOM元素的属性；</p> <p>然后，编译器会为每个这样的属性<u>创建</u>一个 <strong><u><em>绑定</em></u></strong>；数据绑定定义了：<u><em>需要更新的属性名称</em></u>、<u><em>Angular 用于获取新值的表达式</em></u>；</p> <ul><li>比如：此例中，<code>time</code> 属性被用在 <code>textContent</code> 属性的表达式中；所以 Angular 创建了绑定，并将它关联到 <code>span</code> 元素；</li></ul> <img src="/Image/Frame/Angular/7.png" align="" style="zoom:50%;"> <ul><li>注意：实际实现中，<u><em>绑定不是一个有着所有必须信息的单独的对象</em></u>；
<ul><li><code>viewDfinition</code> 为模板元素和需要更新的属性定义了绑定；</li> <li>而用于绑定的表达式则被置于 <code>updateRenderer</code> 函数中；</li></ul></li></ul> <p>**<u><em>Angular 变更检测流程：</em></u>**Angular中，每个组件都会执行变更检测；而组件在 Angular 内部会被表达为视图，所以可以说每个视图都会执行变更检测；</p> <ul><li>首先，当 Angular 检查一个视图时，它只会运行所有的编译器为视图生成的绑定，对表达式求值并将它们的结果，存储在视图的 <code>oldValues</code> 数组中；此亦脏检查的由来；</li> <li>然后，如果后续过程中，Angular 检测到了变化(Zone)，它就会更新与绑定相关的 DOM 属性，并将这个新的值放入视图的 <code>oldValues</code> 数组中；</li> <li>然后，(进行渲染)，用户就得到了一个更新过的 UI (组件层级)；</li> <li>最后，一旦 Angular 完成了当前组件的检测，它会递归地去检查子组件；
<ul><li>比如：在本次示例中只有一个绑定：连接到 <code>App</code> 组件中的 <code>span</code> 元素的 <code>textContent</code> 属性；</li> <li>所以：在变化检测期间，Angular 读取了组件类的 <code>time</code> 属性的值，并将其应用到 <code>date</code> 管道上，然后将返回值与储存在视图中的旧值相比较；如果它检测到不同(也即表示发生值变更)，Angular 就会更新 <code>span</code> 的 <code>textContent</code> 属性和 <code>oldValues</code> 数组；</li></ul></li></ul> <img src="/Image/Frame/Angular/8.png" align="" style="zoom:50%;"> <ul><li><p>注意：<u><em>在开发模式下，每一次变更检测循环后(同步任务)，Angular 会同步地运行另一次检查(同步任务)，以确保表达式生成的值，与先前在变更检测中的值相同</em></u>；这次检查并非是原始变更监测循环的一部分，它在整个组件树的变化检查结束后执行完全相同的步骤；但是在次次检查中，当 Angular 检测到了变更是不会更新DOM的；相反会抛出<code>ExpressionChangedAfterItHasBeenCheckedError</code> 错误；即：开发模式与生产模式不同，前者进行了两次检查，后者进行了一次；前者检查后若值不同则报错，后者值不同则更新UI；</p></li> <li><p><u>原因：Ng 做此次检查的原因：确保表达式生成的值与先前在变更检测中的值相同，在开发模式中排查错误，以免在生产模式下，陷入变更检测循环；</u></p> <ul><li>比如：组件类中的某些属性在变化检测运行期间就已被更新，造成的结果是：表达式产生了与渲染到 UI 中的值不一致的新值；此时的 Angular 当然可以再运行一次变化检测以同步应用状态与UI；但如果在此过程中，某些属性再次被更新了呢？那么 Angular 就有可能会在无限的变化检测循环中崩溃；</li></ul></li> <li><p>所以，为避免这种情况，Angular 强制实行了被称为 <strong><u><em>单项数据流</em></u></strong> 的模式，并且在变化检测后运行的检查和由此产生错误<code>ExpressionChangedAfterItHasBeenCheckedError</code> 是强制的机制；一旦 Angular 处理完当前组件的绑定，就不能再更新绑定表达式中使用的属性；</p></li> <li><p>解决：明白了变更检测原理，即可修复此错误，确保表达式在变化检测期间与随后的检查中返回的值是相同的：</p> <ul><li><p>思路1：确保值始终不变；</p></li> <li><p>思路2：变更检测与二次检查均为同步任务(产生错误的检查在变化检测循环后立即同步运行)，遂可利用 EventLoop 机制，将值的变更操作封装在异步或微任务中执行，等检查后再去更新值，以避免错误发生；注意避免使用 setInterval 等异步操作，因为</p></li> <li><p>思路3：利用 zones 提供 API，在变更检测之外执行，见下方；</p></li> <li><div class="language-ts extra-class"><pre class="language-ts"><code>@<span class="token function">Component</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    selector<span class="token operator">:</span> <span class="token string">'my-app'</span><span class="token punctuation">,</span>
    template<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">
        &lt;h3&gt;Change detection is triggered at: &lt;span [textContent]=&quot;time | date:'hh:mm:ss:SSS'&quot;&gt;&lt;/span&gt;&lt;/h3&gt;
				&lt;!-- Angular 不允许空的表达式，所以在 click 回调中放了一个 0 --&gt;
        &lt;button (click)=&quot;0&quot;&gt;Trigger Change Detection&lt;/button&gt;
    </span><span class="token template-punctuation string">`</span></span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">AppComponent</span> <span class="token punctuation">{</span>
  	<span class="token comment">// ExpressionChangedAfterItHasBeenCheckedError</span>
  	<span class="token comment">// 两次检查，所得的值均不同，报错</span>
    <span class="token keyword">get</span> <span class="token function">time</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  
  	<span class="token comment">// fix - 思路1</span>
  	<span class="token comment">// 将值写死，time 返回值始终不变，不管如何前后两次检测的值均等，无报错，但没有实现需求，</span>
    _time<span class="token punctuation">;</span>
    <span class="token keyword">get</span> <span class="token function">time</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_time<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>_time <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// fix - 思路2</span>
    _time<span class="token punctuation">;</span>
    <span class="token keyword">get</span> <span class="token function">time</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_time<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>_time <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      	<span class="token comment">// 不断更新 _time 值，因为二次检查是同步任务，所以可利用 EventLoop 机制，用异步任务封装更新操作，等检查后再去更新；</span>
      	<span class="token comment">// 异步操作被 Angular 做了劫持，都会触发新一轮的变更检测，若使用 setInterval 更是会无限次触发；</span>
        <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>_time <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul></li></ul> <p><strong><u><em>Angular 变更检测之变更通知 Zone：</em></u></strong></p> <p>与 React 相反，Angular 中的变更检测可完全自动地由浏览器中的任何一个异步事件触发；Angular 通过使用 <code>zone.js</code> 库，以实现变更监测流程的触发( zone.js 检测到异步事件，事件通知 Angular，进入变更检测流程)；</p> <p>此外 Angular 同时还引入了 zones 概念，注意 zones 并非 Angular 变更检测机制的一部分，而是独立于 Angular 之外的仅仅提供了一种拦截异步事件的方法的库，比如 <code>setInterval</code>，并通知 Angular 发生了异步事件，Angular 基于此通知来运行变更检测；一个网页应用可包含许多不同的 zones；其中一个是 <code>NgZone</code>，它在 Angular 启动时被创建；Angular 整一应用就运行在这个 zone 当中；只有在 zone 中发生的异步事件才会通知 Angular；</p> <img src="/Image/Frame/Angular/9.png" align="" style="zoom:50%;"> <p>但是，<code>zone.js</code>也提供了一个API：<code>NgZone</code> 服务实现的 <code>runOutsideAngular</code>，以便在 Angular zone 之外的 zone 中运行某些代码；而在其他 zone 中发生异步事件时，Angular 并不会收到通知；没有通知就意味着没有变更检测；所以在本次示例中，可解决不断触发变更检测的问题：</p> <p><strong><u>注意：使用 NgZone 来在 Angular 之外运行某些代码以避免触发变化检测是一种常用的优化技巧；</u></strong></p> <div class="language-ts extra-class"><pre class="language-ts"><code>@<span class="token function">Component</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    selector<span class="token operator">:</span> <span class="token string">'my-app'</span><span class="token punctuation">,</span>
    template<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">
        &lt;h3&gt;Change detection is triggered at: &lt;span [textContent]=&quot;time | date:'hh:mm:ss:SSS'&quot;&gt;&lt;/span&gt;&lt;/h3&gt;
				&lt;!-- Angular 不允许空的表达式，所以在 click 回调中放了一个 0 --&gt;
        &lt;button (click)=&quot;0&quot;&gt;Trigger Change Detection&lt;/button&gt;
    </span><span class="token template-punctuation string">`</span></span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">AppComponent</span> <span class="token punctuation">{</span>
  	<span class="token comment">// ExpressionChangedAfterItHasBeenCheckedError</span>
  	<span class="token comment">// 两次检查，所得的值均不同，报错</span>
    <span class="token keyword">get</span> <span class="token function">time</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  
  	<span class="token comment">// fix - 思路1</span>
  	<span class="token comment">// 将值写死，time 返回值始终不变，不管如何前后两次检测的值均等，无报错，但没有实现需求，</span>
    _time<span class="token punctuation">;</span>
    <span class="token keyword">get</span> <span class="token function">time</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_time<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>_time <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// fix - 思路2</span>
    _time<span class="token punctuation">;</span>
    <span class="token keyword">get</span> <span class="token function">time</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_time<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>_time <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      	<span class="token comment">// 不断更新 _time 值，因为二次检查是同步任务，所以可利用 EventLoop 机制，用异步任务封装更新操作，等检查后再去更新；</span>
      	<span class="token comment">// 异步操作被 Angular 做了劫持，都会触发新一轮的变更检测，若使用 setInterval 更是会无限次触发；</span>
        <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>_time <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  
  	<span class="token comment">// fix - 思路3</span>
    _time<span class="token punctuation">;</span>
    <span class="token keyword">get</span> <span class="token function">time</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_time<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">constructor</span><span class="token punctuation">(</span>zone<span class="token operator">:</span> NgZone<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>_time <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token comment">// 不断更新 _time 值，因为二次检查是同步任务，所以可利用 EventLoop 机制，用异步任务封装更新操作，等检查后再去更新；</span>
      	<span class="token comment">// 异步操作被 Angular 做了劫持，都会触发新一轮的变更检测，若使用 setInterval 更是会无限次触发；</span>
      	<span class="token comment">// 所以引入 NgZone 服务，使得异步任务在 NgZone 执行，绕开 NgZone 的变更检测，避免无限触发，又能确保检查后再更新值</span>
      	<span class="token comment">// 1、异步 -&gt; EventLoop 机制，异步绕开同步，避免值在检查前变化，保证检查后再变化，避免错误</span>
      	<span class="token comment">// 2、Zone -&gt; NgZone 原理，避免异步多次重复触发变更检测，避免死循环</span>
        zone<span class="token punctuation">.</span><span class="token function">runOutsideAngular</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span>_time <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong><u><em>Angular 变更检测之生命周期钩子的执行顺序：</em></u></strong></p> <p>由于单项数据流的限制，在组件被检查后，不能在变化检测期间改变组件的某些属性；但绝大多数时候，当 Angular 对子组件进行变更检测时，数据的更新通过共享服务或同步事件进行广播、或直接将父组件注入到子组件中，然后通过生命周期钩子更新父组件的状态：<a href="https://stackblitz.com/edit/angular-zntusy" target="_blank" rel="noopener noreferrer">地址<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">// 父组件</span>
@<span class="token function">Component</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    selector<span class="token operator">:</span> <span class="token string">'my-app'</span><span class="token punctuation">,</span>
    template<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">
        &lt;div [textContent]=&quot;text&quot;&gt;&lt;/div&gt;
        &lt;child-comp&gt;&lt;/child-comp&gt;
    </span><span class="token template-punctuation string">`</span></span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">AppComponent</span> <span class="token punctuation">{</span>
    text <span class="token operator">=</span> <span class="token string">'Original text in parent component'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>


<span class="token comment">// 子组件</span>
@<span class="token function">Component</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    selector<span class="token operator">:</span> <span class="token string">'child-comp'</span><span class="token punctuation">,</span>
    template<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&lt;span&gt;I am child component&lt;/span&gt;</span><span class="token template-punctuation string">`</span></span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">ChildComponent</span> <span class="token punctuation">{</span>
  	<span class="token comment">// 获取到父组件</span>
    <span class="token keyword">constructor</span><span class="token punctuation">(</span><span class="token keyword">private</span> parent<span class="token operator">:</span> AppComponent<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
		<span class="token comment">// 通过父组件直接更新数据</span>
    <span class="token function">ngAfterViewChecked</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>parent<span class="token punctuation">.</span>text <span class="token operator">=</span> <span class="token string">'Updated text in parent component'</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 结果：ExpressionChangedAfterItHasBeenCheckedError</span>
<span class="token comment">// 原因：当 Angular 在子组件中调用 ngAfterViewChecked 生命周期钩子时，父级 App 组件视图的数据绑定已被检查过，但这里在检查后更新了父组件中的 text 属性，导致前后两次绑定表达式的产生结果不一致，报错；</span>
<span class="token comment">// 但是：若将 ngAfterViewChecked 改为 ngOnInit 等其他钩子函数(不含 AfterViewInit、AfterViewChecked)则不会报错</span>
<span class="token comment">// 原因：Angular 在变更检测期间执行的操作顺序</span>
</code></pre></div><p>在获悉 Angular 在变更检测期间执行的操作顺序前，需要搞明白 Angular 中的视图和绑定；在 <code>@angular/core</code> 模块中有一个名为 <code>checkAndUpdateView</code>的函数，它遍历组件树中的视图(组件)，并对每个视图执行检测；可通过 <a href="https://angular-eobrrh.stackblitz.io/" target="_blank" rel="noopener noreferrer">此演示<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 去进行调试：打开控制台，找到函数并打上断点，点击按钮触发变化监测，审查<code>view</code>变量</p> <p><video src="/Image/Frame/Angular/10.mov" align="" style="zoom:50%;"></video></p> <p>结果：第一个 view 会成为宿主视图，其是 Angular 创建的一个根组件，用来托管 app 组件，继续执行，以获得它的子视图，此亦 AppComponent 的视图；</p> <ul><li>component 属性存放了 App 组件的实例；</li> <li>node 属性存放了 DOM 节点的引用，这些 DOM 节点是为 App 组件的模板中的元素创建的；</li> <li>oldValues 数组存储了绑定表达式的结果；</li></ul> <p>关键：<code>checkAndUpdateView</code> 函数(<strong><u><em>先别管上面的调试过程与结果，只须知道此函数即可</em></u></strong>)，可以发现，Angular 会在变化检测期间触发生命周期钩子：当 Angular 处理绑定时，一些钩子在渲染前被调用，一些钩子则在渲染后才被调用</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">checkAndUpdateView</span><span class="token punctuation">(</span><span class="token parameter">view<span class="token punctuation">,</span> <span class="token operator">...</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token operator">...</span>       
    <span class="token comment">// 更新子视图(组件)和指令中的绑定,</span>
    <span class="token comment">// 如果有需要的话，调用 NgOnInit, NgDoCheck and ngOnChanges 钩子</span>
    Services<span class="token punctuation">.</span><span class="token function">updateDirectives</span><span class="token punctuation">(</span>view<span class="token punctuation">,</span> CheckType<span class="token punctuation">.</span>CheckAndUpdate<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token comment">// DOM 更新，为当前视图(组件)执行渲染</span>
    Services<span class="token punctuation">.</span><span class="token function">updateRenderer</span><span class="token punctuation">(</span>view<span class="token punctuation">,</span> CheckType<span class="token punctuation">.</span>CheckAndUpdate<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token comment">// 在子视图(组件)中执行变更检测</span>
    <span class="token function">execComponentViewsAction</span><span class="token punctuation">(</span>view<span class="token punctuation">,</span> ViewAction<span class="token punctuation">.</span>CheckAndUpdate<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token comment">// 调用 AfterViewChecked 和 AfterViewInit 钩子</span>
    <span class="token function">callLifecycleHooksChildrenFirst</span><span class="token punctuation">(</span>…<span class="token punctuation">,</span> NodeFlags<span class="token punctuation">.</span>AfterViewChecked…<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">...</span>
<span class="token punctuation">}</span>
</code></pre></div><img src="/Image/Frame/Angular/11.png" align="" style="zoom:50%;"> <ul><li><p>首先，Angular 为子组件更新输入绑定；</p></li> <li><p>然后，Angular 调用了子组件上的 <code>OnInit</code>、<code>DoCheck</code>、<code>Onchanges</code> 钩子；</p> <ul><li>意义：因子组件刚更新了输入绑定，所以 Angular 需要通知子组件输入绑定已被初始化；</li></ul></li> <li><p>然后，Angular 为子组件执行渲染；</p></li> <li><p>此后，<strong><u><em>Angular 为子组件运行变更检测 Run change detection，即意味着它会在子视图中重复这些操作；</em></u></strong></p></li> <li><p>最后，Angular 调用了子组件上的 <code>AfterViewChecked</code>、<code>AfterViewInit</code> 钩子让子组件知道已被检查；</p> <ul><li>注意：Angular 在处理了父组件的绑定后，才调用子组件的 <code>AfterViewChecked</code> 生命周期钩子；</li> <li>注意：<code>OnInit</code> 钩子在绑定被处理前调用，故即使在 <code>OnInit</code> 中改变 <code>text</code> 值，在随后检查中它仍然是相同的，就解释了在 <code>ngOnInit</code>中不报错的行为；</li></ul></li> <li><p>再说流程：一个运行的 Angular 程序其实一个组件树，在变更检测期间，Angular 会按照以下顺序检查每一个组件：</p> <ul><li><strong><a href="https://link.zhihu.com/?target=https%3A//hackernoon.com/the-mechanics-of-property-bindings-update-in-angular-39c0812bc4ce" target="_blank" rel="noopener noreferrer">更新所有子组件/指令的绑定属性<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></strong>；</li> <li>调用所有子组件/指令的三个生命周期钩子：<code>ngOnInit</code>，<code>OnChanges</code>，<code>ngDoCheck</code>；</li> <li><strong><a href="https://link.zhihu.com/?target=https%3A//hackernoon.com/the-mechanics-of-dom-updates-in-angular-3b2970d5c03d" target="_blank" rel="noopener noreferrer">更新当前组件的 DOM<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></strong>；</li> <li>为子组件执行变更检测 (译者注：在子组件上重复上面三个步骤，依次递归下去)；</li> <li>为所有子组件/指令调用当前组件的 <code>ngAfterViewInit</code> 生命周期钩子；</li></ul></li></ul> <h5 id="_1-4-2-2、变更检测机制总结"><a href="#_1-4-2-2、变更检测机制总结" class="header-anchor">#</a> 1-4-2-2、变更检测机制总结</h5> <p>Angular 中的所有组件，在内部均被表示为一种叫视图的数据结构；</p> <p>Angular 的编译器解析模板并创建绑定，而每一绑定定义了：一个要更新的DOM元素的属性 &amp; 用于求值的表达式；</p> <p>视图中的 <code>oldValues</code>属性存储了在变更检测中被用于比较的旧值；</p> <p>在变更检测期间，Angular 遍历所有绑定，并对表达式求值，将所得的结果与旧值比较，若有必要则更新DOM；</p> <p>每个变更检测循环后，Angular 运行一次检查以确保组建的状态与用户界面同步；这次检查为同步运行并可能会报错<code>ExpressionChangedAfterItWasChecked</code>；</p> <ul><li>参考：https://blog.angularindepth.com/a-gentle-introduction-into-change-detection-in-angular-33f9ffff6f10</li></ul> <h5 id="_1-4-2-3、变更检测触发器-zone"><a href="#_1-4-2-3、变更检测触发器-zone" class="header-anchor">#</a> 1-4-2-3、变更检测触发器 Zone</h5> <h5 id="_1-4-2-3-1、变化源于异步操作"><a href="#_1-4-2-3-1、变化源于异步操作" class="header-anchor">#</a> 1-4-2-3-1、变化源于异步操作</h5> <p><strong><u><em>组件初始化后的 一切 数据变化均是由某个异步事件产生</em></u></strong>；因为：初始化是一个同步过程，在 Angular 框架中，组件初始化对应的就是组件的构造方法被调用，此构造过程是一个同步的过程；而在构造过程后只有异步事件才会令组件中的数据发生变化，比如：点击，Ajax 请求，Promise，setTimeout 或 Websocket 等；</p> <h5 id="_1-4-2-3-2、zone-js"><a href="#_1-4-2-3-2、zone-js" class="header-anchor">#</a> 1-4-2-3-2、Zone.js</h5> <p>为能在上述异步事件发生时及时检查变化，在 Angular 应用启动时会通过 Zone.js 库，为许多浏览器提供的 API 打补丁(可理解为劫持或封装处理)，使用代理方法来代理浏览器 API 的调用，代理方法不仅会调用监听事件时提供的回调函数，还会执行变更检查以及刷新界面；</p> <p>Zone.js 是 Angular 团队在开发 Angular2 时实现的一个独立的库；Angular2 框架直接依赖 Zone.js 来实现变更检查；而 <a href="https://www.cnblogs.com/whitewolf/p/zone-js.html" target="_blank" rel="noopener noreferrer">Zone.js<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 实际上是一个异步操作的执行上下文，它为一组异步操作提供了一个统一的运行环境，并为这组异步过程的生命周期提供钩子方法，以方便在异步事件进行的不同阶段执行一些任务；</p> <p>Zone.js 对浏览器中的 setTimeout、setInterval、setImmediate、以及事件、promise、地理信息geolocation都做了特殊处理；</p> <img src="/Image/Frame/Angular/21.png" align="" style="zoom:50%;"> <img src="/Image/Frame/Angular/22.png" align="" style="zoom:50%;"> <p>首先，zone会将浏览器的原生方法保存在 setNative 中以便将会重用；</p> <p>然后，zone 就开始其暴力行为，覆盖 window[setName] 和 window[clearName]；</p> <p>然后，将对 setName 的调用转到自身的 zone[setName] 的调用(如此暴力的对浏览器原生对象实现了拦截转移)；</p> <p>然后，zone 会在 Task 执行的前后调用自身的 addRepeatingTask、addTask 以及 wtf 事件来应用注册上的所有钩子函数；</p> <p>补丁示例如下：addEventListener(Zone.js v0.6.0 版本)：是浏览器提供的用于监听事件的 API，在 Angular 启动的时候将它替换成了一个新的版本：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">patchEventTargetMethods</span><span class="token punctuation">(</span><span class="token parameter">obj<span class="token punctuation">,</span> addFnName<span class="token punctuation">,</span> removeFnName<span class="token punctuation">,</span> metaCreator</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>addFnName <span class="token operator">===</span> <span class="token keyword">void</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> addFnName <span class="token operator">=</span> <span class="token constant">ADD_EVENT_LISTENER</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>removeFnName <span class="token operator">===</span> <span class="token keyword">void</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> removeFnName <span class="token operator">=</span> <span class="token constant">REMOVE_EVENT_LISTENER</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>metaCreator <span class="token operator">===</span> <span class="token keyword">void</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> metaCreator <span class="token operator">=</span> defaultListenerMetaCreator<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token operator">&amp;&amp;</span> obj<span class="token punctuation">[</span>addFnName<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 将 addEventListener 和 removeEventListener 分别替换为 makeZoneAwareAddListener 和 makeZoneAwareRemoveListener</span>
        <span class="token function">patchMethod</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> addFnName<span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">makeZoneAwareAddListener</span><span class="token punctuation">(</span>addFnName<span class="token punctuation">,</span> removeFnName<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> metaCreator<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">patchMethod</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> removeFnName<span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">makeZoneAwareRemoveListener</span><span class="token punctuation">(</span>removeFnName<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> metaCreator<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 实施替换的方法</span>
<span class="token keyword">function</span> <span class="token function">patchMethod</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> name<span class="token punctuation">,</span> patchFn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> proto <span class="token operator">=</span> target<span class="token punctuation">;</span>
    <span class="token comment">// ...</span>
    <span class="token comment">// 获取带前缀的方法名</span>
    <span class="token keyword">var</span> delegateName <span class="token operator">=</span> <span class="token function">zoneSymbol</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> delegate<span class="token punctuation">;</span>
    <span class="token comment">// 检查是否已经 patch 过</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>proto <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span>delegate <span class="token operator">=</span> proto<span class="token punctuation">[</span>delegateName<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        delegate <span class="token operator">=</span> proto<span class="token punctuation">[</span>delegateName<span class="token punctuation">]</span> <span class="token operator">=</span> proto<span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token comment">// 获取代理方法</span>
        <span class="token keyword">var</span> patchDelegate_1 <span class="token operator">=</span> <span class="token function">patchFn</span><span class="token punctuation">(</span>delegate<span class="token punctuation">,</span> delegateName<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 将代理方法赋给对象的 addEventListener 属性</span>
        proto<span class="token punctuation">[</span>name<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token function">patchDelegate_1</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token comment">// 将原来的方法实现作为属性添加到 proto[name] 上面</span>
        <span class="token function">attachOriginToPatched</span><span class="token punctuation">(</span>proto<span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token punctuation">,</span> delegate<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 返回原方法</span>
    <span class="token keyword">return</span> delegate<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 替换后的 &quot;addEventListener&quot;</span>
<span class="token keyword">function</span> <span class="token function">makeZoneAwareAddListener</span><span class="token punctuation">(</span><span class="token parameter">addFnName<span class="token punctuation">,</span> removeFnName<span class="token punctuation">,</span> useCapturingParam<span class="token punctuation">,</span> allowDuplicates<span class="token punctuation">,</span> isPrepend<span class="token punctuation">,</span> metaCreator</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
    <span class="token comment">// 调度事件的方法</span>
    <span class="token keyword">function</span> <span class="token function">scheduleEventListener</span><span class="token punctuation">(</span><span class="token parameter">eventTask</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> meta <span class="token operator">=</span> eventTask<span class="token punctuation">.</span>data<span class="token punctuation">;</span>
        <span class="token function">attachRegisteredEvent</span><span class="token punctuation">(</span>meta<span class="token punctuation">.</span>target<span class="token punctuation">,</span> eventTask<span class="token punctuation">,</span> isPrepend<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> meta<span class="token punctuation">.</span><span class="token function">invokeAddFunc</span><span class="token punctuation">(</span>addFnSymbol<span class="token punctuation">,</span> eventTask<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 取消事件监听的方法</span>
    <span class="token keyword">function</span> <span class="token function">cancelEventListener</span><span class="token punctuation">(</span><span class="token parameter">eventTask</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> meta <span class="token operator">=</span> eventTask<span class="token punctuation">.</span>data<span class="token punctuation">;</span>
        <span class="token function">findExistingRegisteredTask</span><span class="token punctuation">(</span>meta<span class="token punctuation">.</span>target<span class="token punctuation">,</span> eventTask<span class="token punctuation">.</span>invoke<span class="token punctuation">,</span> meta<span class="token punctuation">.</span>eventName<span class="token punctuation">,</span> meta<span class="token punctuation">.</span>useCapturing<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> meta<span class="token punctuation">.</span><span class="token function">invokeRemoveFunc</span><span class="token punctuation">(</span>removeFnSymbol<span class="token punctuation">,</span> eventTask<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// self 是被监听的对象， args 是监听的事件，包括事件名称和 callback</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token function">zoneAwareAddListener</span><span class="token punctuation">(</span><span class="token parameter">self<span class="token punctuation">,</span> args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 根据事件的名称和回调方法创建封装 ZoneTask 的 data 对象</span>
        <span class="token keyword">var</span> data <span class="token operator">=</span> <span class="token function">metaCreator</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// ...</span>
        <span class="token comment">// 获取当前的 Zone</span>
        <span class="token keyword">var</span> zone <span class="token operator">=</span> Zone<span class="token punctuation">.</span>current<span class="token punctuation">;</span>
        <span class="token keyword">var</span> source <span class="token operator">=</span> data<span class="token punctuation">.</span>target<span class="token punctuation">.</span>constructor<span class="token punctuation">[</span><span class="token string">'name'</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">'.'</span> <span class="token operator">+</span> addFnName <span class="token operator">+</span> <span class="token string">':'</span> <span class="token operator">+</span> data<span class="token punctuation">.</span>eventName<span class="token punctuation">;</span>
        <span class="token comment">// 创建 ZoneTask 并开始调度这个 Task</span>
        zone<span class="token punctuation">.</span><span class="token function">scheduleEventTask</span><span class="token punctuation">(</span>source<span class="token punctuation">,</span> delegate<span class="token punctuation">,</span> data<span class="token punctuation">,</span> scheduleEventListener<span class="token punctuation">,</span> cancelEventListener<span class="token punctuation">)</span><span class="token punctuation">;</span>
      	<span class="token comment">// 注意: 上述方法中又调用了 invokeAddFunc 方法，方法中有如下的语句:</span>
      	<span class="token comment">// this.target[addFnSymbol](this.eventName, delegate.invoke, this.useCapturing);</span>
      	<span class="token comment">// target 是被监听的对象</span>
      	<span class="token comment">// target[addFnSymbol] 是浏览器提供的原始的 addEventListener 方法</span>
      
      	<span class="token comment">// 这里，Zone.js 才真正地将 Task 的 invoke 方法与事件绑定在一起</span>
      	<span class="token comment">// 当事件被触发时，便会调用 Task.invoke 在 invoke 中响应事件执行操作;</span>
      	<span class="token comment">// 当事件发生时，便直接调用 invoke 方法来执行用户提供的 callback 以及其他的操作;</span>
      	<span class="token comment">// 至此也就完成了给 addEventListener 打补丁的工作</span>
      	<span class="token comment">// 总结: 层层封装，层层套娃</span>

    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><img src="/Image/Frame/Angular/12.png" align="" style="zoom:50%;"> <p>总结：Zone 为异步事件的处理提供了代理方法，在所有的异步事件被触发的时，都会先经过 Zone 的代理方法，此后，凡是在 Zone 内执行的异步事件的执行过程都在 Zone 的掌控之下，Zone 也就能知道这组异步事件在什么时候执行完成；而又因数据的变化是且仅可能是由于异步事件而产生，所以 Angular 也就可以通过监听 Zone 的生命周期事件，来得知什么时候应该进行变更检查；</p> <h5 id="_1-4-2-3-3、zone-js-的-ng-应用"><a href="#_1-4-2-3-3、zone-js-的-ng-应用" class="header-anchor">#</a> 1-4-2-3-3、Zone.js 的 NG 应用</h5> <p>Zone.js 向外暴露了一个 Zone 对象，下面是其生命周期中各阶段的钩子方法，这些方法都会在 Zone 的各个生命周期钩子中被调用；</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// NgZone</span>
<span class="token class-name">NgZone</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">onEnter</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>_nesting<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>_isStable<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>_isStable <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>_onUnstable<span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token class-name">NgZone</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">onLeave</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>_nesting<span class="token operator">--</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">checkStable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token class-name">NgZone</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">setHasMicrotask</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">hasMicrotasks</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>_hasPendingMicrotasks <span class="token operator">=</span> hasMicrotasks<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">checkStable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token class-name">NgZone</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">setHasMacrotask</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">hasMacrotasks</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_hasPendingMacrotasks <span class="token operator">=</span> hasMacrotasks<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token class-name">NgZone</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">triggerError</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_onErrorEvents<span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>当 NgZone run 之后，Angular 便会实例化一个叫做 <code>ApplicationRef</code> 的类，其中的 onMicrotaskEmpty 监听到后就会触发变更检测；</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ...  </span>
<span class="token keyword">class</span> <span class="token class-name">ApplicationRef</span> <span class="token punctuation">{</span>
    _views<span class="token operator">:</span>Array <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter"><span class="token keyword">private</span> zone<span class="token operator">:</span> NgZone</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      	<span class="token comment">// onMicrotaskEmpty 事件会在当前 Zone 中的异步过程都已完成时触发</span>
      	<span class="token comment">// 当监听到此事件后就去遍历 View 并且调用每个 view 的 detectChanges 方法来进行变更检查</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>zone<span class="token punctuation">.</span>onMicrotaskEmpty<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>zone<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">tick</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">tick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>_runningTick <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>_views<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">view</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span>  view<span class="token punctuation">.</span>ref<span class="token punctuation">.</span><span class="token function">detectChanges</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>注意：并非所有异步操作都有必要触发变更检查；比如某次异步操作，却没有数据发生变化，则应不必触发；而由于 Angular 应用运行在 NgZone 之中，所有在 NgZone 之中的异步操作都会通知框架进行变更检查；为此，NgZone 提供了一个 <code>runOutsideAngular</code> 方法，可供方法在 NgZone 之外运行，而不会触发 Angular 的变更检查，示例见前文，<a href="http://plnkr.co/edit/j9W2op4lGezi8eexwHg6?p=preview" target="_blank" rel="noopener noreferrer">或看此<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h5 id="_1-4-2-3-4、再述变更检测"><a href="#_1-4-2-3-4、再述变更检测" class="header-anchor">#</a> 1-4-2-3-4、再述变更检测</h5> <p>以下内容<u>基于 Angular2.4.9</u>，补充 JIT 与 AOT 机制：</p> <ul><li>JIT：吞吐量高，有运行时性能加成，可跑得更快，并可做到动态生成代码等，但相对启动速度较慢，并需一定时间和调用频率才能触发 JIT 的分层机制证；</li> <li>AOT：内存占用低启动速度快，无需 runtime 运行，直接将 runtime 静态链接至最终程序中，但无运行时性能加成，不能根据程序运行情况做进一步优化；</li></ul> <img src="/Image/Frame/Angular/14.png" align="" style="zoom:50%;"> <p>非 AOT 模式下 Angular 将在运行时利用 JIT 机制，创建组件的包装类，框架将会为每个组件生成相应的包装类，也即对于每一个组件来讲，Angular 会为其生成至少两个类型 <code>View_ClassName_App</code> 和 <code>Wrapper_ClassName_App</code>，根组件还会生成一个 <code>View_ClassNameApp_Host</code>，来作为应用组件的入口，变更检查也是从这个地方开始；<code>Wrapper_ClassName_App</code> 类主要是提供了组件的生命周期钩子，<code>View_ClassName_App</code> 类主要做了下面5件事：</p> <ul><li>注入依赖；</li> <li>创建组件中的 DOM 元素渲染页面；</li> <li>响应绑定的事件；</li> <li>利用类型为 <code>changeDetectorRef</code> 的变更检查器执行变更检查；</li> <li>提供 debug 信息；</li></ul> <p>Angular 应用是由组件组成的树，每个组件又有自己的变更检查器，于是变更检查器们也组成了一颗变更检查器树；</p> <p>无论哪一个组件的变更检查被触发时 Angular 都会采用 <strong><u><em>深度优先遍历</em></u></strong> 方式从根节点遍历整个变更检查器树；在 JIT 模式下，这些变更检查器会被编译成为 <code>View_ClassName_App</code> 中的<code>detectChangesInternal</code> 方法，在这个方法中组件会对自己内部的数据绑定进行检查，调用自己的 <code>ngOnChanges</code> 生命周期方法，若有子组件则还会调用子组件 <code>internalDetectChanges</code> 方法，如此不断，将检查沿着树枝的方向进行下去，如下图；此树也可描述 Angular 中组件的数据流是从上往下流动(原因是变更检查也是从上到下)；</p> <img src="/Image/Frame/Angular/13.png" align="" style="zoom:50%;"> <p><strong><u><em>比如</em></u></strong>：在文本框中输入文字时，就会马上触发组件的变更检查，此时调用了 <code>View_InventoryApp0.detectChangesInternal</code> 方法：</p> <p><strong><u><em>首先</em></u></strong>，仔细留意末行，调用了 <code>jit_checkBinding25</code> 方法，其会比较新旧两个值是否相同，此方法是框架编译生成的方法，在运行时找到实际上调用的是 <code>view_utils.checkBinding</code> 方法，若<code>throwOnChange</code> 的值为 false，则使用 <code>looseIdentical</code> 来进行新旧值的比较，方法存在于 lang.js：</p> <img src="/Image/Frame/Angular/15.png" align="" style="zoom:50%;"> <img src="/Image/Frame/Angular/17.png" align="" style="zoom:70%;"> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">looseIdentical</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> a <span class="token operator">===</span> b <span class="token operator">||</span> <span class="token keyword">typeof</span> a <span class="token operator">===</span> <span class="token string">'number'</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">typeof</span> b <span class="token operator">===</span> <span class="token string">'number'</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isNaN</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isNaN</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 注意: 只是简单比较了引用或者值是否相同，并无做深度比较；所以数组或者对象等集合类型内部的值发生变化，Angular 并不能检查到</span>
</code></pre></div><p><strong><u><em>然后</em></u></strong>，Angular 在检查变更之后立即更新了视图：</p> <img src="/Image/Frame/Angular/18.png" align="" style="zoom:80%;"> <div class="language- extra-class"><pre class="language-text"><code>if (jit_checkBinding24(throwOnChange,self._expr_32,currVal_32)) {
    self.renderer.setText(self._text_5,currVal_32);
    self._expr_32 = currVal_32;
}
</code></pre></div><p>当前组件所有的变更检查执行完成后，开始检查子组件的变更，然后变更检查器会按照深度优先的规则遍历整个组件树，直到所有节点的变更检查都完成为止；</p> <p>由于单向数据流的原因，变更检查只需要执行一遍就可稳定下来，若在首次检查中产生副作用使得已检查过的节点发生了变化，Angular 会抛出异常(在开发模式开启二次检查机制，以避免上线发生此种情况)；抛出前面提到错误 ExpressionChangedAfterItHasBeenCheckedError；</p> <p><strong><u><em>优化：OnPush 策略</em></u></strong></p> <p>默认情况下，Angular使用<code>ChangeDetectionStrategy.Default</code>策略来进行变更检测；而在此 Default 模式下，每一组异步操作结束后(用户事件、记时器、XHR、promise等事件使应用中的数据将发生了改变时)，都会触发对整个组件树的变更检查；</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 子组件</span>
@<span class="token function">Component</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  template<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">
    &lt;h1&gt;Hello {{name}}!&lt;/h1&gt;
    {{runChangeDetection}}
  </span><span class="token template-punctuation string">`</span></span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">HelloComponent</span> <span class="token punctuation">{</span>
  @<span class="token function">Input</span><span class="token punctuation">(</span><span class="token punctuation">)</span> name<span class="token operator">:</span> string<span class="token punctuation">;</span>
  <span class="token keyword">get</span> <span class="token function">runChangeDetection</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Checking the view'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 根组件</span>
@<span class="token function">Component</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  template<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">
    &lt;hello&gt;&lt;/hello&gt;
    &lt;button (click)=&quot;onClick()&quot;&gt;Trigger change detection&lt;/button&gt;
  </span><span class="token template-punctuation string">`</span></span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">AppComponent</span>  <span class="token punctuation">{</span>
  <span class="token function">onClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 执行以上代码后，每当我们点击按钮时。Angular 将会执行一遍变更检测循环，此时还会输出 &quot;Checking the view&quot;</span>
<span class="token comment">// 这种技术被称作脏检查。为了知道视图是否需要更新，Angular 需要访问新值并和旧值比较来判断是否需要更新视图;</span>
<span class="token comment">// 注意: 如果有一个有成千上万个表达式的大应用，Angular 去检查每一个表达式，我们可能会遇到性能上的问题;</span>
</code></pre></div><p>但在某些场景下，某些组件是不需要每次都被检查，此时可启用 OnPush 模式，与 Angular 约定强制使用不可变对象，Angular 将跳过对该组件的全部变化监测(含子组件)，直到有属性的引用发生变化为止，来避免不必要的变更检查以提升应用性能；</p> <ul><li>补充：不可变对象：保证对象不会改变，即当其内部属性发生变化时，将会用新对象来替代旧对象；不可变对象仅仅依赖初始化时的属性，也即初始化时候属性没有改变，没有改变就不会产生一份新的引用；</li></ul> <p>若需要在 Angular 中使用不可变对象，则需要设置 <code>changeDetection: ChangeDetectionStrategy.OnPush</code></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 开启 OnPush 策略</span>
@<span class="token function">Component</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  changeDetection<span class="token operator">:</span> ChangeDetectionStrategy<span class="token punctuation">.</span>OnPush
<span class="token punctuation">}</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">InventoryApp</span> <span class="token punctuation">{</span>
	<span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这将告诉Angular该组件仅仅依赖于它的<code>@inputs()</code>，只有在以下几种情况才需要检查：</p> <p><strong><u><em>1、Input 引用发生改变</em></u></strong></p> <p>在变更检测的上下文中使用不可变对象好处是：Angular 可通过检查引用是否发生了改变来判断视图是否需要检查；这比深度检查要容易很多：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 子组件</span>
@<span class="token function">Component</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  selector<span class="token operator">:</span> <span class="token string">'tooltip'</span><span class="token punctuation">,</span>
  template<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">
    &lt;h1&gt;{{config.position}}&lt;/h1&gt;
    {{runChangeDetection}}
  </span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span>
  <span class="token comment">// 开启 OnPush</span>
  changeDetection<span class="token operator">:</span> ChangeDetectionStrategy<span class="token punctuation">.</span>OnPush
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">TooltipComponent</span>  <span class="token punctuation">{</span>
  @<span class="token function">Input</span><span class="token punctuation">(</span><span class="token punctuation">)</span> config<span class="token punctuation">;</span>
  <span class="token keyword">get</span> <span class="token function">runChangeDetection</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Checking the view'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 父组件</span>
@<span class="token function">Component</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  template<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">
    &lt;tooltip [config]=&quot;config&quot;&gt;&lt;/tooltip&gt;
  </span><span class="token template-punctuation string">`</span></span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">AppComponent</span>  <span class="token punctuation">{</span>
  config <span class="token operator">=</span> <span class="token punctuation">{</span>
    position<span class="token operator">:</span> <span class="token string">'top'</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token comment">// config 引用地址未改变，子组件将不会进行变更检测，不会进行新旧值比较 if( oldValue !== newValue ) {  runChangeDetection(); }，视图未刷新</span>
  <span class="token function">onClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>config<span class="token punctuation">.</span>position <span class="token operator">=</span> <span class="token string">'bottom'</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
	<span class="token comment">// config 引用地址改变后，视图被检查，新值被展示</span>
  <span class="token function">onClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>config <span class="token operator">=</span> <span class="token punctuation">{</span>
      position<span class="token operator">:</span> <span class="token string">'bottom'</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">//  注意: 此时点击按钮时看不到任何日志，因为 Angular 将旧值和新值的引用进行比较，上述变量的引用地址未被改变，故未被触发</span>
</code></pre></div><p><strong><u><em>2、源于该组件或其子组件的事件</em></u></strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 当在一个组件或者其子组件中触发了某一个事件时，这个组件的内部状态会更新</span>
@<span class="token function">Component</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  template<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">
    &lt;button (click)=&quot;add()&quot;&gt;Add&lt;/button&gt;
    {{count}}
  </span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span>
  <span class="token comment">// 开启 OnPush</span>
  changeDetection<span class="token operator">:</span> ChangeDetectionStrategy<span class="token punctuation">.</span>OnPush
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">CounterComponent</span> <span class="token punctuation">{</span>
  count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>count<span class="token operator">++</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 注意：此规则只适用于 DOM 事件，API 并不会触发变更检测</span>
<span class="token comment">// 下列情况中，count 属性发生改变但视图未更改，只有点击时才会更改，但视图会显示 x+1，而非显示 0+1 的 1</span>
@<span class="token function">Component</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  template<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">...</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span>
  <span class="token comment">// 开启 OnPush</span>
  changeDetection<span class="token operator">:</span> ChangeDetectionStrategy<span class="token punctuation">.</span>OnPush
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">CounterComponent</span> <span class="token punctuation">{</span>
  count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>count <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>count <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>count <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token keyword">this</span><span class="token punctuation">.</span>http<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'https://count.com'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token parameter">res</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>count <span class="token operator">=</span> res<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>count<span class="token operator">++</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong><u><em>3、显式的去执行变更检测</em></u></strong></p> <p>Angular给我们提供了3种方法来触发变更检测：</p> <ul><li><code>detectChanges()</code>：告诉 Angular 在该组件和它的子组件中去执行变更检测；</li> <li><code>ApplicationRef.tick()</code>：告诉 Angular 来对整个应用程序执行变更检测；</li> <li><code>markForCheck()</code>：它不会触发变更检测；相反，它会将所有设置了onPush 的祖先标记，在当前或下一次变更检测循环中检测；</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// detectChanges </span>
<span class="token comment">// 告诉 Angular 在该组件和它的子组件中去执行变更检测</span>
@<span class="token function">Component</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  selector<span class="token operator">:</span> <span class="token string">'counter'</span><span class="token punctuation">,</span>
  template<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">{{count}}</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span>
  changeDetection<span class="token operator">:</span> ChangeDetectionStrategy<span class="token punctuation">.</span>OnPush
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">CounterComponent</span> <span class="token punctuation">{</span> 
  count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter"><span class="token keyword">private</span> cdr<span class="token operator">:</span> ChangeDetectorRef</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>count <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>cdr<span class="token punctuation">.</span><span class="token function">detectChanges</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// tick</span>
<span class="token comment">// 告诉 Angular 来对整个应用程序执行变更检测；</span>
<span class="token function">tick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>_views<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">view</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> view<span class="token punctuation">.</span><span class="token function">detectChanges</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// ...</span>
  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// markForCheck</span>
<span class="token comment">// 它不会触发变更检测；相反，它会将所有设置了onPush 的祖先标记，在当前或下一次变更检测循环中检测；</span>
<span class="token function">markForCheck</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span> <span class="token punctuation">{</span> 
  <span class="token function">markParentViewsForCheck</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>_view<span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">markParentViewsForCheck</span><span class="token punctuation">(</span><span class="token parameter">view<span class="token operator">:</span> ViewData</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> currView<span class="token operator">:</span> ViewData<span class="token operator">|</span><span class="token keyword">null</span> <span class="token operator">=</span> view<span class="token punctuation">;</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>currView<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>currView<span class="token punctuation">.</span>def<span class="token punctuation">.</span>flags <span class="token operator">&amp;</span> ViewFlags<span class="token punctuation">.</span>OnPush<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      currView<span class="token punctuation">.</span>state <span class="token operator">|=</span> ViewState<span class="token punctuation">.</span>ChecksEnabled<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    currView <span class="token operator">=</span> currView<span class="token punctuation">.</span>viewContainerParent <span class="token operator">||</span> currView<span class="token punctuation">.</span>parent<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong><u><em>4、Angular Async Pipe</em></u></strong></p> <p><code>async</code> pipe会订阅一个 Observable 或 Promise，并返回它发出的最近一个值；</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 一个 input() 是 observable 的 OnPush 组件</span>
<span class="token comment">// 点击按钮并不能看到视图更新，因为上述提到的几种情况均未发生，所以 Angular 在当前变更检测循环并不会检查该组件</span>
<span class="token comment">// App 组件</span>
@<span class="token function">Component</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  template<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">
    &lt;button (click)=&quot;add()&quot;&gt;Add&lt;/button&gt;
    &lt;app-list [items$]=&quot;items$&quot;&gt;&lt;/app-list&gt;
  </span><span class="token template-punctuation string">`</span></span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">AppComponent</span> <span class="token punctuation">{</span>
  items <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  items$ <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BehaviorSubject</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span> title<span class="token operator">:</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>items$<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// List 组件</span>
@<span class="token function">Component</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  template<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">
     &lt;div *ngFor=&quot;let item of _items ; &quot;&gt;{{item.title}}&lt;/div&gt;
  </span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span>
  changeDetection<span class="token operator">:</span> ChangeDetectionStrategy<span class="token punctuation">.</span>OnPush
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">ListComponent</span> <span class="token keyword">implements</span> <span class="token class-name">OnInit</span> <span class="token punctuation">{</span>
  @<span class="token function">Input</span><span class="token punctuation">(</span><span class="token punctuation">)</span> items<span class="token operator">:</span> Observable<span class="token operator">&lt;</span>Item<span class="token operator">&gt;</span><span class="token punctuation">;</span>
  _items<span class="token operator">:</span> Item<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token function">ngOnInit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// Observable </span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token parameter">items</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>_items <span class="token operator">=</span> items<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// Use Async Pipe</span>
<span class="token comment">// 当点击按钮时，视图也更新了，原因是当新的值被发射出来时，async pipe 将该组件标记为发生了更改需要检查</span>
@<span class="token function">Component</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  template<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">
    &lt;div *ngFor=&quot;let item of items | async&quot;&gt;{{item.title}}&lt;/div&gt;
  </span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span>
  changeDetection<span class="token operator">:</span> ChangeDetectionStrategy<span class="token punctuation">.</span>OnPush
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">ListComponent</span> <span class="token keyword">implements</span> <span class="token class-name">OnInit</span> <span class="token punctuation">{</span>
  @<span class="token function">Input</span><span class="token punctuation">(</span><span class="token punctuation">)</span> items<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// async pipe 内部原理实际还是利用 markForCheck</span>
<span class="token comment">// 所以上述情况中，Angular 为其调用 markForCheck()，所以能看到视图更新了即使 input 引用没有发生改变</span>
<span class="token keyword">private</span> <span class="token function">_updateLatestValue</span><span class="token punctuation">(</span>async<span class="token operator">:</span> any<span class="token punctuation">,</span> value<span class="token operator">:</span> Object<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>async <span class="token operator">===</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>_latestValue <span class="token operator">=</span> value<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>_ref<span class="token punctuation">.</span><span class="token function">markForCheck</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 懵：如果一个组件仅仅依赖于它的input属性，并且input属性是observable，那么这个组件只有在它的input属性发射一个事件的时候才会发生改变</span>
</code></pre></div><p><strong><u><em>OnPush 与视图检查：</em></u></strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 父组件 Tabs</span>
@<span class="token function">Component</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  selector<span class="token operator">:</span> <span class="token string">'app-tabs'</span><span class="token punctuation">,</span>
  template<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&lt;ng-content&gt;&lt;/ng-content&gt;</span><span class="token template-punctuation string">`</span></span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">TabsComponent</span> <span class="token keyword">implements</span> <span class="token class-name">OnInit</span> <span class="token punctuation">{</span>
  <span class="token comment">// 获取 tab 子组件</span>
  @<span class="token function">ContentChild</span><span class="token punctuation">(</span>TabComponent<span class="token punctuation">)</span> tab<span class="token operator">:</span> TabComponent<span class="token punctuation">;</span>
  <span class="token function">ngAfterContentInit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>tab<span class="token punctuation">.</span>content <span class="token operator">=</span> <span class="token string">'Content'</span><span class="token punctuation">;</span> 
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 子组件 Tab</span>
@<span class="token function">Component</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  selector<span class="token operator">:</span> <span class="token string">'app-tab'</span><span class="token punctuation">,</span>
  template<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">{{content}}</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span>
  <span class="token comment">// 开启 OnPush</span>
  changeDetection<span class="token operator">:</span> ChangeDetectionStrategy<span class="token punctuation">.</span>OnPush
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">TabComponent</span> <span class="token punctuation">{</span>
  @<span class="token function">Input</span><span class="token punctuation">(</span><span class="token punctuation">)</span> content<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token operator">&lt;</span>app<span class="token operator">-</span>tabs<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>app<span class="token operator">-</span>tab<span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>app<span class="token operator">-</span>tab<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>app<span class="token operator">-</span>tabs<span class="token operator">&gt;</span>
<span class="token comment">// 注意，上述 Angular 不知道正在更新 tab 组件的 input 属性</span>
<span class="token comment">// 在模板中定义 input()是让 Angular 知道应在变更检测循环中检查此属性的唯一途径;</span>
<span class="token comment">// 在模板中定义 input()是让 Angular 知道应在变更检测循环中检查此属性的唯一途径;</span>
<span class="token comment">// 在模板中定义 input()是让 Angular 知道应在变更检测循环中检查此属性的唯一途径;</span>

<span class="token comment">// 比如</span>
<span class="token comment">// 若明确的在模板中定义了 input()，Angular 会创建一个叫 updateRenderer() 方法，它会在每个变更检测循环中都对 content 的值进行追踪。</span>
<span class="token comment">// &lt;app-tabs&gt;</span>
<span class="token comment">//   &lt;app-tab [content]=&quot;content&quot;&gt;&lt;/app-tab&gt;</span>
<span class="token comment">// &lt;/app-tabs&gt;</span>

<span class="token comment">// 在这种情况下, 即未添加 input，简单的解决办法使用setter然后调用markForCheck()。</span>
@<span class="token function">Component</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  selector<span class="token operator">:</span> <span class="token string">'app-tab'</span><span class="token punctuation">,</span>
  template<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">
    {{_content}}
  </span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span>
  changeDetection<span class="token operator">:</span> ChangeDetectionStrategy<span class="token punctuation">.</span>OnPush
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">TabComponent</span> <span class="token punctuation">{</span>
  _content<span class="token punctuation">;</span>
  @<span class="token function">Input</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">set</span> <span class="token function">content</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>_content <span class="token operator">=</span> value<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>cdr<span class="token punctuation">.</span><span class="token function">markForCheck</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter"><span class="token keyword">private</span> cdr<span class="token operator">:</span> ChangeDetectorRef</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong><u><em>OnPush++</em></u></strong></p> <p>onPush组件越多，Angular需要执行的检查就越少</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 1、原版</span>
<span class="token comment">// 一个 todos 组件，它有一个 todos 作为 input()。</span>
<span class="token comment">// todos 组件</span>
@<span class="token function">Component</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  selector<span class="token operator">:</span> <span class="token string">'app-todos'</span><span class="token punctuation">,</span>
  template<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">
     &lt;div *ngFor=&quot;let todo of todos&quot;&gt;
       {{todo.title}} - {{runChangeDetection}}
     &lt;/div&gt;
  </span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span>
  changeDetection<span class="token operator">:</span> ChangeDetectionStrategy<span class="token punctuation">.</span>OnPush
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">TodosComponent</span> <span class="token punctuation">{</span>
  @<span class="token function">Input</span><span class="token punctuation">(</span><span class="token punctuation">)</span> todos<span class="token punctuation">;</span>
  <span class="token keyword">get</span> <span class="token function">runChangeDetection</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'TodosComponent - Checking the view'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// App 组件</span>
@<span class="token function">Component</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  template<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">
    &lt;button (click)=&quot;add()&quot;&gt;Add&lt;/button&gt;
    &lt;app-todos [todos]=&quot;todos&quot;&gt;&lt;/app-todos&gt;</span><span class="token template-punctuation string">`</span></span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">AppComponent</span> <span class="token punctuation">{</span>
  todos <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">{</span> title<span class="token operator">:</span> <span class="token string">'One'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> title<span class="token operator">:</span> <span class="token string">'Two'</span> <span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>todos <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token keyword">this</span><span class="token punctuation">.</span>todos<span class="token punctuation">,</span> <span class="token punctuation">{</span> title<span class="token operator">:</span> <span class="token string">'Three'</span> <span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 缺点: 当单击添加按钮时，即使之前的数据没有任何更改，Angular 也需要检查每个 todo。因此第一次单击后，控制台中将显示三个日志。</span>
<span class="token comment">// 但在上面的示例中，只有一个表达式需要检查，但是想象一下如果是一个有多个绑定（ngIf，ngClass，表达式等）的真实组件，这将会非常耗性能, 且白白的执行变更检测</span>



<span class="token comment">// 2、优化版</span>
<span class="token comment">// 创建一个 todo 组件并将其变更检测策略定义为 onPush</span>
<span class="token comment">// todo 组件</span>
@<span class="token function">Component</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  selector<span class="token operator">:</span> <span class="token string">'app-todo'</span><span class="token punctuation">,</span>
  template<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">{{todo.title}} {{runChangeDetection}}</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span>
  changeDetection<span class="token operator">:</span> ChangeDetectionStrategy<span class="token punctuation">.</span>OnPush
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">TodoComponent</span> <span class="token punctuation">{</span>
  @<span class="token function">Input</span><span class="token punctuation">(</span><span class="token punctuation">)</span> todo<span class="token punctuation">;</span>
  <span class="token keyword">get</span> <span class="token function">runChangeDetection</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'TodoComponent - Checking the view'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// todos 组件</span>
@<span class="token function">Component</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  selector<span class="token operator">:</span> <span class="token string">'app-todos'</span><span class="token punctuation">,</span>
  template<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">
    &lt;app-todo [todo]=&quot;todo&quot; *ngFor=&quot;let todo of todos&quot;&gt;&lt;/app-todo&gt;
  </span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span>
  changeDetection<span class="token operator">:</span> ChangeDetectionStrategy<span class="token punctuation">.</span>OnPush
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">TodosComponent</span> <span class="token punctuation">{</span>
  @<span class="token function">Input</span><span class="token punctuation">(</span><span class="token punctuation">)</span> todos<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// App 组件</span>
@<span class="token function">Component</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  template<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">
    &lt;button (click)=&quot;add()&quot;&gt;Add&lt;/button&gt;
    &lt;app-todos [todos]=&quot;todos&quot;&gt;&lt;/app-todos&gt;</span><span class="token template-punctuation string">`</span></span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">AppComponent</span> <span class="token punctuation">{</span>
  todos <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">{</span> title<span class="token operator">:</span> <span class="token string">'One'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> title<span class="token operator">:</span> <span class="token string">'Two'</span> <span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>todos <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token keyword">this</span><span class="token punctuation">.</span>todos<span class="token punctuation">,</span> <span class="token punctuation">{</span> title<span class="token operator">:</span> <span class="token string">'Three'</span> <span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 现在，当我们单击添加按钮时，控制台中只会看到一个日志，因为其他的 todo 组件的 input 均未更改，因此不会去检查其视图</span>
<span class="token comment">// 并且，通过创建更小粒度的组件，我们的代码变得更具可读性和可重用性</span>
</code></pre></div><p><strong><u><em>OnPush示例</em></u></strong>：</p> <p><a href="https://plnkr.co/edit/zGNlvnYsPSKbQPv7HxX3?p=preview&amp;preview" target="_blank" rel="noopener noreferrer">示例地址<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>；黄色部分是父组件，灰色的部分是子组件，子组件开启了 OnPush 模式；</p> <p>当点击黄色部分时，虽改变了 <code>this.person.name</code> 值，但是此变化并不能被框架检测到，也即反映在视图上；因为开启了 OnPush 模式的组件，它的变更检查器将会被关闭，它与它的子节点都无法再检查到父组件带来的变更；但注意：由节点内部产生的变化依然会触发变更检查；</p> <img src="/Image/Frame/Angular/20.png" align="" style="zoom:50%;"> <p>点击灰色部分，也即被设置为 OnPush 模式的子组件，此时触发了子组件中的 onclick 方法，改变了 <code>this.person.name</code> 的值，由于此变更是由子组件内部事件导致，这时将会触发变更检查，视图上的文字也会被更新；</p> <h5 id="_1-4-2-3-5、变更检测机制再总结"><a href="#_1-4-2-3-5、变更检测机制再总结" class="header-anchor">#</a> 1-4-2-3-5、变更检测机制再总结</h5> <img src="/Image/Frame/Angular/19.png" align="" style="zoom:50%;"> <ol><li>Zone.js 为浏览器 API 打补丁</li> <li>NgZone 初始化，监听当前 Zone 中的异步事件执行是否完成</li> <li>异步事件执行结束后出发 tick 方法开始变更检查</li> <li>变更检查由根组件开始按照深度优先遍历变更检查器树</li> <li>在每个数据绑定的检查结束之后，立即更新视图</li> <li>在继续检查子组件直到所有组件检查完成</li></ol> <p>参考：https://skyfly.xyz/2017/07/04/Front_End/Angular/AngularChangeDetection/</p> <p>参考：https://zhuanlan.zhihu.com/p/96486260</p> <p>补充：https://zhuanlan.zhihu.com/p/97884917</p> <h3 id="_1-5、状态管理"><a href="#_1-5、状态管理" class="header-anchor">#</a> 1-5、状态管理</h3> <h4 id="_1-5-1、vue"><a href="#_1-5-1、vue" class="header-anchor">#</a> 1-5-1、Vue</h4> <img src="/Image/Frame/Vue/37.png" style="zoom:50%;"> <p>Vue 通过 <a href="https://vuex.vuejs.org/zh-cn/intro.html" target="_blank" rel="noopener noreferrer">Vuex<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 进行应用的状态管理，其借鉴了Flux、redux 基本思想，将共享数据抽离到全局，以单例形式存放，同时利用 Vue 的响应式机制来进行数据状态管理与更新；Vuex实现了一个单向数据流：</p> <ul><li>首先，在全局通过 State 存放数据，而所有修改 State 的操作，均须通过 Mutation 进行，同时其还提供订阅者模式以供外部插件调用获取 State 数据更新；</li> <li>然后，所有异步接口均须通过 Action 操作(常见于调用后端接口异步获取更新数据)；
<ul><li>注意 Action也是无法直接修改 State，仍需通过 Mutation 来修改 State 中数据；</li></ul></li> <li>最后，根据 State 变化，渲染到视图上；
<ul><li>注意：Vuex 运行依赖于 Vue 内部数据双向绑定机制，故需 new一个Vue对象来实现&quot;响应式化”；</li></ul></li></ul> <p>安装：只需提供 store，然后执行下述代码即可完成 Vuex 的引入：</p> <div class="language-js extra-class"><pre class="language-js"><code>Vue<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>Vuex<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 将 store 放入 Vue 创建时的 option 中</span>
<span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    el<span class="token operator">:</span> <span class="token string">'#app'</span><span class="token punctuation">,</span>
    store
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>补充：Vue.use 原理 &amp; Vuex.init</p> <p>Vue 提供 <a href="https://cn.vuejs.org/v2/api/#Vue-use" target="_blank" rel="noopener noreferrer">Vue.use <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>方法来给 Vue 安装插件，其内部通过调用插件的 install 方法(当插件是一个对象时)来进行插件安装，从而将上述代码中的 store 注入到 Vue 实例中去；注意：因 Vue 版本不同；Vue.use 会有不同处理(applyMixin-&gt;VueInit)，若为版本1则将 VueInit 放入 init 方法中，若为版本2则将 VueInit 混淆进 beforeCreate 钩子中；</p> <p>在 Vuex.init 中，根节点执行或使用 store，子组件则直接从父组件中获取 $store，保证所有组件都公用了全局的同一份 store</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 一是防止 Vuex 被重复安装</span>
<span class="token comment">// 二是执行 applyMixin，目的是执行 vuexInit 方法初始化 Vuex</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">install</span> <span class="token punctuation">(</span><span class="token parameter">_Vue</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>Vue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 避免重复安装</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>
        <span class="token string">'[vuex] already installed. Vue.use(Vuex) should be called only once.'</span>
      <span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 保存 Vue，同时用于检测是否重复安装</span>
  Vue <span class="token operator">=</span> _Vue
  <span class="token comment">// 将 vuexInit 混淆进 Vue 的 beforeCreate(Vue2.0) 或 _init方法(Vue1.0)</span>
  <span class="token function">applyMixin</span><span class="token punctuation">(</span>Vue<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// ...</span>

<span class="token comment">// Vuex 的 init 钩子，会存入每一个 Vue 实例等钩子列表</span>
<span class="token keyword">function</span> <span class="token function">vuexInit</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> options <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$options
  <span class="token comment">// store injection</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>options<span class="token punctuation">.</span>store<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 存在 store 其实代表的就是 Root 节点，直接执行 store(function时) 或使用 store(非function)</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>$store <span class="token operator">=</span> <span class="token keyword">typeof</span> options<span class="token punctuation">.</span>store <span class="token operator">===</span> <span class="token string">'function'</span>
      <span class="token operator">?</span> options<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token operator">:</span> options<span class="token punctuation">.</span>store
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>options<span class="token punctuation">.</span>parent <span class="token operator">&amp;&amp;</span> options<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>$store<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 子组件直接从父组件中获取 $store，以保证了所有组件都公用了全局的同一份 store</span>
    <span class="token comment">// 如此便可以在每一个组件中通过 this.$store 访问全局的 Store 实例</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>$store <span class="token operator">=</span> options<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>$store
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h5 id="_1-5-1-1、store"><a href="#_1-5-1-1、store" class="header-anchor">#</a> 1-5-1-1、Store</h5> <p>上述传入根组件的 store，即 Store 实例，其使用 Vuex 提供的 Store 方法构造：</p> <p>Store 构造类初始化了些内部变量，并主要执行 installModule (初始化module) 以及 resetStoreVM (通过 VM 使 store &quot;响应式&quot;)</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    strict<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    modules<span class="token operator">:</span> <span class="token punctuation">{</span>
        moduleA<span class="token punctuation">,</span>
        moduleB
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Store constructor</span>
<span class="token function">constructor</span> <span class="token punctuation">(</span><span class="token parameter">options <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// Auto install if it is not done yet and `window` has `Vue`.</span>
    <span class="token comment">// To allow users to avoid auto-installation in some cases,</span>
    <span class="token comment">// this code should be placed here. See #731</span>
  	<span class="token comment">// 在浏览器环境下，如果插件还未安装（!Vue即判断是否未安装），则它会自动安装。</span>
  	<span class="token comment">// 允许用户在某些情况下避免自动安装;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>Vue <span class="token operator">&amp;&amp;</span> <span class="token keyword">typeof</span> window <span class="token operator">!==</span> <span class="token string">'undefined'</span> <span class="token operator">&amp;&amp;</span> window<span class="token punctuation">.</span>Vue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">install</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>Vue<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">assert</span><span class="token punctuation">(</span>Vue<span class="token punctuation">,</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">must call Vue.use(Vuex) before creating a store instance.</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
      <span class="token function">assert</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> Promise <span class="token operator">!==</span> <span class="token string">'undefined'</span><span class="token punctuation">,</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">vuex requires a Promise polyfill in this browser.</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
      <span class="token function">assert</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token keyword">instanceof</span> <span class="token class-name">Store</span><span class="token punctuation">,</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Store must be called with the new operator.</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">const</span> <span class="token punctuation">{</span>
      <span class="token comment">// 包含应用在 store 上的插件方法</span>
      <span class="token comment">// 这些插件直接接收 store 作为唯一参数</span>
      <span class="token comment">// 可监听 mutation（用于外部地数据持久化、记录或调试）或提交 mutation （用于内部数据，例如 websocket 或 某些观察者）</span>
      plugins <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
      <span class="token comment">// 让 Vuex store 进入严格模式，此时的任何 mutation 处理函数以外修改 Vuex state 都会抛出错误</span>
      strict <span class="token operator">=</span> <span class="token boolean">false</span>
    <span class="token punctuation">}</span> <span class="token operator">=</span> options

    <span class="token comment">// 从 option 中取出 state，若为 function 则执行，最终得到一个对象</span>
    <span class="token keyword">let</span> <span class="token punctuation">{</span> state <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token punctuation">}</span> <span class="token operator">=</span> options
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> state <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> state <span class="token operator">=</span> <span class="token function">state</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>

    <span class="token comment">// store internal state</span>
    <span class="token comment">// 用来判断严格模式下是否是用 mutation 修改 state</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>_committing <span class="token operator">=</span> <span class="token boolean">false</span>
    <span class="token comment">// 存放 action</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>_actions <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>
    <span class="token comment">// 存放 mutation</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>_mutations <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>
    <span class="token comment">// 存放 getter</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>_wrappedGetters <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>
    <span class="token comment">// module 收集器</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>_modules <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ModuleCollection</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span>
    <span class="token comment">// 根据 namespace 存放 module</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>_modulesNamespaceMap <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>
    <span class="token comment">// 存放订阅者</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>_subscribers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token comment">// 用以实现 Watch 的 Vue 实例</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>_watcherVM <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token comment">// bind commit and dispatch to self</span>
    <span class="token comment">// 将 dispatch 与 commit 调用的 this 绑定为 store 对象本身，否则在组件内部 this.dispatch 时的 this 会指向组件的 vm</span>
    <span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token keyword">this</span>
    <span class="token keyword">const</span> <span class="token punctuation">{</span> dispatch<span class="token punctuation">,</span> commit <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">this</span>
    <span class="token comment">// 为 dispatch 与 commit 绑定 this (Store实例本身)</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">dispatch</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">boundDispatch</span> <span class="token punctuation">(</span><span class="token parameter">type<span class="token punctuation">,</span> payload</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token function">dispatch</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>store<span class="token punctuation">,</span> type<span class="token punctuation">,</span> payload<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">commit</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">boundCommit</span> <span class="token punctuation">(</span><span class="token parameter">type<span class="token punctuation">,</span> payload<span class="token punctuation">,</span> options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token function">commit</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>store<span class="token punctuation">,</span> type<span class="token punctuation">,</span> payload<span class="token punctuation">,</span> options<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// strict mode</span>
    <span class="token comment">// 严格模式(使 Vuex store 进入严格模式，此时任何 mutation 处理函数以外修改 Vuex state 都会抛出错误)</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>strict <span class="token operator">=</span> strict

    <span class="token comment">// init root module.</span>
    <span class="token comment">// this also recursively registers all sub-modules</span>
    <span class="token comment">// and collects all module getters inside this._wrappedGetters</span>
    <span class="token comment">// 初始化根 module，同时递归注册了所有子 modle，收集所有 module 的 getter 到 _wrappedGetters 中去</span>
  	<span class="token comment">// this._modules.root 代表根 module才独有保存的 Module 对象</span>
    <span class="token function">installModule</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> state<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_modules<span class="token punctuation">.</span>root<span class="token punctuation">)</span>

    <span class="token comment">// initialize the store vm, which is responsible for the reactivity</span>
    <span class="token comment">// (also registers _wrappedGetters as computed properties)</span>
    <span class="token comment">// 通过 vm 重设 store，新建 Vue 对象使用 Vue 内部的响应式实现注册 state 及 computed</span>
    <span class="token function">resetStoreVM</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> state<span class="token punctuation">)</span>

    <span class="token comment">// apply plugins</span>
    <span class="token comment">// 调用插件</span>
    plugins<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">plugin</span> <span class="token operator">=&gt;</span> <span class="token function">plugin</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

    <span class="token comment">// devtool 插件</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>Vue<span class="token punctuation">.</span>config<span class="token punctuation">.</span>devtools<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">devtoolPlugin</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
</code></pre></div><h5 id="_1-5-1-2、store-installmodule"><a href="#_1-5-1-2、store-installmodule" class="header-anchor">#</a> 1-5-1-2、Store-installModule</h5> <p>作用是用为 module 加上 namespace名字空间后，注册 mutation、action 及 getter，同时递归安装所有子 module</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//  初始化 module</span>
<span class="token keyword">function</span> <span class="token function">installModule</span> <span class="token punctuation">(</span><span class="token parameter">store<span class="token punctuation">,</span> rootState<span class="token punctuation">,</span> path<span class="token punctuation">,</span> module<span class="token punctuation">,</span> hot</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">//  是否是根 module </span>
  <span class="token keyword">const</span> isRoot <span class="token operator">=</span> <span class="token operator">!</span>path<span class="token punctuation">.</span>length
  <span class="token comment">//  获取 module 的 namespace </span>
  <span class="token keyword">const</span> namespace <span class="token operator">=</span> store<span class="token punctuation">.</span>_modules<span class="token punctuation">.</span><span class="token function">getNamespace</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span>

  <span class="token comment">// register in namespace map</span>
  <span class="token comment">//  若有 namespace 则在 _modulesNamespaceMap 中注册 </span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>module<span class="token punctuation">.</span>namespaced<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    store<span class="token punctuation">.</span>_modulesNamespaceMap<span class="token punctuation">[</span>namespace<span class="token punctuation">]</span> <span class="token operator">=</span> module
  <span class="token punctuation">}</span>

  <span class="token comment">// set state</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isRoot <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>hot<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//  获取父级的 state </span>
    <span class="token keyword">const</span> parentState <span class="token operator">=</span> <span class="token function">getNestedState</span><span class="token punctuation">(</span>rootState<span class="token punctuation">,</span> path<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token comment">//  module 的 name </span>
    <span class="token keyword">const</span> moduleName <span class="token operator">=</span> path<span class="token punctuation">[</span>path<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span>
    store<span class="token punctuation">.</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">_withCommit</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token comment">//  将子 module 设置称响应式的 </span>
      Vue<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>parentState<span class="token punctuation">,</span> moduleName<span class="token punctuation">,</span> module<span class="token punctuation">.</span>state<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">const</span> local <span class="token operator">=</span> module<span class="token punctuation">.</span>context <span class="token operator">=</span> <span class="token function">makeLocalContext</span><span class="token punctuation">(</span>store<span class="token punctuation">,</span> namespace<span class="token punctuation">,</span> path<span class="token punctuation">)</span>

  <span class="token comment">//  遍历注册 mutation </span>
  module<span class="token punctuation">.</span><span class="token function">forEachMutation</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">mutation<span class="token punctuation">,</span> key</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> namespacedType <span class="token operator">=</span> namespace <span class="token operator">+</span> key
    <span class="token function">registerMutation</span><span class="token punctuation">(</span>store<span class="token punctuation">,</span> namespacedType<span class="token punctuation">,</span> mutation<span class="token punctuation">,</span> local<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>

  <span class="token comment">//  遍历注册 action </span>
  module<span class="token punctuation">.</span><span class="token function">forEachAction</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">action<span class="token punctuation">,</span> key</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> namespacedType <span class="token operator">=</span> namespace <span class="token operator">+</span> key
    <span class="token function">registerAction</span><span class="token punctuation">(</span>store<span class="token punctuation">,</span> namespacedType<span class="token punctuation">,</span> action<span class="token punctuation">,</span> local<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>

  <span class="token comment">//  遍历注册 getter </span>
  module<span class="token punctuation">.</span><span class="token function">forEachGetter</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">getter<span class="token punctuation">,</span> key</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> namespacedType <span class="token operator">=</span> namespace <span class="token operator">+</span> key
    <span class="token function">registerGetter</span><span class="token punctuation">(</span>store<span class="token punctuation">,</span> namespacedType<span class="token punctuation">,</span> getter<span class="token punctuation">,</span> local<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>

  <span class="token comment">//  递归安装 mudule </span>
  module<span class="token punctuation">.</span><span class="token function">forEachChild</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">child<span class="token punctuation">,</span> key</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">installModule</span><span class="token punctuation">(</span>store<span class="token punctuation">,</span> rootState<span class="token punctuation">,</span> path<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> child<span class="token punctuation">,</span> hot<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h5 id="_1-5-1-3、store-resetstorevm-core"><a href="#_1-5-1-3、store-resetstorevm-core" class="header-anchor">#</a> 1-5-1-3、Store-resetStoreVM-Core</h5> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//  通过 vm 重设 store，新建 Vue 对象使用 Vue 内部的响应式实现注册 state 及 computed </span>
<span class="token keyword">function</span> <span class="token function">resetStoreVM</span> <span class="token punctuation">(</span><span class="token parameter">store<span class="token punctuation">,</span> state<span class="token punctuation">,</span> hot</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">//  存放之前的 vm 对象 </span>
  <span class="token keyword">const</span> oldVm <span class="token operator">=</span> store<span class="token punctuation">.</span>_vm 

  <span class="token comment">// bind store public getters</span>
  store<span class="token punctuation">.</span>getters <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token keyword">const</span> wrappedGetters <span class="token operator">=</span> store<span class="token punctuation">.</span>_wrappedGetters
  <span class="token keyword">const</span> computed <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

  <span class="token comment">// 遍历 wrappedGetters，使用 Object.defineProperty 方法为每一个 getter 绑定上get方法</span>
  <span class="token comment">// 如此在组件里访问 this.$store.getter.test 就等同于访问 store._vm.test，也即 Vue 对象的 computed 属性 </span>
  <span class="token function">forEachValue</span><span class="token punctuation">(</span>wrappedGetters<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span> key</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// use computed to leverage its lazy-caching mechanism</span>
    computed<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">fn</span><span class="token punctuation">(</span>store<span class="token punctuation">)</span>
    Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>store<span class="token punctuation">.</span>getters<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token punctuation">{</span>
      <span class="token function-variable function">get</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> store<span class="token punctuation">.</span>_vm<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">,</span>
      enumerable<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token comment">// for local getters</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>

  <span class="token comment">// use a Vue instance to store the state tree</span>
  <span class="token comment">// suppress warnings just in case the user has added</span>
  <span class="token comment">// some funky global mixins</span>
  <span class="token keyword">const</span> silent <span class="token operator">=</span> Vue<span class="token punctuation">.</span>config<span class="token punctuation">.</span>silent
  <span class="token comment">//  Vue.config.silent 暂时设置为 true，原因是 new 一个 Vue 实例过程中不会报出一切警告 </span>
  Vue<span class="token punctuation">.</span>config<span class="token punctuation">.</span>silent <span class="token operator">=</span> <span class="token boolean">true</span>
  <span class="token comment">// 关键: Vuex 采用了 new 一个 Vue对象来实现数据的&quot;响应式化&quot;，运用 Vue 内部提供的数据双向绑定功能来实现 store 的数据与视图的同步更新</span>
  <span class="token comment">// 此时访问 store._vm.test 也即访问 Vue 实例中的属性</span>
  store<span class="token punctuation">.</span>_vm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    data<span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token operator">?</span>state<span class="token operator">:</span> state
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    computed
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  Vue<span class="token punctuation">.</span>config<span class="token punctuation">.</span>silent <span class="token operator">=</span> silent

  <span class="token comment">// enable strict mode for new vm</span>
  <span class="token comment">//  使能严格模式，保证修改 store 只能通过 mutation </span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>store<span class="token punctuation">.</span>strict<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">enableStrictMode</span><span class="token punctuation">(</span>store<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>oldVm<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//  解除旧 vm 的 state 的引用，及销毁旧 Vue 对象 </span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>hot<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// dispatch changes in all subscribed watchers</span>
      <span class="token comment">// to force getter re-evaluation for hot reloading.</span>
      store<span class="token punctuation">.</span><span class="token function">_withCommit</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        oldVm<span class="token punctuation">.</span>_data<span class="token punctuation">.</span><span class="token operator">?</span>state <span class="token operator">=</span> <span class="token keyword">null</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    Vue<span class="token punctuation">.</span><span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> oldVm<span class="token punctuation">.</span><span class="token function">$destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
  
<span class="token comment">// 上述两步完成后，即可通过 this.$store.getter.test 访问 vm 中的 test 属性</span>
</code></pre></div><h5 id="_1-5-1-4、vuexstrictmode"><a href="#_1-5-1-4、vuexstrictmode" class="header-anchor">#</a> 1-5-1-4、VuexStrictMode</h5> <p>Vuex 的 Store 构造类的 option 有 strict 参数，可控制 Vuex 执行严格模式，严格模式下，所有修改 state 的操作须通过 mutation 实现，否则会抛出错误；</p> <p>总的来说局势通过标志位判断；只有正确方法调用标志位才会放开，从而实现 Vuex 的严格模式；</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 使能严格模式</span>
<span class="token keyword">function</span> <span class="token function">enableStrictMode</span> <span class="token punctuation">(</span><span class="token parameter">store</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// Vuex 利用 vm 的 $watch 方法来观察 ?state，也即 Store 的 state，在它被修改时进入回调</span>
  <span class="token comment">// 回调中用 assert 断言来检测 store._committing，当 store._committing 为 false 时触发断言，抛出异常</span>
  store<span class="token punctuation">.</span>_vm<span class="token punctuation">.</span><span class="token function">$watch</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_data<span class="token punctuation">.</span><span class="token operator">?</span>state <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 检测 store 中的 _committing 值，若是 true 代表不是通过 mutation 方法修改</span>
      <span class="token function">assert</span><span class="token punctuation">(</span>store<span class="token punctuation">.</span>_committing<span class="token punctuation">,</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Do not mutate vuex store state outside mutation handlers.</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> deep<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> sync<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// Store 的 commit 方法中，执行 mutation 的语句是这样</span>
<span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">_withCommit</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  entry<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">commitIterator</span> <span class="token punctuation">(</span><span class="token parameter">handler</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">handler</span><span class="token punctuation">(</span>payload<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token function">_withCommit</span> <span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 调用 withCommit 修改 state 值时，会将 store 的 committing 值置为 true，内部会有断言检查该值</span>
  <span class="token comment">// 在严格模式下只允许使用 mutation 来修改 store 中值，而不允许直接修改 store 的数值</span>

  <span class="token comment">// 通过 commit（mutation）修改 state 数据时，会再调用 mutation 方法之前将 committing 置为 true，</span>
  <span class="token comment">// 接下来再通过 mutation 函数修改 state 中的数据，此时触发 $watch 中的回调断言 committing 是不会抛出异常的（此时committing为true）</span>
  <span class="token comment">// 而当直接修改 state 数据时，触发 $watch 的回调执行断言，此时 committing 为 false，则会抛出异常</span>
  <span class="token keyword">const</span> committing <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_committing
  <span class="token keyword">this</span><span class="token punctuation">.</span>_committing <span class="token operator">=</span> <span class="token boolean">true</span>
  <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>_committing <span class="token operator">=</span> committing
<span class="token punctuation">}</span>
</code></pre></div><h5 id="_1-5-1-5、commit-mutation"><a href="#_1-5-1-5、commit-mutation" class="header-anchor">#</a> 1-5-1-5、Commit-mutation</h5> <p>commit 方法会根据 type 找到并调用 _mutations 中的所有 type 对应的 mutation 方法，然后会执行 _subscribers 中的所有订阅者</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 调用 mutation 的 commit 方法</span>
<span class="token function">commit</span> <span class="token punctuation">(</span><span class="token parameter">_type<span class="token punctuation">,</span> _payload<span class="token punctuation">,</span> _options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// check object-style commit</span>
  <span class="token comment">// 校验参数</span>
  <span class="token keyword">const</span> <span class="token punctuation">{</span>
    type<span class="token punctuation">,</span>
    payload<span class="token punctuation">,</span>
    options
  <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">unifyObjectStyle</span><span class="token punctuation">(</span>_type<span class="token punctuation">,</span> _payload<span class="token punctuation">,</span> _options<span class="token punctuation">)</span>

  <span class="token keyword">const</span> mutation <span class="token operator">=</span> <span class="token punctuation">{</span> type<span class="token punctuation">,</span> payload <span class="token punctuation">}</span>
  <span class="token comment">// 取出 type 对应的 mutation 方法</span>
  <span class="token keyword">const</span> entry <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_mutations<span class="token punctuation">[</span>type<span class="token punctuation">]</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>entry<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">[vuex] unknown mutation type: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>type<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 执行 mutation 中所有方法</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">_withCommit</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    entry<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">commitIterator</span> <span class="token punctuation">(</span><span class="token parameter">handler</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">handler</span><span class="token punctuation">(</span>payload<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token comment">// 通知所有订阅者</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>_subscribers<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">sub</span> <span class="token operator">=&gt;</span> <span class="token function">sub</span><span class="token punctuation">(</span>mutation<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">)</span><span class="token punctuation">)</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>
    process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span> <span class="token operator">&amp;&amp;</span>
    options <span class="token operator">&amp;&amp;</span> options<span class="token punctuation">.</span>silent
  <span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span>
      <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">[vuex] mutation type: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>type<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">. Silent option has been removed. </span><span class="token template-punctuation string">`</span></span> <span class="token operator">+</span>
      <span class="token string">'Use the filter functionality in the vue-devtools'</span>
    <span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// commit 方法会根据 type 找到并调用 _mutations 中的所有 type 对应的 mutation 方法</span>
<span class="token comment">// 所以当没有 namespace 时，commit 方法会触发所有 module 中的 mutation 方法, 再执行完所有的 mutation 后会执行 _subscribers 中的所有订阅者</span>


<span class="token comment">// Store 向外部提供了一个 subscribe 方法</span>
<span class="token comment">// 用以注册一个订阅函数，会 push 到 Store 实例的 _subscribers 中，同时返回一个从 _subscribers 中注销该订阅者的方法。</span>
<span class="token comment">// 注册一个订阅函数，返回取消订阅的函数</span>
<span class="token function">subscribe</span> <span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> subs <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_subscribers
  <span class="token keyword">if</span> <span class="token punctuation">(</span>subs<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    subs<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> i <span class="token operator">=</span> subs<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&gt;</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      subs<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 在 commit 结束后则会调用这些 _subscribers 中的订阅者，此订阅者模式提供给外部一个监视 state 变化的可能 state 通过 mutation改变时，可有效补获这些变化</span>
</code></pre></div><h5 id="_1-5-1-6、dispatch-action"><a href="#_1-5-1-6、dispatch-action" class="header-anchor">#</a> 1-5-1-6、Dispatch-action</h5> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 调用 action 的 dispatch 方法</span>
<span class="token function">dispatch</span> <span class="token punctuation">(</span><span class="token parameter">_type<span class="token punctuation">,</span> _payload</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// check object-style dispatch</span>
  <span class="token keyword">const</span> <span class="token punctuation">{</span>
    type<span class="token punctuation">,</span>
    payload
  <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">unifyObjectStyle</span><span class="token punctuation">(</span>_type<span class="token punctuation">,</span> _payload<span class="token punctuation">)</span>

  <span class="token comment">// actions 中取出 type 对应的 ation</span>
  <span class="token keyword">const</span> entry <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_actions<span class="token punctuation">[</span>type<span class="token punctuation">]</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>entry<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">[vuex] unknown action type: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>type<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 若是数组则包装 Promise 形成一个新 Promise，只有一个则直接返回第0个</span>
  <span class="token keyword">return</span> entry<span class="token punctuation">.</span>length <span class="token operator">&gt;</span> <span class="token number">1</span>
    <span class="token operator">?</span> Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span>entry<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token parameter">handler</span> <span class="token operator">=&gt;</span> <span class="token function">handler</span><span class="token punctuation">(</span>payload<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token operator">:</span> entry<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">(</span>payload<span class="token punctuation">)</span>
<span class="token punctuation">}</span>


<span class="token comment">// 遍历注册 action</span>
<span class="token keyword">function</span> <span class="token function">registerAction</span> <span class="token punctuation">(</span><span class="token parameter">store<span class="token punctuation">,</span> type<span class="token punctuation">,</span> handler<span class="token punctuation">,</span> local</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 取出 type 对应的 action</span>
  <span class="token keyword">const</span> entry <span class="token operator">=</span> store<span class="token punctuation">.</span>_actions<span class="token punctuation">[</span>type<span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token punctuation">(</span>store<span class="token punctuation">.</span>_actions<span class="token punctuation">[</span>type<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
  entry<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">wrappedActionHandler</span> <span class="token punctuation">(</span><span class="token parameter">payload<span class="token punctuation">,</span> cb</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> res <span class="token operator">=</span> <span class="token function">handler</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>store<span class="token punctuation">,</span> <span class="token punctuation">{</span>
      dispatch<span class="token operator">:</span> local<span class="token punctuation">.</span>dispatch<span class="token punctuation">,</span>
      commit<span class="token operator">:</span> local<span class="token punctuation">.</span>commit<span class="token punctuation">,</span>
      getters<span class="token operator">:</span> local<span class="token punctuation">.</span>getters<span class="token punctuation">,</span>
      state<span class="token operator">:</span> local<span class="token punctuation">.</span>state<span class="token punctuation">,</span>
      rootGetters<span class="token operator">:</span> store<span class="token punctuation">.</span>getters<span class="token punctuation">,</span>
      rootState<span class="token operator">:</span> store<span class="token punctuation">.</span>state
    <span class="token punctuation">}</span><span class="token punctuation">,</span> payload<span class="token punctuation">,</span> cb<span class="token punctuation">)</span>
    <span class="token comment">// 判断是否是 Promise</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isPromise</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 不是 Promise 对象则转化 Promise 对象</span>
      res <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>store<span class="token punctuation">.</span>_devtoolHook<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 存在 devtool 插件时触发 vuex 的 error 给 devtool</span>
      <span class="token keyword">return</span> res<span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token parameter">err</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        store<span class="token punctuation">.</span>_devtoolHook<span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token string">'vuex:error'</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
        <span class="token keyword">throw</span> err
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> res
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>


<span class="token comment">// 因 registerAction 时将 push 进 _actions 的 action 进行了一层封装（wrappedActionHandler）</span>
<span class="token comment">// 所以在进行 dispatch 的第一个参数中获取 state、commit 等方法</span>
<span class="token comment">// 之后，执行结果 res 会被进行判断是否是 Promise，不是则会进行一层封装，将其转化成 Promise 对象, </span>
<span class="token comment">// dispatch 时则从 _actions 中取出，只有一个的时候直接返回，否则用P romise.all 处理再返回。</span>
</code></pre></div><h5 id="_1-5-1-7、watch"><a href="#_1-5-1-7、watch" class="header-anchor">#</a> 1-5-1-7、watch</h5> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 观察一个 getter 方法</span>
<span class="token comment">// _watcherVM 是一个 Vue 实例，所以 watch 就可以直接采用 Vue 内部的 watch 特性提供了一种观察数据 getter 变动的方法</span>
<span class="token function">watch</span> <span class="token punctuation">(</span><span class="token parameter">getter<span class="token punctuation">,</span> cb<span class="token punctuation">,</span> options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">assert</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> getter <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">,</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">store.watch only accepts a function.</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_watcherVM<span class="token punctuation">.</span><span class="token function">$watch</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">getter</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>getters<span class="token punctuation">)</span><span class="token punctuation">,</span> cb<span class="token punctuation">,</span> options<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h5 id="_1-5-1-8、un-registermodule"><a href="#_1-5-1-8、un-registermodule" class="header-anchor">#</a> 1-5-1-8、un/registerModule</h5> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// registerModule 用以注册一个动态模块，也即在 store 创建后再注册模块的时候用该接口</span>
<span class="token comment">// 注册一个动态 module，当业务进行异步加载的时候，可通过该接口进行注册动态 module</span>
<span class="token function">registerModule</span> <span class="token punctuation">(</span><span class="token parameter">path<span class="token punctuation">,</span> rawModule</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 转化称 Array</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> path <span class="token operator">===</span> <span class="token string">'string'</span><span class="token punctuation">)</span> path <span class="token operator">=</span> <span class="token punctuation">[</span>path<span class="token punctuation">]</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">assert</span><span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">module path must be a string or an Array.</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
    <span class="token function">assert</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span>length <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">'cannot register the root module by using registerModule.'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 注册</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>_modules<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> rawModule<span class="token punctuation">)</span>
  <span class="token comment">// 初始化 module</span>
  <span class="token function">installModule</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">,</span> path<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_modules<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token comment">// reset store to update getters...</span>
  <span class="token comment">// 通过 vm 重设 store，新建 Vue 对象使用 Vue 内部的响应式实现注册 state 及 computed</span>
  <span class="token function">resetStoreVM</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">)</span>
<span class="token punctuation">}</span>



<span class="token comment">//  注销一个动态 module</span>
<span class="token comment">// 动态注销模块, 通过先从 state 中删除模块，然后用 resetStore 来重制 store</span>
<span class="token function">unregisterModule</span> <span class="token punctuation">(</span><span class="token parameter">path</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 转化称 Array</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> path <span class="token operator">===</span> <span class="token string">'string'</span><span class="token punctuation">)</span> path <span class="token operator">=</span> <span class="token punctuation">[</span>path<span class="token punctuation">]</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">assert</span><span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">module path must be a string or an Array.</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 注销</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>_modules<span class="token punctuation">.</span><span class="token function">unregister</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">_withCommit</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 获取父级的 state</span>
    <span class="token keyword">const</span> parentState <span class="token operator">=</span> <span class="token function">getNestedState</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">,</span> path<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token comment">// 从父级中删除</span>
    Vue<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>parentState<span class="token punctuation">,</span> path<span class="token punctuation">[</span>path<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token comment">// 重制 store</span>
  <span class="token function">resetStore</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h5 id="_1-5-1-9、resetstore"><a href="#_1-5-1-9、resetstore" class="header-anchor">#</a> 1-5-1-9、ResetStore</h5> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 重制 store</span>
<span class="token comment">// 将 store 中的 _actions 等进行初始化以后，重新执行 installModule 与 resetStoreVM 来初始化 module 及用 Vue 特性使其&quot;响应式化&quot;</span>
<span class="token keyword">function</span> <span class="token function">resetStore</span> <span class="token punctuation">(</span><span class="token parameter">store<span class="token punctuation">,</span> hot</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  store<span class="token punctuation">.</span>_actions <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>
  store<span class="token punctuation">.</span>_mutations <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>
  store<span class="token punctuation">.</span>_wrappedGetters <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>
  store<span class="token punctuation">.</span>_modulesNamespaceMap <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>
  <span class="token keyword">const</span> state <span class="token operator">=</span> store<span class="token punctuation">.</span>state
  <span class="token comment">// init all modules</span>
  <span class="token function">installModule</span><span class="token punctuation">(</span>store<span class="token punctuation">,</span> state<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> store<span class="token punctuation">.</span>_modules<span class="token punctuation">.</span>root<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
  <span class="token comment">// reset vm</span>
  <span class="token function">resetStoreVM</span><span class="token punctuation">(</span>store<span class="token punctuation">,</span> state<span class="token punctuation">,</span> hot<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="_1-6、组件化"><a href="#_1-6、组件化" class="header-anchor">#</a> 1-6、组件化</h3> <h4 id="_1-6-1、vue"><a href="#_1-6-1、vue" class="header-anchor">#</a> 1-6-1、Vue</h4> <h4 id="_1-6-2、angular"><a href="#_1-6-2、angular" class="header-anchor">#</a> 1-6-2、Angular</h4> <h3 id="_1-7、依赖注入"><a href="#_1-7、依赖注入" class="header-anchor">#</a> 1-7、依赖注入</h3> <h4 id="_1-7-1、vue"><a href="#_1-7-1、vue" class="header-anchor">#</a> 1-7-1、Vue</h4> <h4 id="_1-7-2、angular"><a href="#_1-7-2、angular" class="header-anchor">#</a> 1-7-2、Angular</h4> <h5 id="_1-7-2-1、依赖注入"><a href="#_1-7-2-1、依赖注入" class="header-anchor">#</a> 1-7-2-1、依赖注入</h5> <p><strong><u><em>依赖</em></u></strong>：如果类 A 功能的实现需借助类 B，则称类 B 是类 A 的依赖；</p> <p><strong><u><em>问题</em></u></strong>：如果在类 A 内部实例化类 B，则两者间就会出现较高耦合，一旦类 B 出现问题，类 A 也需进行改造，若此类情况较多，且每个类之间都有很多依赖，那么就会出现牵一发而动全身的情况，程序会变得极难维护，且很容易出现问题；</p> <p><strong><u><em>解决</em></u></strong>：将 A 类对 B 类的控制权抽离，交给第三方去管理；而将控制权反转给第三方，就称为 <strong><u><em>控制反转(IOC—InversionOf Control)</em></u></strong></p> <ul><li><p>比如：类 A 依赖类 B，但 A 不控制 B 的创建和销毁，仅使用 B，那么将 B 的控制权则交给 A 之外的第三方处理，叫控制反转(IOC)；</p></li> <li><p><strong><u><em>控制反转</em></u></strong>：最早在 04年由 <em>Martin Fowler</em> 提出，它是针对面向对象设计不断复杂化而提出的一种设计原则，是一种利用面向对象编程法则来降低应用程序耦合的设计模式；</p></li> <li><p><strong><u><em>IOC 容器</em></u></strong>：IOC 强调对代码引用的控制权，由调用方法方转移到外部容器，在运行时通过某种方式注入进来，实现控制的反转，以降低服务类间的耦合度；实现 IOC 的框架叫 IOC 容器；</p></li> <li><p><strong><u><em>依赖注入</em></u></strong>：DI—Dependency Injection，是 IOC 最典型的实现方法，由IOC容器来控制依赖，通过使用构造函数、属性或工厂模式等方法，将依赖注入到所需类中，极大程度对双方进行了解耦；Angular实现控制反转的形式/手段就是依赖注入；</p> <ul><li>DI 有利于应用程序中各模块之间的解耦，使得代码更容易维护，这种优势会随着项目复杂度的增加而增加；</li> <li>DI 让开发者可专注于所依赖对象的消费，而无需关注这些依赖对象的产生过程，大大提升开发效率，此外还可松耦合和可重用性、提高可测试性；</li></ul></li> <li><p><strong><u><em>两者区别</em></u></strong>：DI 与 IOC 基本是一个意思，但前者是后者的具体形式，后者是一种思想和设计原则；</p></li> <li><p>比如：类 A 对类 B 的控制，起初由程序员人工添加，形式、传参均被敲代码的瞬间固定下来，即可说明类 A &quot;控制&quot; 了类 B；引入 IOC 后，注入行为还是由程序员管理，但改为 import 等的统一形式，控制权不再由类 A 管理，而是由 DI 统一控制、统一管理；</p></li></ul> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">// 不使用 DI</span>
<span class="token keyword">class</span> <span class="token class-name">Player</span> <span class="token punctuation">{</span>
  Weapon<span class="token operator">:</span> weapon<span class="token punctuation">;</span>

  <span class="token function">Player</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 与 Sord 类紧耦合</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>weapon <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Sord</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">attack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    weapon<span class="token punctuation">.</span><span class="token function">attack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 使用 DI 效果</span>
<span class="token keyword">class</span> <span class="token class-name">Player</span> <span class="token punctuation">{</span>
  Weapon<span class="token operator">:</span> weapon<span class="token punctuation">;</span>

  <span class="token comment">// weapon 被注入进来</span>
  <span class="token function">Player</span><span class="token punctuation">(</span>Weapon weapon<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>weapon <span class="token operator">=</span> weapon<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">attack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    weapon<span class="token punctuation">.</span><span class="token function">attack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// DI EX1</span>
<span class="token comment">// A 依赖于 B，因此在 A 中必然要使用 B 的 instance，这里通过 A 的构造函数将 B 的实例注入</span>
<span class="token keyword">class</span> <span class="token class-name"><span class="token constant">B</span></span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name"><span class="token constant">A</span></span> <span class="token punctuation">{</span>
  <span class="token keyword">constructor</span><span class="token punctuation">(</span>b<span class="token operator">:</span> <span class="token constant">B</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'b: '</span><span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token constant">B</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 将 b 实例注入 A 中</span>
<span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token constant">A</span></span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h5 id="_1-7-2-2、ng依赖注入"><a href="#_1-7-2-2、ng依赖注入" class="header-anchor">#</a> 1-7-2-2、NG依赖注入</h5> <p><strong><u><em>基本</em></u></strong>：Angular 的依赖注入一种创建依赖其他对象的方法，在创建一个新的对象实例时，依赖注入系统将会提供依赖对象(称为依赖关系) - <strong><u><em>Angular Docs；</em></u></strong></p> <p>Angular 的依赖注入是用来创建对象及其依赖的其它对象的一种方式，当依赖注入系统创建某个对象实例时，会负责提供该对象所依赖的对象(称为该对象的依赖)；在依赖注入模式中，应用组件无需关注所依赖对象的创建和初始化过程，可认为框架已初始化完毕，开发者只管调用即可；</p> <p><strong><u><em>流程</em></u></strong>：得到依赖项、查找依赖项所对应的对象、执行时注入；</p> <p><strong><u><em>注入器</em></u></strong>：Angular 依赖注入器，负责创建服务的实例，并把它们注入到你想要注入的类中；Angular 本身无法自动判断你是打算自行创建服务类的实例，亦或者是等注入器来创建它；若想通过注入器来创建，则须为每个服务指定服务提供商，<u>每个服务均需用 @xx 声明(以供 Angular 识别，方便统一管理)</u></p> <h5 id="_1-7-2-2-1、旧注入方式ng6"><a href="#_1-7-2-2-1、旧注入方式ng6" class="header-anchor">#</a> 1-7-2-2-1、旧注入方式NG6-</h5> <ul><li>在预加载的模块的 @NgModule 装饰器中指定 providers:[]</li> <li>在懒加载的模块的 @NgModule 装饰器中指定 providers:[]</li> <li>在 @Component 和 @Directive 装饰器中指定 providers:[]</li></ul> <p>预加载：服务将是全局单例，即使它被多个模块的 providers: [] 重复申明，也不会重新创建实例；</p> <ul><li>注入器只会创建一个实例，因为它们最终都会注册到根级注入器；</li></ul> <p>懒加载：在应用程序运行初始化后一段时间，懒加载模块中提供的服务实例才会在子注入器(懒加载模块)上创建；</p> <ul><li>假若在预加载模块中注入这些服务，将会报 <u><em><code>No provider for MyService!</code></em></u> 错误；</li> <li>补充：<a href="https://zhuanlan.zhihu.com/p/56596626" target="_blank" rel="noopener noreferrer">上述两种 NG 的预加载懒加载策略<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul> <p>第三种：服务是按组件实例化，且可在组件及其子树中的所有子组件中访问；</p> <ul><li>此时的服务非单例对象，每次在另1个组件模板中使用组件时，均会获得所提供服务的新实例，但也意味着服务实例将与组件一起销毁；</li> <li>比如：<code>RandomService</code> 在 <code>RandomComponent</code> 中被注册，因此每当在模板中使用 <code>&lt;random&gt;&lt;/random&gt;</code> 组件时均将得到不同随机数；</li> <li>但若：在模块级别提供 <code>RandomService</code>并且将被作为单例提供则不会出现这种情况；</li> <li>因为：此时 <code>&lt;random&gt;&lt;/random&gt;</code> 组件的每次使用都会显示相同的随机数，因为该数字是在服务实例化期间生成的；</li></ul> <h5 id="_1-7-2-2-2、新注入方式ng6"><a href="#_1-7-2-2-2、新注入方式ng6" class="header-anchor">#</a> 1-7-2-2-2、新注入方式NG6+</h5> <p>通过使用 @Injectable 装饰器的新增的 provideIn 属性来使用，官方名称是“Tree-shakable providers”；</p> <ul><li>注意：其将 provideIn 视为以反向方式指定依赖关系，即非 &quot;模块声明需要哪些服务”，而是“服务本身宣布它应该提供给哪些模块使用&quot;；</li> <li>注意：声明的模块可以是 root 或其他任何可用模块，此外，root 实际上是 AppModule 别名，使用 root 别名便可无需额外导入 AppModule；</li> <li><img src="/Image/Frame/Angular/1.png" align="" style="zoom:50%;"></li></ul> <p><strong><u><em>问题A：懒加载模块与正常模块的服务自动绑定行为不可预测：</em></u></strong></p> <ul><li>懒加载模块意义：可非常容易的将应用程序分成完全独立的逻辑块：
<ul><li>更小的初始化代码，这意味着更快的加载和启动时间；</li> <li>懒惰加载的模块是真正隔离的，主机应用程序应该引用它们的唯一一点是某些路由的 <code>loadChildren</code> 属性；</li> <li>即若：懒加载使用正确，可将整个模块删除或外部化为独立的应用程序/库，可能有数百个组件和服务的模块可在不影响应用程序其余部分的情况下随意移动，而对懒惰模块的逻辑进行更改永远不会导致应用程序的其他部分出错；</li></ul></li> <li>解释：在懒加载中使用 <code>providerIn:'root'</code> 实现服务，就会发生如下行为，但问题在于在拥有大量模块和服务的大型应用中，其将变得不可预测；
<ul><li>若服务仅被注入到懒加载模块中，则其将绑定在懒加载包中；</li> <li>若服务又被注入到正常模块中，则将捆绑在主包中；</li></ul></li></ul> <p>解决A-1：使用 <code>providedIn: EagerlyImportedModule</code></p> <p>原因：可用于防止应用程序的其余部分注入服务而无需导入相应的模块，但这其实并非必需，应坚持使用 <code>provideIn：'root'</code></p> <p>解决A-2：使用 <code>providedIn: LazyLoadedModule</code></p> <p><strong><u><em>问题B：循环引用：</em></u></strong></p> <img src="/Image/Frame/Angular/2.png" align="" style="zoom:50%;"> <p>解决B：可通过创建 LazyServiceModule 来避免此问题，如下图；它将是 LazyModule 的一个子模块，并将被用作我们想要提供的所有懒加载服务的“锚”；</p> <img src="/Image/Frame/Angular/3.png" align="" style="zoom:50%;"> <p>注意：虽然有点不方便，但只需增加一个模块，这种方法结合了2者的优点:</p> <ul><li>其防止我们将懒加载的服务注入应用程序的正常加载模块；</li> <li>只有当服务被&quot;真正”注入其他惰性组件时，它才会打包到服务中；</li></ul> <p>注意：新注入方式不适用于@Component 和 @Directive，@Directive还需通过传统的使用 provider:[]来创建多个服务实例(每个组件)</p> <img src="/Image/Frame/Angular/4.png" align="" style="zoom:50%;"> <h5 id="_1-7-2-2-3、总结"><a href="#_1-7-2-2-3、总结" class="header-anchor">#</a> 1-7-2-2-3、总结</h5> <ul><li>将 <code>providedIn: 'root'</code> 用于在整个应用程序中作为单例可用的服务；</li> <li>永远不要使用 <code>providedIn:EagerLiymportedmodule</code>，若有一些非常特殊的用例，则使用 <code>providers: []</code> 来代替；</li> <li>使用 <code>providedIn: LazyServiceModule</code> 可防止将懒加载的服务注入应用程序的正常加载模块；</li> <li>若想使用 <code>LazyServiceModule</code>，则须先将其导入 <code>LazyModule</code>，以防止循环引用，然后 <code>LazyModule</code> 将以标准方式使用 NgRouter 为某些路由进行懒加载；</li> <li>使用 <code>@Component 或 @Directive</code> 内部的 <code>providers: []</code>，为特定的组件子树提供服务，当然这将导致创建多个服务实例(每个组件使用一个服务实例)；</li> <li>始终尝试保守地确定服务范围，以防止依赖蔓延和由此产生的巨大混乱；</li></ul> <h5 id="_1-7-2-3、ng2依赖注入原理"><a href="#_1-7-2-3、ng2依赖注入原理" class="header-anchor">#</a> 1-7-2-3、NG2依赖注入原理</h5> <p>在 JS 语境下，依赖注入实际就是：函数参数是函数而已(高阶函数，因为JS没有类)；</p> <p>在 TS 语境下，依赖注入实际就是：在类的构造函数中传入另一个类，类实例化时包括其参数的类也会被实例化；</p> <ul><li>为什么 DI 只有在 Angular 中才会被探讨：因为其它框架并不是原生支持强类型，自然无法以DI为出发点进行框架设计；</li></ul> <p><strong><u><em>1、Angular 依赖注入是如何实现的：</em></u></strong></p> <p>可以参考 express 与 vue (实际上就是中间件)，如下；但不同的是它们没有类，因此传递的是一个函数，然后只要约定返回值和参数即可进行依赖注入；</p> <div class="language- extra-class"><pre class="language-text"><code>app.use(bodyParser.json());
Vue.use(Vuex);
</code></pre></div><p>但 <strong><u>Angular 传递的是类，需要进行类的实例化，实例化后还须绑定到当前 this 以供当前类使用；</u></strong></p> <p>注意：传统 OO 中的依赖注入是类，但这更灵活：值/工厂/类均可：<code>ValueProvider、FactoryProvider、ExistingProvider、StaticClassProvider、function</code></p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">// https://github.com/angular/angular/blob/master/packages/core/src/di/injector.ts 181</span>
<span class="token comment">// 1、有参数的工厂模式依赖 如 RouterModule.forChild(), 分析其参数依赖并加载</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">USE_VALUE</span> <span class="token keyword">in</span> provider<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// We need to use USE_VALUE in provider since provider.useValue could be defined as undefined.</span>
  value <span class="token operator">=</span> <span class="token punctuation">(</span>provider <span class="token keyword">as</span> ValueProvider<span class="token punctuation">)</span><span class="token punctuation">.</span>useValue<span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>provider <span class="token keyword">as</span> FactoryProvider<span class="token punctuation">)</span><span class="token punctuation">.</span>useFactory<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  fn <span class="token operator">=</span> <span class="token punctuation">(</span>provider <span class="token keyword">as</span> FactoryProvider<span class="token punctuation">)</span><span class="token punctuation">.</span>useFactory<span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>provider <span class="token keyword">as</span> ExistingProvider<span class="token punctuation">)</span><span class="token punctuation">.</span>useExisting<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// Just use IDENT</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>provider <span class="token keyword">as</span> StaticClassProvider<span class="token punctuation">)</span><span class="token punctuation">.</span>useClass<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  useNew <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  fn <span class="token operator">=</span> <span class="token function">resolveForwardRef</span><span class="token punctuation">(</span><span class="token punctuation">(</span>provider <span class="token keyword">as</span> StaticClassProvider<span class="token punctuation">)</span><span class="token punctuation">.</span>useClass<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> provide <span class="token operator">==</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  useNew <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  fn <span class="token operator">=</span> provide<span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
  <span class="token keyword">throw</span> <span class="token function">staticError</span><span class="token punctuation">(</span>
    <span class="token string">'StaticProvider does not have [useValue|useFactory|useExisting|useClass] or [provide] is not newable'</span><span class="token punctuation">,</span>
    provider<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// ...</span>

<span class="token comment">// 2、然后 resolveToken 加载相关工厂参数，即依赖的依赖；</span>
<span class="token comment">// 注意：一旦加载依赖的参数是另一个依赖，为避免出现环形依赖，Angular 会自行判断，每加载一个依赖就会进行记录</span>
value <span class="token operator">=</span> record<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">==</span> <span class="token constant">CIRCULAR</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">throw</span> <span class="token function">Error</span><span class="token punctuation">(</span><span class="token constant">NO_NEW_LINE</span> <span class="token operator">+</span> <span class="token string">'Circular dependency'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// ...</span>

<span class="token comment">// 3、最后，将所有依赖实例化</span>
<span class="token keyword">static</span> <span class="token function">create</span><span class="token punctuation">(</span>
  options<span class="token operator">:</span> StaticProvider<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">|</span><span class="token punctuation">{</span>providers<span class="token operator">:</span> StaticProvider<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> parent<span class="token operator">?</span><span class="token operator">:</span> Injector<span class="token punctuation">,</span> name<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
  parent<span class="token operator">?</span><span class="token operator">:</span> Injector<span class="token punctuation">)</span><span class="token operator">:</span> Injector <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token builtin">Array</span><span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">StaticInjector</span><span class="token punctuation">(</span>options<span class="token punctuation">,</span> parent<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">StaticInjector</span><span class="token punctuation">(</span>options<span class="token punctuation">.</span>providers<span class="token punctuation">,</span> options<span class="token punctuation">.</span>parent<span class="token punctuation">,</span> options<span class="token punctuation">.</span>name <span class="token operator">||</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong><u><em>2、Angular Module装饰器(decorator)是如何装配相关依赖和组件的：</em></u></strong></p> <p>所有的 Angular decorator 都继承自 makePropDecorator 方法，自动为目标函数添加方法属性：</p> <p>因此，组件，指令，服务都会被添加到同一 module 下；</p> <p>然后， Angular 在 app 实例化时会初始化一个 module，添加根 Injector，形成 <u>模块树</u>；</p> <p>此外，惰性模块中的依赖还涉及延迟加载等内容，模块加载也是在 zone 中进行；</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">makePropDecorator</span><span class="token punctuation">(</span>
    name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> props<span class="token operator">?</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">any</span><span class="token punctuation">,</span> parentClass<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">any</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> metaCtor <span class="token operator">=</span> <span class="token function">makeMetadataCtor</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">function</span> <span class="token function">PropDecoratorFactory</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">any</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token keyword">instanceof</span> <span class="token class-name">PropDecoratorFactory</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">metaCtor</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">const</span> decoratorInstance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token builtin">any</span><span class="token operator">&gt;</span>PropDecoratorFactory<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token function">PropDecorator</span><span class="token punctuation">(</span>target<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">,</span> name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> <span class="token keyword">constructor</span> <span class="token operator">=</span> target<span class="token punctuation">.</span><span class="token keyword">constructor</span><span class="token punctuation">;</span>
      <span class="token comment">// Use of Object.defineProperty is important since it creates non-enumerable property which</span>
      <span class="token comment">// prevents the property is copied during subclassing.</span>
      <span class="token keyword">const</span> meta <span class="token operator">=</span> <span class="token keyword">constructor</span><span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span><span class="token constant">PROP_METADATA</span><span class="token punctuation">)</span> <span class="token operator">?</span>
          <span class="token punctuation">(</span><span class="token keyword">constructor</span> <span class="token keyword">as</span> <span class="token builtin">any</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token constant">PROP_METADATA</span><span class="token punctuation">]</span> <span class="token operator">:</span>
          Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span><span class="token keyword">constructor</span><span class="token punctuation">,</span> <span class="token constant">PROP_METADATA</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>value<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token constant">PROP_METADATA</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
      meta<span class="token punctuation">[</span>name<span class="token punctuation">]</span> <span class="token operator">=</span> meta<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> meta<span class="token punctuation">[</span>name<span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
      meta<span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">unshift</span><span class="token punctuation">(</span>decoratorInstance<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>parentClass<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    PropDecoratorFactory<span class="token punctuation">.</span>prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>parentClass<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  PropDecoratorFactory<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>ngMetadataName <span class="token operator">=</span> name<span class="token punctuation">;</span>
  <span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token builtin">any</span><span class="token operator">&gt;</span>PropDecoratorFactory<span class="token punctuation">)</span><span class="token punctuation">.</span>annotationCls <span class="token operator">=</span> PropDecoratorFactory<span class="token punctuation">;</span>
  <span class="token keyword">return</span> PropDecoratorFactory<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>参考：<a href="https://www.zhihu.com/question/265773703/answer/298969485" target="_blank" rel="noopener noreferrer">Ng2 依赖注入是如何实现的<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h5 id="_1-7-2-4、新版ng依赖注入原理"><a href="#_1-7-2-4、新版ng依赖注入原理" class="header-anchor">#</a> 1-7-2-4、新版NG依赖注入原理</h5> <h5 id="_1-7-2-5、依赖注入使用"><a href="#_1-7-2-5、依赖注入使用" class="header-anchor">#</a> 1-7-2-5、依赖注入使用</h5> <h3 id="_1-8、模板解析"><a href="#_1-8、模板解析" class="header-anchor">#</a> 1-8、模板解析</h3> <h4 id="_1-8-1、vue"><a href="#_1-8-1、vue" class="header-anchor">#</a> 1-8-1、Vue</h4> <p>总览：模板解析这种事，本质是将数据转化为一段html，最开始出现在后端，经过各种处理吐给前端；但随着各种 mv* 兴起，模板解析交由前端处理；Vue complier 将 template 转化成一个 render 函数字符串，编译过程如下：</p> <ul><li>parse 函数：负责解析 template，利用正则生成 AST；</li> <li>optimize 函数：负责优化静态节点(标记不需要每次都更新的内容，diff 算法会直接跳过静态节点，从而减少比较过程，优化 patch 性能)；</li> <li>generate 函数：生成 render 函数字符串；</li></ul> <p>内容：parse，optimize，generate</p> <p>作用：解析模板，生成渲染模板的 render</p> <p>比如：<code>&lt;div&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt;</code>，经过 compile 之后，就会生成下面的 render，而 render 作用，也是为了生成跟模板节点一一对应的 Vnode：</p> <img src="/Image/Frame/Vue/300.png" align="" style="zoom:50%;"> <img src="/Image/Frame/Vue/301.png" align="" style="zoom:50%;"> <h5 id="_1-8-1-1、parse"><a href="#_1-8-1-1、parse" class="header-anchor">#</a> 1-8-1-1、parse</h5> <p>作用：接收 template 原始模板，按照模板节点和数据 生成对应的 AST；</p> <p>比如：<code>&lt;div test=2&gt;&lt;span name=1&gt;&lt;/span&gt;&lt;/div&gt;</code></p> <img src="/Image/Frame/Vue/302.png" align="" style="zoom:50%;"> <h5 id="_1-8-1-2、optimize"><a href="#_1-8-1-2、optimize" class="header-anchor">#</a> 1-8-1-2、optimize</h5> <p>作用：遍历递归每一AST节点，并标记静态节点(不会变化的、没有绑定任何动态数据的节点)，在页面更新时，减少比对此部分 DOM，从而达到性能优化的目的；</p> <p>比如：<code>&lt;div&gt;&lt;span&gt;&lt;b&gt;1&lt;/b&gt;&lt;/span&gt;&lt;/div&gt;</code> ，span 和 b 就是静态节点；在 optimize 处理中，就会给他们添加 static 判断是否是静态节点，用来标记某部分静态节点最大的祖宗节点，后面更新时，只要碰到这个属性，就知道其所有子孙节点都是静态节点，而不需每个子孙节点都要判断一次浪费时间；</p> <img src="/Image/Frame/Vue/303.png" align="" style="zoom:50%;"> <h5 id="_1-8-1-3、generate"><a href="#_1-8-1-3、generate" class="header-anchor">#</a> 1-8-1-3、generate</h5> <p>作用：将前两步生成完善的 AST 组装成 render 字符串 (这个 render 变成函数后是可执行的函数，不过现在是字符串的形态，后面会转成函数)</p> <p>比如：<code>&lt;div&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt;</code> 经过前2步生成AST：</p> <img src="/Image/Frame/Vue/304.png" align="" style="zoom:50%;"> <p>然后，generate 接收 AST，先处理最外层 AST，然后开始递归遍历子节点，直到所有节点被处理完，这个过程中，字符串会被一点一点拼接完成，比如上面的 AST 拼接结果如下；注意：_c 是生成节点对应的 Vnode 的一个函数；</p> <img src="/Image/Frame/Vue/305.png" align="" style="zoom:50%;"> <p>简述拼接流程：</p> <img src="/Image/Frame/Vue/306.png" align="" style="zoom:50%;"> <h5 id="_1-8-1-4、render"><a href="#_1-8-1-4、render" class="header-anchor">#</a> 1-8-1-4、render</h5> <p>前面两步将 template 解析生成了 render 字符串，但仍需要转换成函数才可执行，<code>render = new Function(render)，vm.$options.render</code></p> <img src="/Image/Frame/Vue/307.png" align="" style="zoom:50%;"> <p>参考：https://juejin.im/post/5d4cec74e51d4561bb33fb0d</p> <h4 id="_1-8-2、angular"><a href="#_1-8-2、angular" class="header-anchor">#</a> 1-8-2、Angular</h4> <h3 id="_1-x、其他"><a href="#_1-x、其他" class="header-anchor">#</a> 1-X、其他</h3> <h4 id="_1-x-1、vuecomputed"><a href="#_1-x-1、vuecomputed" class="header-anchor">#</a> 1-X-1、VueComputed</h4> <h5 id="_1-x-1-1、概览"><a href="#_1-x-1-1、概览" class="header-anchor">#</a> 1-X-1-1、概览</h5> <p>computed 计算就是调用设置的 get 函数，然后得到返回值；其能控制缓存的重要一点是它的属性：脏数据标志位 dirty；</p> <ul><li>当 dirty 为 true 时，读取 computed 会重新计算</li> <li>当 dirty 为 false 时，读取 computed 会使用缓存</li></ul> <p>1、开始每个 computed 新建自己的 watcher 时，会设置 watcher.dirty = true，以便于 computed 被使用时，会计算得到值；</p> <p>2、当依赖数据发生变化后，通知 computed 时，会设置 watcher.dirty = true，以便于其他地方重新渲染、重新读取 computed 时，computed 重新计算</p> <p>3、当 computed 计算完成后，会设置 watcher.dirty = false，以便于其他地方再次读取时，使用缓存，免于计算；</p> <p>比如：下面的流程示意图：</p> <img src="/Image/Frame/Vue/308.png" align="" style="zoom:50%;"> <ul><li><p>data C 开始变化后.......</p></li> <li><p>通知 computed B watcher 更新，并只重置脏数据标志位 dirty = true，而不会计算值；</p></li> <li><p>通知 页面 A watcher 进行更新渲染，进而重新读取 computed B ，然后 computed B 开始重新计算；</p></li></ul> <p>为什么 data C 能通知 页面 A：因为 data C 的依赖收集器会同时收集到 computed B 和 页面 A 的 watcher</p> <p>为什么 data C 能收集到 页面A 的watcher：因为 computed 在 页面 A 在读取 computed B 时，data C 就会收集到页面A watcher</p> <p>为什么 computed 能够更新：因为被依赖通知更新后，computed 重置了脏数据标志位(放开权限)，允许页面读取 computed 时再更新值；</p> <h5 id="_1-x-1-1、源码分析"><a href="#_1-x-1-1、源码分析" class="header-anchor">#</a> 1-X-1-1、源码分析</h5> <p><strong><u><em>首先</em></u></strong>，在调用 Vue 创建实例过程中，会处理各种选项(初始化)，其中包括处理 computed(initComputed)；每个 computed 都创建一个 watcher，用来存储计算值，判断是否需要重新计算；initComputed 作用：</p> <ul><li>为每个 computed 配发 watcher；</li> <li>defineComputed 处理；</li> <li>收集所有 computed 的 watcher；</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">initComputed</span><span class="token punctuation">(</span><span class="token parameter">vm<span class="token punctuation">,</span> computed</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> watchers <span class="token operator">=</span> vm<span class="token punctuation">.</span>_computedWatchers <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> key <span class="token keyword">in</span> computed<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> userDef <span class="token operator">=</span> computed<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> getter <span class="token operator">=</span> <span class="token keyword">typeof</span> userDef <span class="token operator">===</span> <span class="token string">'function'</span> <span class="token operator">?</span> userDef <span class="token operator">:</span> userDef<span class="token punctuation">.</span>get<span class="token punctuation">;</span>
    <span class="token comment">// 1、为每个 computed 都创建一个 watcher</span>
    <span class="token comment">// watcher 用来存储计算值，判断是否需要重新计算</span>
    watchers<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Watcher</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> getter<span class="token punctuation">,</span> <span class="token punctuation">{</span> lazy<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 判断是否有重名的属性</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>key <span class="token keyword">in</span> vm<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">defineComputed</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> key<span class="token punctuation">,</span> userDef<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// Watcher</span>
<span class="token comment">// 总结: computed 即带有标志位的 watcher</span>
<span class="token keyword">function</span> <span class="token function">Watcher</span><span class="token punctuation">(</span><span class="token parameter">vm<span class="token punctuation">,</span> expOrFn<span class="token punctuation">,</span> options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   
  	<span class="token comment">// dirty 默认为 false 的，而 lazy 赋给 dirty 只相当于一个开启的作用(或初始化)，使其延后执行</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>dirty <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lazy <span class="token operator">=</span> options<span class="token punctuation">.</span>lazy<span class="token punctuation">;</span>  
  	<span class="token comment">// 保存设置的 getter</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>getter <span class="token operator">=</span> expOrFn<span class="token punctuation">;</span>   
  	<span class="token comment">// watcher.value 存放计算结果，但因受 lazy 条件的控制，不会新建实例并马上读取值，最初为 undefined</span>
  	<span class="token comment">// 只有再读取 computed 时，才开始计算，而不是初始化就开始计算值，通过 watcher.get 计算 value </span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lazy <span class="token operator">?</span> <span class="token keyword">undefined</span><span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token class-name">Watcher</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">get</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    
    <span class="token comment">// getter 就是 watcher 回调</span>
    <span class="token keyword">var</span> value <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getter</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> vm<span class="token punctuation">)</span><span class="token punctuation">;</span>    
    <span class="token keyword">return</span> value
<span class="token punctuation">}</span><span class="token punctuation">;</span>


<span class="token comment">// defineComputed</span>
<span class="token comment">// 总结: 使用 createComputedGetter 包装 get 函数</span>
<span class="token keyword">function</span> <span class="token function">defineComputed</span><span class="token punctuation">(</span> <span class="token parameter">target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> userDef</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    
    <span class="token comment">// 设置 set 为默认值，避免 computed 并没有设置 set</span>
  	<span class="token comment">// 1、set 函数默认是空函数，如果用户设置，则使用用户设置</span>
    <span class="token keyword">var</span> <span class="token function-variable function">set</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>      
    <span class="token comment">//  如果用户设置了set，就使用用户的set</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>userDef<span class="token punctuation">.</span>set<span class="token punctuation">)</span> set <span class="token operator">=</span> userDef<span class="token punctuation">.</span>set   

  	<span class="token comment">// 2、使用 Object.defineProperty 在实例上 computed 属性，所以可以直接访问</span>
    Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token punctuation">{</span>        
        <span class="token comment">// 3、使用 createComputedGetter 包装 get 函数，主要用于判断计算缓存结果是否有效</span>
        get<span class="token operator">:</span><span class="token function">createComputedGetter</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span>        
        set<span class="token operator">:</span>set
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>


<span class="token comment">// createComputedGetter</span>
<span class="token keyword">function</span> <span class="token function">createComputedGetter</span><span class="token punctuation">(</span><span class="token parameter">key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    
    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        
        <span class="token comment">// 获取到相应 key 的 computed-watcher</span>
        <span class="token comment">// 总结：即当 data 变化时，获取相应的 watcher，若 _computedWatchers 中包含所依赖的数据的 watcher，则返回 watcher；</span>
        <span class="token keyword">var</span> watcher <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_computedWatchers<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>        
        <span class="token comment">// 若 computed 依赖的数据变化，dirty 会变成 true，从而重新计算，然后更新缓存值 watcher.value</span>
      	<span class="token comment">// 总结: </span>
      	<span class="token comment">// 首先，watcher 初始化时，dirty 为默认值 true，遂进行首次执行；</span>
 				<span class="token comment">// 然后，data 发生变化时，触发 watcher.prototype.update, 设置标志为 true；</span>
      	<span class="token comment">// (data 会有一个 watcher 数组，其中有 computed类的 watcher，也有 watch类的watcher);</span>
      	<span class="token comment">// 注意: 关键在于控制 watcher.dirty，这是执行的关键，首先要明白: computed 数据A 引用了 data 数据B，即 A 依赖 B，所以 B 会收集到 A 的 watcher，而当 B 改变时，会通知 A 进行更新，即调用 A-watcher.update, 而 update 中开启了 dirty，从而读取 comptued 时，会调用 evalute 重新计算</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>watcher<span class="token punctuation">.</span>dirty<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            watcher<span class="token punctuation">.</span><span class="token function">evaluate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>        
        <span class="token comment">// data 与 computed 双向绑定</span>
      	<span class="token comment">// 总结: 之所以 data 能通知 computed 的 watcher，是因为初始化时就进行了双方关系绑定，绑定通过 watcher.depend 实现</span>
      	<span class="token comment">// 即让 data 依赖收集器收集当前 watcher(computed_watcher)</span>
      	<span class="token comment">// 举例说即: 页面-P、computed-C、data-D</span>
      	<span class="token comment">// 1、P 引用了 C，C 引用了 D</span>
				<span class="token comment">// 2、理论上 D 改变时，C 就会改变，C 则通知 P 更新</span>
				<span class="token comment">// 3、实际上 C 让 D 和 P 建立联系，让 D 改变时直接通知 P</span>
				<span class="token comment">// 而绑定的关键即下方代码 depend</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>Dep<span class="token punctuation">.</span>target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            watcher<span class="token punctuation">.</span><span class="token function">depend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>        
        <span class="token keyword">return</span> watcher<span class="token punctuation">.</span>value
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// evaluate</span>
<span class="token class-name">Watcher</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">evaluate</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    
    <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    
    <span class="token comment">// 执行完更新函数之后，立即重置标志位</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>dirty <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>


<span class="token comment">// update </span>
<span class="token class-name">Watcher</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">update</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>lazy<span class="token punctuation">)</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>dirty <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  	<span class="token comment">// ...</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>


<span class="token comment">// depend</span>
<span class="token class-name">Watcher</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">depend</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    
    <span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>deps<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    
    <span class="token keyword">while</span> <span class="token punctuation">(</span>i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        
        <span class="token comment">// this.deps[i].depend();</span>
      	<span class="token comment">// Dep.target 即页面 watcher</span>
        dep<span class="token punctuation">.</span><span class="token function">addSub</span><span class="token punctuation">(</span>Dep<span class="token punctuation">.</span>target<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>


<span class="token class-name">Watcher</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">get</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    
    <span class="token comment">// 改变 Dep.target</span>
    <span class="token function">pushTarget</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    
    <span class="token comment">// getter 就是 watcher 回调</span>
    <span class="token keyword">var</span> value <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getter</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>vm<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>vm<span class="token punctuation">)</span><span class="token punctuation">;</span>    
    <span class="token comment">// 恢复前一个 watcher</span>
    <span class="token function">popTarget</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    
    <span class="token keyword">return</span> value
<span class="token punctuation">}</span><span class="token punctuation">;</span>
Dep<span class="token punctuation">.</span>target <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> targetStack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">pushTarget</span><span class="token punctuation">(</span><span class="token parameter">_target</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    
    <span class="token comment">// 把上一个 Dep.target 缓存起来，便于后面恢复</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>Dep<span class="token punctuation">.</span>target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        targetStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>Dep<span class="token punctuation">.</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    Dep<span class="token punctuation">.</span>target <span class="token operator">=</span> _target<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">popTarget</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Dep<span class="token punctuation">.</span>target <span class="token operator">=</span> targetStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 1、页面 watcher.getter 保存 页面更新函数，computed watcher.getter 保存 计算 getter</span>
<span class="token comment">// 2、watcher.get 用于执行 watcher.getter 并 设置 Dep.target</span>
<span class="token comment">// 3、Dep.target 会有缓存</span>
</code></pre></div><p><strong><u><em>Computed 机制总结：</em></u></strong></p> <p><strong><u><em>首先，初始化时：</em></u></strong></p> <ul><li>初始化：init—&gt;initComputed—&gt;页面初次渲染，此时 Dep.target 为页面 Watcher—&gt;触发用 createComputed包装的 get 函数 createComputedGetter，createComputedGetter 主要执行了：<code>if (watcher.dirty) { watcher.evaluate(); }</code>、<code>if (Dep.target) { watcher.depend(); }</code> <ul><li>前者：执行前者；此时 watcher.dirty = true，因使用的是 lazy 的初始值 (initComputed 中 <code>new Watcher(vm, getter, { lazy: true });</code>)，所以 <code>watcher.evaluted</code> 可以被调用 (注意：调用完毕就要设置 dirty 为 false，此后除非与 computed 相关 data  发生变化，否则不会触发，即此值控制着缓存，是 computed 的核心实现)，随即 <code>computed.watcher.get</code> 被调用，进行 <code>pushTarget</code>，导致 <code>Dep.target</code> 被修改为 computed-watcher，而原来的值(页面 Watcher)会先被缓存到 targetStack 中；同时，computed 的计算会读取 data，因为双绑机制，此时 data 就能收集到 computed-watcher，即computed-watcher 也会保存到 data 的依赖收集器 dep.subs 中；随后，computed 计算完毕，执行 popTarget，释放 Dep.target，并将 Dep.target 恢复上一个 watcher(页面watcher)；</li> <li>后者，执行后者；即 <code>watcher.depend</code>，即执行 <code>dep.addSub(Dep.target)</code>，目的是让 data 再收集一次 Dep.target， 即收集页面 watcher；</li></ul></li> <li>此时，<code>data 的依赖收集器 = [ computed-watcher, 页面-watcher]</code></li></ul> <p><strong><u><em>然后，数据更新时：</em></u></strong></p> <ul><li>即 computed 所依赖的 data 更新时，触发 <code>dep.nodify</code>，依次触发依赖数组下的每一watcher：
<ul><li>先执行 computed-watcher 计算值(调用了 <code>watcher.update</code>，而其中包含了 <code>if (this.lazy) this.dirty = true;</code>，但注意此时尚未计算结果，只是控制计算的阀门打开，计算行为由 <code>watcher.evaluate()</code> 负责，而此方法在 <code>get:createComputedGetter(key),</code>，注意 get，所以 get 时，也即页面渲染时，读取值时才做真正计算 )；</li> <li>再执行页面-watcher 渲染页面做真正计算；</li> <li>即 data 改变，正序遍历通知，computed 先更新，页面再更新，所以页面才能读取到最新的 computed 值；</li></ul></li></ul> <p><strong><u><em>最后总结</em></u></strong>：由双绑控制变化的触发，值相等则不触发，值不等才触发 watcher.update，而平时的刷新渲染不会触发 computed 的计算求值，因为 watcher.dirty 为 false，但 watcher 监听属性则会随着页面刷新而触发，即使它所绑定的值未发生值变化，因为它没有设置 watcher.dirty 变量去阻止；所以可以理解为 computed 计算属性是带有 dirty 标记的 watch，也正因为通过此标记，才能阻止不随页面刷新而计算；</p> <img src="/Image/Frame/Vue/510.png" align="" style="zoom:50%;"> <p>参考：https://juejin.im/post/6844903877699960846</p> <h4 id="_1-x-2、nexttick"><a href="#_1-x-2、nexttick" class="header-anchor">#</a> 1-X-2、nextTick</h4> <h5 id="_1-x-2-1、概览"><a href="#_1-x-2-1、概览" class="header-anchor">#</a> 1-X-2-1、概览</h5> <p>官方描述：在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM；</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 修改数据</span>
vm<span class="token punctuation">.</span>msg <span class="token operator">=</span> <span class="token string">'Hello'</span>
<span class="token comment">// DOM 还没有更新</span>
Vue<span class="token punctuation">.</span><span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// DOM 更新了</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// 作为一个 Promise 使用 (2.1.0 起新增，详见接下来的提示)</span>
Vue<span class="token punctuation">.</span><span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
 <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// DOM 更新了</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">// 2.1.0 起新增：若无提供回调且在支持 Promise 的环境中，则返回一个 Promise；</span>
<span class="token comment">// 注意 Vue 不自带 Promise 的 polyfill，所以若目标浏览器不原生支持 Promise，得自己提供 polyfill... =。=</span>
</code></pre></div><p>注意：Vue 异步执行 DOM 更新，只要观察到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据改变；若同一个 watcher 被多次触发，只会被推入到队列中一次；这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作上非常重要；然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部尝试对异步队列使用原生的 Promise.then 和 MessageChannel，如果执行环境不支持，会采用 setTimeout(fn, 0) 代替。</p> <p>比如：当设置 vm.someData = 'new value' ，该组件不会立即重新渲染。当刷新队列时，组件会在事件循环队列清空时的下一个“tick”更新。多数情况我们不需要关心这个过程，但是如果你想在 DOM 状态更新后做点什么，这就可能会有些棘手。虽然 Vue.js 通常鼓励开发人员沿着“数据驱动”的方式思考，避免直接接触 DOM，但是有时我们确实要这么做。为了在数据变化之后等待 Vue 完成更新 DOM ，可以在数据变化之后立即使用 Vue.nextTick(callback) 。这样回调函数在 DOM 更新完成后就会调用；</p> <p>Vue 在2.4版本、2.5版本和2.6版本中对于<code>nextTick</code>进行反复变动，原因是浏览器对于<strong>微任务</strong>的不兼容性影响、<strong>微任务</strong>和<strong>宏任务</strong>各自优缺点的权衡；</p> <img src="/Image/Frame/Vue/511.png" align="" style="zoom:50%;"> <p>若 Vue 使用<code>setTimeout</code>等**<u>宏任务函数</u><strong>，则势必要等待UI渲染完成后的下一个</strong><u>宏任务</u><strong>执行，而若 Vue 使用</strong><u>微任务函数</u><strong>，则无需等待UI渲染完成才进行<code>nextTick</code>的回调函数操作，可想象在 <strong>JS引擎线程</strong> 和 <strong>GUI渲染线程</strong> 间来回切换，及等待</strong>GUI渲染线程**的过程中，浏览器势必要消耗性能，这是一个严谨的框架完全需要考虑的事情。</p> <p>当然这里所说的只是<code>nextTick</code>执行用户回调之后的性能情况考虑，这中间当然不能忽略<code>flushBatcherQueue</code>更新Dom的操作，使用异步函数的另外一个作用当然是要确保同步代码执行完毕Dom更新性能优化（例如同步操作对响应式数据使用for循环更新一千次，那么这里只有一次DOM更新而不是一千次）。</p> <p>到了这里，对于Vue中<code>nextTick</code>函数的命名应该是了然于心了，当然这个命名不知道和Node.js的<code>process.nextTick</code>还有没有什么必然联系</p> <h5 id="_1-x-2-2、源码分析"><a href="#_1-x-2-2、源码分析" class="header-anchor">#</a> 1-X-2-2、源码分析</h5> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 2.5</span>
<span class="token comment">/* @flow */</span>
<span class="token comment">/* globals MessageChannel */</span>

<span class="token keyword">import</span> <span class="token punctuation">{</span> noop <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'shared/util'</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> handleError <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./error'</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> isIOS<span class="token punctuation">,</span> isNative <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./env'</span>

<span class="token keyword">const</span> callbacks <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token keyword">let</span> pending <span class="token operator">=</span> <span class="token boolean">false</span>

<span class="token keyword">function</span> <span class="token function">flushCallbacks</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  pending <span class="token operator">=</span> <span class="token boolean">false</span>
  <span class="token keyword">const</span> copies <span class="token operator">=</span> callbacks<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
  callbacks<span class="token punctuation">.</span>length <span class="token operator">=</span> <span class="token number">0</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> copies<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    copies<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 在2.4中使用了microtasks ，但是还是存在问题，</span>
<span class="token comment">// 在2.5版本中组合使用macrotasks和microtasks，组合使用的方式是对外暴露withMacroTask函数</span>
<span class="token comment">// Here we have async deferring wrappers using both microtasks and (macro) tasks.</span>
<span class="token comment">// In &lt; 2.4 we used microtasks everywhere, but there are some scenarios where</span>
<span class="token comment">// microtasks have too high a priority and fire in between supposedly</span>
<span class="token comment">// sequential events (e.g. #4521, #6690) or even between bubbling of the same</span>
<span class="token comment">// event (#6566). However, using (macro) tasks everywhere also has subtle problems</span>
<span class="token comment">// when state is changed right before repaint (e.g. #6813, out-in transitions).</span>
<span class="token comment">// Here we use microtask by default, but expose a way to force (macro) task when</span>
<span class="token comment">// needed (e.g. in event handlers attached by v-on).</span>

<span class="token comment">// 2.5版本在nextTick中对于调用microtask（微任务）还是macrotask（宏任务）声明了两个不同的变量</span>
<span class="token keyword">let</span> microTimerFunc
<span class="token keyword">let</span> macroTimerFunc

<span class="token comment">// 默认使用microtask（微任务）</span>
<span class="token keyword">let</span> useMacroTask <span class="token operator">=</span> <span class="token boolean">false</span>


<span class="token comment">// 这里主要定义macrotask（宏任务）函数</span>
<span class="token comment">// macrotask（宏任务）的执行优先级</span>
<span class="token comment">// setImmediate -&gt; MessageChannel -&gt; setTimeout</span>
<span class="token comment">// setImmediate是最理想的选择</span>
<span class="token comment">// 最Low的状况是降级执行setTimeout</span>

<span class="token comment">// Determine (macro) task defer implementation.</span>
<span class="token comment">// Technically setImmediate should be the ideal choice, but it's only available</span>
<span class="token comment">// in IE. The only polyfill that consistently queues the callback after all DOM</span>
<span class="token comment">// events triggered in the same loop is by using MessageChannel.</span>
<span class="token comment">/* istanbul ignore if */</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> setImmediate <span class="token operator">!==</span> <span class="token string">'undefined'</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isNative</span><span class="token punctuation">(</span>setImmediate<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function-variable function">macroTimerFunc</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">setImmediate</span><span class="token punctuation">(</span>flushCallbacks<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> MessageChannel <span class="token operator">!==</span> <span class="token string">'undefined'</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>
  <span class="token function">isNative</span><span class="token punctuation">(</span>MessageChannel<span class="token punctuation">)</span> <span class="token operator">||</span>
  <span class="token comment">// PhantomJS</span>
  MessageChannel<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">'[object MessageChannelConstructor]'</span>
<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> channel <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MessageChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">const</span> port <span class="token operator">=</span> channel<span class="token punctuation">.</span>port2
  channel<span class="token punctuation">.</span>port1<span class="token punctuation">.</span>onmessage <span class="token operator">=</span> flushCallbacks
  <span class="token function-variable function">macroTimerFunc</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    port<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
  <span class="token comment">/* istanbul ignore next */</span>
  <span class="token function-variable function">macroTimerFunc</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span>flushCallbacks<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>


<span class="token comment">// 这里主要定义microtask（微任务）函数</span>
<span class="token comment">// microtask（微任务）的执行优先级</span>
<span class="token comment">// Promise -&gt; macroTimerFunc</span>
<span class="token comment">// 如果原生不支持Promise，那么执行macrotask（宏任务）函数</span>

<span class="token comment">// Determine microtask defer implementation.</span>
<span class="token comment">/* istanbul ignore next, $flow-disable-line */</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> Promise <span class="token operator">!==</span> <span class="token string">'undefined'</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isNative</span><span class="token punctuation">(</span>Promise<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> p <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token function-variable function">microTimerFunc</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>flushCallbacks<span class="token punctuation">)</span>
    <span class="token comment">// in problematic UIWebViews, Promise.then doesn't completely break, but</span>
    <span class="token comment">// it can get stuck in a weird state where callbacks are pushed into the</span>
    <span class="token comment">// microtask queue but the queue isn't being flushed, until the browser</span>
    <span class="token comment">// needs to do some other work, e.g. handle a timer. Therefore we can</span>
    <span class="token comment">// &quot;force&quot; the microtask queue to be flushed by adding an empty timer.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>isIOS<span class="token punctuation">)</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span>noop<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
  <span class="token comment">// fallback to macro</span>
  microTimerFunc <span class="token operator">=</span> macroTimerFunc
<span class="token punctuation">}</span>


<span class="token comment">// 对外暴露withMacroTask 函数</span>
<span class="token comment">// 触发变化执行nextTick时强制执行macrotask（宏任务）函数</span>

<span class="token comment">/**
 * Wrap a function so that if any code inside triggers state change,
 * the changes are queued using a (macro) task instead of a microtask.
 */</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">withMacroTask</span> <span class="token punctuation">(</span><span class="token parameter">fn<span class="token operator">:</span> Function</span><span class="token punctuation">)</span><span class="token operator">:</span> Function <span class="token punctuation">{</span>
  <span class="token keyword">return</span> fn<span class="token punctuation">.</span>_withTask <span class="token operator">||</span> <span class="token punctuation">(</span>fn<span class="token punctuation">.</span><span class="token function-variable function">_withTask</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    useMacroTask <span class="token operator">=</span> <span class="token boolean">true</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
      useMacroTask <span class="token operator">=</span> <span class="token boolean">false</span>    
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// 这里需要注意pending</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">nextTick</span> <span class="token punctuation">(</span><span class="token parameter">cb<span class="token operator">?</span><span class="token operator">:</span> Function<span class="token punctuation">,</span> ctx<span class="token operator">?</span><span class="token operator">:</span> Object</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> _resolve
  callbacks<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>cb<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token function">cb</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span>
      <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">handleError</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> ctx<span class="token punctuation">,</span> <span class="token string">'nextTick'</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>_resolve<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">_resolve</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>pending<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    pending <span class="token operator">=</span> <span class="token boolean">true</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>useMacroTask<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">macroTimerFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token function">microTimerFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// $flow-disable-line</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>cb <span class="token operator">&amp;&amp;</span> <span class="token keyword">typeof</span> Promise <span class="token operator">!==</span> <span class="token string">'undefined'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token parameter">resolve</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      _resolve <span class="token operator">=</span> resolve
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>









<span class="token comment">// 2.6</span>
<span class="token comment">/* @flow */</span>
<span class="token comment">/* globals MutationObserver */</span>

<span class="token keyword">import</span> <span class="token punctuation">{</span> noop <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'shared/util'</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> handleError <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./error'</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> isIE<span class="token punctuation">,</span> isIOS<span class="token punctuation">,</span> isNative <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./env'</span>

<span class="token keyword">export</span> <span class="token keyword">let</span> isUsingMicroTask <span class="token operator">=</span> <span class="token boolean">false</span>

<span class="token keyword">const</span> callbacks <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token keyword">let</span> pending <span class="token operator">=</span> <span class="token boolean">false</span>

<span class="token keyword">function</span> <span class="token function">flushCallbacks</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  pending <span class="token operator">=</span> <span class="token boolean">false</span>
  <span class="token keyword">const</span> copies <span class="token operator">=</span> callbacks<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
  callbacks<span class="token punctuation">.</span>length <span class="token operator">=</span> <span class="token number">0</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> copies<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    copies<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 在2.5版本中组合使用microtasks 和macrotasks，但是重绘的时候还是存在一些小问题，而且使用macrotasks在任务队列中会有几个特别奇怪的行为没办法避免，So又回到了之前的状态，在任何地方优先使用microtasks 。</span>
<span class="token comment">// Here we have async deferring wrappers using microtasks.</span>
<span class="token comment">// In 2.5 we used (macro) tasks (in combination with microtasks).</span>
<span class="token comment">// However, it has subtle problems when state is changed right before repaint</span>
<span class="token comment">// (e.g. #6813, out-in transitions).</span>
<span class="token comment">// Also, using (macro) tasks in event handler would cause some weird behaviors</span>
<span class="token comment">// that cannot be circumvented (e.g. #7109, #7153, #7546, #7834, #8109).</span>
<span class="token comment">// So we now use microtasks everywhere, again.</span>
<span class="token comment">// A major drawback of this tradeoff is that there are some scenarios</span>
<span class="token comment">// where microtasks have too high a priority and fire in between supposedly</span>
<span class="token comment">// sequential events (e.g. #4521, #6690, which have workarounds)</span>
<span class="token comment">// or even between bubbling of the same event (#6566).</span>
<span class="token keyword">let</span> timerFunc

<span class="token comment">// The nextTick behavior leverages the microtask queue, which can be accessed</span>
<span class="token comment">// via either native Promise.then or MutationObserver.</span>
<span class="token comment">// MutationObserver has wider support, however it is seriously bugged in</span>
<span class="token comment">// UIWebView in iOS &gt;= 9.3.3 when triggered in touch event handlers. It</span>
<span class="token comment">// completely stops working after triggering a few times... so, if native</span>
<span class="token comment">// Promise is available, we will use it:</span>
<span class="token comment">/* istanbul ignore next, $flow-disable-line */</span>


<span class="token comment">// task的执行优先级</span>
<span class="token comment">// Promise -&gt; MutationObserver -&gt; setImmediate -&gt; setTimeout</span>

<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> Promise <span class="token operator">!==</span> <span class="token string">'undefined'</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isNative</span><span class="token punctuation">(</span>Promise<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> p <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token function-variable function">timerFunc</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>flushCallbacks<span class="token punctuation">)</span>
    <span class="token comment">// In problematic UIWebViews, Promise.then doesn't completely break, but</span>
    <span class="token comment">// it can get stuck in a weird state where callbacks are pushed into the</span>
    <span class="token comment">// microtask queue but the queue isn't being flushed, until the browser</span>
    <span class="token comment">// needs to do some other work, e.g. handle a timer. Therefore we can</span>
    <span class="token comment">// &quot;force&quot; the microtask queue to be flushed by adding an empty timer.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>isIOS<span class="token punctuation">)</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span>noop<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  isUsingMicroTask <span class="token operator">=</span> <span class="token boolean">true</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isIE <span class="token operator">&amp;&amp;</span> <span class="token keyword">typeof</span> MutationObserver <span class="token operator">!==</span> <span class="token string">'undefined'</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>
  <span class="token function">isNative</span><span class="token punctuation">(</span>MutationObserver<span class="token punctuation">)</span> <span class="token operator">||</span>
  <span class="token comment">// PhantomJS and iOS 7.x</span>
  MutationObserver<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">'[object MutationObserverConstructor]'</span>
<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// Use MutationObserver where native Promise is not available,</span>
  <span class="token comment">// e.g. PhantomJS, iOS7, Android 4.4</span>
  <span class="token comment">// (#6466 MutationObserver is unreliable in IE11)</span>
  <span class="token keyword">let</span> counter <span class="token operator">=</span> <span class="token number">1</span>
  <span class="token keyword">const</span> observer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MutationObserver</span><span class="token punctuation">(</span>flushCallbacks<span class="token punctuation">)</span>
  <span class="token keyword">const</span> textNode <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createTextNode</span><span class="token punctuation">(</span><span class="token function">String</span><span class="token punctuation">(</span>counter<span class="token punctuation">)</span><span class="token punctuation">)</span>
  observer<span class="token punctuation">.</span><span class="token function">observe</span><span class="token punctuation">(</span>textNode<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    characterData<span class="token operator">:</span> <span class="token boolean">true</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token function-variable function">timerFunc</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    counter <span class="token operator">=</span> <span class="token punctuation">(</span>counter <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">2</span>
    textNode<span class="token punctuation">.</span>data <span class="token operator">=</span> <span class="token function">String</span><span class="token punctuation">(</span>counter<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  isUsingMicroTask <span class="token operator">=</span> <span class="token boolean">true</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> setImmediate <span class="token operator">!==</span> <span class="token string">'undefined'</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isNative</span><span class="token punctuation">(</span>setImmediate<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// Fallback to setImmediate.</span>
  <span class="token comment">// Techinically it leverages the (macro) task queue,</span>
  <span class="token comment">// but it is still a better choice than setTimeout.</span>
  <span class="token function-variable function">timerFunc</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">setImmediate</span><span class="token punctuation">(</span>flushCallbacks<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
  <span class="token comment">// Fallback to setTimeout.</span>
  <span class="token function-variable function">timerFunc</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span>flushCallbacks<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">nextTick</span> <span class="token punctuation">(</span><span class="token parameter">cb<span class="token operator">?</span><span class="token operator">:</span> Function<span class="token punctuation">,</span> ctx<span class="token operator">?</span><span class="token operator">:</span> Object</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> _resolve
  callbacks<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>cb<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token function">cb</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span>
      <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">handleError</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> ctx<span class="token punctuation">,</span> <span class="token string">'nextTick'</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>_resolve<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">_resolve</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>pending<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    pending <span class="token operator">=</span> <span class="token boolean">true</span>
    <span class="token function">timerFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// $flow-disable-line</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>cb <span class="token operator">&amp;&amp;</span> <span class="token keyword">typeof</span> Promise <span class="token operator">!==</span> <span class="token string">'undefined'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token parameter">resolve</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      _resolve <span class="token operator">=</span> resolve
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>参考：https://juejin.im/post/6844903843197616136#heading-2</p></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/docs/assets/js/app.cda475f7.js" defer></script><script src="/docs/assets/js/2.c902c426.js" defer></script><script src="/docs/assets/js/56.388173c5.js" defer></script>
  </body>
</html>
