<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>一、基本 | Leibnize 个人学习笔记</title>
    <meta name="generator" content="VuePress 1.5.4">
    
    <meta name="description" content="整理自网络">
    <link rel="preload" href="/docs/assets/css/0.styles.2f643d57.css" as="style"><link rel="preload" href="/docs/assets/js/app.cda475f7.js" as="script"><link rel="preload" href="/docs/assets/js/2.c902c426.js" as="script"><link rel="preload" href="/docs/assets/js/49.9d81175e.js" as="script"><link rel="prefetch" href="/docs/assets/js/10.418fecbd.js"><link rel="prefetch" href="/docs/assets/js/11.e2c998bf.js"><link rel="prefetch" href="/docs/assets/js/12.b627468b.js"><link rel="prefetch" href="/docs/assets/js/13.682b9b92.js"><link rel="prefetch" href="/docs/assets/js/14.0880e743.js"><link rel="prefetch" href="/docs/assets/js/15.4a6c4027.js"><link rel="prefetch" href="/docs/assets/js/16.200e0299.js"><link rel="prefetch" href="/docs/assets/js/17.1c6394bc.js"><link rel="prefetch" href="/docs/assets/js/18.c0560a2b.js"><link rel="prefetch" href="/docs/assets/js/19.f63607cc.js"><link rel="prefetch" href="/docs/assets/js/20.d56d802e.js"><link rel="prefetch" href="/docs/assets/js/21.52c3ae8e.js"><link rel="prefetch" href="/docs/assets/js/22.b47add39.js"><link rel="prefetch" href="/docs/assets/js/23.a8a40e53.js"><link rel="prefetch" href="/docs/assets/js/24.a0e2af55.js"><link rel="prefetch" href="/docs/assets/js/25.1fb24116.js"><link rel="prefetch" href="/docs/assets/js/26.068130b1.js"><link rel="prefetch" href="/docs/assets/js/27.6cb72d75.js"><link rel="prefetch" href="/docs/assets/js/28.d99e5701.js"><link rel="prefetch" href="/docs/assets/js/29.4848d9ba.js"><link rel="prefetch" href="/docs/assets/js/3.be11a00a.js"><link rel="prefetch" href="/docs/assets/js/30.92ed4a03.js"><link rel="prefetch" href="/docs/assets/js/31.de402b39.js"><link rel="prefetch" href="/docs/assets/js/32.b5ca6564.js"><link rel="prefetch" href="/docs/assets/js/33.c3d91abd.js"><link rel="prefetch" href="/docs/assets/js/34.b868c98b.js"><link rel="prefetch" href="/docs/assets/js/35.4128bd9f.js"><link rel="prefetch" href="/docs/assets/js/36.8e4b22b8.js"><link rel="prefetch" href="/docs/assets/js/37.090897e6.js"><link rel="prefetch" href="/docs/assets/js/38.f8d5752b.js"><link rel="prefetch" href="/docs/assets/js/39.f949333a.js"><link rel="prefetch" href="/docs/assets/js/4.64176cb5.js"><link rel="prefetch" href="/docs/assets/js/40.39833f40.js"><link rel="prefetch" href="/docs/assets/js/41.a12c7b96.js"><link rel="prefetch" href="/docs/assets/js/42.a5e6d9e8.js"><link rel="prefetch" href="/docs/assets/js/43.28874788.js"><link rel="prefetch" href="/docs/assets/js/44.8d4042e3.js"><link rel="prefetch" href="/docs/assets/js/45.b148e845.js"><link rel="prefetch" href="/docs/assets/js/46.91062fd6.js"><link rel="prefetch" href="/docs/assets/js/47.2026c6cc.js"><link rel="prefetch" href="/docs/assets/js/48.b0f3d68f.js"><link rel="prefetch" href="/docs/assets/js/5.1d876c62.js"><link rel="prefetch" href="/docs/assets/js/50.1a00f734.js"><link rel="prefetch" href="/docs/assets/js/51.b16e53d7.js"><link rel="prefetch" href="/docs/assets/js/52.831b9cca.js"><link rel="prefetch" href="/docs/assets/js/53.4ce4ac34.js"><link rel="prefetch" href="/docs/assets/js/54.6d7ca762.js"><link rel="prefetch" href="/docs/assets/js/55.2bb32bbd.js"><link rel="prefetch" href="/docs/assets/js/56.388173c5.js"><link rel="prefetch" href="/docs/assets/js/57.cd784d78.js"><link rel="prefetch" href="/docs/assets/js/58.d994c1a9.js"><link rel="prefetch" href="/docs/assets/js/59.0665a00b.js"><link rel="prefetch" href="/docs/assets/js/6.bc091efc.js"><link rel="prefetch" href="/docs/assets/js/60.12f3479d.js"><link rel="prefetch" href="/docs/assets/js/61.679d1273.js"><link rel="prefetch" href="/docs/assets/js/62.04ef0d26.js"><link rel="prefetch" href="/docs/assets/js/63.70e8cd2b.js"><link rel="prefetch" href="/docs/assets/js/64.c7956833.js"><link rel="prefetch" href="/docs/assets/js/65.0304095c.js"><link rel="prefetch" href="/docs/assets/js/66.f16304a7.js"><link rel="prefetch" href="/docs/assets/js/67.d0a945f4.js"><link rel="prefetch" href="/docs/assets/js/68.26e1c58d.js"><link rel="prefetch" href="/docs/assets/js/69.ac162984.js"><link rel="prefetch" href="/docs/assets/js/7.255d7d5f.js"><link rel="prefetch" href="/docs/assets/js/70.5408bf05.js"><link rel="prefetch" href="/docs/assets/js/8.2117996a.js"><link rel="prefetch" href="/docs/assets/js/9.e855c324.js">
    <link rel="stylesheet" href="/docs/assets/css/0.styles.2f643d57.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/docs/" class="home-link router-link-active"><!----> <span class="site-name">Leibnize 个人学习笔记</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="https://github.com/rjwx60" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="https://github.com/rjwx60" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span></span> <span class="arrow down"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h3 id="一、基本"><a href="#一、基本" class="header-anchor">#</a> 一、基本</h3> <h4 id="_1-1、基本"><a href="#_1-1、基本" class="header-anchor">#</a> 1-1、基本</h4> <ul><li><p><strong><u>原型 prototype</u></strong>： 创建的每一个函数，都有一个prototype属性，该属性指向一个对象，这个对象就是原型</p> <ul><li><p>定B：一个简单的对象，用于实现对象的 <strong>属性继承</strong>；可简单的理解成对象的爹；</p></li> <li><p>比如：在火狐、谷歌中，每个 JS 对象中都包含一<code>__proto__</code>    属性(非标)指向它爹(该对象原型)，即 <code>obj.__proto__</code> 进行访问；</p></li> <li><p>定C：原型是构造调用时，也即在实例创建过程中，系统自动创建出来的、与构造函数相关联的一个空的对象，可由 <code>构造函数.prototype</code> 访问到；</p></li> <li><p>注意：<code>实例.__proto__</code>，指向函数原型，于是在原型上增加属性或方法，便可成为实例的共有属性和方法；</p></li> <li><p>补充：原型对象是一个内部对象，官方没有给出能直接访问的方法，浏览器提供了一个 <strong>proto</strong> 属性，通过它来访问对象原型：</p> <p>原型对象在 JS 标准中用 [[prototype]] 表示 (参见 <a href="https://developer.mozilla.org/en-US/docs/Glossary/ECMAScript" target="_blank" rel="noopener noreferrer">ECMAScript<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>)；</p></li></ul></li> <li><p><strong><u>构造函数</u></strong>：可通过 <code>new</code> 来 <strong>新建一个对象</strong> 的函数；</p> <ul><li>本质：即函数、专用于同 new 操作符一起实例化对象、new 调用的时候称为构造调用；</li> <li>约定：大写字母开头、应仅作为构造调用使用；</li></ul></li> <li><p><strong><u>实例</u></strong>：通过构造函数和 <code>new</code> 创建出来的对象(或中间对象，或函数在中间对象环境下调用产生的结果)，即实例；</p> <ul><li><strong>实例通过<code>__proto__</code>指向原型，通过<code>constructor</code>指向构造函数</strong>；</li></ul></li></ul> <h5 id="_1-1-1、注意事项"><a href="#_1-1-1、注意事项" class="header-anchor">#</a> 1-1-1、注意事项</h5> <img src="/Image/Basics/Special/Mode/21.png" align="" style="zoom:50%;"> <img src="/Image/Basics/Special/Mode/22.png" align="" style="zoom:50%;"> <ul><li>注意：每个对象的 <code>__proto__</code> 属性，指向对象的构造函数的 prototype；</li> <li>所以：上面图中，对象为 Foo.prototype(原型)，对象的构造函数为 Object，对象指向对象的构造函数的原型即 Object.prototype；</li> <li>所以：此处对象乃原型，是故原型的构造函数为 Object；</li> <li>那么：若对象为 Object.prototype(原型)，则又指向谁呢？null；</li></ul> <img src="/Image/Basics/Special/Mode/23.png" align="" style="zoom:50%;"> <h4 id="_1-2、关系"><a href="#_1-2、关系" class="header-anchor">#</a> 1-2、关系</h4> <p>在 JS 中，每当定义一个函数数据类型(普通函数、类)时候，都会天生自带一个 prototype 属性，这个属性指向函数的 <strong><u>原型对象</u></strong>；</p> <p>当函数经过 new 调用时，此函数便作为 <strong><u>构造函数</u></strong>，返回一全新的 <strong><u>实例</u></strong> 对象，此实例对象有一个__proto__属性，指向构造函数的原型对象；</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 实例为 instance, 构造函数为 Object, 构造函数拥有一个 prototype 属性指向原型</span>
<span class="token keyword">const</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> prototype <span class="token operator">=</span> <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype
</code></pre></div><h5 id="_1-2-1、构造与实例"><a href="#_1-2-1、构造与实例" class="header-anchor">#</a> 1-2-1、构造与实例</h5> <p>构造函数、实例之间关系：</p> <p>创建和被创建的关系，实例需通过 <code>__proto__</code> 找原型，再通过原型的 constructor 找构造其的函数；</p> <img src="/Image/Basics/Special/Mode/30.png" align="" style="zoom:50%;"> <h5 id="_1-2-2、构造与原型"><a href="#_1-2-2、构造与原型" class="header-anchor">#</a> 1-2-2、构造与原型</h5> <p>构造函数、原型之间关系：</p> <p>函数的原型对象即：<code>构造函数的原型对象.constructor === 函数</code>；</p> <img src="/Image/Basics/Special/Mode/31.png" align="" style="zoom:50%;"> <h5 id="_1-2-3、实例与原型"><a href="#_1-2-3、实例与原型" class="header-anchor">#</a> 1-2-3、实例与原型</h5> <p>某某实例、原型之间关系**：**</p> <p>实例的原型 === 构造实例的函数的原型对象，即：<code>实例.__proto__ === 构造实例的函数.prototype</code>；</p> <img src="/Image/Basics/Special/Mode/32.png" align="" style="zoom:50%;"> <h5 id="_1-2-4、prototype-与-proto"><a href="#_1-2-4、prototype-与-proto" class="header-anchor">#</a> 1-2-4、prototype 与 proto</h5> <p>显式原型：prototype：</p> <ul><li>含义：每一个函数，在创建之后都会拥有一个名为 prototype 的属性，属性指向函数的原型对象；</li> <li>作用：用以实现基于原型的继承与属性共享；
<ul><li>注意：通过 Function.prototype.bind 构造出的函数是例外，其没有 prototype 属性；</li></ul></li></ul> <p>隐式原型：<code>__proto__</code>：</p> <ul><li>含义：任意 JS 对象，都有内置属性 [[prototype]]，指向创建此对象的函数的显式原型 prototype；</li> <li>作用：用以构成原型链，同样可用以实现基于原型的继承与属性共享，当找寻某对象属性或方法时，便会沿此进行搜索；
<ul><li>注意：ES5 前，没有标准方法访问此属性(prototype)，但大多数浏览器均支持通过 <code>__proto__</code> 访问；</li> <li>注意：ES5 后，有标准方法可访问：Object.getPrototypeOf()：<code>Object.getPrototypeOf(fn) == test.prototype // true</code></li> <li>注意：Object.prototype 是唯一的，没有原型的对象：</li></ul></li></ul> <p>两者关系：</p> <ul><li>对象的隐式原型 <code>__proto__</code> 指向，创建这个对象的函数(constructor)，的显式原型 prototype；</li> <li><img src="/Image/Basics/Special/Mode/38.png" align="" style="zoom:50%;"></li></ul> <p>两者区别：</p> <ul><li>prototype：对象且函数才有属性；</li> <li><code>__proto__</code>：对象皆有的属性，但并非规范属性 (部分浏览器实现，标准属性为 [[Prototype]]</li> <li><img src="/Image/Basics/Special/Mode/39.png" align="" style="zoom:50%;"></li></ul> <p>注意事项：</p> <ul><li><p><code>__proto__</code> 为 构造器原型；</p> <ul><li><div class="language-js extra-class"><pre class="language-js"><code>__proto__ <span class="token operator">==</span> constructor<span class="token punctuation">.</span>prototype <span class="token comment">// true</span>
</code></pre></div></li></ul></li> <li><p><code>__proto__</code> 实际上是 getter setter，源于 Object.prototype，使用时可理解成返回 Object.getPrototypeOf(obj)；</p> <ul><li><div class="language-js extra-class"><pre class="language-js"><code>Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span> <span class="token operator">==</span> fn__proto__ <span class="token comment">// true</span>
</code></pre></div></li></ul></li> <li><p><code>__proto__</code> 指向取决于对象创建的实现方式，图3-5；</p></li></ul> <img src="/Image/Basics/Special/Mode/40.png" align="" style="zoom:50%;"> <img src="/Image/Basics/Special/Mode/41.png" align="" style="zoom:50%;"> <img src="/Image/Basics/Special/Mode/42.png" align="" style="zoom:50%;"> <h5 id="_1-2-5、constructor"><a href="#_1-2-5、constructor" class="header-anchor">#</a> 1-2-5、constructor</h5> <p>constructor 属性是原型对象的属性，指向这个原型对象所对应的构造函数；</p> <p>每个对象实例都具有 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/constructor" target="_blank" rel="noopener noreferrer">constructor<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 属性，它指向创建该实例的构造器函数</p> <ul><li>比如：person2.constructor，返回 Person() 构造器</li> <li>比如：new person2.constructor()，返回 Person() 构造器 创建的新实例</li></ul> <h5 id="_1-2-6、关系综述"><a href="#_1-2-6、关系综述" class="header-anchor">#</a> 1-2-6、关系综述</h5> <p>构造函数、原型和实例之间的关系：每个 <u>构造函数</u> 都有一个 <u>原型</u> 对象，<u>原型</u> 对象都包含一个指向 <u>构造函数</u> 的指针，而 <u>实例</u> 都包含一个 <u>原型对象</u> 的指针；</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 三者的关系(再述):</span>
实例<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> 原型

<span class="token class-name">原型</span><span class="token punctuation">.</span>constructor <span class="token operator">===</span> 构造函数

<span class="token class-name">构造函数</span><span class="token punctuation">.</span>prototype <span class="token operator">===</span> 原型

<span class="token class-name">实例</span><span class="token punctuation">.</span>constructor <span class="token operator">===</span> 构造函数
<span class="token comment">// 注意: 其实实例上并不是真正有 constructor 这个指针，它其实是从原型链上获取的: </span>
<span class="token comment">// instance.hasOwnProperty('constructor') === false </span>

<span class="token comment">// 例如: </span>
<span class="token comment">// const o = new Object()</span>
<span class="token comment">// o.constructor === Object   --&gt; true</span>
<span class="token comment">// o.__proto__ = null;</span>
<span class="token comment">// o.constructor === Object   --&gt; false </span>

<span class="token comment">// 对象原型 prototype 属性 与 构造函数 prototype 属性间区别：</span>
<span class="token comment">// 前者可通过 Object.getPrototypeOf(obj) 或，已被弃用的 __proto__ 属性获得</span>
<span class="token comment">// 前者是每个实例上都有的属性，后者是构造函数的属性</span>
<span class="token comment">// 也就是说，Object.getPrototypeOf(new Foobar())和 Foobar.prototype 指向着同一个对象</span>
<span class="token comment">// function Foobar(){} -&gt; undefined</span>
<span class="token comment">// foobar = new Foobar() -&gt; Foobar {}</span>
<span class="token comment">// Object.getPrototypeOf(foobar) == Foobar.prototype -&gt; true</span>
</code></pre></div><img src="/Image/Basics/Special/Mode/4.png" style="zoom:35%;"> <img src="/Image/Basics/Special/Mode/43.png" style="zoom:50%;"> <h5 id="_1-2-6-1、大图解说"><a href="#_1-2-6-1、大图解说" class="header-anchor">#</a> 1-2-6-1、大图解说</h5> <p>再叙：实例对象的原型([[Prototype]] 或 <code>__proto__</code>) === 构造实例的函数的原型对象，即构造实例的函数的 prototype 属性；</p> <p>再叙：构造函数的 prototype 属性，即原型对象，又可作为新的实例对象，实例对象的原型又指向下一轮；</p> <p>再叙：一直到达 Object.prototype，其原型，即 <code>Object.prototype.__proto__ === null</code>；</p> <p>再叙：<code>对象.__proto__…..__proto__</code>为 Object.prototype，随即 <code>Object.prototype. __proto__</code> 指向 Null；</p> <img src="/Image/Basics/Special/Mode/14.png" align="" style="zoom:50%;"> <ul><li><p>分析：<code>__proto__</code> 即实例对象的原型 <code>[[Prototype]]</code>;</p></li> <li><p>注意：<code>__proto__</code> 是私有属性，现代浏览器将其暴露给用户，修改此值会改变继承关系；</p></li> <li><p>分析：函数构建出的实例对象的原型 <code>__proto__</code>，指向函数的原型 <code>Foo.prototype</code>，图左上角；</p></li> <li><p>分析：函数的属性 prototype，指向函数原型，即 <code>Foo.prototype</code>，图中上方；</p></li> <li><p>分析：函数原型的原型，即 <code>Foo.prototype.__proto__</code> ，指向 Object 原型 <code>Object.prototype</code>，图右上角；</p></li> <li><p>注意：唯一例外：Function 构造函数，可用 <code>Function.__proto__</code> 来访问 <code>Function.prototype</code></p> <ul><li>一般情况是：实例的__proto__指向实例构造函数的 prototype ;</li></ul></li> <li><p>因为：Function 构造函数即其自身，故作为实例化对象来访问；</p> <ul><li><code>Function.__proto__(作为实例) == Function.prototype(作为构造函数)</code>；</li></ul></li> <li><p>注意：唯一例外：<code>Function.prototype</code> 并非普通对象，而是函数对象 (特殊匿名函数，此函数的 <code>__proto__</code> 指向 Object.prototype)；</p></li> <li><p>而且：所有构造函数中，只有 Function 的 prototype 属性为函数</p></li></ul> <img src="/Image/Basics/Special/Mode/35.png" align="" style="zoom:50%;"> <img src="/Image/Basics/Special/Mode/34.png" align="" style="zoom:50%;"> <h5 id="_1-2-6-2、大图解说"><a href="#_1-2-6-2、大图解说" class="header-anchor">#</a> 1-2-6-2、大图解说</h5> <img src="/Image/Basics/Special/Mode/36.png" align="" style="zoom:50%;"> <p>注意：任何对象均函数，均继承 Function 所有属性和方法，而 Function 是内置的构造函数也是对象，均继承 Object 的所有属性方法；</p> <p>注意：各种 function、Object、Function 等实际上均为 new Function() 后的实例，而这些实例原型 <code>__proto__</code> 均指向 Function.prototype；</p> <p>同理：Object、Number、String、Array、Function、Date 等均为函数，而所有函数均由 Function 创建，故其原型 <code>__proto__</code> 指向 Function.prototype：</p> <img src="/Image/Basics/Special/Mode/37.png" align="" style="zoom:50%;"> <h4 id="_1-3、new"><a href="#_1-3、new" class="header-anchor">#</a> 1-3、new</h4> <h5 id="_1-3-1、new-过程"><a href="#_1-3-1、new-过程" class="header-anchor">#</a> 1-3-1、new 过程</h5> <img src="/Image/Basics/Special/Mode/19.png" align="" style="zoom:55%;"> <p>构造调用过程即 new 过程：</p> <ul><li>首先，创建全新的对象 (中间对象) obj；</li> <li>然后，新对象会被执行 [[ 原型 ]] 连接 (将中间对象的原型，指向函数原型，此后便可使用函数原型上的方法和属性)；
<ul><li><code>obj.__proto__ = Target.prototype</code></li></ul></li> <li>然后，新对象会绑定到函数调用的 this (即将函数内部 this 指向中间对象)；</li> <li>最后，若函数返回基本类型，则返回中间对象；若返回对象，则代替中间对象，返回函数返回的对象；</li></ul> <p>再说：new 调用过程：</p> <ul><li>它创建了一个全新的对象</li> <li>它会被执行[[Prototype]](也即 <code>__proto__</code>)链接</li> <li>它使 this 指向新创建的对象</li> <li>通过 new 创建的每个对象将最终被[[Prototype]]链接到这个函数的prototype对象上</li> <li>如果函数没有返回对象类型 Object(包含Functoin, Array, Date, RegExg, Error)，那么new表达式中的函数调用将返回该对象引用</li></ul> <p>再说：new 调用过程：</p> <ul><li>创建(或者说构造)一个全新对象；</li> <li>这个新对象会被执行 [[ Prototype ]] 连接；</li> <li>这个新对象会绑定到函数调用的 this；</li> <li>若函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象；</li></ul> <img src="/Image/Basics/Special/Mode/20.png" align="" style="zoom:50%;"> <p>再说：new 调用过程：</p> <ul><li><strong>创建一个新对象，并继承其构造函数的<code>prototype</code></strong>；此步是为了继承构造函数原型上的属性和方法；</li> <li><strong>执行构造函数，方法内的<code>this</code>被指定为该新实例</strong>；此步是为了执行构造函数内的赋值操作；</li> <li><strong>返回新实例</strong> (规范规定，若构造方法返回了一个对象，则返回该对象，否则返回第一步创建的新对象)；</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// new 是关键字, 这里用函数来模拟, new Foo(args) &lt;=&gt; myNew(Foo, args)</span>
<span class="token keyword">function</span> <span class="token function">myNew</span><span class="token punctuation">(</span><span class="token parameter">foo<span class="token punctuation">,</span> <span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 创建新对象, 并继承构造方法的 prototype 属性</span>
  <span class="token comment">// 此步是为了把 obj 挂原型链上, 相当于 obj.__proto__ = Foo.prototype</span>
  <span class="token keyword">let</span> obj <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>foo<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span>  
  
  <span class="token comment">// 执行构造方法, 并为其绑定新 this</span>
  <span class="token comment">// 此步是为了让构造方法能进行 this.name = name 类似操作, args 是构造方法的入参, 因为此处用 myNew 模拟, 故入参从 myNew 传入</span>
  <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> args<span class="token punctuation">)</span>

  <span class="token comment">// 若构造方法已 return 了一个对象，则就返回该对象，否则返回 myNew 创建的新对象</span>
  <span class="token comment">// 一般情况下，构造方法不会返回新实例，但使用者可以选择返回新实例来覆盖 new 创建的对象</span>
  <span class="token keyword">return</span> <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">'[object Object]'</span> <span class="token operator">?</span> result <span class="token operator">:</span> obj
<span class="token punctuation">}</span>

<span class="token comment">// 测试：</span>
<span class="token keyword">function</span> <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
<span class="token punctuation">}</span>
<span class="token keyword">const</span> newObj <span class="token operator">=</span> <span class="token function">myNew</span><span class="token punctuation">(</span>Foo<span class="token punctuation">,</span> <span class="token string">'zhangsan'</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>newObj<span class="token punctuation">)</span>                 <span class="token comment">// Foo {name: &quot;zhangsan&quot;}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>newObj <span class="token keyword">instanceof</span> <span class="token class-name">Foo</span><span class="token punctuation">)</span>  <span class="token comment">// true</span>
</code></pre></div><h5 id="_1-3-2、创建对象方式"><a href="#_1-3-2、创建对象方式" class="header-anchor">#</a> 1-3-2、创建对象方式</h5> <p>创建对象的三种方式：字面量、new、Object.create()，但本质的只有1种：new；</p> <ul><li>字面量是方便创建对象的语法糖，本质是 new Object()</li> <li>new Object 内部还是通过 new 创建</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// Object.create</span>
<span class="token keyword">function</span> <span class="token function">object</span><span class="token punctuation">(</span><span class="token parameter">o</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">function</span> <span class="token constant">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token class-name">F</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> o<span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="_1-4、原型链"><a href="#_1-4、原型链" class="header-anchor">#</a> 1-4、原型链</h4> <p><strong><u>原型链</u></strong>：即 JS 对象通过 <code>__proto__</code>  指向父类对象，直到指向 Object 对象为止，形成的一个原型指向的链条；</p> <p><strong><u>原型链</u></strong>：当访问一对象的属性/方法时，首先在该对象上查找，然后查找该对象原型，以及该对象原型的原型，逐层上找，直到匹配属性/方法或达原型链尾-null；</p> <p><strong><u>原型链</u></strong>：即相互关联的原型组成的链条结构；</p> <p>[[Prototype]] 内置属性，其实就是对其他对象的引用，几乎所有对象在创建时 [[Prototype]] 属性都会被赋予一非空值；</p> <ul><li><p>查找操作：</p> <ul><li>如果，在对象上没有找到需要的属性或者方法引用，引擎就会继续在 [[Prototype]] 关联的对象上进行查找；</li> <li>如果，在后者中也没有找到需要的引用就会继续查找它的 [[Prototype]]，以此类推；</li> <li>这一系列对象的链接即 <strong><u>原型链</u></strong>；</li></ul></li> <li><p>Get 操作：试图引用对象的属性时会触发[[Get]] 操作，比如 myObject.a：</p> <ul><li>首先，检查对象本身是否有这个 [[Prototype]] 内置属性，若有则使用它，若没有，则需使用对象的 [[Prototype]] 链；</li> <li>但若，anotherObject 中也找不到 a 且 [[Prototype]] 链不为空，则继续查找下去，此过程会持续到找到匹配属性名或查找完整条 [[Prototype]] 链；</li> <li>最后，若还是找不到那个值，[[Get]] 操作返回 undefined；</li></ul></li> <li><p>Set 操作：试图给一个 对象设置属性 或 修改已有的属性值会触发 [[Set]] 操作，myObject.foo = &quot;bar”：</p> <ul><li>首先，若 myObject 对象中包含名为 foo 的普通数据访问属性，则只修改已有属性值；
<ul><li>若 myObject 的 [[Prototype]] 链上层也有 foo，此时发生屏蔽，因 myObject.foo 总是会选择原型链中最底层的 foo 属性；</li></ul></li> <li>然后，若 foo 非直接存在于 myObject 中，[[Prototype]] 链就会被遍历，类似 [[Get]] 操作：
<ul><li>若原型链上找不到 foo，foo 就会被直接添加到 myObject 上。</li> <li>若原型链上存在 foo (在 [[Prototype]] 链上层存在名为 foo)：
<ul><li>情况1：其为没有被标记为只读(writable:false)，则会直接在 myObject 中添加一个名为 foo 的新属性，它是屏蔽属性；</li> <li>情况2：其为被标记为只读(writable:false)，则无法修改已有属性或者在 myObject 上创建屏蔽属性；
<ul><li>如果，运行在严格模式下会抛出一个错误，否则，这条赋值语句会被忽略，总之，不会发生屏蔽；</li></ul></li> <li>情况3：其为一个 setter ，则一定会调用这个 setter；
<ul><li>foo 不会被添加到(或说屏蔽于)myObject，也不会重新定义 foo 这个 setter；</li></ul></li></ul></li></ul></li></ul></li></ul> <img src="/Image/Basics/Special/Mode/24.png" align="" style="zoom:50%;"> <ul><li>注意：使用 for..in ，遍历对象时原理和查找 [[Prototype]] 链类似，任何可通过原型链访问到且是 enumerable的属性都会被枚举；</li> <li>注意：使用 in 操作符，检查属性在对象中是否存在时，同样会查找对象的整条原型链(此时无论属性是否可枚举)；</li> <li>注意：所有普通 [[Prototype]] 链，最终均指向内置的 Object.prototype：
<ul><li>由于所有普通内置对象都“源于”(将 [[Prototype]] 链的顶端设置为)此 Object.prototype 对象，故包含 JS 中许多通用的功能：</li> <li>比如： .toString() 和 .valueOf()， .hasOwnProperty(..) 和 .isPrototypeOf(..)；</li></ul></li></ul> <p><strong><u>原型链</u></strong>：每一对象都有自己的原型对象：实例对象有原型，原型对象也是对象(此处原型对象相当于上一级原型的实例)，故也有其原型(上一级原型对象)，如此形成的一个链式结构；</p> <p>比如：下图：<code>实例.__proto__</code>指向其原型，<code>原型.__proto__</code>又指向其原型，然后指向 Object.prototype，最终指向 null；</p> <img src="/Image/Basics/Special/Mode/25.png" align="" style="zoom:50%;"> <img src="/Image/Basics/Special/Mode/26.png" align="" style="zoom:50%;"> <img src="/Image/Basics/Special/Mode/27.png" align="" style="zoom:50%;"> <p><strong><u>原型链</u></strong>：Js 是一种基于原型的语言：每个对象，拥有一个原型对象，对象以其原型为模板，从原型继承方法和属性原型对象也可能拥有原型，并从中继承方法和属性，一层一层、以此类推，此种关系被称为原型链；</p> <ul><li>意义：它解释了为何一个对象会拥有，“定义在其他对象中的属性和方法”。更准确说，它解释了为何一个对象会拥有，定义在 Object的，构造器函数(constructor functions)上的，prototype属性上的属性和方法，而非定义在对象实例上；</li> <li>注意：Js 中并不是复制，而是建立链接：传统的 OOP 中，定义类后，创建对象实例时，类中定义的所有属性和方法都被，复制到实例中，但在 JS 中，并不是复制在 JS 中，是在对象实例，和它的构造器间，建立一个链接(它是 <code>__proto__</code> 属性，是从构造函数的prototype 属性派生的)之后通过上溯原型链，在构造器中找到这些属性和方法</li> <li>重申：原型链中的方法和属性，没有被复制到其他对象，它们的访问需要通过原型链；</li> <li>注意：Object中有大量的属性和方法，但实际被继承的，就只有那些以 Object.prototype 开头的属性；是因为继承的属性和方法是定义在 prototype 属性之上的；比如：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/watch" target="_blank" rel="noopener noreferrer">Object.prototype.watch()<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/valueOf" target="_blank" rel="noopener noreferrer">Object.prototype.valueOf()<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 等；但：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/is" target="_blank" rel="noopener noreferrer">Object.is()<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>、<a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Objects/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/keys" target="_blank" rel="noopener noreferrer">Object.keys()<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>等不在 prototype 对象内的成员，仅能被 Object() 构造器自身使用，不会被对象实，或继承自 Object() 的对象类型所继承；</li> <li>prototype 属性的值是一个对象，希望被原型链下游的对象继承的属性和方法，都被储存在其中；</li> <li>注意：一般很少将属性定义在构造器上的prototype上，因为不灵活；</li> <li><strong><u>原型链模型</u></strong>：上游对象的方法，不会复制到下游的对象实例中；下游对象本身虽然没有定义这些方法，但通过上溯原型链、能从上游对象中找到它们；这种继承模型提供了一个强大而可扩展的功能系统；</li></ul> <p><strong><u>原型链</u></strong>：即由原型对象组成，每个对象都有 <code>__proto__</code> 属性，指向了创建该对象的构造函数的原型，<code>__proto__</code> 将对象连接起来组成了原型链，是一个用来 <u>实现继承和共享属性</u> 的有限的对象链；它有两个机制和特点：</p> <ul><li><strong>属性查找机制</strong>：当查找对象的属性时，若实例对象自身不存在该属性，则沿着原型链往上一级查找，找到时则输出，不存在时，则继续沿着原型链往上一级查找，直至最顶级的原型对象 <code>Object.prototype</code>，如还是没找到，则输出 <code>undefined</code>；</li> <li>比如：person.valueOf()；</li> <li><img src="/Image/Basics/Special/Mode/44.png" align="" style="zoom:50%;"></li> <li><strong>属性修改机制</strong>：只会修改实例对象本身的属性，若不存在，则进行添加该属性，若需要修改原型的属性时，则可用: <code>b.prototype.x = 2</code>；但会造成所有继承于该对象的实例的属性发生改变；</li> <li>特点：对象的 hasOwnProperty() 来检查对象自身中是否含有该属性；</li> <li>特点：使用 in 检查对象中是否含有某个属性时，如果对象中没有但是原型链中有，也会返回 true；</li></ul> <img src="/Image/Basics/Special/Mode/2.png" style="zoom:50%;"> <img src="/Image/Basics/Special/Mode/28.png" style="zoom:50%;"> <img src="/Image/Basics/Special/Mode/29.png" style="zoom:50%;"> <h4 id="_1-5、instance-of"><a href="#_1-5、instance-of" class="header-anchor">#</a> 1-5、instance of</h4> <h5 id="_1-5-1、理解一"><a href="#_1-5-1、理解一" class="header-anchor">#</a> 1-5-1、理解一</h5> <p>在实例的 <strong>原型对象链</strong> 中找到该构造函数的 <code>prototype</code> 属性所指向的 <strong>原型对象</strong>，就返回<code>true</code>：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// __proto__: 代表原型对象链</span>
instance<span class="token punctuation">.</span><span class="token punctuation">[</span>__proto__<span class="token operator">...</span><span class="token punctuation">]</span> <span class="token operator">===</span> instance<span class="token punctuation">.</span>constructor<span class="token punctuation">.</span>prototype
<span class="token comment">// return true</span>
</code></pre></div><h5 id="_1-5-2、理解二"><a href="#_1-5-2、理解二" class="header-anchor">#</a> 1-5-2、理解二</h5> <p>应理解为：</p> <p>检测左侧对象 L 的原型链上(即 L.<strong>proto</strong>.<strong>proto</strong>……)，是否存在右侧 R 的 prototype 原型(即 R.prototype)，如下图；</p> <p>或者：用以判断某个构造函数，的 prototype 属性，是否存在于另外一个要检测对象，的原型链上；</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token constant">L</span> <span class="token keyword">instanceof</span> <span class="token class-name">R</span> <span class="token operator">==</span><span class="token operator">&gt;</span> <span class="token constant">L</span><span class="token punctuation">.</span>__proto__<span class="token punctuation">.</span>__proto__<span class="token operator">...</span><span class="token punctuation">.</span> <span class="token operator">===</span> <span class="token class-name">R</span><span class="token punctuation">.</span>prototype 
</code></pre></div><h5 id="_1-5-3、模拟实现"><a href="#_1-5-3、模拟实现" class="header-anchor">#</a> 1-5-3、模拟实现</h5> <p>instanceof 运算时会递归查找 left Value 的原型链，即 <code>left Value.__proto__.__proto__.__proto__</code>... ，直至找到 / 到达顶层为止</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">instance_of</span><span class="token punctuation">(</span><span class="token parameter"><span class="token constant">L</span><span class="token punctuation">,</span> <span class="token constant">R</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> <span class="token constant">O</span> <span class="token operator">=</span> <span class="token class-name">R</span><span class="token punctuation">.</span>prototype <span class="token comment">// 取 R 显式原型</span>
  <span class="token constant">L</span> <span class="token operator">=</span> <span class="token constant">L</span><span class="token punctuation">.</span>__proto__<span class="token punctuation">;</span>		<span class="token comment">// 取 L 隐式原型</span>
  <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token constant">L</span> <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token constant">L</span> <span class="token operator">===</span> <span class="token constant">O</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>	<span class="token comment">// 注意严格相等</span>
    <span class="token constant">L</span> <span class="token operator">=</span> <span class="token constant">L</span><span class="token punctuation">.</span>__proto__<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h5 id="_1-5-4、注意事项与示例"><a href="#_1-5-4、注意事项与示例" class="header-anchor">#</a> 1-5-4、注意事项与示例</h5> <ul><li><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     
    <span class="token comment">// ...  </span>
<span class="token punctuation">}</span> 
<span class="token class-name">Foo</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>xxx <span class="token operator">=</span> <span class="token operator">...</span><span class="token punctuation">;</span> 
<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
</code></pre></div></li></ul> <img src="/Image/Basics/Special/Mode/5.png" align="" style="zoom:50%;"> <ul><li>instanceof 工作机制；若修改 prototype 的 值，则会改变原有(图2)</li></ul> <img src="/Image/Basics/Special/Mode/6.png" align="" style="zoom:50%;"> <img src="/Image/Basics/Special/Mode/7.png" align="" style="zoom:50%;"> <ul><li>Fun 是单纯的函数，<code>Fun.__proto__</code> 属于 Function.prototype，除非 new 出来，否则不属于 Fun.prototype；</li></ul> <img src="/Image/Basics/Special/Mode/8.png" align="" style="zoom:50%;"> <ul><li>JS 在访问 str 属性时创建临时 String 对象 (假设叫tmpStr)，并在得到此返回值时销毁临时对象，故此处是 <code>tmpStr.__proto__</code> 的值；而引用类型的字面量和基础类型的不一样(图2)；</li></ul> <img src="/Image/Basics/Special/Mode/9.png" align="" style="zoom:50%;"> <img src="/Image/Basics/Special/Mode/10.png" align="" style="zoom:50%;"> <ul><li>对于三种基本类型的字面声明，instanceof 均返回 false；而其他类型的字面量声明则为 true；</li></ul> <img src="/Image/Basics/Special/Mode/11.png" align="" style="zoom:50%;"> <img src="/Image/Basics/Special/Mode/12.png" align="" style="zoom:50%;"> <ul><li><code>Object.prototype.__proto__</code> 为 null，但 null 不等于 <code>Object.prototype</code>；</li></ul> <img src="/Image/Basics/Special/Mode/13.png" align="" style="zoom:50%;"> <h5 id="_1-5-5、js-object-layout"><a href="#_1-5-5、js-object-layout" class="header-anchor">#</a> 1-5-5、JS Object Layout</h5> <img src="/Image/Basics/Special/Mode/14.png" align="" style="zoom:50%;"> <ul><li><strong>Object instanceof Object</strong></li></ul> <img src="/Image/Basics/Special/Mode/15.png" align="" style="zoom:50%;"> <ul><li><strong>Function instanceof Function</strong></li></ul> <img src="/Image/Basics/Special/Mode/16.png" align="" style="zoom:50%;"> <ul><li><strong>Foo instanceof Foo</strong></li></ul> <img src="/Image/Basics/Special/Mode/17.png" align="" style="zoom:50%;"> <h4 id="_1-x、编程分类"><a href="#_1-x、编程分类" class="header-anchor">#</a> 1-X、编程分类</h4> <p>面向对象编程——OOP：</p> <ul><li>定义：把构成问题事务分解成单或多个对象，但分拆成对象并非为了完成某一步骤，而是为了描述某个事物在整个解决问题的步骤中的行为；</li> <li>示例：Eat(Dog，Apple)；</li> <li>示例：Refrigerator.open() —&gt; Refrigerator.load(thing) —&gt; Refrigerator.close()；</li> <li>优点：具有良好的可移植性和可扩展性；</li> <li>缺点：掌握难，容易偏向为面向过程；</li> <li>特性：
<ul><li>多态、封装、继承</li></ul></li></ul> <p>面向过程编程——POP：</p> <ul><li>定义：分析出解决问题所需步骤，然后用方法将各个步骤逐一实现，使用时依次调用；</li> <li>示例：Dog.eat(apple)；</li> <li>示例：Open(Refrigerator) —&gt; Load(Refrigerator，thing) —&gt; Close(Refrigerator)；</li> <li>优点：同步思维开发；</li> <li>缺点：牵一发而动全身，移植性和可扩展性差；</li></ul> <p>面向组件编程——COP：(暂略)；</p> <p>面向方面编程——AOP：(暂略)；</p> <p>面向服务编程——SOP：(暂略)；</p> <h3 id="二、多态"><a href="#二、多态" class="header-anchor">#</a> 二、多态</h3> <p>基本：根据传入参数的个数不同，调用相应的方法</p> <p>JS 是弱类型，不存在编译时要确定类型，天然支持多态。</p> <h3 id="三、封装"><a href="#三、封装" class="header-anchor">#</a> 三、封装</h3> <p>含义：将客观事物封装成抽象的类，隐藏属性和方法的实现细节，仅对外公开接口(可见性控制)；此点 JS 可通过闭包</p> <p>ES6 class 为语法糖，在此之前没有类概念(实际上 JS 没有类，只是模拟行为)，均借助于：原型对象、构造函数来实现；</p> <ul><li>私有属性/方法：只能在构造函数内访问不能被外部所访问：在构造函数内使用 var 等声明的属性/方法；</li> <li>公有属性/方法(或实例方法)：对象外可访问到对象内的属性和方法：在构造函数内使用 this 设置，或设置在构造函数原型 prototype 对象上；</li> <li>静态属性/方法：定义在构造函数上的方法，无需实例即可调用；</li></ul> <p>使用 <code>for...in...</code> 能获取到实例对象自身的属性和原型链上的属性(可枚举属性)；</p> <p>使用 <code>Object.keys()</code> 和 <code>Object.getOwnPropertyNames()</code>只能获取实例对象自身属性(可枚举属性)；</p> <p>使用 <code>Object.hasOwnProperty()</code> 方法传入属性名来判断某属性是不是实例自身属性(可枚举属性)；</p> <ul><li><p>注意：类不会提升(不像普通变量和函数)，注意报错</p> <ul><li><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">function</span> <span class="token constant">A</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
<span class="token comment">// A{}</span>

<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>
<span class="token comment">// Uncaught ReferenceError: Cannot access 'B' before initialization</span>
</code></pre></div></li></ul></li> <li></li> <li><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">TLP</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> type <span class="token operator">=</span> <span class="token string">'fykms'</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'tlp'</span>
  <span class="token punctuation">}</span>
  type <span class="token operator">=</span> <span class="token string">'old man'</span>
  <span class="token function-variable function">getType</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>type<span class="token punctuation">)</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> type <span class="token operator">=</span> <span class="token string">'window'</span>
<span class="token keyword">var</span> tlp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TLP</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
tlp<span class="token punctuation">.</span><span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// old man</span>
<span class="token comment">// window</span>
</code></pre></div></li> <li><p>注意：constructor 的 var 等声明变量为私有变量不可获取</p></li> <li><p>注意：类中箭头函数转为 ES5 时，仍作为一个函数处理，只是处理后仍为箭头函数，保留箭头函数特性；</p></li> <li><p>注意：若同名变量则以 constructor 为优先(优先是因为Babel转译顺序导致)，原因看Babel 转译结果</p></li> <li><img src="/Image/Basics/Special/Mode/222.png" style="zoom:50%;"></li></ul> <h3 id="四、继承"><a href="#四、继承" class="header-anchor">#</a> 四、继承</h3> <p>将属性和方法组装成一个类的过程(私有化变量和方法 (通过 this 创建的属性视作为共有变量，而通过 <u>闭包</u> 还可实现对私有变量的访问))；</p> <ul><li>问题1：JS 中没有类概念；</li> <li>解决2：可通过作用域的变量访问限制，以模拟类实现，比如：构造函数、<code>Object.create()</code>、点语法；
<ul><li>方法1：<u>通过构造函数添加类</u>：在函数中创建 this 相关属性和方法，再通过 new 生成实例和绑定 this，例略；
<ul><li>好处：实例间相互独立，不受影响；</li> <li>坏处：好处即坏处，通过 this 定义的属性或方法，每次实例化都复制一份，内存消耗大、复杂、可读性；</li></ul></li> <li>方法2：<u>通过原型添加类</u>：基于 <code>实例.__proto__</code> 指向 函数原型，从而使用原型上的方法；
<ul><li>好处：原型链上的属性和方法只需建立一次;</li> <li>坏处：原型链上的属性和方法为全体实例共用，若链上的属性是引用类型则会被改变(而链上的方法铁定会改变)，不能实现私有属性和私有方法；</li></ul></li> <li>方法3：<u>通过点语法</u>：在构造函数身上通过点语法增加属性或方法；
<ul><li>好处：仅创建一次；</li> <li>坏处：显而易见，实例无法访问，仅能用过自身访问；</li></ul></li></ul></li> <li>问题2：JS没有 <code>private public protected</code> 关键字；</li> <li>解决2：可通过作用域的变量访问限制，来模拟此类关键字：图1
<ul><li>Public：对所有用户开放，均可直接调用；</li> <li>Private：自身属性或方法，仅自身能直接访问；</li> <li>Protected：自身实例可访问，外部类不可访问；</li></ul></li></ul> <img src="/Image/Basics/Special/Mode/220.png" align="" style="zoom:50%;"> <ul><li>总结：JS 很容易模拟一个类，并且可以一定程度上做到面向对象中的三大特性：封装、继承、多态；</li> <li>所以，从最初去模拟一个类，到 ES5 提供更便捷的原型操控API，到 ES6 中提供更多类相关的关键字，都是在帮助开发者减小 JS 中面向对象的使用成本；</li> <li>虽然，JS 中的继承并非真正&quot;继承&quot;，类也不是真正的&quot;类&quot;，相比 Java 肯定还有很多实现不了的地方；
<ul><li>比如，abstract class、Interface 等，只能通过一些 tricky 的办法去模拟；</li></ul></li> <li>因此 JS 中所谓的继承，是为方便程序员用面向对象的方式来组织代码；</li></ul> <img src="/Image/Basics/Special/Mode/215.png" align="" style="zoom:50%;"> <h4 id="_4-2、构造函数的继承-原型继承演进"><a href="#_4-2、构造函数的继承-原型继承演进" class="header-anchor">#</a> 4-2、构造函数的继承(原型继承演进)</h4> <h5 id="_4-2-1、原型链继承"><a href="#_4-2-1、原型链继承" class="header-anchor">#</a> 4-2-1、原型链继承</h5> <p>基本：构造函数、原型、实例间关系：每个 <u>构造函数</u> 都有一 <u>原型</u> 对象，<u>原型</u> 对象都包含一指向 <u>构造函数</u> 的指针，而 <u>实例</u> 都包含一 <u>原型对象</u> 的指针；</p> <p>关键：<code>子类.prototype = new 父类(); 子类.prototype.constructor = 子类;</code></p> <p>原理：直接让子类原型对象指向父类实例，当子类实例找不到相应属性和方法时，就会往其原型对象，也即父类实例上找，从而实现对父类属性和方法的继承；</p> <p>注意：但凡对 prototype 作赋值操作，均需重新将 prototype.constructor 修正为子类；因 子类.constructor 属性默认调用 prototype 对象 constructor 属性；</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 父类</span>
<span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'特朗普'</span>
<span class="token punctuation">}</span>
<span class="token comment">// 父类原型方法</span>
<span class="token class-name">Parent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name
<span class="token punctuation">}</span>
<span class="token comment">// 子类</span>
<span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token comment">// 让子类的原型对象指向父类实例, 这样一来在 Child 实例中找不到的属性和方法就会到原型对象(父类实例)上寻找</span>
<span class="token class-name">Child</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// 根据原型链的规则, 顺便绑定一下 constructor, 这一步不影响继承, 只是在用到 constructor 时会需要</span>
<span class="token comment">// 帮助修复 子类实例的构造函数错误指向</span>
<span class="token class-name">Child</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Child 

<span class="token comment">// 然后 Child 实例就能访问到父类及其原型上的 name 属性和 getName() 方法</span>
<span class="token keyword">const</span> child <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
child<span class="token punctuation">.</span>name          <span class="token comment">// '特朗普'</span>
child<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span>     <span class="token comment">// '特朗普'</span>
</code></pre></div><p>优点：可使用父类方法；</p> <p>缺点：</p> <ul><li><p>因直接 <code>子类.prototype = new 父类</code>，故会覆盖 <code>子类.prototype</code> 原有属性 (不解释)；</p></li> <li><p>父类的引用属性会被所有子类实例共享，多个实例对引用类型的操作会相互影响；</p> <ul><li>解释：由于所有子类实例原型都指向同一个父类实例，故对某个子类实例的父类引用类型变量修改会影响所有子类实例 (因为是多对一关系)</li></ul></li> <li><p>子类构建实例时不能向父类传递参数，即没有实现 <code>super()</code> 的功能 (你™怎么传参，子类与父类的关系纽带就靠 prototype 维系，无关构造)</p> <ul><li><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// Ex1:</span>
<span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'特朗普'</span><span class="token punctuation">]</span> 
<span class="token punctuation">}</span>
<span class="token class-name">Parent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token class-name">Child</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token class-name">Child</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Child 

<span class="token comment">// 测试</span>
<span class="token keyword">const</span> child1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> child2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
child1<span class="token punctuation">.</span>name<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'foo'</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child1<span class="token punctuation">.</span>name<span class="token punctuation">)</span>  <span class="token comment">// ['foo']</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child2<span class="token punctuation">.</span>name<span class="token punctuation">)</span>  <span class="token comment">// ['foo'] (预期是['特朗普'], 对 child1.name 的修改引起了所有 child 实例的变化)</span>
</code></pre></div></li></ul></li></ul> <h5 id="_4-2-2、构造函数继承"><a href="#_4-2-2、构造函数继承" class="header-anchor">#</a> 4-2-2、构造函数继承</h5> <p>基本：使用父类的构造函数来增强子类实例，等同于复制父类的实例给子类(不使用原型)</p> <p>关键： 在子类函数中执行：<code>父类函数.apply/call(this, arguments/…arguments);</code></p> <p>原理：即在子类的构造函数中执行父类的构造函数，并为其绑定子类的 <code>this</code>，让父类的构造函数将成员属性和方法，都挂到 <code>子类的this</code>上去，避免原型继承中，实例间共享同一原型实例问题，此外还能向父类构造方法传参；</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token punctuation">[</span>name<span class="token punctuation">]</span>
<span class="token punctuation">}</span>
<span class="token class-name">Parent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  	<span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'child'</span><span class="token punctuation">]</span>			<span class="token comment">// 执行 call 后被覆盖</span>
    <span class="token function">Parent</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span>   <span class="token comment">// 执行父类构造方法并绑定子类的 this, 使得父类中的属性能够赋到子类的 this 上</span>
  	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 传参测试</span>
<span class="token keyword">const</span> child1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">'test1'</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> child2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">'test2'</span><span class="token punctuation">)</span>
<span class="token comment">// 共享测试</span>
child1<span class="token punctuation">.</span>name<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'foo'</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child1<span class="token punctuation">.</span>name<span class="token punctuation">)</span>          <span class="token comment">// ['foo'] </span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child2<span class="token punctuation">.</span>name<span class="token punctuation">)</span>          <span class="token comment">// ['test2']</span>
<span class="token comment">// 原型链继承测试</span>
child2<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                  <span class="token comment">// Error, 找不到 getName(), 无法继承父类原型上的属性和方法，因为只是单纯的在子类执行，获取父类构造中的方法和属性</span>
</code></pre></div><p>优点：与原型链继承相反</p> <ul><li>父类的引用属性不会被共享；</li> <li>子类构建实例时可向父类传递参数；</li></ul> <p>缺点：</p> <ul><li>只能继承父类的实例属性和方法，不能继承原型属性/方法 (因为只是单纯的在子类执行，获取父类构造中的方法和属性)；</li> <li>无法实现复用，每个子类都有父类实例函数的副本，影响性能 (无法复用是因为父类原型链上属性方法子类完全无法用到)；</li></ul> <h5 id="_4-2-3、组合式继承"><a href="#_4-2-3、组合式继承" class="header-anchor">#</a> 4-2-3、组合式继承</h5> <p>基本：即组合上述两种方法，借用原型链实现对<strong>原型</strong>属性和方法的继承，借用构造函数技术来实现<strong>实例</strong>属性的继承；</p> <p>原理：原型链继承和构造函数继承各有互补的优缺点，合体为组合式继承；</p> <p>注意：但凡对 prototype 作赋值操作，均需重新将 prototype.constructor 修正为子类；因 子类.constructor 属性默认调用 prototype 对象 constructor 属性；</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token punctuation">;</span>
  	<span class="token keyword">this</span><span class="token punctuation">.</span>play <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token class-name">Parent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 1、构造函数的继承 复制父类构造属性方法给子类实例 - 第二次调用 Parent</span>
    <span class="token function">Parent</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
  	<span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 2、原型链的继承 - 第一次调用 Parent</span>
<span class="token class-name">Child</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// 因上一句的关系，故须将指向修正为原本态: 指向自身构造函数, 否则指向的是 Parent</span>
<span class="token class-name">Child</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Child
<span class="token class-name">Child</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getAge</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>age
<span class="token punctuation">}</span>

<span class="token comment">// 传参测试</span>
<span class="token keyword">const</span> child1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">'TPP'</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> child2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">'TLP'</span><span class="token punctuation">,</span> <span class="token number">70</span><span class="token punctuation">)</span>
<span class="token comment">// 原型链继承测试</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'child1'</span><span class="token punctuation">,</span> child1<span class="token punctuation">)</span><span class="token punctuation">;</span>		
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child1<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> child1<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// ['TPP'] 20</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child1 <span class="token keyword">instanceof</span> <span class="token class-name">Child</span><span class="token punctuation">,</span> child1 <span class="token keyword">instanceof</span> <span class="token class-name">Parent</span><span class="token punctuation">)</span> <span class="token comment">// true true</span>

child1<span class="token punctuation">.</span>name<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'foo'</span>
child1<span class="token punctuation">.</span>play<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 共享测试</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child1<span class="token punctuation">.</span>play<span class="token punctuation">,</span> child2<span class="token punctuation">.</span>play<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [1,2,3,4] [1,2,3]</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child1<span class="token punctuation">.</span>name<span class="token punctuation">)</span>          <span class="token comment">// ['foo']</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child2<span class="token punctuation">.</span>name<span class="token punctuation">)</span>          <span class="token comment">// ['TLP']</span>
child2<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                  <span class="token comment">// ['TLP']</span>
</code></pre></div><p>优点：</p> <ul><li>父类的方法可以被复用；</li> <li>父类的引用属性不会被共享；</li> <li>子类构建实例时可以向父类传递参数；</li></ul> <p>缺点：每次创建子类实例都执行了两次构造函数，虽不影响对父类的继承，但子类创建实例时，原型中会存在两份相同的属性和方法，这并不优雅；</p> <ul><li>第一次调用 <code>Parent()</code>：给 <code>Child.prototype</code> 写入两个属性 name，play (可通过 <code>child1.__proto__.play</code> 访问得到)</li> <li>第二次调用 <code>Parent()</code>：给 <code>Child</code> 写入两个属性 name、play；</li> <li>再解释：实例对象 <code>child1</code> 上的两个属性就屏蔽了其原型对象 Child.prototype 的两个同名属性；所以，组合模式的缺点就是在使用子类创建实例对象时，其原型中会存在两份相同的父类实例的属性/方法；这种被覆盖的情况造成了性能上的浪费</li></ul> <h4 id="_4-3、非构造函数的继承-普通对象的继承"><a href="#_4-3、非构造函数的继承-普通对象的继承" class="header-anchor">#</a> 4-3、非构造函数的继承(普通对象的继承)</h4> <h5 id="_4-3-1、原型式继承"><a href="#_4-3-1、原型式继承" class="header-anchor">#</a> 4-3-1、原型式继承</h5> <img src="/Image/Basics/Special/Mode/223.png" align="" style="zoom:50%;"> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> Chinese <span class="token operator">=</span> <span class="token punctuation">{</span>
  nation<span class="token operator">:</span> <span class="token string">'中国'</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> Doctor <span class="token operator">=</span> <span class="token punctuation">{</span>
  career<span class="token operator">:</span> <span class="token string">'医生'</span>
<span class="token punctuation">}</span>

<span class="token comment">// How to make 'ChineseDoctor' ?</span>
</code></pre></div><p>可利用 object() 方法：即将子对象的 prototype 属性，指向父对象，从而使得子对象与父对象连在一起；</p> <p>其本质上是对传入其中的对象执行了一次 <strong><u><em>浅拷贝</em></u></strong>，将构造函数 <code>F</code> 的原型直接指向传入的对象；</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ES5 中存在 Object.create() 方法，能覆盖下面这个方法</span>
<span class="token keyword">function</span> <span class="token function">object</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">function</span> <span class="token constant">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
  <span class="token class-name">F</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> obj
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> person <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token string">&quot;Nicholas&quot;</span><span class="token punctuation">,</span>
  friends<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">&quot;Shelby&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Court&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Van&quot;</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> anotherPerson <span class="token operator">=</span> <span class="token function">object</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>
anotherPerson<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;Greg&quot;</span><span class="token punctuation">;</span>
anotherPerson<span class="token punctuation">.</span>friends<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">&quot;Rob&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> yetAnotherPerson <span class="token operator">=</span> <span class="token function">object</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>
yetAnotherPerson<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;Linda&quot;</span><span class="token punctuation">;</span>
yetAnotherPerson<span class="token punctuation">.</span>friends<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">&quot;Barbie&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>friends<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// &quot;Shelby,Court,Van,Rob,Barbie&quot;</span>
</code></pre></div><p>ECMAScript 5 通过新增 <a href="https://link.zhihu.com/?target=https%3A//developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create" target="_blank" rel="noopener noreferrer">Object.create()<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 方法规范化了原型式继承；此方法接收两个参数：在传入一个参数情况下， Object.create 与 object() 方法行为相同；</p> <ul><li>一 个用作新对象原型的对象和(可选的)</li> <li>一个为新对象定义额外属性的对象；</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> yetAnotherPerson <span class="token operator">=</span> <span class="token function">object</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span>
<span class="token comment">//  =&gt; </span>
<span class="token keyword">let</span> yetAnotherPerson <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span>
</code></pre></div><p><strong>优点</strong>：</p> <ul><li>父类方法可以复用</li></ul> <p><strong>缺点</strong>：</p> <ul><li>原型链继承多个实例的引用类型属性指向相同，存在篡改的可能</li> <li>子类构建实例时不能向父类传递参数</li></ul> <h5 id="_4-3-2、寄生式继承"><a href="#_4-3-2、寄生式继承" class="header-anchor">#</a> 4-3-2、寄生式继承</h5> <p>使用原型式继承获得一份目标对象的 <code>浅拷贝</code>，然后增强了此浅拷贝的能力；</p> <p>优缺点：其实和原型式继承一样，寄生式继承说白了就是：能在拷贝来的对象上加点方法，也就是所谓增强能力；</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">object</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">function</span> <span class="token constant">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
  <span class="token class-name">F</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> obj
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">createAnother</span><span class="token punctuation">(</span><span class="token parameter">original</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 通过调用函数创建一个新对象</span>
  <span class="token keyword">let</span> clone <span class="token operator">=</span> <span class="token function">object</span><span class="token punctuation">(</span>original<span class="token punctuation">)</span>
  <span class="token comment">// 以某种方式来增强这个对象</span>
  clone<span class="token punctuation">.</span><span class="token function-variable function">getName</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'我有了getName方法: '</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> clone
<span class="token punctuation">}</span>

<span class="token keyword">let</span> person <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token string">'Asuna'</span><span class="token punctuation">,</span>
  friends<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'Kirito'</span><span class="token punctuation">,</span> <span class="token string">'Yuuki'</span><span class="token punctuation">,</span> <span class="token string">'Sinon'</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> inst1 <span class="token operator">=</span> <span class="token function">createAnother</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span>
<span class="token keyword">let</span> inst2 <span class="token operator">=</span> <span class="token function">createAnother</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span>
</code></pre></div><p><strong>优点</strong>：</p> <ul><li>父类方法可以复用</li></ul> <p><strong>缺点</strong>：</p> <ul><li>原型链继承多个实例的引用类型属性指向相同，存在篡改的可能</li> <li>子类构建实例时不能向父类传递参数</li></ul> <h4 id="_4-4、寄生组合式继承"><a href="#_4-4、寄生组合式继承" class="header-anchor">#</a> 4-4、寄生组合式继承</h4> <p>组合继承会有两次调用父类的构造函数而造成浪费的缺点，寄生组合继承就可解决此问题：</p> <p>核心在于<u>让子类的 prototype 指向父类原型的拷贝</u>，如此就不会调用父类的构造函数，进而引发内存的浪费问题；</p> <ul><li>即构造函数被执行两次的问题，将 <code>指向父类实例</code> 改为 <code>指向父类原型</code>，减去一次构造函数的执行；</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token punctuation">;</span>
  	<span class="token keyword">this</span><span class="token punctuation">.</span>play <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token class-name">Parent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 1、构造函数的继承 复制父类构造属性方法给子类实例</span>
    <span class="token function">Parent</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
  	<span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 2、原型链的继承</span>
<span class="token comment">// Child.prototype = new Parent()</span>
<span class="token comment">// 3、优化组合继承 2 </span>
<span class="token class-name">Child</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token class-name">Parent</span><span class="token punctuation">.</span>prototype  <span class="token comment">// 寄生组合式继承中，将组合式继承的: 指向父类实例 改为:指向父类原型</span>
<span class="token comment">// 因上一句的关系，故须将指向修正为原本态: 指向自身构造函数, 否则指向的是 Parent</span>
<span class="token class-name">Child</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Child
<span class="token class-name">Child</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getAge</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>age
<span class="token punctuation">}</span>

<span class="token comment">// 传参测试</span>
<span class="token keyword">const</span> child1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">'TPP'</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> child2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">'TLP'</span><span class="token punctuation">,</span> <span class="token number">70</span><span class="token punctuation">)</span>
<span class="token comment">// 原型链继承测试</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'child1'</span><span class="token punctuation">,</span> child1<span class="token punctuation">)</span><span class="token punctuation">;</span>		
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child1<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> child1<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// ['TPP'] 20</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child1 <span class="token keyword">instanceof</span> <span class="token class-name">Child</span><span class="token punctuation">,</span> child1 <span class="token keyword">instanceof</span> <span class="token class-name">Parent</span><span class="token punctuation">)</span> <span class="token comment">// true true</span>

child1<span class="token punctuation">.</span>name<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'foo'</span>
child1<span class="token punctuation">.</span>play<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 共享测试</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child1<span class="token punctuation">.</span>play<span class="token punctuation">,</span> child2<span class="token punctuation">.</span>play<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [1,2,3,4] [1,2,3]</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child1<span class="token punctuation">.</span>name<span class="token punctuation">)</span>          <span class="token comment">// ['foo']</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child2<span class="token punctuation">.</span>name<span class="token punctuation">)</span>          <span class="token comment">// ['TLP']</span>
child2<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                  <span class="token comment">// ['TLP']</span>
</code></pre></div><p>问题：而由于子类原型和父类原型指向同一个对象：<code>Child.prototype = Parent.prototype</code>，故对子类原型的操作会影响到父类原型；</p> <ul><li>比如：给 <code>Child.prototype</code> 增加一个getName() 方法，会导致 <code>Parent.prototype</code> 也增加或被覆盖一个 getName() 方法；</li></ul> <p>解决：可对 <code>Parent.prototype</code> 做浅拷贝，利用 <u>空对象</u> 作为中介，此几乎不占内存，且修改 子类 的 prototype 对象，也不会影响到 父类 的 prototype 对象；</p> <ul><li>注意：后续演进中的 super() 作用也大致如此；</li> <li>注意：继承后才在子类 prototype 上添加方法和属性；</li> <li><img src="/Image/Basics/Special/Mode/218.png" align="" style="zoom:50%;"></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token punctuation">;</span>
  	<span class="token keyword">this</span><span class="token punctuation">.</span>play <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token class-name">Parent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 1、构造函数的继承 复制父类构造属性方法给子类实例</span>
    <span class="token function">Parent</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
  	<span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 2、原型链的继承</span>
<span class="token comment">// Child.prototype = new Parent()</span>
<span class="token comment">// 3、优化组合继承 2 </span>
<span class="token comment">// Child.prototype = Parent.prototype  // 寄生组合式继承中，将组合式继承的: 指向父类实例 改为:指向父类原型</span>
<span class="token comment">// 将 指向父类实例 改为 指向父类原型，并使用浅拷贝避免父子原型间的影响</span>
<span class="token class-name">Child</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token class-name">Parent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span>  
<span class="token comment">// 因上一句的关系，故须将指向修正为原本态: 指向自身构造函数, 否则指向的是 Parent</span>
<span class="token class-name">Child</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Child
<span class="token class-name">Child</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getAge</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>age
<span class="token punctuation">}</span>

<span class="token comment">// 传参测试</span>
<span class="token keyword">const</span> child1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">'TPP'</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> child2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">'TLP'</span><span class="token punctuation">,</span> <span class="token number">70</span><span class="token punctuation">)</span>
<span class="token comment">// 原型链继承测试</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'child1'</span><span class="token punctuation">,</span> child1<span class="token punctuation">)</span><span class="token punctuation">;</span>		
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child1<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> child1<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// ['TPP'] 20</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child1 <span class="token keyword">instanceof</span> <span class="token class-name">Child</span><span class="token punctuation">,</span> child1 <span class="token keyword">instanceof</span> <span class="token class-name">Parent</span><span class="token punctuation">)</span> <span class="token comment">// true true</span>

child1<span class="token punctuation">.</span>name<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'foo'</span>
child1<span class="token punctuation">.</span>play<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 共享测试</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child1<span class="token punctuation">.</span>play<span class="token punctuation">,</span> child2<span class="token punctuation">.</span>play<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [1,2,3,4] [1,2,3]</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child1<span class="token punctuation">.</span>name<span class="token punctuation">)</span>          <span class="token comment">// ['foo']</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child2<span class="token punctuation">.</span>name<span class="token punctuation">)</span>          <span class="token comment">// ['TLP']</span>
child2<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                  <span class="token comment">// ['TLP']</span>
</code></pre></div><h5 id="_4-4-1、最优解"><a href="#_4-4-1、最优解" class="header-anchor">#</a> 4-4-1、最优解</h5> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> inherit <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">c<span class="token punctuation">,</span>p</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">var</span> <span class="token function-variable function">F</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">c<span class="token punctuation">,</span>p</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">// 中间对象</span>
		<span class="token class-name">F</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> p<span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>
    <span class="token comment">// 子类 prototype 通过中间对象寻找 父类 prototype, 避免子类原型操作影响父类</span>
		c<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 备用: 为子对象设置 uber 属性，其指向父对象的 prototype 属性，仅用欧冠与实现继承完备性，纯属备用性质</span>
		c<span class="token punctuation">.</span>uber <span class="token operator">=</span> p<span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>
		<span class="token comment">// 修复子类实例的构造函数错误指向</span>
		c<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> c<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>



<span class="token comment">// 其他: ES6 语法糖 class / extends</span>
<span class="token comment">// 拓展: Extend 编译源码</span>
<span class="token keyword">function</span> <span class="token function">_possibleConstructorReturn</span><span class="token punctuation">(</span><span class="token parameter">self<span class="token punctuation">,</span> call</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
    <span class="token keyword">return</span> call <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> call <span class="token operator">===</span> <span class="token string">'object'</span> <span class="token operator">||</span> <span class="token keyword">typeof</span> call <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token operator">?</span> call <span class="token operator">:</span> self<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 核心</span>
<span class="token keyword">function</span> <span class="token function">_inherits</span><span class="token punctuation">(</span><span class="token parameter">subClass<span class="token punctuation">,</span> superClass</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
 		<span class="token comment">// 子类的原型的__proto__指向父类的原型</span>
    subClass<span class="token punctuation">.</span>prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>superClass <span class="token operator">&amp;&amp;</span> superClass<span class="token punctuation">.</span>prototype<span class="token punctuation">,</span> <span class="token punctuation">{</span>
      	<span class="token comment">// 给子类添加 constructor 属性 subclass.prototype.constructor === subclass</span>
        constructor<span class="token operator">:</span> <span class="token punctuation">{</span>
            value<span class="token operator">:</span> subClass<span class="token punctuation">,</span>
            enumerable<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
            writable<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
            configurable<span class="token operator">:</span> <span class="token boolean">true</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  	<span class="token comment">// 用来继承父类的静态方法, 寄生组合遗漏地方</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>superClass<span class="token punctuation">)</span> Object<span class="token punctuation">.</span>setPrototypeOf <span class="token operator">?</span> Object<span class="token punctuation">.</span><span class="token function">setPrototypeOf</span><span class="token punctuation">(</span>subClass<span class="token punctuation">,</span> superClass<span class="token punctuation">)</span> <span class="token operator">:</span> subClass<span class="token punctuation">.</span>__proto__ <span class="token operator">=</span> superClass<span class="token punctuation">;</span>
<span class="token punctuation">}</span>


<span class="token keyword">var</span> <span class="token function-variable function">Parent</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 验证是否是 Parent 构造出来的 this</span>
    <span class="token function">_classCallCheck</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> Parent<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> Child <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">_Parent</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  	<span class="token comment">// 采用寄生组合继承方式</span>
    <span class="token function">_inherits</span><span class="token punctuation">(</span>Child<span class="token punctuation">,</span> _Parent<span class="token punctuation">)</span><span class="token punctuation">;</span>
  	
    <span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">_classCallCheck</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> Child<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token function">_possibleConstructorReturn</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>Child<span class="token punctuation">.</span>__proto__ <span class="token operator">||</span> Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>Child<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> Child<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">(</span>Parent<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// _possibleConstructorReturn 实现了 super</span>
<span class="token keyword">function</span> <span class="token function">_possibleConstructorReturn</span><span class="token punctuation">(</span><span class="token parameter">self<span class="token punctuation">,</span> call</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>self<span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ReferenceError</span><span class="token punctuation">(</span><span class="token string">&quot;this hasn't been initialised - super() hasn't been called&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
  <span class="token comment">// 显示绑定 Child 的内置 [[prototype]] 到 this，即在 Child 中执行 Child 原型链上关联的属性</span>
  <span class="token keyword">return</span> call <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> call <span class="token operator">===</span> <span class="token string">&quot;object&quot;</span> <span class="token operator">||</span> <span class="token keyword">typeof</span> call <span class="token operator">===</span> <span class="token string">&quot;function&quot;</span><span class="token punctuation">)</span> <span class="token operator">?</span> call <span class="token operator">:</span> self<span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
<span class="token comment">// 核心: _inherits 函数，采用的依然也是第五种方式————寄生组合继承方式，同时证明了这种方式的成功; </span>
<span class="token comment">// 注意: 此处增加 Object.setPrototypeOf(subClass, superClass)，用来继承父类的静态方法, 此乃寄生组合遗漏地方</span>
</code></pre></div><h4 id="_4-5、es6-继承"><a href="#_4-5、es6-继承" class="header-anchor">#</a> 4-5、ES6 继承</h4> <p>虽 ES6 引入了关键字 class，但底层仍然是基于原型的实现，Class 只是语法糖，让对象原型的写法更加清晰、更像面向对象编程的语法而已；</p> <h5 id="_4-5-1、es6-的-es5-对应-结构"><a href="#_4-5-1、es6-的-es5-对应-结构" class="header-anchor">#</a> 4-5-1、ES6 的 ES5 对应(结构)</h5> <ul><li><p><strong>constructor</strong></p> <ul><li><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ES6</span>
<span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token string">'hello, I am '</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> kevin <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'Kevin'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
kevin<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 														<span class="token comment">// hello, I am Kevin</span>
Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span> 								<span class="token comment">// []</span>
Object<span class="token punctuation">.</span><span class="token function">getOwnPropertyNames</span><span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [&quot;constructor&quot;, &quot;sayHello&quot;]</span>


<span class="token comment">// ES5</span>
<span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayHello</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token string">'hello, I am '</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> kevin <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'Kevin'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
kevin<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 														<span class="token comment">// hello, I am Kevin</span>
Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span> 								<span class="token comment">// ['sayHello']</span>
Object<span class="token punctuation">.</span><span class="token function">getOwnPropertyNames</span><span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [&quot;constructor&quot;, &quot;sayHello&quot;]</span>

<span class="token comment">// 1、ES5 的构造函数 Person，对应 ES6 的 Person 类的 constructor 方法</span>
<span class="token comment">// 2、类的内部所有定义的方法，都是不可枚举的（non-enumerable）</span>
</code></pre></div></li> <li><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span>
  	<span class="token comment">// constructor 构造函数，默认方法，通过 new 命令创建对象实例时，自动调用该方法；</span>
  	<span class="token comment">// 一个类必须有 constructor 方法，若无显式定义，则会被默认添加</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>p <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>x<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token class-name">Point</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>z <span class="token operator">=</span> <span class="token string">'4'</span>
<span class="token keyword">class</span> <span class="token class-name">ColorPoint</span> <span class="token keyword">extends</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>color <span class="token operator">=</span> color<span class="token punctuation">;</span> <span class="token comment">// ReferenceError</span>
      	<span class="token comment">// 留意 super</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token comment">// 正确</span>
    <span class="token punctuation">}</span>
    <span class="token function">m</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 上述 Point 等同于</span>
<span class="token keyword">function</span> <span class="token function">Points</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> x<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>p <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token class-name">Points</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">print</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token string">'('</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">+</span><span class="token string">')'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 也即 constructor 代表在父类上加属性，而在 class 对象加方法属性等于在原型上的加</span>
<span class="token comment">// 而这些属性方法 只有通过 new 出的实例 或  extends 继承出来的实例才可获取到</span>
<span class="token keyword">new</span> <span class="token class-name">Points</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__proto__<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 	<span class="token comment">// 可调用到 Points 的 print 方法</span>
<span class="token keyword">new</span> <span class="token class-name">Points</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">1</span> 							<span class="token comment">// 可调用到 constructor 的 this.x = 1</span>
</code></pre></div></li></ul></li> <li><p><strong>实例属性</strong></p> <ul><li><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ES6</span>
<span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
    state <span class="token operator">=</span> <span class="token punctuation">{</span>
        count<span class="token operator">:</span> <span class="token number">0</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>


<span class="token comment">// ES5</span>
<span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span>
        count<span class="token operator">:</span> <span class="token number">0</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul></li> <li><p><strong>静态方法</strong></p> <ul><li><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ES6</span>
<span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token string">'hello'</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
Person<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 				<span class="token comment">// 'hello'</span>
<span class="token keyword">var</span> kevin <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
kevin<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 				<span class="token comment">// TypeError: kevin.sayHello is not a function</span>


<span class="token comment">// ES5</span>
<span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
Person<span class="token punctuation">.</span><span class="token function-variable function">sayHello</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token string">'hello'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
Person<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 				<span class="token comment">// 'hello'</span>
<span class="token keyword">var</span> kevin <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
kevin<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 				<span class="token comment">// TypeError: kevin.sayHello is not a function</span>
</code></pre></div></li></ul></li> <li><p><strong>静态属性</strong></p> <ul><li><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ES6</span>
<span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
Person<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'kevin'</span><span class="token punctuation">;</span>
或
<span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
  <span class="token keyword">static</span> name <span class="token operator">=</span> <span class="token string">'kevin'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>


<span class="token comment">// ES5</span>
<span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
Person<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'kevin'</span><span class="token punctuation">;</span>
</code></pre></div></li></ul></li> <li><p><strong>new 调用</strong></p> <ul><li><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// TypeError: Class constructor Foo cannot be invoked without 'new'</span>

<span class="token comment">// 类必须使用 new 调用，否则会报错；这是它跟普通构造函数的一个主要区别，后者不用 new 也可以执行；</span>
</code></pre></div></li></ul></li> <li><p><strong>Getter&amp;Setter</strong></p> <ul><li><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ES6</span>
<span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
    <span class="token keyword">get</span> <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token string">'kevin'</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">set</span> <span class="token function">name</span><span class="token punctuation">(</span><span class="token parameter">newName</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'new name 为：'</span> <span class="token operator">+</span> newName<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
person<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'daisy'</span><span class="token punctuation">;</span>				<span class="token comment">// new name 为：daisy</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>			<span class="token comment">// kevin</span>


<span class="token comment">// ES5</span>
<span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token keyword">get</span> <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token string">'kevin'</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token keyword">set</span> <span class="token function">name</span><span class="token punctuation">(</span><span class="token parameter">newName</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'new name 为：'</span> <span class="token operator">+</span> newName<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
person<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'daisy'</span><span class="token punctuation">;</span>				<span class="token comment">// new name 为：daisy</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>			<span class="token comment">// kevin</span>
</code></pre></div></li></ul></li> <li><p><strong>综合</strong></p> <ul><li><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ZH - 1</span>
<span class="token keyword">class</span> <span class="token class-name">TLP</span> <span class="token punctuation">{</span>
  <span class="token comment">// 0、相当于 ES5 的静态属性/方法</span>
  <span class="token keyword">static</span> test <span class="token operator">=</span> <span class="token string">'anything'</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 1、constructor 中 var 变量，只存在于 constructor 这个构造函数中 - 私有属性/方法</span>
    <span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token string">&quot;TLP&quot;</span><span class="token punctuation">;</span>
		<span class="token comment">// 2、this 属性方法则定义到实例上 - 公有属性/方法</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;TSL&quot;</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">say</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 3、等号定义会定义到实例上 - 公有属性/方法(另类)</span>
  age <span class="token operator">=</span> <span class="token number">80</span><span class="token punctuation">;</span>
  <span class="token function-variable function">showName</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;showName&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token comment">// 4、直接定义方法则定义到原型上 - 相当于 ES5 的 prototype 方法 - 公有属性/方法</span>
  <span class="token function">showAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;showAge&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> tlp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TLP</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Cat<span class="token punctuation">.</span>test<span class="token punctuation">)</span>  <span class="token comment">// anything</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>tlp<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// {age: 80, name: &quot;TSL&quot;, showName: ƒ, say: ƒ}</span>
</code></pre></div></li></ul></li></ul> <p>console.log(Object.keys(tlp)); // [&quot;age&quot;, &quot;showName&quot;, &quot;name&quot;, &quot;say&quot;]
console.log(tlp.<strong>proto</strong>) // { ... showAge... }
tlp.showName();
tlp.showAge();</p> <div class="language- extra-class"><pre><code>// ZH - 2
class TLP {
  // 静态属性/方法
  static test = &quot;static-test&quot;;
  static test2 = &quot;static-test2&quot;;
  
  constructor() {
    // 私有属性/方法
    var type = &quot;con-oldman&quot;;
    // 公有属性/方法(实例-优先级高)
    this.name = &quot;con-this-tlp&quot;;
    this.type = &quot;con-this-oldman&quot;
    this.getType = () =&gt; {
      console.log(this.type);
      console.log(type);
    };
  }
  // 公有属性/方法(实例-优先级低)
  name = &quot;tlp&quot;
  type = &quot;oldman&quot;;
  getType = () =&gt; {
    console.log(this.type);
    console.log(type);
  };
  // 公有属性/方法(原型链)
  showName() {
  	console.log(this.type)
  };
}
var type = &quot;window&quot;;
var tlp = new TLP();
tlp.getType();
// con-this-oldman
// con-oldman
console.log(tlp);
// TLP {name: &quot;con-this-tlp&quot;, type: &quot;con-this-oldman&quot;, getType: ƒ}
```
</code></pre></div><ul><li><img src="/Image/Basics/Special/Mode/222.png" style="zoom:50%;"></li></ul> <h5 id="_4-5-2、es6-的-es5-对应-源码"><a href="#_4-5-2、es6-的-es5-对应-源码" class="header-anchor">#</a> 4-5-2、ES6 的 ES5 对应(源码)</h5> <p>利用 Babel 进行转译观察结果，<a href="https://babeljs.io/repl/#?babili=false&amp;evaluate=true&amp;lineWrap=false&amp;presets=es2015%2Creact%2Cstage-2&amp;targets=&amp;browsers=&amp;builtIns=false&amp;debug=false&amp;code_lz=Q" target="_blank" rel="noopener noreferrer"> Try it out <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>：</p> <h5 id="_4-5-2-1、class"><a href="#_4-5-2-1、class" class="header-anchor">#</a> 4-5-2-1、Class</h5> <ul><li><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ES6</span>
<span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>


<span class="token comment">// Babel 转译结果</span>
<span class="token string">&quot;use strict&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">_instanceof</span><span class="token punctuation">(</span><span class="token parameter">left<span class="token punctuation">,</span> right</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>
    right <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span>
    <span class="token keyword">typeof</span> Symbol <span class="token operator">!==</span> <span class="token string">&quot;undefined&quot;</span> <span class="token operator">&amp;&amp;</span>
    right<span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>hasInstance<span class="token punctuation">]</span>
  <span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token operator">!</span><span class="token operator">!</span>right<span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>hasInstance<span class="token punctuation">]</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> left <span class="token keyword">instanceof</span> <span class="token class-name">right</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">_classCallCheck</span><span class="token punctuation">(</span><span class="token parameter">instance<span class="token punctuation">,</span> Constructor</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">_instanceof</span><span class="token punctuation">(</span>instance<span class="token punctuation">,</span> Constructor<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token string">&quot;Cannot call a class as a function&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> <span class="token function-variable function">Person</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">_classCallCheck</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> Person<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div></li></ul> <h5 id="_4-5-2-2、constructor"><a href="#_4-5-2-2、constructor" class="header-anchor">#</a> 4-5-2-2、Constructor</h5> <ul><li><p>注意：一个类必须有 constructor 方法，若无显式定义，则会被默认添加；所以上一代码虽无 constructor 但被默认添加；</p></li> <li><p>注意：<strong><u>constructor 对应的就是 ES5 中的构造函数；</u></strong></p></li> <li><p>注意：<strong><u>因类必须通过 new 方式调用，否则报错，此乃类特性之一，通过 _classCallCheck 实现；其作用是检查 Person 是否是通过 new 的方式调用；</u></strong></p> <ul><li>比如：当一类 Person 以此种方式调用：<code>var person = Person()</code>，则 this 指向 window， <code>instance instanceof Constructor</code>  为 false，报错；</li></ul></li> <li><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ES6</span>
<span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>


<span class="token comment">// Babel 转译结果</span>
<span class="token string">&quot;use strict&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">_instanceof</span><span class="token punctuation">(</span><span class="token parameter">left<span class="token punctuation">,</span> right</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>
    right <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span>
    <span class="token keyword">typeof</span> Symbol <span class="token operator">!==</span> <span class="token string">&quot;undefined&quot;</span> <span class="token operator">&amp;&amp;</span>
    right<span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>hasInstance<span class="token punctuation">]</span>
  <span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ES6 环境则使用更为不可外部更改的 Symbol 去检查</span>
    <span class="token keyword">return</span> <span class="token operator">!</span><span class="token operator">!</span>right<span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>hasInstance<span class="token punctuation">]</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// ES5 环境下则退化为 instanceof</span>
    <span class="token keyword">return</span> left <span class="token keyword">instanceof</span> <span class="token class-name">right</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">_classCallCheck</span><span class="token punctuation">(</span><span class="token parameter">instance<span class="token punctuation">,</span> Constructor</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 检查 Person 是否是通过 new 的方式调用, 实现类须通过 new 调用的特性</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">_instanceof</span><span class="token punctuation">(</span>instance<span class="token punctuation">,</span> Constructor<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token string">&quot;Cannot call a class as a function&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> <span class="token function-variable function">Person</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">_classCallCheck</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> Person<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 与上一相比只增加此行</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div></li></ul> <h5 id="_4-5-2-3、实例-静态属性"><a href="#_4-5-2-3、实例-静态属性" class="header-anchor">#</a> 4-5-2-3、实例&amp;静态属性</h5> <ul><li><p>注意：<strong><u>ES6 Class 实例属性对应 ES5 构造函数中的 this 对象上的属性；</u></strong></p></li> <li><p>注意：<strong><u>ES6 Class 静态属性对应 ES5 构造函数的自身属性；</u></strong></p></li> <li><p>注意：上述对应关系通过 _defineProperty 实现，其为 Object.defineProperty 的实现封装；</p></li> <li><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ES6</span>
<span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
    <span class="token comment">// 实例属性</span>
    foo <span class="token operator">=</span> <span class="token string">'foo'</span><span class="token punctuation">;</span>
    <span class="token comment">// 静态属性</span>
    <span class="token keyword">static</span> bar <span class="token operator">=</span> <span class="token string">'bar'</span><span class="token punctuation">;</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>


<span class="token comment">// Babel 转译结果</span>
<span class="token string">&quot;use strict&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">_instanceof</span><span class="token punctuation">(</span><span class="token parameter">left<span class="token punctuation">,</span> right</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>
    right <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span>
    <span class="token keyword">typeof</span> Symbol <span class="token operator">!==</span> <span class="token string">&quot;undefined&quot;</span> <span class="token operator">&amp;&amp;</span>
    right<span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>hasInstance<span class="token punctuation">]</span>
  <span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token operator">!</span><span class="token operator">!</span>right<span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>hasInstance<span class="token punctuation">]</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> left <span class="token keyword">instanceof</span> <span class="token class-name">right</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">_classCallCheck</span><span class="token punctuation">(</span><span class="token parameter">instance<span class="token punctuation">,</span> Constructor</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">_instanceof</span><span class="token punctuation">(</span>instance<span class="token punctuation">,</span> Constructor<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token string">&quot;Cannot call a class as a function&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 与上一相比增加此函数</span>
<span class="token keyword">function</span> <span class="token function">_defineProperty</span><span class="token punctuation">(</span><span class="token parameter">obj<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token keyword">in</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token punctuation">{</span>
      value<span class="token operator">:</span> value<span class="token punctuation">,</span>
      enumerable<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
      configurable<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
      writable<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> obj<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> <span class="token function-variable function">Person</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">_classCallCheck</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> Person<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">// 与上一相比增加此行1</span>
    <span class="token function">_defineProperty</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token string">&quot;foo&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;foo&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 与上一相比增加此行2</span>
<span class="token function">_defineProperty</span><span class="token punctuation">(</span>Person<span class="token punctuation">,</span> <span class="token string">&quot;bar&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;bar&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li></ul> <h5 id="_4-5-2-4、实例-静态方法"><a href="#_4-5-2-4、实例-静态方法" class="header-anchor">#</a> 4-5-2-4、实例&amp;静态方法</h5> <ul><li><p>注意：<strong><u>ES6 Class 实例方法对应 ES5 构造函数中的原型对象上的方法；</u></strong></p></li> <li><p>注意：<strong><u>ES6 Class 静态方法对应 ES5 构造函数的自身方法；</u></strong></p></li> <li><p>注意：<strong><u>上述对应关系通过 _createClass 实现，作用是根据方法类型(protoProps/staticProps)安插相应位置，使用 _defineProperties 实现方法遍历；</u></strong></p></li> <li><p>注意：<strong><u>前一代码返回一个 Person 构造函数，而此处，为自动执行 _createClass 方法而实现方法的绑定，返回一 IIFE，IIFE 则返回绑定后的构造函数；</u></strong></p></li> <li><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ES6</span>
<span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
    foo <span class="token operator">=</span> <span class="token string">'foo'</span><span class="token punctuation">;</span>
    <span class="token keyword">static</span> bar <span class="token operator">=</span> <span class="token string">'bar'</span><span class="token punctuation">;</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
		<span class="token comment">// 实例方法</span>
    <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token string">'hello, I am '</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
		<span class="token comment">// 静态方法</span>
    <span class="token keyword">static</span> <span class="token function">onlySayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token string">'hello'</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>


<span class="token comment">// Babel 转译结果</span>
<span class="token string">&quot;use strict&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">_instanceof</span><span class="token punctuation">(</span><span class="token parameter">left<span class="token punctuation">,</span> right</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>
    right <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span>
    <span class="token keyword">typeof</span> Symbol <span class="token operator">!==</span> <span class="token string">&quot;undefined&quot;</span> <span class="token operator">&amp;&amp;</span>
    right<span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>hasInstance<span class="token punctuation">]</span>
  <span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token operator">!</span><span class="token operator">!</span>right<span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>hasInstance<span class="token punctuation">]</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> left <span class="token keyword">instanceof</span> <span class="token class-name">right</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">_classCallCheck</span><span class="token punctuation">(</span><span class="token parameter">instance<span class="token punctuation">,</span> Constructor</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">_instanceof</span><span class="token punctuation">(</span>instance<span class="token punctuation">,</span> Constructor<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token string">&quot;Cannot call a class as a function&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">_defineProperty</span><span class="token punctuation">(</span><span class="token parameter">obj<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token keyword">in</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token punctuation">{</span>
      value<span class="token operator">:</span> value<span class="token punctuation">,</span>
      enumerable<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
      configurable<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
      writable<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> obj<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 与上一相比增加此函数1</span>
<span class="token keyword">function</span> <span class="token function">_defineProperties</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> props<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> descriptor <span class="token operator">=</span> props<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment">// 默认 enumerable 为 false，configurable 为 true，是为防止 Object.keys() 之类的方法遍历</span>
    descriptor<span class="token punctuation">.</span>enumerable <span class="token operator">=</span> descriptor<span class="token punctuation">.</span>enumerable <span class="token operator">||</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    descriptor<span class="token punctuation">.</span>configurable <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token comment">// 通过判断 value 是否存在，来判断是否是 getter 和 setter</span>
    <span class="token comment">// 若存在 value，就为 descriptor 添加 value 和 writable 属性，若不存在，就直接使用 get 和 set 属性</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">&quot;value&quot;</span> <span class="token keyword">in</span> descriptor<span class="token punctuation">)</span> descriptor<span class="token punctuation">.</span>writable <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> descriptor<span class="token punctuation">.</span>key<span class="token punctuation">,</span> descriptor<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 与上一相比增加此函数2</span>
<span class="token keyword">function</span> <span class="token function">_createClass</span><span class="token punctuation">(</span><span class="token parameter">Constructor<span class="token punctuation">,</span> protoProps<span class="token punctuation">,</span> staticProps</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>protoProps<span class="token punctuation">)</span> <span class="token function">_defineProperties</span><span class="token punctuation">(</span><span class="token class-name">Constructor</span><span class="token punctuation">.</span>prototype<span class="token punctuation">,</span> protoProps<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>staticProps<span class="token punctuation">)</span> <span class="token function">_defineProperties</span><span class="token punctuation">(</span>Constructor<span class="token punctuation">,</span> staticProps<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> Constructor<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 与上一相比增加此行1(IIFE)</span>
<span class="token keyword">var</span> Person <span class="token operator">=</span> <span class="token comment">/*#__PURE__*/</span> <span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">_classCallCheck</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> Person<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">_defineProperty</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token string">&quot;foo&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;foo&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> 

  <span class="token comment">// 与上一相比增加此行2</span>
  <span class="token function">_createClass</span><span class="token punctuation">(</span>
    Person<span class="token punctuation">,</span>
    <span class="token punctuation">[</span>
      <span class="token punctuation">{</span>
        key<span class="token operator">:</span> <span class="token string">&quot;sayHello&quot;</span><span class="token punctuation">,</span>
        <span class="token function-variable function">value</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">return</span> <span class="token string">&quot;hello, I am &quot;</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment">// 静态方法</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token punctuation">[</span>
      <span class="token punctuation">{</span>
        key<span class="token operator">:</span> <span class="token string">&quot;onlySayHello&quot;</span><span class="token punctuation">,</span>
        <span class="token function-variable function">value</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token function">onlySayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">return</span> <span class="token string">&quot;hello&quot;</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">]</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> Person<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">_defineProperty</span><span class="token punctuation">(</span>Person<span class="token punctuation">,</span> <span class="token string">&quot;bar&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;bar&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li></ul> <h5 id="_4-5-2-5、getter-setter"><a href="#_4-5-2-5、getter-setter" class="header-anchor">#</a> 4-5-2-5、Getter&amp;Setter</h5> <ul><li><p>注意：<strong><u>ES6 Class  Getter&amp;Setter 方法对应 ES5 构造函数中的原型对象上的方法；</u></strong></p></li> <li><p>注意：<strong><u>还通过 _createClass —&gt;  _defineProperties 的 Object.defineProperty(target, descriptor.key, descriptor); 为 set get 对象绑定相关方法</u></strong></p> <ul><li><div class="language- extra-class"><pre><code>// 通过判断 value 是否存在，来判断是否是 getter 和 setter
// 若存在 value，就为 descriptor 添加 value 和 writable 属性，若不存在，就直接使用 get 和 set 属性
</code></pre></div></li> <li><p>比如：<code>Object.defineProperty(target, 'name', set: function set(newName) { console.log('new name 为：' + newName);});</code></p></li></ul></li> <li><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ES6</span>
<span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
    foo <span class="token operator">=</span> <span class="token string">'foo'</span><span class="token punctuation">;</span>
    <span class="token keyword">static</span> bar <span class="token operator">=</span> <span class="token string">'bar'</span><span class="token punctuation">;</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token string">'hello, I am '</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">static</span> <span class="token function">onlySayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token string">'hello'</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// Getter</span>
    <span class="token keyword">get</span> <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token string">'kevin'</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// Setter</span>
    <span class="token keyword">set</span> <span class="token function">name</span><span class="token punctuation">(</span><span class="token parameter">newName</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'new name 为：'</span> <span class="token operator">+</span> newName<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>


<span class="token comment">// Babel 转译结果</span>
<span class="token string">&quot;use strict&quot;</span><span class="token punctuation">;</span>

<span class="token comment">// ...</span>

<span class="token keyword">function</span> <span class="token function">_defineProperties</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> props<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> descriptor <span class="token operator">=</span> props<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    descriptor<span class="token punctuation">.</span>enumerable <span class="token operator">=</span> descriptor<span class="token punctuation">.</span>enumerable <span class="token operator">||</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    descriptor<span class="token punctuation">.</span>configurable <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">&quot;value&quot;</span> <span class="token keyword">in</span> descriptor<span class="token punctuation">)</span> descriptor<span class="token punctuation">.</span>writable <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> descriptor<span class="token punctuation">.</span>key<span class="token punctuation">,</span> descriptor<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">_createClass</span><span class="token punctuation">(</span><span class="token parameter">Constructor<span class="token punctuation">,</span> protoProps<span class="token punctuation">,</span> staticProps</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>protoProps<span class="token punctuation">)</span> <span class="token function">_defineProperties</span><span class="token punctuation">(</span><span class="token class-name">Constructor</span><span class="token punctuation">.</span>prototype<span class="token punctuation">,</span> protoProps<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>staticProps<span class="token punctuation">)</span> <span class="token function">_defineProperties</span><span class="token punctuation">(</span>Constructor<span class="token punctuation">,</span> staticProps<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> Constructor<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// ...</span>

<span class="token keyword">var</span> Person <span class="token operator">=</span> <span class="token comment">/*#__PURE__*/</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">_classCallCheck</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> Person<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">_defineProperty</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token string">&quot;foo&quot;</span><span class="token punctuation">,</span> <span class="token string">'foo'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">_createClass</span><span class="token punctuation">(</span>Person<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">{</span>
    key<span class="token operator">:</span> <span class="token string">&quot;sayHello&quot;</span><span class="token punctuation">,</span>
    <span class="token function-variable function">value</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token string">'hello, I am '</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
    key<span class="token operator">:</span> <span class="token string">&quot;name&quot;</span><span class="token punctuation">,</span>
    <span class="token function-variable function">get</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token string">'kevin'</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function-variable function">set</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token parameter">newName</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'new name 为：'</span> <span class="token operator">+</span> newName<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">{</span>
    key<span class="token operator">:</span> <span class="token string">&quot;onlySayHello&quot;</span><span class="token punctuation">,</span>
    <span class="token function-variable function">value</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token function">onlySayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token string">'hello'</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> Person<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// ...</span>
</code></pre></div></li></ul> <h5 id="_4-5-2-6、extend"><a href="#_4-5-2-6、extend" class="header-anchor">#</a> 4-5-2-6、Extend</h5> <p>首先，几个 Extend 特殊特性：</p> <ul><li><p><strong><u>super 关键字表示父类的构造函数，相当于 ES5 的 Parent.call(this)</u></strong></p></li> <li><p>子类必须在 constructor 方法中调用 super 方法，<u><strong>否则新建实例时会报错 (已优化了，可新建实例)</strong></u>；</p> <ul><li>因为子类没有自己的 this 对象，而是继承父类的 this 对象，然后对其进行加工；<strong><u>若不调用 super 方法，子类就得不到 this 对象</u></strong>；</li> <li>同时也因为此原因，在子类的构造函数中，<strong><u>只有调用 super 之后，才可使用 this 关键字，否则会报错</u></strong></li></ul></li> <li><p><strong><u>父类的静态方法，可被子类继承</u></strong>；</p> <ul><li><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
  <span class="token comment">// 最终变为 ES5 构造函数自身方法</span>
  <span class="token keyword">static</span> <span class="token function">classMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token string">'hello'</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// extends 内部实现了静态方法的继承: Bar.__proto__ = Foo</span>
<span class="token keyword">class</span> <span class="token class-name">Bar</span> <span class="token keyword">extends</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>

Bar<span class="token punctuation">.</span><span class="token function">classMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 'hello'</span>
</code></pre></div></li> <li><p>因为 Class 作为构造函数的语法糖，同时有 prototype 属性和 <code>__proto__</code> 属性，因此同时存在两条继承链：</p> <ul><li><p>子类的 <code>__proto__</code> 属性，表示构造函数的继承，总是指向父类；</p></li> <li><p>子类 prototype 属性的 <code>__proto__</code> 属性，表示方法的继承，总是指向父类的 prototype 属性；</p></li> <li><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Parent</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Child</span> <span class="token keyword">extends</span> <span class="token class-name">Parent</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Child<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> Parent<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Child</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Parent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
</code></pre></div></li> <li><img src="/Image/Basics/Special/Mode/219.png" align="" style="zoom:50%;"></li> <li><p>相比寄生组合式继承，ES6 的 class 多了一个 <code>Object.setPrototypeOf(Child, Parent)</code> 的步骤，此步就是用来继承父类的静态方法；</p></li></ul></li></ul></li> <li><p><strong><u>extends 关键字后面可以跟多种类型的值：Function &amp; null；</u></strong></p> <ul><li><p>只要是一个有 prototype 属性的函数，就能被继承；而由于函数都有 prototype 属性(除了 Function.prototype 函数)，因此 A 可是任意函数</p></li> <li><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token keyword">extends</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token keyword">extends</span> <span class="token class-name">null</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token constant">A</span><span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span> 	<span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">A</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
</code></pre></div></li></ul></li></ul> <p>然后，Babel 编译与 ES6 继承区别探究：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ES6</span>
<span class="token keyword">class</span> <span class="token class-name">Parent</span> <span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Child</span> <span class="token keyword">extends</span> <span class="token class-name">Parent</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>


<span class="token comment">// Babel 转译结果</span>
<span class="token punctuation">(</span><span class="token string">&quot;use strict&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">_inherits</span><span class="token punctuation">(</span><span class="token parameter">subClass<span class="token punctuation">,</span> superClass</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 实现特性: 继承父类必须为 Function 或 null</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> superClass <span class="token operator">!==</span> <span class="token string">&quot;function&quot;</span> <span class="token operator">&amp;&amp;</span> superClass <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token string">&quot;Super expression must either be null or a function&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 类似于 ES5 的寄生组合式继承，使用 Object.create，设置子类 prototype 属性的 __proto__ 属性指向父类的 prototype 属性</span>
  <span class="token comment">// 并给 subClass.prototype 添加一个可配置可写不可枚举的 constructor 属性，该属性值为 subClass (修正指向)</span>
  subClass<span class="token punctuation">.</span>prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>superClass <span class="token operator">&amp;&amp;</span> superClass<span class="token punctuation">.</span>prototype<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    constructor<span class="token operator">:</span> <span class="token punctuation">{</span> value<span class="token operator">:</span> subClass<span class="token punctuation">,</span> writable<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> configurable<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 设置子类的 __proto__ 属性指向父类</span>
  <span class="token comment">// 实现特性: 静态方法继承, ES5 与 ES6 继承区别之一: subClass.__proto__ = superClass</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>superClass<span class="token punctuation">)</span> <span class="token function">_setPrototypeOf</span><span class="token punctuation">(</span>subClass<span class="token punctuation">,</span> superClass<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">_setPrototypeOf</span><span class="token punctuation">(</span><span class="token parameter">o<span class="token punctuation">,</span> p</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  _setPrototypeOf <span class="token operator">=</span>
    Object<span class="token punctuation">.</span>setPrototypeOf <span class="token operator">||</span>
    <span class="token keyword">function</span> <span class="token function">_setPrototypeOf</span><span class="token punctuation">(</span><span class="token parameter">o<span class="token punctuation">,</span> p</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	<span class="token comment">// subClass.__proto__ = superClass</span>
      o<span class="token punctuation">.</span>__proto__ <span class="token operator">=</span> p<span class="token punctuation">;</span>
      <span class="token keyword">return</span> o<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token function">_setPrototypeOf</span><span class="token punctuation">(</span>o<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 函数测试是否存在 NativeReflectConstruct</span>
<span class="token keyword">function</span> <span class="token function">_isNativeReflectConstruct</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> Reflect <span class="token operator">===</span> <span class="token string">&quot;undefined&quot;</span> <span class="token operator">||</span> <span class="token operator">!</span>Reflect<span class="token punctuation">.</span>construct<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>Reflect<span class="token punctuation">.</span>construct<span class="token punctuation">.</span>sham<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token comment">// 检查 Proxy 是因为 Reflect 是一个内置的对象，它提供拦截 JavaScript 操作的方法。这些方法与proxy handlers的方法相同</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> Proxy <span class="token operator">===</span> <span class="token string">&quot;function&quot;</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token class-name">Date</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>Reflect<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span>Date<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 获取 o.__proto__ </span>
<span class="token keyword">function</span> <span class="token function">_getPrototypeOf</span><span class="token punctuation">(</span><span class="token parameter">o</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  _getPrototypeOf <span class="token operator">=</span> Object<span class="token punctuation">.</span>setPrototypeOf
    <span class="token operator">?</span> Object<span class="token punctuation">.</span><span class="token function-variable function">getPrototypeOf</span>
    <span class="token operator">:</span> <span class="token keyword">function</span> <span class="token function">_getPrototypeOf</span><span class="token punctuation">(</span><span class="token parameter">o</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> o<span class="token punctuation">.</span>__proto__ <span class="token operator">||</span> Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token function">_getPrototypeOf</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">_assertThisInitialized</span><span class="token punctuation">(</span><span class="token parameter">self</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>self <span class="token operator">===</span> <span class="token keyword">void</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ReferenceError</span><span class="token punctuation">(</span>
      <span class="token string">&quot;this hasn't been initialised - super() hasn't been called&quot;</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> self<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 帮助确定调用父类构造函数的返回值</span>
<span class="token keyword">function</span> <span class="token function">_possibleConstructorReturn</span><span class="token punctuation">(</span><span class="token parameter">self<span class="token punctuation">,</span> call</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>call <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token function">_typeof</span><span class="token punctuation">(</span>call<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">&quot;object&quot;</span> <span class="token operator">||</span> <span class="token keyword">typeof</span> call <span class="token operator">===</span> <span class="token string">&quot;function&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> call<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token function">_assertThisInitialized</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>


<span class="token comment">// _createSuper(Child) 作用是检查 Reflect 若有则利用 Reflect 创建对象否则 Super.apply(this, arguments);</span>
<span class="token comment">// Reflect.construct() 与 Object.create() 均可创建对象，两种方式结果相同，但在创建对象过程中仍一点不同: new.target 的值上</span>
<span class="token comment">// 当使用 Object.create() 和 Function.prototype.apply() 时，若不使用 new 操作符调用构造函数，构造函数内部的 new.target 值会指向 undefined。</span>
<span class="token comment">// 当调用 Reflect.construct() 来创建对象，new.target 值会自动指定到 target（或者 newTarget，前提是 newTarget 指定了)</span>
<span class="token comment">// new.target 属性允许你检测函数或构造方法是否是通过 new 运算符被调用的</span>
<span class="token comment">// 通过 new 运算符被初始化的函数或构造方法时，new.target 返回一个指向构造方法或函数的引用；在普通的函数调用中，new.target 值是 undefined</span>
<span class="token keyword">function</span> <span class="token function">_createSuper</span><span class="token punctuation">(</span><span class="token parameter">Derived</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 首先检查是否有定义 Reflect</span>
  <span class="token keyword">var</span> hasNativeReflectConstruct <span class="token operator">=</span> <span class="token function">_isNativeReflectConstruct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token function">_createSuperInternal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 获取父类: return o.__proto__ || Object.getPrototypeOf(o) 因为先前 SubClass.__proto__ = SuperClass</span>
    <span class="token keyword">var</span> Super <span class="token operator">=</span> <span class="token function">_getPrototypeOf</span><span class="token punctuation">(</span>Derived<span class="token punctuation">)</span><span class="token punctuation">,</span>
      result<span class="token punctuation">;</span>
    <span class="token comment">// 若有定义 Reflect</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>hasNativeReflectConstruct<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 获取实例的 constructor 即 SubClass: (return o.__proto__ || Object.getPrototypeOf(o)).constructor</span>
      <span class="token keyword">var</span> NewTarget <span class="token operator">=</span> <span class="token function">_getPrototypeOf</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">.</span>constructor<span class="token punctuation">;</span>
      <span class="token comment">// result 将会是 NewTarget 即 SubClass 类型</span>
      <span class="token comment">// Reflect.construct() 方法的行为有点像 new 操作符构造函数, 相当于运行 new target(...args).</span>
      <span class="token comment">// Reflect.construct (target, argumentsList[, newTarget]) </span>
      <span class="token comment">// Reflect.construct (被运行的目标构造函数, 类数组-目标构造函数调用时的参数, 作为新创建对象的原型对象的 constructor 属性)</span>
      <span class="token comment">// 返回: 以 target(若 newTarget 存在，则为 newTarget）函数为构造函数，argumentList 为其初始化参数的对象实例</span>
      <span class="token comment">// new Foo(...args) === Reflect.construct(Foo, args)</span>
      <span class="token comment">// 所以: Reflect.construct(Super, arguments, NewTarget); === new NewTarget(arguments)</span>
      <span class="token comment">// result 将会是 NewTarget 即 SubClass 类型</span>
      result <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span>Super<span class="token punctuation">,</span> arguments<span class="token punctuation">,</span> NewTarget<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token comment">// 不使用 Reflect 此时的 new.target 值为 undefined</span>
      result <span class="token operator">=</span> <span class="token function">Super</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token function">_possibleConstructorReturn</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 严格 typeof 实现</span>
<span class="token keyword">function</span> <span class="token function">_typeof</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token string">&quot;@babel/helpers - typeof&quot;</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> Symbol <span class="token operator">===</span> <span class="token string">&quot;function&quot;</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">typeof</span> Symbol<span class="token punctuation">.</span>iterator <span class="token operator">===</span> <span class="token string">&quot;symbol&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function-variable function">_typeof</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">_typeof</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token keyword">typeof</span> obj<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token function-variable function">_typeof</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">_typeof</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> obj <span class="token operator">&amp;&amp;</span>
        <span class="token keyword">typeof</span> Symbol <span class="token operator">===</span> <span class="token string">&quot;function&quot;</span> <span class="token operator">&amp;&amp;</span>
        obj<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Symbol <span class="token operator">&amp;&amp;</span>
        obj <span class="token operator">!==</span> <span class="token class-name">Symbol</span><span class="token punctuation">.</span>prototype
        <span class="token operator">?</span> <span class="token string">&quot;symbol&quot;</span>
        <span class="token operator">:</span> <span class="token keyword">typeof</span> obj<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token function">_typeof</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 严格 instanceof 实现</span>
<span class="token keyword">function</span> <span class="token function">_instanceof</span><span class="token punctuation">(</span><span class="token parameter">left<span class="token punctuation">,</span> right</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>
    right <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span>
    <span class="token keyword">typeof</span> Symbol <span class="token operator">!==</span> <span class="token string">&quot;undefined&quot;</span> <span class="token operator">&amp;&amp;</span>
    right<span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>hasInstance<span class="token punctuation">]</span>
  <span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token operator">!</span><span class="token operator">!</span>right<span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>hasInstance<span class="token punctuation">]</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> left <span class="token keyword">instanceof</span> <span class="token class-name">right</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// Class 须为 new 调用</span>
<span class="token keyword">function</span> <span class="token function">_classCallCheck</span><span class="token punctuation">(</span><span class="token parameter">instance<span class="token punctuation">,</span> Constructor</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">_instanceof</span><span class="token punctuation">(</span>instance<span class="token punctuation">,</span> Constructor<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token string">&quot;Cannot call a class as a function&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> <span class="token function-variable function">Parent</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">_classCallCheck</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> Parent<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> Child <span class="token operator">=</span> <span class="token comment">/*#__PURE__*/</span> <span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">_Parent</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 继承实现</span>
  <span class="token function">_inherits</span><span class="token punctuation">(</span>Child<span class="token punctuation">,</span> _Parent<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 返回闭包延迟执行</span>
  <span class="token keyword">var</span> _super <span class="token operator">=</span> <span class="token function">_createSuper</span><span class="token punctuation">(</span>Child<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">_classCallCheck</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> Child<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">_super</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> Child<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>Parent<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><ul><li><p>注意：<strong><u>Babel 创建 _inherits 函数帮助实现继承，又创建了 _possibleConstructorReturn 函数帮助确定调用父类构造函数的返回值</u></strong>；</p></li> <li><p>注意：<strong><u>过去缺少调用 super 时新建实例会报错，但现已通过新增 var _super = _createSuper(Child); 优化，故可新建实例，但仍无法拿到 this；</u></strong></p> <ul><li><p><code>var _super = _createSuper(Child);</code> 作用是：</p> <ul><li>若有 <code>Reflect</code>，则利用 <code>Reflect.construct</code> 创建对象；</li> <li>若无，则利用 <code>Super.apply(this, arguments);</code> (<code>Object.create()</code>) 创建，<strong><u><em>相当于在子类执行父类构造，所以 result = 其构造函数返回值</em></u></strong></li></ul></li> <li><p>注意：<strong><u><em>为何如此大费周章</em></u></strong>，是因为后者 new.target 值为 undefined，无法完美实现 ES6 继承特征，但也不一定需要，所以支持 apply 形式，而 apply 就是 ES5 寄生组合式继承的方式：<code>function Child() { Parent.call(this, name, ...) ...};</code></p></li> <li><p>注意：<code>Super = _getPrototypeOf(Child), 而 _getPrototypeOf == return o.__proto__ || Object.getPrototypeOf(o);</code>，Super 为父类；</p></li> <li><p>注意：<code>Reflect.construct()</code> 方法的行为有点像 new 操作符构造函数, 相当于运行 <code>new target(...args).</code></p> <ul><li><code>Reflect.construct (target, argumentsList[, newTarget])</code></li> <li><code>Reflect.construct (被运行的目标构造函数, 类数组-目标构造函数调用时的参数, 作为新创建对象的原型对象的 constructor 属性)</code></li> <li>返回: <code>以 target (若 newTarget 存在，则为 newTarget) 函数为构造函数，argumentList 为其初始化参数的对象实例</code></li> <li><code>new Foo(...args) === Reflect.construct(Foo, args)</code></li> <li>所以: <code>Reflect.construct(Super, arguments, NewTarget); === new NewTarget(arguments)</code></li> <li><code>NewTarget = _getPrototypeOf(this).constructor，即获取实例的 constructor 即 SubClass</code></li> <li><strong><u><em>所以 Reflect.construct() 方式下，result = SubClass 的实例；</em></u></strong></li></ul></li> <li><p>注意：<code>Reflect.construct()</code> 与 <code>Object.create()</code> 均可创建对象，两种方式结果相同，但在创建对象过程中仍一点不同：体现在 <code>new.target</code> 的值上</p> <ul><li>当使用 <code>Object.create</code> 和 <code>Function.prototype.apply</code> 时，若不用 new 操作符调用构造函数，则其内部的 <code>new.target</code> 值会指向 <code>undefined</code>；</li> <li>当调用 <code>Reflect.construct</code> 来创建对象，<code>new.target</code> 值会自动指定到 target (或 newTarget，前提是 newTarget 指定了)</li> <li><code>new.target</code> 属性允许检测函数或构造方法是否是通过 new 运算符被调用的:
<ul><li>通过 new 运算符被初始化的函数或构造方法时，<code>new.target</code> 返回一个指向构造方法或函数的引用；</li> <li>而通过普通函数调用，则其值是 undefined；</li></ul></li></ul></li> <li><p>创建出来的对象 result 再经过 <code>_possibleConstructorReturn(this, result);</code> 处理，其帮助确定调用父类构造函数的返回值；</p> <ul><li><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 此为旧版实现方式，新版实现的作用与之相同，只是做了功能分拆和细化，但旧版更容易理解</span>
<span class="token keyword">function</span> <span class="token function">_possibleConstructorReturn</span><span class="token punctuation">(</span><span class="token parameter">self<span class="token punctuation">,</span> call</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>self<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ReferenceError</span><span class="token punctuation">(</span><span class="token string">&quot;this hasn't been initialised - super() hasn't been called&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> call <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> call <span class="token operator">===</span> <span class="token string">&quot;object&quot;</span> <span class="token operator">||</span> <span class="token keyword">typeof</span> call <span class="token operator">===</span> <span class="token string">&quot;function&quot;</span><span class="token punctuation">)</span> <span class="token operator">?</span> call <span class="token operator">:</span> self<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>前面提到，result 有两种情况，一个是 Reflect.construct 的处理结果，为子类实例，一个是 Super.apply(this, arguments) 的处理结果；对于 result 值，如果是 object 类型或是 function 类型，则返回 result，如果是 null 或 基本类型的值 或 undefined，则返回 self 也即子类的 this；</p></li> <li><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// Ex1 return null</span>
<span class="token keyword">class</span> <span class="token class-name">Parent</span> <span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      	<span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
      	<span class="token keyword">return</span> <span class="token keyword">null</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Child</span> <span class="token keyword">extends</span> <span class="token class-name">Parent</span> <span class="token punctuation">{</span>
  	<span class="token comment">// Child 未增加 constructor &amp; super 版</span>
  	<span class="token comment">// ...</span>

  	<span class="token comment">// Child 增加 constructor &amp; super 版</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> 
        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// Ex1 - Babel</span>
<span class="token comment">// ...</span>
<span class="token keyword">function</span> <span class="token function">_createSuper</span><span class="token punctuation">(</span><span class="token parameter">Derived</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> hasNativeReflectConstruct <span class="token operator">=</span> <span class="token function">_isNativeReflectConstruct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token function">_createSuperInternal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// Super 为 Parent 构造函数</span>
    <span class="token keyword">var</span> Super <span class="token operator">=</span> <span class="token function">_getPrototypeOf</span><span class="token punctuation">(</span>Derived<span class="token punctuation">)</span><span class="token punctuation">,</span> result<span class="token punctuation">;</span>	
    
    <span class="token comment">// 注意!!! 此段目的就是调用 Parent.call/apply(this, arguments)</span>
    <span class="token comment">// 只是前者能使 new.target 有其值，后者 new.target 为 undefined</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>hasNativeReflectConstruct<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// NewTarget = Child 构造函数</span>
      <span class="token keyword">var</span> NewTarget <span class="token operator">=</span> <span class="token function">_getPrototypeOf</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">.</span>constructor<span class="token punctuation">;</span>
      <span class="token comment">// result = Child 实例</span>
      result <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span>Super<span class="token punctuation">,</span> arguments<span class="token punctuation">,</span> NewTarget<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token comment">// result = null</span>
      result <span class="token operator">=</span> <span class="token function">Super</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token comment">// 注意!!! 此段目的就是根据 result 值</span>
    <span class="token comment">// 方式1 result 为 Child 实例，返回 result</span>
    <span class="token comment">// 方式2:</span>
    <span class="token comment">//			若 result 为 null、undefined、基本值 则返回 Child 实例</span>
  	<span class="token comment">// 			否则返回 result</span>
    <span class="token keyword">return</span> <span class="token function">_possibleConstructorReturn</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">_possibleConstructorReturn</span><span class="token punctuation">(</span><span class="token parameter">self<span class="token punctuation">,</span> call</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>call <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token function">_typeof</span><span class="token punctuation">(</span>call<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">&quot;object&quot;</span> <span class="token operator">||</span> <span class="token keyword">typeof</span> call <span class="token operator">===</span> <span class="token string">&quot;function&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> call<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token function">_assertThisInitialized</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">_assertThisInitialized</span><span class="token punctuation">(</span><span class="token parameter">self</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>self <span class="token operator">===</span> <span class="token keyword">void</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ReferenceError</span><span class="token punctuation">(</span>
      <span class="token string">&quot;this hasn't been initialised - super() hasn't been called&quot;</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> self<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// ...</span>
<span class="token keyword">var</span> <span class="token function-variable function">Parent</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">_classCallCheck</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> Parent<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> Child <span class="token operator">=</span> <span class="token comment">/*#__PURE__*/</span> <span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">_Parent</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">_inherits</span><span class="token punctuation">(</span>Child<span class="token punctuation">,</span> _Parent<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> _super <span class="token operator">=</span> <span class="token function">_createSuper</span><span class="token punctuation">(</span>Child<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// Child 未增加 constructor &amp; super 版</span>
  <span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">_classCallCheck</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> Child<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">_super</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// Child 增加 constructor &amp; super 版</span>
  <span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> _this<span class="token punctuation">;</span> 												<span class="token comment">// undefined</span>
    <span class="token function">_classCallCheck</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> Child<span class="token punctuation">)</span><span class="token punctuation">;</span>
    _this <span class="token operator">=</span> <span class="token function">_super</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Child 实例</span>
    _this<span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
    <span class="token keyword">return</span> _this<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> Child<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>Parent<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> child <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">&quot;TLP&quot;</span><span class="token punctuation">,</span> <span class="token number">70</span><span class="token punctuation">)</span>
</code></pre></div></li></ul></li></ul></li></ul> <h5 id="_4-5-2-7、extend-总结"><a href="#_4-5-2-7、extend-总结" class="header-anchor">#</a> 4-5-2-7、Extend 总结</h5> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ...</span>
<span class="token keyword">function</span> <span class="token function">_createSuper</span><span class="token punctuation">(</span><span class="token parameter">Derived</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> hasNativeReflectConstruct <span class="token operator">=</span> <span class="token function">_isNativeReflectConstruct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token function">_createSuperInternal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// Super 为 Parent 构造函数</span>
    <span class="token keyword">var</span> Super <span class="token operator">=</span> <span class="token function">_getPrototypeOf</span><span class="token punctuation">(</span>Derived<span class="token punctuation">)</span><span class="token punctuation">,</span> result<span class="token punctuation">;</span>	
    
    <span class="token comment">// 注意!!! 此段目的就是调用 Parent.call/apply(this, arguments)</span>
    <span class="token comment">// 只是前者能使 new.target 有其值，后者 new.target 为 undefined</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>hasNativeReflectConstruct<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// NewTarget = Child 构造函数</span>
      <span class="token keyword">var</span> NewTarget <span class="token operator">=</span> <span class="token function">_getPrototypeOf</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">.</span>constructor<span class="token punctuation">;</span>
      <span class="token comment">// result = Child 实例</span>
      result <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span>Super<span class="token punctuation">,</span> arguments<span class="token punctuation">,</span> NewTarget<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token comment">// result = null</span>
      result <span class="token operator">=</span> <span class="token function">Super</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token comment">// 注意!!! 此段目的就是根据 result 值</span>
    <span class="token comment">// 方式1 result 为 Child 实例，返回 result</span>
    <span class="token comment">// 方式2:</span>
    <span class="token comment">//			若 result 为 null、undefined、基本值 则返回 Child 实例</span>
  	<span class="token comment">// 			否则返回 result</span>
    <span class="token keyword">return</span> <span class="token function">_possibleConstructorReturn</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">_possibleConstructorReturn</span><span class="token punctuation">(</span><span class="token parameter">self<span class="token punctuation">,</span> call</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>call <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token function">_typeof</span><span class="token punctuation">(</span>call<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">&quot;object&quot;</span> <span class="token operator">||</span> <span class="token keyword">typeof</span> call <span class="token operator">===</span> <span class="token string">&quot;function&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> call<span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token function">_assertThisInitialized</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">_assertThisInitialized</span><span class="token punctuation">(</span><span class="token parameter">self</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>self <span class="token operator">===</span> <span class="token keyword">void</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ReferenceError</span><span class="token punctuation">(</span><span class="token string">&quot;this hasn't been initialised - super() hasn't been called&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>
  <span class="token keyword">return</span> self<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// ...</span>
<span class="token comment">// 主体部分</span>
<span class="token keyword">var</span> <span class="token function-variable function">Parent</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">_classCallCheck</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> Parent<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> Child <span class="token operator">=</span> <span class="token comment">/*#__PURE__*/</span> <span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">_Parent</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">_inherits</span><span class="token punctuation">(</span>Child<span class="token punctuation">,</span> _Parent<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> _super <span class="token operator">=</span> <span class="token function">_createSuper</span><span class="token punctuation">(</span>Child<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// Child 未增加 constructor &amp; super 版</span>
  <span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">_classCallCheck</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> Child<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">_super</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  
  <span class="token comment">// Child 增加 constructor &amp; super 版</span>
  <span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> _this<span class="token punctuation">;</span> 												<span class="token comment">// undefined</span>
    <span class="token function">_classCallCheck</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> Child<span class="token punctuation">)</span><span class="token punctuation">;</span>
    _this <span class="token operator">=</span> <span class="token function">_super</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Child 实例作为 this</span>
    _this<span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
    <span class="token keyword">return</span> _this<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> Child<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>Parent<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// ...</span>
</code></pre></div><ul><li><p>首先，执行 <code>_inherits(Child, Parent)</code>，建立 Child 和 Parent 的原型链关系，即：</p> <ul><li><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//  Object.setPrototypeOf(Child.prototype, Parent.prototype) 和 Object.setPrototypeOf(Child, Parent)</span>
<span class="token keyword">function</span> <span class="token function">_inherits</span><span class="token punctuation">(</span><span class="token parameter">subClass<span class="token punctuation">,</span> superClass</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 实现特性: 继承父类必须为 Function 或 null</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> superClass <span class="token operator">!==</span> <span class="token string">&quot;function&quot;</span> <span class="token operator">&amp;&amp;</span> superClass <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token string">&quot;Super expression must either be null or a function&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 类似于 ES5 的寄生组合式继承，使用 Object.create，设置子类 prototype 属性的 __proto__ 属性指向父类的 prototype 属性</span>
  <span class="token comment">// 并给 subClass.prototype 添加一个可配置可写不可枚举的 constructor 属性，该属性值为 subClass (修正指向)</span>
  subClass<span class="token punctuation">.</span>prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>superClass <span class="token operator">&amp;&amp;</span> superClass<span class="token punctuation">.</span>prototype<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    constructor<span class="token operator">:</span> <span class="token punctuation">{</span> value<span class="token operator">:</span> subClass<span class="token punctuation">,</span> writable<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> configurable<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 设置子类的 __proto__ 属性指向父类</span>
  <span class="token comment">// 实现特性: 静态方法继承, ES5 与 ES6 继承区别之一: subClass.__proto__ = superClass</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>superClass<span class="token punctuation">)</span> <span class="token function">_setPrototypeOf</span><span class="token punctuation">(</span>subClass<span class="token punctuation">,</span> superClass<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul></li> <li><p>然后，调用 <code>_super.call(this, name)</code>，内部核心为   <code>Parent.call(this, name)</code>；</p> <ul><li>若无调用 super()，则返回子类实例，_this 不可用；</li> <li>若调用 super，则将返回值(根据 Parent 构造函数的返回值类型，确定子类构造函数 this 的初始值)赋给 _this，_this 可用；</li></ul></li> <li><p>最终，根据子类构造函数，修改 _this 的值，然后返回该值；</p></li> <li><p><strong><u><em>问题：为何 super 调用前不能用 this；</em></u></strong></p> <ul><li><p>因为 super 负责继承中的：构造函数的继承，复制父类构造属性方法给子类实例，倘若不加限制，在 super 前使用 this 为子类构造函数添加属性，则 super 调用后，父类构造函数属性就会覆盖掉先前设置的同名属性，所以 super 调用前不能使用 this；</p></li> <li><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 先看转换结果</span>
<span class="token keyword">class</span> <span class="token class-name">Parent</span> <span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      	<span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
      	<span class="token keyword">return</span> <span class="token keyword">null</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Child</span> <span class="token keyword">extends</span> <span class="token class-name">Parent</span> <span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> 
        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>


<span class="token comment">// ...</span>
<span class="token keyword">function</span> <span class="token function">_assertThisInitialized</span><span class="token punctuation">(</span><span class="token parameter">self</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
	<span class="token keyword">if</span> <span class="token punctuation">(</span>self <span class="token operator">===</span> <span class="token keyword">void</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ReferenceError</span><span class="token punctuation">(</span><span class="token string">&quot;this hasn't been initialised - super() hasn't been called&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> 
	<span class="token keyword">return</span> self<span class="token punctuation">;</span> 
<span class="token punctuation">}</span>

<span class="token comment">// ...</span>
<span class="token keyword">var</span> <span class="token function-variable function">Parent</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">_classCallCheck</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> Parent<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> Child <span class="token operator">=</span> <span class="token comment">/*#__PURE__*/</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">_Parent</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">_inherits</span><span class="token punctuation">(</span>Child<span class="token punctuation">,</span> _Parent<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> _super <span class="token operator">=</span> <span class="token function">_createSuper</span><span class="token punctuation">(</span>Child<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> _this<span class="token punctuation">;</span>
    <span class="token function">_classCallCheck</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> Child<span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">_assertThisInitialized</span><span class="token punctuation">(</span>_this<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// error</span>
    _this <span class="token operator">=</span> <span class="token function">_super</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    _this<span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
    <span class="token keyword">return</span> _this<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> Child<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">(</span>Parent<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// ...</span>
</code></pre></div></li></ul></li> <li><p><strong><u><em>区别：ES5 的寄生组合继承实现与 ES6 继承有细微差别：</em></u></strong></p> <ul><li>ES6 Class 中含有 Object.setPrototypeOf(subClass, superClass)，用以继承父类静态方法，但寄生组合没有；</li> <li>super 机制，确保构造函数属性添加顺序进行；</li></ul></li></ul> <h4 id="_4-6、总结"><a href="#_4-6、总结" class="header-anchor">#</a> 4-6、总结</h4> <ul><li>首先，最容易想到的是 <strong><u>原型链继承</u></strong>，通过把子类实例的原型指向父类实例来继承父类的属性和方法，但原型链继承的缺陷在于<u>对子类实例继承的引用类型的修改会影响到所有的实例对象，以及无法向父类的构造方法传参</u>；</li> <li>因此，引入了 <strong><u>构造函数继承</u></strong>, 通过在子类构造函数中调用父类构造函数并传入子类 this 来获取父类的属性和方法，但构造函数继承也存在缺陷，<u>构造函数继承不能继承到父类原型链上的属性和方法</u>；</li> <li>所以，综合两种继承的优点，提出了 <strong><u>组合式继承</u></strong>，但组合式继承也引入了新的问题：<u>它每次创建子类实例都执行了两次父类构造方法</u>；最后，通过将子类原型指向父类实例，改为子类原型指向父类原型的浅拷贝来解决这一问题，也即最终实现：<strong><u>寄生组合式继承</u></strong></li></ul> <h4 id="_4-7、多继承"><a href="#_4-7、多继承" class="header-anchor">#</a> 4-7、多继承</h4> <h5 id="_4-7-1、基本"><a href="#_4-7-1、基本" class="header-anchor">#</a> 4-7-1、基本</h5> <p>基本：没有几个语言能真正实现多继承，比如 C++ 和 python 提供了多继承的语法；</p> <p>而 Java 只允许继承一个父类，但可同时 implements 多个接口类，也算一种变相的多继承；</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">MyClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token function">SuperClass</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token function">OtherSuperClass</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 继承一个类（就是寄生组合继承的套路）</span>
<span class="token class-name">MyClass</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token class-name">SuperClass</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 混合其它类，关键是 assign() 方法: </span>
<span class="token comment">// assign 会将 OtherSuperClass 原型上的函数拷贝到 MyClass 原型上，使 MyClass 的所有实例都可用 OtherSuperClass 的方法</span>
Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token class-name">MyClass</span><span class="token punctuation">.</span>prototype<span class="token punctuation">,</span> <span class="token class-name">OtherSuperClass</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 重新指定 constructor</span>
<span class="token class-name">MyClass</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> MyClass<span class="token punctuation">;</span>

<span class="token comment">// 在之类上附加方法</span>
<span class="token class-name">MyClass</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">myMethod</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// do a thing</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p><a href="https://link.zhihu.com/?target=https%3A//developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign" target="_blank" rel="noopener noreferrer">Object.assign<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> <a href="https://link.zhihu.com/?target=https%3A//developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign%23Polyfill" target="_blank" rel="noopener noreferrer"> polyfilled<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，支持旧浏览器可用使用 <a href="https://link.zhihu.com/?target=https%3A//api.jquery.com/jQuery.extend/" target="_blank" rel="noopener noreferrer">jQuery.extend()<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 或 <a href="https://link.zhihu.com/?target=https%3A//lodash.com/docs/%23assign" target="_blank" rel="noopener noreferrer">_.assign()<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>、<a href="https://link.zhihu.com/?target=https%3A//developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create" target="_blank" rel="noopener noreferrer">MDN] Object.create()<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h5 id="_4-7-2、多继承问题"><a href="#_4-7-2、多继承问题" class="header-anchor">#</a> 4-7-2、多继承问题</h5> <ul><li><p>问题：instanceof 指向</p> <ul><li><p>JS 只有 prototype 链，且约束了每一对象只能有一条 Prototype，则在多继承情况下， instanceof 须另外实现；</p></li> <li><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token comment">// 假定有继承</span>
<span class="token keyword">class</span> <span class="token class-name">C</span> extend <span class="token constant">A</span><span class="token punctuation">,</span> <span class="token constant">B</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token comment">// 此时 C 的实例，则应同时指向 A &amp; B</span>
<span class="token keyword">const</span> c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
c <span class="token keyword">instanceof</span> <span class="token class-name">A</span> <span class="token comment">// true</span>
c <span class="token keyword">instanceof</span> <span class="token class-name">B</span> <span class="token comment">// true</span>
c <span class="token keyword">instanceof</span> <span class="token class-name">C</span> <span class="token comment">// true</span>
</code></pre></div></li></ul></li> <li><p>问题：Diamond Problem</p> <ul><li>假如 ABC 三类均定义一同名函数，则 D 的实例应取谁为准</li> <li><img src="/Image/Basics/Special/Mode/219.png" align="" style="zoom:50%;"></li></ul></li></ul> <h5 id="_4-7-3、多继承解决"><a href="#_4-7-3、多继承解决" class="header-anchor">#</a> 4-7-3、多继承解决</h5> <ul><li><p>解决：instanceof</p></li> <li><p>思路：借鉴 Java 思路，实际只继承一个类，而其他类则通过其他方式将其功能融入；</p></li> <li><p>Java 中可用 Interface 约束类该有的行为，当然 JS 也可参考使用 interface，但如此的话，除校验外别无他用，故 JS 改用 mixin 方式更为实在</p></li> <li><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 构造一个中间类，让中间类直接继承 A，并且 mixin 了 B 的原型成员，然后再让 C 去继承这个中间类</span>
<span class="token keyword">const</span> <span class="token function-variable function">mixinClass</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">base<span class="token punctuation">,</span> <span class="token operator">...</span>mixins</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// tool</span>
  <span class="token keyword">const</span> <span class="token function-variable function">mixinProps</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> source</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    Object<span class="token punctuation">.</span><span class="token function">getOwnPropertyNames</span><span class="token punctuation">(</span>source<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">prop</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token regex">/^constructor$/</span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>prop<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
      Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> prop<span class="token punctuation">,</span> Object<span class="token punctuation">.</span><span class="token function">getOwnPropertyDescriptor</span><span class="token punctuation">(</span>source<span class="token punctuation">,</span> prop<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token keyword">let</span> Ctor<span class="token punctuation">;</span>
  
  <span class="token comment">// 由于 B 是通过 mixin 方式浅拷贝了一份，B.prototype 并不在 C 的原型链上（C.__proto__.__proto__），所以 c instanceof B 为 false</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>base <span class="token operator">&amp;&amp;</span> <span class="token keyword">typeof</span> base <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Ctor <span class="token operator">=</span> <span class="token keyword">class</span> <span class="token class-name">extends</span> base <span class="token punctuation">{</span>
      <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token operator">...</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    mixins<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">source</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token function">mixinProps</span><span class="token punctuation">(</span><span class="token class-name">Ctor</span><span class="token punctuation">.</span>prototype<span class="token punctuation">,</span> source<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// </span>
    Ctor <span class="token operator">=</span> <span class="token keyword">class</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> Ctor<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
  <span class="token function">methodA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token punctuation">{</span>
  <span class="token function">methodB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">C</span> <span class="token keyword">extends</span> <span class="token class-name">mixinClass</span><span class="token punctuation">(</span><span class="token constant">A</span><span class="token punctuation">,</span> <span class="token constant">B</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">methodA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'methodA in C'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token function">methodC</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
c <span class="token keyword">instanceof</span> <span class="token class-name">C</span>  <span class="token comment">// true</span>
c <span class="token keyword">instanceof</span> <span class="token class-name">A</span>  <span class="token comment">// true</span>
c <span class="token keyword">instanceof</span> <span class="token class-name">B</span>  <span class="token comment">// false</span>
</code></pre></div></li> <li><p>解决 Diamond Problem</p></li> <li><p>思路：Method Resolution Order (MRO) 指的是在继承结构中确定类的线性顺序，例如 <code>C =&gt; B =&gt; A</code> 表示 C 继承 B，B 继承 A，那么 C 的 MRO 就是 <code>C B A</code>，也即当调用 C 实例中的一个函数时，会按照 <code>C B A</code> 的优先级顺序去“寻找”该函数。在单继承的结构中自然没有问题，而在多继承中 MRO 发挥着其作用；常用的 <a href="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/C3_linearization" target="_blank" rel="noopener noreferrer">C3算法<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 就是用来计算 MRO</p></li> <li><p>详见：<a href="https://zhuanlan.zhihu.com/p/34693209" target="_blank" rel="noopener noreferrer">JS多继承<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></li></ul> <h3 id="五、设计模式"><a href="#五、设计模式" class="header-anchor">#</a> 五、设计模式</h3> <h4 id="_5-1、面向对象的设计"><a href="#_5-1、面向对象的设计" class="header-anchor">#</a> 5-1、面向对象的设计</h4> <h5 id="_5-1-1、设计原则"><a href="#_5-1-1、设计原则" class="header-anchor">#</a> 5-1-1、设计原则</h5> <ul><li>S一Single Responsibility Principle单一职责原则
<ul><li>一个程序只做好一 -件事</li> <li>如果功能过于 复杂就拆分开，每个部分保持独立</li></ul></li> <li>O—OpenClosed Principle 开放/封闭原则
<ul><li>对扩展开放，对修改封闭</li> <li>增加需求时，扩展新代码，而非修改已有代码</li></ul></li> <li>L—Liskov Substitution Principle 里氏替换原则
<ul><li>子类能覆盖父类</li> <li>父类能出现的地方子类就能出现</li></ul></li> <li>I—Interface Segregation Principle接口隔离原则
<ul><li>保持接口的单一独立</li> <li>类似单一职责原则，这里更关注接口</li></ul></li> <li>D—Dependency Inversion Principle 依赖倒转原则
<ul><li>面向接口编程， 依赖于抽象而不依赖于具体</li> <li>使用方只关注接口 而不关注具体类的实现</li></ul></li></ul> <p><strong><u>JS常用之一：单一职责原则—SRP(Single Responsibility Principle)-</u></strong></p> <ul><li>基本：一个方法、一个类只负责一个职责，各个职责的程序改动，不影响其它程序；</li> <li>比如：组件化、模块化；</li></ul> <p><strong><u>JS常用之二：开放封闭原则—OP(OpenClosed Principle)</u></strong></p> <ul><li>基本：核心思想是软件实体(类、模块、函数等)是可扩展的、但不可修改；即对扩展是开放的，而对修改是封闭的</li> <li>比如：类、模块和函数，应当对扩展开放，但对修改关闭；</li></ul> <h5 id="_5-1-2、单例模式"><a href="#_5-1-2、单例模式" class="header-anchor">#</a> 5-1-2、单例模式</h5> <p>基本：保证一个类只有一个实例，并提供一个访问它的全局访问点；</p> <p>场景：</p> <ul><li>定义命名空间和实现分支型方法</li> <li>登录控件、模态框、注销删除控件、vuex、redux 中的 store、<code>JQ的$</code></li></ul> <p>优点：划分命名空间，减少全局变量、只实例化一次、简化代码，便于调试和维护、增强模块性；</p> <p>缺点：单点访问、可能导致模块间的强耦合，不利于单元测试(无法单独测试一个调用了来自单例的方法的类，而只能把它与那个单例作为一个单元一起测试)</p> <p><strong><u>总结：单一、唯一性、共享</u></strong></p> <p>种类：可细分为惰性单例(在需要时才创建对象实例)；</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">SingletonLogin</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span>password</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
    <span class="token keyword">this</span><span class="token punctuation">.</span>password <span class="token operator">=</span> password
  <span class="token punctuation">}</span>
  <span class="token keyword">static</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span>password</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">// 判断对象是否已经被创建,若创建则返回旧对象</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>instance<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SingletonLogin</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span>password<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>instance
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
 
<span class="token keyword">let</span> obj1 <span class="token operator">=</span> SingletonLogin<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token string">'TLP'</span><span class="token punctuation">,</span><span class="token string">'123'</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> obj2 <span class="token operator">=</span> SingletonLogin<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token string">'TLP'</span><span class="token punctuation">,</span><span class="token string">'321'</span><span class="token punctuation">)</span>
 
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj1<span class="token operator">===</span>obj2<span class="token punctuation">)</span>    <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj1<span class="token punctuation">)</span>           <span class="token comment">// {name:TLP,password:123}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj2<span class="token punctuation">)</span>           <span class="token comment">// 输出的依然是 {name:TLP,password:123}</span>


<span class="token comment">// 惰性单例</span>
<span class="token keyword">const</span> createLoginLayer <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> div<span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>div<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      div <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">&quot;div&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      div<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token string">&quot;TLP&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> div<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 在点击按钮时才创建节点(惰性)</span>
document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&quot;login-btn&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function-variable function">onclick</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> loginLayer <span class="token operator">=</span> <span class="token function">createLoginLayer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  loginLayer<span class="token punctuation">.</span>style<span class="token punctuation">.</span>display <span class="token operator">=</span> <span class="token string">&quot;block&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h5 id="_5-1-3、工厂模式"><a href="#_5-1-3、工厂模式" class="header-anchor">#</a> 5-1-3、工厂模式</h5> <p>基本：定义一用于创建对象的接口，此接口由子类决定实例化哪个类(而这些类通常都拥有相同的接口(属性和方法))；</p> <p>特点：使父类的实例化，延迟到子类，子类还可重写父类的属性和方法，以便创建时指定自己的对象类型；</p> <p>场景：常见于大型项目，比如 JQ、<code>React.createElement()</code>、<code>Vue.component()</code></p> <p>优点：</p> <ul><li>构造函数和创建者分离，相同方法在父类中编写，符合 OP—开闭原则；</li> <li>减少代码冗余、耦合度低、扩展性高、灵活性高(子类可在父类基础上自定义接口)；</li> <li>意即：父类即抽象类，存放一般性问题的处理与相同方法，随着子类构建而被其继承，子类间相互独立，负责具体业务逻辑；</li></ul> <p>缺点：</p> <ul><li>扩展时需引入抽象层(父类)，增加了系统的抽象性和理解难度；</li></ul> <p><strong><u>总结：实例延迟到子类创建、子类继承父类相同接口并各自根据情况实现业务逻辑、父类实现通用方法的封装(抽象层)</u></strong></p> <p>种类：<code>简单工厂模式</code>、<code>工厂方法模式</code>、<code>抽象工厂模式</code>；</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 简单工厂模式</span>
<span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> auth</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
    <span class="token keyword">this</span><span class="token punctuation">.</span>auth <span class="token operator">=</span> auth
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">UserFactory</span> <span class="token punctuation">{</span>
  <span class="token keyword">static</span> <span class="token function">createUser</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> auth</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 工厂内部封装了创建对象的逻辑:</span>
    <span class="token comment">// 权限为admin时,auth=1, 权限为user时, auth为2</span>
    <span class="token comment">// 使用者在外部创建对象时,不需要知道各个权限对应哪个字段, 不需要知道赋权的逻辑，只需要知道创建了一个管理员和用户</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>auth <span class="token operator">===</span> <span class="token string">'admin'</span><span class="token punctuation">)</span>  <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>auth <span class="token operator">===</span> <span class="token string">'user'</span><span class="token punctuation">)</span>  <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> admin <span class="token operator">=</span> UserFactory<span class="token punctuation">.</span><span class="token function">createUser</span><span class="token punctuation">(</span><span class="token string">'cxk'</span><span class="token punctuation">,</span> <span class="token string">'admin'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> user <span class="token operator">=</span> UserFactory<span class="token punctuation">.</span><span class="token function">createUser</span><span class="token punctuation">(</span><span class="token string">'cxk'</span><span class="token punctuation">,</span> <span class="token string">'user'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><img src="/Image/Basics/Special/Mode/224.png" align="" style="zoom:50%;"> <h5 id="_5-1-4、观察者模式"><a href="#_5-1-4、观察者模式" class="header-anchor">#</a> 5-1-4、观察者模式</h5> <p>基本：定义1种1对多的关系，观察者监听被观察者的变化，被观察者发生改变时，通知所有的观察者；观察者模式算是前端最常用的设计模式；</p> <p>场景：当一对象的改变需同时改变其它对象且不知道有多少对象需要改变时，就应考虑观察者模式；比如DOM事件、Vue 响应原理；</p> <p>优点：</p> <ul><li>灵活性高、支持简单广播通信，自动通知所有已订阅过的对象；</li> <li>目标对象与观察者间抽象耦合关系(重在解耦，让耦合双方均依赖于抽象，而非依赖具体，使各自变化而不会影响另一边)能单独扩展及重用；</li></ul> <p>缺点：过度使用会导致对象与对象间联系弱化，难以跟踪维护和理解；</p> <p>注意：有些文章将观察者模式称为发布订阅模式，但二者是有所区别的，发布订阅相较此模式多一个调度中心；</p> <p><strong><u>总结：即概念：观察者监听被观察者的变化，被观察者发生改变时，通知所有的观察者；注意发布订阅相较此模式多一个调度中心</u></strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//观察者</span>
<span class="token keyword">class</span> <span class="token class-name">Observer</span> <span class="token punctuation">{</span>    
  <span class="token function">constructor</span> <span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      
    <span class="token keyword">this</span><span class="token punctuation">.</span>update <span class="token operator">=</span> fn    
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">//被观察者</span>
<span class="token keyword">class</span> <span class="token class-name">Subject</span> <span class="token punctuation">{</span>    
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        
        <span class="token keyword">this</span><span class="token punctuation">.</span>observers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>          <span class="token comment">// 观察者队列    </span>
    <span class="token punctuation">}</span>    
    <span class="token function">addObserver</span><span class="token punctuation">(</span><span class="token parameter">observer</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          
        <span class="token keyword">this</span><span class="token punctuation">.</span>observers<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>observer<span class="token punctuation">)</span><span class="token comment">// 往观察者队列添加观察者    </span>
    <span class="token punctuation">}</span>    
    <span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                       <span class="token comment">// 通知所有观察者,实际上是把观察者的 update()都执行了一遍       </span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>observers<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">observer</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>        
            observer<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token comment">// 依次取出观察者,并执行观察者的 update 方法        </span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>    
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> subject <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Subject</span><span class="token punctuation">(</span><span class="token punctuation">)</span>       <span class="token comment">// 被观察者</span>
<span class="token keyword">const</span> <span class="token function-variable function">update</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'被观察者发出通知'</span><span class="token punctuation">)</span><span class="token punctuation">}</span>  <span class="token comment">//收到广播时要执行的方法</span>
<span class="token keyword">var</span> ob1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Observer</span><span class="token punctuation">(</span>update<span class="token punctuation">)</span>    <span class="token comment">// 观察者1</span>
<span class="token keyword">var</span> ob2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Observer</span><span class="token punctuation">(</span>update<span class="token punctuation">)</span>    <span class="token comment">// 观察者2</span>
subject<span class="token punctuation">.</span><span class="token function">addObserver</span><span class="token punctuation">(</span>ob1<span class="token punctuation">)</span>          <span class="token comment">// 观察者1订阅 subject 的通知</span>
subject<span class="token punctuation">.</span><span class="token function">addObserver</span><span class="token punctuation">(</span>ob2<span class="token punctuation">)</span>          <span class="token comment">// 观察者2订阅 subject 的通知</span>
subject<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                  <span class="token comment">// 发出广播,执行所有观察者的 update 方法</span>
</code></pre></div><h5 id="_5-1-5、发布订阅模式"><a href="#_5-1-5、发布订阅模式" class="header-anchor">#</a> 5-1-5、发布订阅模式</h5> <p>有别于观察模式，多一个调度中心</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> Event <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 缓存列表</span>
  <span class="token keyword">var</span> list <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> listen<span class="token punctuation">;</span> <span class="token comment">// 监听函数</span>
  <span class="token keyword">var</span> trigger<span class="token punctuation">;</span> <span class="token comment">// 触发监听</span>
  <span class="token keyword">var</span> remove<span class="token punctuation">;</span> <span class="token comment">// 移除监听函数</span>

  <span class="token function-variable function">listen</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">key<span class="token punctuation">,</span> fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>list<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      list<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    list<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token function-variable function">trigger</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> key <span class="token operator">=</span> <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span><span class="token punctuation">,</span>
      fns <span class="token operator">=</span> list<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>fns <span class="token operator">||</span> fns<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> fn<span class="token punctuation">;</span> <span class="token punctuation">(</span>fn <span class="token operator">=</span> fns<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token function-variable function">remove</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">key<span class="token punctuation">,</span> fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> fns <span class="token operator">=</span> list<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>fns<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      fns <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>fns<span class="token punctuation">.</span>length <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> fns<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> _fn <span class="token operator">=</span> fns<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>_fn <span class="token operator">===</span> fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          fns<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    listen<span class="token punctuation">,</span>
    trigger<span class="token punctuation">,</span>
    remove<span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


<span class="token keyword">function</span> <span class="token function">d1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;first&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">d2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;second&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// RQUiti5</span>
Event<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token string">&quot;color&quot;</span><span class="token punctuation">,</span> d1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// d1</span>
Event<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token string">&quot;color&quot;</span><span class="token punctuation">,</span> d2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// d2</span>
Event<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token string">&quot;color&quot;</span><span class="token punctuation">,</span> d1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// d1</span>
Event<span class="token punctuation">.</span><span class="token function">trigger</span><span class="token punctuation">(</span><span class="token string">&quot;color&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// second</span>
</code></pre></div><h5 id="_5-1-6、装饰器模式"><a href="#_5-1-6、装饰器模式" class="header-anchor">#</a> 5-1-6、装饰器模式</h5> <p>基本：在不改变原对象的基础上，通过对其进行包装扩展，使原有对象可满足用户的复杂需求，而不影响从这个类中派生的其他对象，是一种实现继承的替代方案；该模式可以在被装饰者前面或者后面加上自己的行为以达到特定的目的；可简单理解为对类的一个包装，动态地拓展类的功能；</p> <p>场景：ES7 的装饰器语法、React 中的高阶组件(HoC) 、react-redux 的 connect()、angular-decorators</p> <ul><li><p>比如现有4 种型号自行车，为每种自行车都定义1个单 独的类，现在要给每种自行车都装上前灯、尾 灯和铃铛这3 种配件；</p></li> <li><ul><li>若使用继承的方式来给 每种自行车创建子类，则需要 4×3 = 12 个子类；</li> <li>但若把前灯、尾灯、铃铛这些对象动态组 合到自行车上面，则只需要额外增加3 个类；</li></ul></li></ul> <p>优点：装饰类与被装饰类，均只需关心自身核心业务，实现了解耦；可方便动态地扩展功能，提供了比继承更多灵活性；</p> <p>缺点：多层装饰比较复杂，常引入许多小对象，看起来比较相似，实际功能大相径庭，从而使得应用程序架构变得复杂；</p> <p><strong><u>总结：如字面意思，装饰；</u></strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 以 ES7 的装饰器为例</span>
<span class="token keyword">function</span> <span class="token function">info</span><span class="token punctuation">(</span><span class="token parameter">target</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  target<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'张三'</span>
  target<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">10</span>
<span class="token punctuation">}</span>

@info
<span class="token keyword">class</span> <span class="token class-name">Man</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token keyword">let</span> man <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Man</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
man<span class="token punctuation">.</span>name <span class="token comment">// 张三</span>
</code></pre></div><h5 id="_5-1-7、适配器模式"><a href="#_5-1-7、适配器模式" class="header-anchor">#</a> 5-1-7、适配器模式</h5> <p>基本：将1个类的接口(方法或属性)转化为另1个接口，以满足用户需求，解决类间接口不兼容问题；</p> <p>场景：</p> <ul><li>封装旧接口、或整合第3方SDK(比如当系统中某个接口结构已无法满足现有业务需求，不能改动原有接口或改动接口会牵扯太多功能模块)时；</li></ul> <p>优点：适配对象、库、数据、让任何2个无关联的类一起运行、代码复用；</p> <p>缺点：额外对象的创建非直接调用，存在一定的开销(且不同代理模式在某些功能点上可实现性能优化)</p> <p>注意：</p> <ul><li>若无必要则应考虑重构，否则需完善文档；</li> <li>尽量少使用，因其类似打补丁，若在接口还没有确定时使用会影响后期维护，需思考接口设计是否合理；</li></ul> <p>区别：</p> <ul><li>与代理模式：前者提供1不同接口以适配，后者提供相同接口，并为另外1对象定义代理；</li> <li>与桥接模式：出发点不同，前者是改变已有对象接口以达到适配目的，后者目的则是将接口与实现部分相互分离，从而可更为容易、也相对独立地加以改变；</li> <li>与装饰者模式：后者增强其装饰对象的功能，且同时不改变其接口，结构更为透明、功能更为强大；</li></ul> <p><strong><u>总结：适配、插座；</u></strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Adaptee</span> <span class="token punctuation">{</span>
  <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token string">'旧接口'</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
 
<span class="token keyword">class</span> <span class="token class-name">Target</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>adaptee <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Adaptee</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">let</span> info <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>adaptee<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token keyword">return</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">适配</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>info<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
 
<span class="token keyword">let</span> target <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Target</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>target<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><h5 id="_5-1-8、代理模式"><a href="#_5-1-8、代理模式" class="header-anchor">#</a> 5-1-8、代理模式</h5> <p>基本：为一个对象提供一个代用品或占位符，以便控制对它的访问；</p> <p>场景：</p> <ul><li>图片预加载、图片懒加载、合并 HTTP 请求(代理收集一定时间内的所有HTTP请求，然后一次性发给服务器)、</li> <li>惰性加载(通过代理处理和收集一些基本操作，然后仅在真正需要本体的时候才加载本体)、</li> <li>缓存代理(缓存请求结果、计算结果)</li></ul> <p>注意：代理对象与本体对象实现了同样接口，且会把任何方法调用传递给本体对象；</p> <p>优点：</p> <ul><li><p>可扩展目标对象功能、符合 OP 开闭原则；</p></li> <li><p>能将代理对象与被调用对象分离，降低系统耦合度、在客户端和目标对象之间起到中介作用，以保护目标对象的作用</p></li></ul> <p>缺点：处理请求速度可能有差别，因非直接访问存在开销；</p> <p>区别：与装饰器模式：前者显示原有功能，但经过限制之后，后者扩展功能，原有功能不变且可直接使用；</p> <p>总结：字面意思，代为实行：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> idol <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token string">'特朗普'</span><span class="token punctuation">,</span>
  phone<span class="token operator">:</span> <span class="token number">10086</span><span class="token punctuation">,</span>
  price<span class="token operator">:</span> <span class="token number">1000000</span>  <span class="token comment">//报价</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> agent <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>idol<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token function-variable function">get</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">target</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 拦截明星电话的请求,只提供经纪人电话</span>
    <span class="token keyword">return</span> <span class="token string">'经纪人电话: 10086'</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function-variable function">set</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>key <span class="token operator">===</span> <span class="token string">'price'</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 经纪人过滤资质</span>
      <span class="token keyword">if</span><span class="token punctuation">(</span>value <span class="token operator">&lt;</span> target<span class="token punctuation">.</span>price<span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'报价过低'</span><span class="token punctuation">)</span>
      target<span class="token punctuation">.</span>price <span class="token operator">=</span> value
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>


agent<span class="token punctuation">.</span>phone        <span class="token comment">// 经纪人电话:10086</span>
agent<span class="token punctuation">.</span>price <span class="token operator">=</span> <span class="token number">100</span>  <span class="token comment">// Uncaught Error: 报价过低</span>
</code></pre></div><h4 id="_5-2、面向组合的设计"><a href="#_5-2、面向组合的设计" class="header-anchor">#</a> 5-2、面向组合的设计</h4> <p><strong><u>继承最大问题在于：无法决定继承哪些属性，所有属性都得继承；</u></strong></p> <p>比如：B 类继承 A 类，为避免上述问题，可创建父类，把不必要的内容先剔除；但问题仍显著：</p> <ul><li>一方面：父类无法描述所有子类的细节情况，为不同子类特性去增加不同的父类，<u>代码大量重复</u>；</li> <li>一方面：一旦子类有所变动，父类也要进行相应更新，<u>代码耦合性太高</u>，<u>难以维护</u>；</li></ul> <p><strong><u>解决：使用组合，当今编程语法发展趋势，比如 golang 完全采用的是面向组合的设计方式；</u></strong></p> <p>其原理即先设计一系列零件，然后将这些零件进行拼装，来形成不同的实例或者类；</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">drive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;wuwuwu!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">music</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;lalala!&quot;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">addOil</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;kakaka！&quot;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> car <span class="token operator">=</span> <span class="token function">compose</span><span class="token punctuation">(</span>drive<span class="token punctuation">,</span> music<span class="token punctuation">,</span> addOil<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> newEnergyCar <span class="token operator">=</span> <span class="token function">compose</span><span class="token punctuation">(</span>drive<span class="token punctuation">,</span> music<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="x、架构模式"><a href="#x、架构模式" class="header-anchor">#</a> X、架构模式</h3> <h4 id="x-1、基本"><a href="#x-1、基本" class="header-anchor">#</a> X-1、基本</h4> <p>软件架构模式—<strong><u><em>Architectural Pattern</em></u></strong>：MVC，MVP，MVVM，均是常见的软件架构模式(Architectural Pattern)；</p> <p>软件架构模式通过分离关注点，来改进代码的组织方式，且相对独立不影响；</p> <ul><li>相同部分：<strong><u><em>MV(Model-View)</em></u></strong></li> <li>不同部分：<strong><u><em>C(Controller)、P(Presenter)、VM(View-Model)</em></u></strong></li></ul> <p>架构模式不同于设计模式 (Design Pattern)</p> <ul><li>前者往往使用了多种设计模式；</li> <li>后者只是为了解决一类问题而总结出的抽象方法；</li></ul> <h4 id="x-2、m-v-c"><a href="#x-2、m-v-c" class="header-anchor">#</a> X-2、M&amp; V &amp; C</h4> <h5 id="x-2-1、model"><a href="#x-2-1、model" class="header-anchor">#</a> X-2-1、Model</h5> <p>应用程序中用于，处理应用程序数据逻辑的部分；</p> <p>用于封装和应用程序的业务逻辑相关的数据以及对数据的处理方法；</p> <p>通常 Model 负责在数据库中存取数据；</p> <h5 id="x-2-2、view"><a href="#x-2-2、view" class="header-anchor">#</a> X-2-2、View</h5> <p>应用程序中，处理数据显示的部分；</p> <p>通常 View 依据模型数据创建；</p> <h5 id="x-2-3、controller"><a href="#x-2-3、controller" class="header-anchor">#</a> X-2-3、Controller</h5> <p>应用程序中，处理用户交互的部分；</p> <p>用于连接 Model &amp; View，控制应用程序流程，定义用户界面对用户输入响应方式，处理用户行为和数据上的改变；</p> <p>通常 Controller 负责从 View 读取数据，控制用户输入，并向 Model 发送数据，是一个中间件；</p> <h4 id="x-3、mv-c-p-vm"><a href="#x-3、mv-c-p-vm" class="header-anchor">#</a> X-3、MV(C/P/VM)</h4> <p>分别用三种模式实现一个可以对数值进行加减操作的组件：</p> <img src="/Image/Basics/Special/Mode/200.png" align="" style="zoom:50%;"> <h5 id="x-3-1、mvc"><a href="#x-3-1、mvc" class="header-anchor">#</a> X-3-1、MVC</h5> <img src="/Image/Basics/Special/Mode/201.png" align="" style="zoom:50%;"> <p>基本：View 负责接收用户的输入操作，Controller 负责业务逻辑的处理，Model 负责数据持久化(数据管理)，Controller 将结果反馈给 View</p> <p>优点：</p> <ul><li>简化分组开发，实现同时开发；</li> <li>利于管理，让开发人员更专注于开发；</li> <li>职责明确，独立改变而不影响，较高的灵活性和重用性；</li></ul> <p>缺点：</p> <ul><li>Controller 集中了过多业务逻辑；</li> <li>View 与 Controller 间耦合重，难以复用；</li> <li>当每个事件都流经 Controller 时，Controller 变得臃肿；</li></ul> <p>应用：JavaEE 中的 SSH框架(Struts/Spring/Hibernate)、Struts(View, STL)、Spring(Controller, Ioc、Spring MVC)、Hibernate(Model, ORM)</p> <ul><li><p>MVC 的 Model</p> <ul><li>用于存储业务数据，数据发生变化，Model 将通知 View；</li> <li>Model 和 View 间使用了观察者模式，View 事先在 Model 上注册从而观察 Model，当 Model 上数据发生改变时 View 则及时刷新(Controller)；</li> <li><img src="/Image/Basics/Special/Mode/202.png" align="" style="zoom:50%;"></li></ul></li> <li><p>MVC 的 View</p> <ul><li>Controller 和 View 间使用了策略模式，View 引入 Controller 的实例 来实现特定的响应策略，如其中的按钮的 click 事件：</li> <li><img src="/Image/Basics/Special/Mode/203.png" align="" style="zoom:50%;"></li></ul></li> <li><p>MVC 的 Controller</p> <ul><li>Controller 是 Model 和 View 间的纽带，MVC 将响应机制封装在 controller 对象中</li> <li>在 Controller 中响应 View 的事件并调用 Model 的接口对数据进行操作，一旦 Model 发生变化便通知 View 进行更新；</li> <li><img src="/Image/Basics/Special/Mode/204.png" align="" style="zoom:50%;"></li></ul></li></ul> <p>此处实例化 View 并向对应的 Model 实例注册，当 Model 发生变化时就去通知 View 做更新，这里用到了观察者模式；</p> <p>最后一步，使用 Controller 初始化：</p> <ul><li><img src="/Image/Basics/Special/Mode/205.png" align="" style="zoom:50%;"></li></ul> <h5 id="x-3-2、mvp"><a href="#x-3-2、mvp" class="header-anchor">#</a> X-3-2、MVP</h5> <img src="/Image/Basics/Special/Mode/206.png" align="" style="zoom:50%;"> <p>基本：MVP 是 MVC 模式的改良，其将 MVC 中的 Controller 换为 Presenter-呈现，同样负责业务逻辑；即 View 负责控件组成的页面，Model 负责实体数据库操作；而 View 和 Model 间的控件数据绑定操作则属于 Presenter，目的时隔绝 View 和 Model 间的通信，View 不再像 MVC 那样直接访问 Model，而此任务交由 Presenter 负责；</p> <p>优点：</p> <ul><li>与 MVC 相比，解决了无法实现多个 View 共用一个 Controller的问题，降低 View 和 Controller 耦合度，可复用性提高</li> <li>与 MVC 相比，MVP模式通过解耦 View 和 Model ，使职责划分更加清晰</li> <li>隔绝 View 和 Model，可将 View 抽离封装成组件(往后只需提供接口提供给上层操作即可)</li></ul> <p>缺点：</p> <ul><li>Presenter 还是很重，维护困难；</li> <li>Presenter 负责基本业务逻辑，还需管理 View 与 Model 间的数据流动；</li> <li>由于没有数据绑定，若 View 需求增多，Presenter 也要改变</li></ul> <p>应用：<a href="http://asp.net/" target="_blank" rel="noopener noreferrer">ASP.NET<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 的 webform、winform 基于事件驱动的开发技术就是使用的 MVP 模式</p> <p>注意：React 是 View 层的框架，Model 层的框架需要结合 Flux 或 Redux ；</p> <ul><li><p>MVP 的 Model</p> <ul><li>同 MVC，依然用于封装业务相关的数据和对应处理数据的方法</li> <li><img src="/Image/Basics/Special/Mode/207.png" align="" style="zoom:50%;"></li></ul></li> <li><p>MVP 的 View</p> <ul><li>用户对 View 的操作都转移到了Presenter</li> <li>待 Presenter 通知 Model 更新后，Presenter 调用 View 提供的接口更新视图(下 this)；</li> <li><img src="/Image/Basics/Special/Mode/208.png" align="" style="zoom:50%;"></li></ul></li> <li><p>MVP 的 Presenter</p> <ul><li>负责基本的业务逻辑，并管理 从 View 与 View 间的数据流动；</li> <li><img src="/Image/Basics/Special/Mode/209.png" align="" style="zoom:50%;"></li></ul></li></ul> <p>最后一步，使用 View 初始化：(MVC 用的是 Controller 实例化)</p> <ul><li><img src="/Image/Basics/Special/Mode/210.png" align="" style="zoom:50%;"></li></ul> <h5 id="x-3-3、mvvm"><a href="#x-3-3、mvvm" class="header-anchor">#</a> X-3-3、MVVM</h5> <p>基本：MVP 是对 MVC 的改良，MVVM 则是变革，MVVM 将数据模型的，数据双向绑定的思想作为核心；MVVM 将 View 和 Model 的同步逻辑自动化，之间的同步不再需手动操作，而是交由框架提供的数据绑定功能来负责处理；即只需告诉框架 V层 显示的数据，对应 M层哪一部分即可；至此，V层 数据的变化会同时修改 M层的数据源，而 M层的数据变化也会立即反应到 V层上；</p> <p>注意：ViewModel 是整个模式的重点，业务逻辑也主要集中在这里，其中的一大核心就是数据绑定；</p> <p>优点：</p> <ul><li>与 MVC/P 相比，简化业务与界面的依赖，解决数据频繁更新的问题；</li> <li>与 MVC/P 相比，V 层 和 M 层分离，低耦合，提高可复用性；</li> <li>与 MVC/P 相比，MVVM 中的 View 通过使用模板语法来声明式的将数据渲染进 DOM；</li> <li>VM 对Model 进行更新时，会通过数据绑定，更新到 View</li></ul> <p>应用：.NET的 WPF、JS 的 Knockout、AngularJS、Angular 框架；</p> <ul><li>MVVM 的 Model
<ul><li>在 MVVM 中，可将 Model 称为数据层，仅关注数据本身，不关心任何行为；</li> <li><img src="/Image/Basics/Special/Mode/211.png" align="" style="zoom:50%;"></li></ul></li> <li>MVVM 的 View
<ul><li>与 MVC/MVP 不同的是，MVVM 中的 View 通过使用模板语法来声明式的将数据渲染进 DOM</li> <li>VM 对 Model 进行更新时，会通过数据绑定，更新到 View；</li> <li><img src="/Image/Basics/Special/Mode/212.png" align="" style="zoom:50%;"></li></ul></li> <li>MVVM 的 ViewModel
<ul><li>与 MVP 不同的是，没有了 View 为 Presente 提供的接口；</li> <li>之前由 Presenter 负责的 View 和 Model 间的数据同步交给了 ViewModel 中的数据绑定进行处理；</li> <li>Model 和 ViewModel 任一一个发生变化，就会自动更新对方；</li> <li><img src="/Image/Basics/Special/Mode/213.png" align="" style="zoom:50%;"></li></ul></li></ul> <p>补充A：</p> <p><strong>Model</strong>: 代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑。我们可以把Model称为数据层，因为它仅仅关注数据本身，不关心任何行为</p> <p><strong>View</strong>: 用户操作界面。当ViewModel对Model进行更新的时候，会通过数据绑定更新到View</p> <p><strong>ViewModel</strong>： 业务逻辑层，View需要什么数据，ViewModel要提供这个数据；View有某些操作，ViewModel就要响应这些操作，所以可以说是Model for View.</p> <p><strong>总结</strong>： MVVM 模式简化了界面与业务的依赖，解决了数据频繁更新；在使用当中，利用双向绑定技术，使得 Model 变化时，ViewModel 会自动更新，而 ViewModel 变化时，View 也会自动变化；</p> <p>补充B：</p> <p>ViewModel 是由前端开发人员组织生成和维护的视图数据层。在这一层，前端开发者对从后端获取的 Model 数据进行转换处理，做二次封装，以生成符合 View 层使用预期的视图数据模型。需要注意的是 ViewModel 所封装出来的数据模型包括视图的状态和行为两部分，而 Model 层的数据模型是只包含状态的，比如页面的这一块展示什么，而页面加载进来时发生什么，点击这一块发生什么，这一块滚动时发生什么这些都属于视图行为（交互），视图状态和行为都封装在了 ViewModel 里。这样的封装使得 ViewModel 可以完整地去描述 View 层。</p> <p>MVVM 框架实现了双向绑定，这样 ViewModel 的内容会实时展现在 View 层，前端开发者再也不必低效又麻烦地通过操纵 DOM 去更新视图，MVVM 框架已经把最脏最累的一块做好了，我们开发者只需要处理和维护 ViewModel，更新数据视图就会自动得到相应更新。这样 View 层展现的不是 Model 层的数据，而是 ViewModel 的数据，由 ViewModel 负责与 Model 层交互，这就完全解耦了 View 层和 Model 层，这个解耦是至关重要的，它是前后端分离方案实施的重要一环</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// View 层</span>
<span class="token operator">&lt;</span>div id<span class="token operator">=</span><span class="token string">&quot;app&quot;</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>p<span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token punctuation">{</span>message<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>button v<span class="token operator">-</span>on<span class="token operator">:</span>click<span class="token operator">=</span><span class="token string">&quot;showMessage()&quot;</span><span class="token operator">&gt;</span>Click me<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>

<span class="token comment">// ViewModel 层</span>
<span class="token keyword">var</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    el<span class="token operator">:</span> <span class="token string">'#app'</span><span class="token punctuation">,</span>
    data<span class="token operator">:</span> <span class="token punctuation">{</span>  <span class="token comment">// 用于描述视图状态   </span>
        message<span class="token operator">:</span> <span class="token string">'Hello Vue!'</span><span class="token punctuation">,</span> 
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    methods<span class="token operator">:</span> <span class="token punctuation">{</span>  <span class="token comment">// 用于描述视图行为  </span>
        <span class="token function">showMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">let</span> vm <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
            <span class="token function">alert</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">created</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">let</span> vm <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
        <span class="token comment">// Ajax 获取 Model 层的数据</span>
        <span class="token function">ajax</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
            url<span class="token operator">:</span> <span class="token string">'/your/server/data/api'</span><span class="token punctuation">,</span>
            <span class="token function">success</span><span class="token punctuation">(</span><span class="token parameter">res</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                vm<span class="token punctuation">.</span>message <span class="token operator">=</span> res<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// Model 层</span>
<span class="token punctuation">{</span>
    <span class="token string">&quot;url&quot;</span><span class="token operator">:</span> <span class="token string">&quot;/your/server/data/api&quot;</span><span class="token punctuation">,</span>
    <span class="token string">&quot;res&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token string">&quot;success&quot;</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
        <span class="token string">&quot;name&quot;</span><span class="token operator">:</span> <span class="token string">&quot;IoveC&quot;</span><span class="token punctuation">,</span>
        <span class="token string">&quot;domain&quot;</span><span class="token operator">:</span> <span class="token string">&quot;www.cnblogs.com&quot;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="x-4、使用例子"><a href="#x-4、使用例子" class="header-anchor">#</a> X-4、使用例子</h4> <h5 id="x-4-1、vue"><a href="#x-4-1、vue" class="header-anchor">#</a> X-4-1、Vue</h5> <img src="/Image/Basics/Special/Mode/214.png" align="" style="zoom:50%;"></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/docs/assets/js/app.cda475f7.js" defer></script><script src="/docs/assets/js/2.c902c426.js" defer></script><script src="/docs/assets/js/49.9d81175e.js" defer></script>
  </body>
</html>
