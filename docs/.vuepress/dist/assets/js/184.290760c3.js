(window.webpackJsonp=window.webpackJsonp||[]).push([[184],{505:function(_,v,e){"use strict";e.r(v);var n=e(4),l=Object(n.a)({},(function(){var _=this,v=_.$createElement,e=_._self._c||v;return e("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[e("h1",{attrs:{id:"三、模块机制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#三、模块机制"}},[_._v("#")]),_._v(" 三、模块机制")]),_._v(" "),e("p",[_._v("Node 借鉴 CommonJS 的 Modules 规范实现自身模块系统；")]),_._v(" "),e("h2",{attrs:{id:"_3-1、模块分类"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-1、模块分类"}},[_._v("#")]),_._v(" 3-1、模块分类")]),_._v(" "),e("h3",{attrs:{id:"_3-1-1、核心模块"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-1、核心模块"}},[_._v("#")]),_._v(" 3-1-1、核心模块")]),_._v(" "),e("p",[_._v("描述：由 Node 自身提供，其在源码编译时即被编译进二进制执行文件，当进程启动时便被直接加载进内存；")]),_._v(" "),e("p",[_._v("注意：因上述原因，此类模块的引入/文件定位/编译执行步骤均可忽略，而在路径分析中，其优先级更高，加载速度也更快；")]),_._v(" "),e("h3",{attrs:{id:"_3-1-2、文件模块"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-2、文件模块"}},[_._v("#")]),_._v(" 3-1-2、文件模块")]),_._v(" "),e("p",[_._v("用户提供的，运行时加载的，速度比核心慢，需经过3阶段：路径分析、文件定位、编译执行；")]),_._v(" "),e("h3",{attrs:{id:"_3-1-3、两者异同"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-3、两者异同"}},[_._v("#")]),_._v(" 3-1-3、两者异同")]),_._v(" "),e("p",[_._v("相同：引入的模块均会进行缓存 (缓存内容：编译 & 执行后的对象)，以减少二次引入时的开销；不同如下：")]),_._v(" "),e("ul",[e("li",[_._v("缓存检查优先度中，核心模块依然优先于文件模块；")]),_._v(" "),e("li",[_._v("文件模块无须将源代码编译进 Node，而是通过 "),e("code",[_._v("dlopen")]),_._v(" 方法动态加载；")]),_._v(" "),e("li",[_._v("文件模块在编写时无须将源代码写入 Node 命名空间，也无需提供头文件；")])]),_._v(" "),e("h2",{attrs:{id:"_3-2、模块路径分析"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-2、模块路径分析"}},[_._v("#")]),_._v(" 3-2、模块路径分析")]),_._v(" "),e("p",[_._v("模块标识符分析(require() 中的标识符参数分析)，基于此标识符进行模块查找；等同npm包路径分析；")]),_._v(" "),e("p",[_._v("核心模块：http、fs、path 等；")]),_._v(" "),e("ul",[e("li",[_._v("首先，路径优先级最高，其次是缓存；")]),_._v(" "),e("li",[_._v("其次，无需定位、无需编译，直接使用；")])]),_._v(" "),e("p",[_._v("文件模块：以点开始的相对路径文件模块 & 以斜杠开始的绝对路径文件模块；")]),_._v(" "),e("ul",[e("li",[_._v("首先，"),e("code",[_._v("require")]),_._v(" 会将其转为真实路径，并以此作为索引；")]),_._v(" "),e("li",[_._v("然后，根据模块路径查找策略定位文件，并进行编译；")]),_._v(" "),e("li",[_._v("随后，将编译后的执行结果存放在缓存，以便二次加载更快；")])]),_._v(" "),e("p",[_._v("自定模块：非路径形式的文件模块，形式为文件/包，比如自定义 connect 模块；")]),_._v(" "),e("ul",[e("li",[_._v("首先，根据模块路径查找策略定位文件；")]),_._v(" "),e("li",[_._v("注意：自定义模块均在文件最外层，故加载速度最慢 (除非写在当前文件的 "),e("code",[_._v("node_modules")]),_._v(" 中..)；")])]),_._v(" "),e("h3",{attrs:{id:"_3-2-1、模块路径形式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-1、模块路径形式"}},[_._v("#")]),_._v(" 3-2-1、模块路径形式")]),_._v(" "),e("p",[_._v("模块路径具体表现为由路径组成的数组；")]),_._v(" "),e("ul",[e("li",[_._v("生成方式：创建任意 JS 文件，内容为 "),e("code",[_._v("console.log(module.paths)")]),_._v("，然后 "),e("code",[_._v("node 目标文件.js")]),_._v(" 即可输出；")])]),_._v(" "),e("h3",{attrs:{id:"_3-2-2、模块查找策略"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-2、模块查找策略"}},[_._v("#")]),_._v(" 3-2-2、模块查找策略")]),_._v(" "),e("p",[_._v("加载过程中，Node 会逐个尝试模块路径中的路径，直到找到目标文件为止，路径越深，模块查找耗时越多；")]),_._v(" "),e("ul",[e("li",[e("u",[_._v("搜寻当前文件目录")]),_._v("下的 node_modules 目录；")]),_._v(" "),e("li",[e("u",[_._v("搜寻父级文件目录")]),_._v("下的 node_modules 目录；")]),_._v(" "),e("li",[e("u",[_._v("搜寻爷级文件目录")]),_._v("下的 node_modules 目录；")]),_._v(" "),e("li",[_._v("沿路径向上逐级递归，直至根目录下的 node_modules 目录；")])]),_._v(" "),e("h2",{attrs:{id:"_3-3、文件定位"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-3、文件定位"}},[_._v("#")]),_._v(" 3-3、文件定位")]),_._v(" "),e("p",[e("strong",[e("u",[e("em",[_._v("文件扩展分析：")])])])]),_._v(" "),e("p",[_._v("若不包含扩展名，则调用 fs 模块同步阻塞式判断文件是否存在，并按 "),e("code",[_._v(".js > .json > .node")]),_._v(" 顺序补足扩展名；")]),_._v(" "),e("ul",[e("li",[_._v("注意：因缓存优化策略，二次引入时无需路径分析、文件定位、编译执行等过程；")]),_._v(" "),e("li",[_._v("优化：对 node、json 文件，可在使用 require 时，顺带添加扩展名，以稍微提高速度；")])]),_._v(" "),e("p",[e("strong",[e("u",[e("em",[_._v("目录与包分析：")])])])]),_._v(" "),e("p",[_._v("若通过文件扩展名分析后，仍无法找到对应文件(或得到一目录<常见于自定义模块，逐个模块路径查找时>)，此时 Node 会将目录当作包来处理；")]),_._v(" "),e("ul",[e("li",[_._v("首先，在所在目录查找 "),e("code",[_._v("package.json")]),_._v("：\n"),e("ul",[e("li",[_._v("若有，则通过 "),e("code",[_._v("JSON.parse")]),_._v(" 解析出包描述对象，并取出 main 属性指定的文件名进行定位；\n"),e("ul",[e("li",[_._v("若缺少文件名扩展名，则进入文件扩展名分析流程；")]),_._v(" "),e("li",[_._v("若文件名错误，则将 index 作为默认文件名，依次查找 index.js、index.json、index.node；")])])]),_._v(" "),e("li",[_._v("若无，则将 index 作为默认文件名，依次查找 index.js、index.json、index.node；")])])]),_._v(" "),e("li",[_._v("最后，若还是没有成功定位任何文件，则继续查找下一个模块路径，直至路径数组遍历完毕，若依然没有找到，则向上抛出查找失败错误；")])]),_._v(" "),e("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200918140137.png",align:""}}),_._v(" "),e("h2",{attrs:{id:"_3-4、模块编译与导出"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-4、模块编译与导出"}},[_._v("#")]),_._v(" 3-4、模块编译与导出")]),_._v(" "),e("p",[_._v("编译后进行加载并导出，此节亦是 CommonJS 模块规范的 Node 实现")]),_._v(" "),e("p",[_._v("首先，编译过程中，Node 对获取到的 JS 文件，进行头尾包装，以实现每个模块文件的作用域隔离 ("),e("strong",[e("u",[e("em",[_._v("作用域隔离原理")])])]),_._v(")：")]),_._v(" "),e("ul",[e("li",[_._v("头部增加："),e("code",[_._v("(function(*exports*, *require*, *module*, *__filename*, *__dirname*){ \\n；")])]),_._v(" "),e("li",[_._v("尾部增加："),e("code",[_._v("\\n })")])])]),_._v(" "),e("p",[_._v("然后，通过执行 vm 原生模块的 "),e("code",[_._v("runInThisContext")]),_._v(" ，返回一个具体的 function 对象，并将当前模块的 exports、require、module(模块自身)、查找到的文件路径、文件目录作为参数传递此 function 执行；(require/exports/module 变量没有在模块中定义，却可在每个模块中存在的原因)；")]),_._v(" "),e("p",[_._v("最后，对象执行后，将模块 "),e("code",[_._v("exports")]),_._v(" 属性返回给调用方，此后属性上的方法 & 属性，均可被外部调用，但其余变量则不可直接调用；")]),_._v(" "),e("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200918140138.png",align:""}}),_._v(" "),e("h3",{attrs:{id:"_3-4-1、文件模块编译"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-4-1、文件模块编译"}},[_._v("#")]),_._v(" 3-4-1、文件模块编译")]),_._v(" "),e("p",[e("strong",[e("u",[e("em",[_._v("普通文件模块")])])])]),_._v(" "),e("ul",[e("li",[e("p",[_._v("首先，定位到具体文件后，新建模块对象；")])]),_._v(" "),e("li",[e("p",[_._v("然后，按照路径 & 文件扩展名载入并进行相应编译 (具体编译实现看核心模块的JS模块编译)：")]),_._v(" "),e("ul",[e("li",[e("code",[_._v(".js")]),_._v("：用 fs 模块同步读取，随后编译执行；")]),_._v(" "),e("li",[e("code",[_._v(".json")]),_._v(" ：用 fs 模块同步读取并用 "),e("code",[_._v("JSON.parse")]),_._v(" 解析，将结果赋给模块对象的 "),e("code",[_._v("exports")]),_._v(" 供外部调用；")]),_._v(" "),e("li",[e("code",[_._v(".node")]),_._v(" ：使用 dlopen 方法加载最后编译生成的文件；")]),_._v(" "),e("li",[e("code",[_._v(".else")]),_._v("  ：处理同 "),e("code",[_._v(".js")]),_._v(" 文件；")])])]),_._v(" "),e("li",[e("p",[_._v("最后，编译成功的模块，将其文件路径作为索引，在 "),e("code",[_._v("Module._cache")]),_._v(" 对象上缓存以提高二次导入性能；")])])]),_._v(" "),e("p",[e("strong",[e("u",[e("em",[_._v("特殊文件模块：C/C++ 模块")])])]),_._v("：即上述提到的 node 文件，用于提升性能与执行效率；")]),_._v(" "),e("ul",[e("li",[_._v("注意：使用 "),e("code",[_._v("dlopen")]),_._v(" 方法动态加载最后编译生成的文件；"),e("code",[_._v("dlopen")]),_._v(" 的实现因平台而不同，但均通过 libux 兼容层封装统一；")]),_._v(" "),e("li",[_._v("注意：实际上，node 文件是用 C/C++ 编写的扩展文件，经编译后生产，故无需编译，只需加载 & 执行；")]),_._v(" "),e("li",[_._v("注意：执行时，模块的 exports 与 .node 模块相关联，然后返回给调用者；")])]),_._v(" "),e("p",[e("strong",[e("u",[e("em",[_._v("特殊文件模块：C/C++扩展模块")])])])]),_._v(" "),e("ul",[e("li",[_._v("编写：与核心模块相比，无需编写如 node 命名空间，即 "),e("code",[_._v("namespace node { ..")])]),_._v(" "),e("li",[_._v("加载：仅通过 "),e("code",[_._v("process.dlopeen")]),_._v(" 动态加载；")])]),_._v(" "),e("h3",{attrs:{id:"_3-4-2、核心模块编译"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-4-2、核心模块编译"}},[_._v("#")]),_._v(" 3-4-2、核心模块编译")]),_._v(" "),e("p",[_._v("核心模块实际可分成 C/C++ 编写部分和 JS 编写两部分：")]),_._v(" "),e("p",[e("strong",[e("u",[e("em",[_._v("核心模块 JS 编写部分：")])])])]),_._v(" "),e("ul",[e("li",[e("p",[_._v("存储：在 lib 目录；")])]),_._v(" "),e("li",[e("p",[_._v("转换：使用 V8 的 "),e("code",[_._v("js2c.py")]),_._v(" 工具，将 JS 代码 ("),e("code",[_._v("src/node.js & lib/*.js")]),_._v(") 转换成 C++ 数组，生成 "),e("code",[_._v("node_natives.h")]),_._v(" 文件，并存储在 "),e("code",[_._v("NativeModule._source")]),_._v(" 中；")]),_._v(" "),e("ul",[e("li",[_._v("首先，通过 "),e("code",[_._v("process.binding(‘natives’)")]),_._v(" 取出上述通过 "),e("code",[_._v("js2c.py")]),_._v(" 转换的字符串数组，并将其重新转为普通字符串；")]),_._v(" "),e("li",[_._v("然后，进行头尾包装以导出 "),e("code",[_._v("export")]),_._v(" 对象；")]),_._v(" "),e("li",[_._v("最后，编译成功的模块，将其文件路径作为索引，缓存在 "),e("code",[_._v("NativeModule._cache")]),_._v(" 对象上；")]),_._v(" "),e("li",[_._v("注意：转换 JS 码时，JS 代码以字符串形式，存储在 node 命名空间中，不可直接执行；")]),_._v(" "),e("li",[_._v("注意：核心模块需编译，而文件模块还需进行路径分析、文件定位；")]),_._v(" "),e("li",[_._v("注意：文件模块缓存中在 "),e("code",[_._v("Module._cache")]),_._v(" 对象中；")]),_._v(" "),e("li",[_._v("注意：当 Node 进程启动时，JS 代码将直接加载进内存JS 核心模块经标识符分析后直接定位到内存；")])])])]),_._v(" "),e("p",[e("strong",[e("u",[e("em",[_._v("核心模块 C/C++ 编写部分：")])])])]),_._v(" "),e("ul",[e("li",[e("p",[_._v("存储：在 src 目录；")])]),_._v(" "),e("li",[e("p",[_._v("转换：因原本即用 C/C++ 编写，随后又被编译成二进制文件，故无需再转换；")]),_._v(" "),e("ul",[e("li",[_._v("注意：当 Node 进程启动时，便被直接加载进内存，无需定位、分析、编译等步骤，直接可执行；")])])]),_._v(" "),e("li",[e("p",[_._v("协助加载：在 Node 启动过程中，还会生成全局变量 "),e("code",[_._v("process")]),_._v("，其提供 "),e("code",[_._v("Binding")]),_._v(" 方法协助加载；")])]),_._v(" "),e("li",[e("p",[_._v("真正加载：此时，会先构建 "),e("code",[_._v("exports")]),_._v(" 对象，调用 "),e("code",[_._v("get_builtin_module")]),_._v(" 方法取出模块，执行 "),e("code",[_._v("register_func")]),_._v(" 填充 "),e("code",[_._v("exports")]),_._v(" 对象，最后 "),e("code",[_._v("exports")]),_._v(" 对象按模块名缓存，并返回给调用方完成导出；")])])]),_._v(" "),e("h2",{attrs:{id:"_3-x、npm"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-x、npm"}},[_._v("#")]),_._v(" 3-X、NPM")]),_._v(" "),e("p",[_._v("为何讲 NPM，因为 NPM 依赖于 Node，尤其是它的模块寻找机制，个人认为它是最出色的 Node 产品…(每天/项目都要用)；")]),_._v(" "),e("h3",{attrs:{id:"_3-x-1、基本"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-x-1、基本"}},[_._v("#")]),_._v(" 3-X-1、基本")]),_._v(" "),e("p",[_._v("基本：现有的、最大的包管理系统：node package manager；")]),_._v(" "),e("p",[_._v("命令：save/-S：会将下载的依赖包，放到  “dependencies” 中，产品上线 & 线下开发均需用到；")]),_._v(" "),e("p",[_._v("命令：--save-dev/-D：会将下载的依赖包，放到 “devDependencies” 中，仅线下开发用到；")]),_._v(" "),e("p",[_._v("配置：切换npm镜像地址为国内：mac：npm config set registry "),e("a",{attrs:{href:"https://registry.npm.taobao.org/",target:"_blank",rel:"noopener noreferrer"}},[_._v("https://registry.npm.taobao.org"),e("OutboundLink")],1)]),_._v(" "),e("p",[_._v("地址：npm 的 registry：")]),_._v(" "),e("ul",[e("li",[_._v("Mac： "),e("code",[_._v("~ 下的文件 .npmrc")])]),_._v(" "),e("li",[_._v("Windows： "),e("code",[_._v("C:\\Program Files\\nodejs\\node_modules\\npm\\npmrc")])])]),_._v(" "),e("p",[_._v("查看：查看配置成功与否：npm config list & npm config get registry")]),_._v(" "),e("p",[_._v("区别：cnpm 与配置淘宝镜像区别：如下图")]),_._v(" "),e("ul",[e("li",[_._v("cnpm：经过阿里云 CDN 读取阿里云 npm 包缓存服务器，此服务器又通过别的 NgInx 服务器通过七牛 CDN 获取位于新加坡服务器上 npm包数据；")]),_._v(" "),e("li",[_._v("淘宝镜像：经过 Nginx 服务器访问淘宝 npm 包缓存服务器，此服务器又通过别的 NgInx 服务器通过七牛 CDN 获取位于新加坡服务器上 npm 包数据；")]),_._v(" "),e("li",[_._v("总结：整个流程是从新加坡服务器获取 npm 包内容(翻墙)，然后通过 CDN 优化以实现快速下载的效果；")])]),_._v(" "),e("p",[_._v("更新：注意不要使用 sudo 全局安装或更新；")]),_._v(" "),e("p",[e("img",{attrs:{src:"https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20201006161827.png",alt:"截屏2020-10-06 下午4.18.24"}})]),_._v(" "),e("h3",{attrs:{id:"_3-x-2、package"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-x-2、package"}},[_._v("#")]),_._v(" 3-X-2、Package")]),_._v(" "),e("p",[e("strong",[e("u",[_._v("包种类：")])])]),_._v(" "),e("p",[e("code",[_._v("npm install <package>")]),_._v(" 中的 package 的定义有9种，诸如压缩包、url 和已发布的包；"),e("a",{attrs:{href:"https://docs.npmjs.com/about-packages-and-modules",target:"_blank",rel:"noopener noreferrer"}},[_._v("更多"),e("OutboundLink")],1)]),_._v(" "),e("p",[e("strong",[e("u",[_._v("包安装：")])])]),_._v(" "),e("ul",[e("li",[e("p",[e("a",{attrs:{href:"http://www.ruanyifeng.com/blog/2016/01/npm-install.html",target:"_blank",rel:"noopener noreferrer"}},[_._v("离线包安装"),e("OutboundLink")],1),_._v("："),e("a",{attrs:{href:"https://addyosmani.com/blog/using-npm-offline/",target:"_blank",rel:"noopener noreferrer"}},[_._v("文章2"),e("OutboundLink")],1)])]),_._v(" "),e("li",[e("p",[_._v("本地包安装：即将频繁使用的模块封装成包来使用，并非塞入node_module而是通过创建软链使用："),e("a",{attrs:{href:"https://medium.com/@arnaudrinquin/build-modular-application-with-npm-local-modules-dfc5ff047bcc",target:"_blank",rel:"noopener noreferrer"}},[_._v("极好文章"),e("OutboundLink")],1),_._v("，步骤：")]),_._v(" "),e("ul",[e("li",[_._v("首先，根目录新建 config 文件夹、其中新建 index.js、再新建 package.json 并作基本定义；")]),_._v(" "),e("li",[_._v("然后，根目录执行 npm install file:./config")]),_._v(" "),e("li",[_._v("此时，会在 node_modules 目录下多出 config模块，指向上层 config/文件夹的软链；")]),_._v(" "),e("li",[_._v("如此，可显式将依赖信息固化到 dependencies 字段中，开发团队其他成员亦可执行 npm install 后直接使用；")])])]),_._v(" "),e("li",[e("p",[_._v("未正式发布的私有依赖包安装，步骤：")]),_._v(" "),e("ul",[e("li",[_._v("首先，将包放到仓库后，直接 npm + url 安装：")]),_._v(" "),e("li",[_._v("比如，"),e("code",[_._v("<protocol>://[<user>[:<password>]@]<hostname>[:<port>][:][/]<path>[#<commit-ish> | #semver:<semver>]（#后缀跟别名）")])])])]),_._v(" "),e("li",[e("p",[_._v("有问题不能及时更新/已不再维护的开源包，步骤：")]),_._v(" "),e("ul",[e("li",[_._v("首先，fork 到仓库；")]),_._v(" "),e("li",[_._v("然后，修复后通过 npm url 安装；")])])])]),_._v(" "),e("p",[e("strong",[e("u",[_._v("包规范：")])])]),_._v(" "),e("p",[_._v("包的命名管理采用规范："),e("a",{attrs:{href:"https://semver.org/lang/zh-CN/",target:"_blank",rel:"noopener noreferrer"}},[_._v("semver语义化版本规范"),e("OutboundLink")],1)]),_._v(" "),e("p",[_._v("版本号：须包含3个数字、格式须为 "),e("code",[_._v("MAJOR.MINOR.PATCH（主版本号.次版本号.修订号）")])]),_._v(" "),e("ul",[e("li",[_._v("比如：1.15.2 => 1：marjor version、15：minor version、2：patch version；")]),_._v(" "),e("li",[_._v("MAJOR：大版本号迭代，做了不兼容之前版本的大更改；")]),_._v(" "),e("li",[_._v("MINOR：小版本迭代，增添了新功能，做了向下兼容；")]),_._v(" "),e("li",[_._v("PATCH：修订版本迭代，修复了 Bug，做了向下兼容；")])]),_._v(" "),e("p",[_._v("建议事项：")]),_._v(" "),e("ul",[e("li",[e("p",[_._v("使用：使用 npm: >=5.1 版本；")])]),_._v(" "),e("li",[e("p",[_._v("开启：package-lock.json 开关；")])]),_._v(" "),e("li",[e("p",[_._v("禁止：手动修改 package-lock.json")])]),_._v(" "),e("li",[e("p",[_._v("命名：长度需大于0且不超过214，并要求：可由连字符组成，所有字符均须小写；")]),_._v(" "),e("ul",[e("li",[_._v("注意：不应以 . or _ 开头、不应包含任何前导或尾随空格、不应包含以下任何字符: ~)(‘!*")]),_._v(" "),e("li",[_._v("注意：不得与node.js / io.js核心模块相同、不能保留/黑名单名称、不能包含任何non-url-safe字符(因名称最终成为URL的一部分)")]),_._v(" "),e("li",[_._v("比如：非法名称：http、stream、node_modules、favicon.ico")])])])]),_._v(" "),e("p",[e("strong",[e("u",[_._v("包管理：")])])]),_._v(" "),e("p",[_._v("安装：")]),_._v(" "),e("ul",[e("li",[_._v("安装当前版本的最新 major 版本：^\n"),e("ul",[e("li",[_._v("比如：bluebird：^3.3.4，匹配最新 3.x.x；")])])]),_._v(" "),e("li",[_._v("安装当前版本的最新 minor 版本：~\n"),e("ul",[e("li",[_._v("比如：body-parser：~1.15.2，匹配更新 1.15.x；")])])])]),_._v(" "),e("p",[_._v("删除：")]),_._v(" "),e("ul",[e("li",[_._v("方式一：")]),_._v(" "),e("li",[e("code",[_._v("npm uninstall <package>")]),_._v(" ，提交 package.json 和 package-lock.json；")]),_._v(" "),e("li",[_._v("方式二：删除 package.json - dependencies 欲卸载包字段；执行 npm install 并提交；")])]),_._v(" "),e("p",[_._v("升级：")]),_._v(" "),e("ul",[e("li",[_._v("小版本升级：本地执行 npm update 升级到新的小版本；")]),_._v(" "),e("li",[_._v("大版本升级：本地执行 "),e("code",[_._v("npm install <package-name>@<version>")]),_._v(" 升级到新的大版本(推荐)；")]),_._v(" "),e("li",[_._v("大版本升级：上述手动修改：升级package.json 中版本号，并 npm install；")]),_._v(" "),e("li",[_._v("验证升级后：提交新的 package.json, package-lock.json 文件；")])]),_._v(" "),e("p",[_._v("降级:")]),_._v(" "),e("ul",[e("li",[_._v("正确：首先，"),e("code",[_._v("npm install <package-name>@<old-version>")]),_._v("；然后，验证无问题后提交；")]),_._v(" "),e("li",[_._v("错误：手动修改 package.json 中版本号为更低版本的 semver 并不会生效！原因：再次 install 会安装 package-lock.json 中锁定版本；")])]),_._v(" "),e("h3",{attrs:{id:"_3-x-3、npm-init"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-x-3、npm-init"}},[_._v("#")]),_._v(" 3-X-3、NPM Init")]),_._v(" "),e("p",[_._v("基本：初始化，并附带询问字段，可通过 npm init --yes 跳过；")]),_._v(" "),e("p",[_._v("注意：询问字段可自定义：home 目录下新建 .npm-init.js，结合 promt 和 module.export 可自定义，不限于生成 package.json；")]),_._v(" "),e("h3",{attrs:{id:"_3-x-4、npm-install"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-x-4、npm-install"}},[_._v("#")]),_._v(" 3-X-4、NPM Install")]),_._v(" "),e("p",[e("strong",[e("u",[_._v("npm2：")])])]),_._v(" "),e("ul",[e("li",[_._v("原理：使用递归安装，简单粗暴，发现模块依赖后，直接在模块层级新建 node_module 安装，以此类推；")]),_._v(" "),e("li",[_._v("优点：层级结构明显，便于管理 (可直接在 node_module & package.json 修改以手动增添包、保证了对依赖包无论是安装还是删除都会有统一的行为和结构)、简单的(但粗暴野蛮的)实现了多版本兼容")]),_._v(" "),e("li",[_._v("问题1：嵌套太深 (此外window下有文件路径长度限制，而嵌套太深会导致bug)；")]),_._v(" "),e("li",[_._v("问题2：相同模块大量冗余(重复安装)")])]),_._v(" "),e("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20201006162940.png",alt:"截屏2020-10-06 下午4.29.35"}}),_._v(" "),e("p",[e("strong",[e("u",[_._v("npm3：")])])]),_._v(" "),e("p",[_._v("原理：递归安装，但新增以下特性，解决上述 npm2 的2个问题：")]),_._v(" "),e("ul",[e("li",[e("p",[_._v("扁平化：相同模块会被提升至顶层(随后借助 node 寻路机制正确寻址—即逐级向上寻址)，从而解决代码冗余问题，并缓解过深嵌套(若依赖包版本并不重复时并不会提升)；")])]),_._v(" "),e("li",[e("p",[_._v("算法优化：安装时遍历整个依赖树，计算出最合理文件夹安装方式，使所有被重复依赖的包均可去重安装；")]),_._v(" "),e("ul",[e("li",[_._v("比如：遇到新包则将其安装在1级目录，后续安装时，若遇到1级目录中已存在的包，则会先按照版本约定判断，若版本相符则忽略，否则按照npm 2.x方式依次挂在依赖包目录下，此时会有如示例2的问题(因只判读1级目录，而这种简单的判断机制在会因模块的安装次序发生问题)；")])])]),_._v(" "),e("li",[e("p",[_._v("缺点：此时 npm 依赖树结构，不再与文件夹层级一一对应，不便于管理，(npm设计初衷：负责包管理)；")])]),_._v(" "),e("li",[e("p",[_._v("注意：模块的安装次序决定了node_modules中的目录结构，npm会优先将模块安装在根目录下的node_modules中；")])])]),_._v(" "),e("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20201006163008.png",alt:"截屏2020-10-06 下午4.30.05"}}),_._v(" "),e("p",[e("strong",[e("u",[_._v("npm5：")])])]),_._v(" "),e("p",[_._v("原理：同上，但又解决一问题：因 semver range 管理机制下包不对应问题，增加 package-lock.json 文件(也是最大的变化)："),e("a",{attrs:{href:"https://medium.com/coinmonks/everything-you-wanted-to-know-about-package-lock-json-b81911aa8ab8",target:"_blank",rel:"noopener noreferrer"}},[_._v("详看1"),e("OutboundLink")],1),_._v("、"),e("a",{attrs:{href:"https://docs.npmjs.com/files/package-lock.json",target:"_blank",rel:"noopener noreferrer"}},[_._v("详看2"),e("OutboundLink")],1)]),_._v(" "),e("p",[_._v("作用：锁定依赖安装结构，使内容结构 与 node_modules 目录文件层级结构一一对应（实际上是其中的 dependencies 字段内容）；")]),_._v(" "),e("ul",[e("li",[e("p",[_._v("记录 node_modules 中所有包的结构、层级、版本号、安装源，即保存 node_module 状态；")])]),_._v(" "),e("li",[e("p",[_._v("意即：结合逻辑树与物理树的一个快照(snapshot)、里面有明确的各依赖版本号，实际安装的结构，也有逻辑树的结构，")])])]),_._v(" "),e("p",[_._v("好处：能可重复的构建 (repeatable build)；")]),_._v(" "),e("ul",[e("li",[e("p",[_._v("比如：当你在CI（持续集成）上重复build的时候，得到的artifact是一样的，因为依赖的版本都被锁住了；")])]),_._v(" "),e("li",[e("p",[_._v("注意：npm5-已有相同作用文件："),e("a",{attrs:{href:"https://docs.npmjs.com/cli/shrinkwrap",target:"_blank",rel:"noopener noreferrer"}},[_._v("npm-shrinkwrap.json"),e("OutboundLink")],1),_._v("；但须手动生成，而在 npm5 后，其内容和 npm-shrinkwrap.json一模一样；")])]),_._v(" "),e("li",[e("p",[_._v("补充：package.json，定义的依赖关系树，可以称之为逻辑树(logical tree)；")])]),_._v(" "),e("li",[e("p",[_._v("补充：node_modules 文件夹，npm 实际安装的确定版本的东西，这里面的文件夹结构可称之为物理树(physical tree)，当然安装过程中有一些去重算法，故逻辑树结构和物理树结构不完全一样；")])])]),_._v(" "),e("p",[_._v("问题：")]),_._v(" "),e("ul",[e("li",[e("p",[_._v("锁定了旧状态，手动在 package.json 新增依赖并 install 后并不会安装，lock 也不会更新 (已在5.1中修复)")])]),_._v(" "),e("li",[e("p",[_._v("禁用：禁用 package-locak.json：npm config set package-lock false")])])]),_._v(" "),e("h4",{attrs:{id:"_3-x-4-1、安装机制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-x-4-1、安装机制"}},[_._v("#")]),_._v(" 3-X-4-1、安装机制")]),_._v(" "),e("p",[_._v("首先，发出 npm install 命令")]),_._v(" "),e("p",[_._v("然后，查询 node_modules 目录中是否已经存在指定模块")]),_._v(" "),e("ul",[e("li",[_._v("若存在，不再重新安装")]),_._v(" "),e("li",[_._v("若不存\n"),e("ul",[e("li",[_._v("npm 向 registry 查询模块压缩包的网址；")]),_._v(" "),e("li",[_._v("下载压缩包，存放在 ~/.npm 目录；")]),_._v(" "),e("li",[_._v("解压压缩包到当前项目的node_modules目录；")])])])]),_._v(" "),e("p",[_._v("流程：")]),_._v(" "),e("ul",[e("li",[_._v("首先，执行 npm install 时，会分析每个依赖包的 package.json 中的 bin 字段，并将其包含的条目，")]),_._v(" "),e("li",[_._v("然后，安装到 "),e("code",[_._v("./node_modules/.bin")]),_._v(" 目录中，文件名为 "),e("code",[_._v("<command>")]),_._v("；")]),_._v(" "),e("li",[_._v("注意，若是全局 npm install，则会在 npm 全局安装路径的 bin 目录下，创建指向 "),e("code",[_._v("<file>")]),_._v(" 名为 "),e("code",[_._v("<command>")]),_._v(" 的软链；")]),_._v(" "),e("li",[_._v("所以，执行 "),e("code",[_._v("./node_modules/.bin/webpack")]),_._v(" 命令时，实际上是在执行 "),e("code",[_._v("node ./node_modules/.bin/webpack.js")]),_._v(" 命令；")])]),_._v(" "),e("p",[_._v("建议：")]),_._v(" "),e("ul",[e("li",[_._v("将项目依赖的命令行工具安装在项目依赖文件夹，而非全局安装；")]),_._v(" "),e("li",[_._v("再通过 npm script 调用，减少因各项目版本依赖的不同而报错；")])]),_._v(" "),e("p",[e("img",{attrs:{src:"https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20201006165350.png",alt:"截屏2020-10-06 下午4.53.47"}})]),_._v(" "),e("h4",{attrs:{id:"_3-x-4-2、安装原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-x-4-2、安装原理"}},[_._v("#")]),_._v(" 3-X-4-2、安装原理")]),_._v(" "),e("ul",[e("li",[_._v("首先，执行工程自身 preinstall 钩子：\n"),e("ul",[e("li",[_._v("前提，当前 npm 工程定义了 preinstall 钩子则会执行；")]),_._v(" "),e("li",[_._v("注意：此属于 npm 早期设计时不足，现已给出废弃提示，但仍会运行：scripts | npm Documentation；")])])]),_._v(" "),e("li",[_._v("然后，确定工程中首层依赖模块：\n"),e("ul",[e("li",[_._v("意即：dependencies & devDependencies 属性中，直接指定的模块；")]),_._v(" "),e("li",[_._v("工程：即整棵依赖树根节点，每个首层依赖模块均为根节点下的子树，npm 会开启多进程，从每个首层依赖模块开始，逐步寻找更深层级的节点；")])])]),_._v(" "),e("li",[_._v("然后，递归获取模块：\n"),e("ul",[e("li",[_._v("步骤1：获取模块信息：详看：https://semver.npmjs.com/；\n"),e("ul",[e("li",[_._v("首先，分别从 npm-shrinkwrap.json / package-lock.json 文件查找，以便确定真实版本(因 package.json 中往往是 semantic 版本)；")]),_._v(" "),e("li",[_._v("如果，找不到则从仓库获取符合形式的最新版本，比如 package.json 中为 ^1.1.0 则远端仓库获取时取符合的 1.x.x；")])])]),_._v(" "),e("li",[_._v("步骤2：获取模块实体：\n"),e("ul",[e("li",[_._v("根据从步1，获取模块压缩包地址 (resolved 字段)，检查本地缓存，若有则获取，无则从仓库下载；")])])]),_._v(" "),e("li",[_._v("步骤3：查找该模块依赖：若有依赖则回到步1，若无则停止；")])])]),_._v(" "),e("li",[_._v("然后，模块扁平化（dedupe）详看：https://docs.npmjs.com/cli/install\n"),e("ul",[e("li",[_._v("原因：上一步获取到的，很可能是冗余度非常高的依赖树；")]),_._v(" "),e("li",[_._v("步骤1：遍历所有节点，逐个将模块放在根节点下面 (即 node-modules 1层)；")]),_._v(" "),e("li",[_._v("步骤2：若有重复模块则将其丢弃，以降低冗余度；")]),_._v(" "),e("li",[_._v("注意：子模块此时仍能调取得到依赖包；\n"),e("ul",[e("li",[_._v("原因：是借助了 Node 的寻找依赖算法，首先寻找自身目录，再寻找项目目录；")]),_._v(" "),e("li",[_._v("比如：N/A 依赖于 B，此时首先会寻找 N/A/N/B，若无则会寻找 N/B；")])])]),_._v(" "),e("li",[_._v("注意：重复模块并非单纯指模块名相同，而是名同且 semver 兼容；\n"),e("ul",[e("li",[_._v("原因：每个 semver 都对应一段版本允许范围；")]),_._v(" "),e("li",[_._v("如果：两模块版本允许范围存在交集，则可得到一个兼容版本而不必版本号完全一致；")])])])])]),_._v(" "),e("li",[_._v("然后，安装模块并更新\n"),e("ul",[e("li",[_._v("安装、更新工程中 node_modules、执行模块生命周期函数 (按照 preinstall、install、postinstall 的顺序)；")])])]),_._v(" "),e("li",[_._v("最后，执行工程自身生命周期\n"),e("ul",[e("li",[_._v("如果，有则执行 npm 定义钩子 (按照 install、postinstall、prepublish、prepare 的顺序)；")]),_._v(" "),e("li",[_._v("最后，生成/更新版本描述文件；")])])]),_._v(" "),e("li",[_._v("总结：进入生命周期(确定依赖，递归获取-缓存-远端，模块扁平化，安装更新)")])]),_._v(" "),e("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20201006165241.png",alt:"截屏2020-10-06 下午4.52.37"}})])}),[],!1,null,null,null);v.default=l.exports}}]);