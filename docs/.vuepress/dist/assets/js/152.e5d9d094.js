(window.webpackJsonp=window.webpackJsonp||[]).push([[152],{517:function(_,t,v){"use strict";v.r(t);var s=v(4),e=Object(s.a)({},(function(){var _=this,t=_.$createElement,v=_._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h1",{attrs:{id:"四、异步机制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#四、异步机制"}},[_._v("#")]),_._v(" 四、异步机制")]),_._v(" "),v("p",[_._v("Node 中阻塞IO与异步IO的实现：")]),_._v(" "),v("ul",[v("li",[_._v("阻塞和非阻塞 I/O 其实是针对操作系统内核而言：\n"),v("ul",[v("li",[_._v("阻塞 I/O："),v("strong",[v("u",[_._v("一定要等到操作系统完成所有操作后才表示调用结束")])]),_._v("；")]),_._v(" "),v("li",[_._v("非阻塞 I/O："),v("strong",[v("u",[_._v("调用后立马返回不等操作系统内核完成操作")])]),_._v("；")])])]),_._v(" "),v("li",[_._v("Node 的异步 I/O 采用多线程的方式，由 "),v("code",[_._v("EventLoop")]),_._v("、"),v("code",[_._v("I/O 观察者")]),_._v("，"),v("code",[_._v("请求对象")]),_._v("、"),v("code",[_._v("线程池")]),_._v("四大要素相互配合，共同实现；")])]),_._v(" "),v("h2",{attrs:{id:"_4-1、i-o"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-1、i-o"}},[_._v("#")]),_._v(" 4-1、I/O")]),_._v(" "),v("p",[v("strong",[v("u",[_._v("I/O 即 Input/Output")])]),_._v("；在浏览器端，只有一种 I/O(网络I/O)，即利用 Ajax 发送网络请求，然后读取返回的内容；而 Node 则有相对广泛的 I/O 的场景：")]),_._v(" "),v("ul",[v("li",[v("strong",[v("u",[_._v("文件 I/O")])]),_._v("：比如用 fs 模块对文件进行读写操作；")]),_._v(" "),v("li",[v("strong",[v("u",[_._v("网络 I/O")])]),_._v("：比如用 http 模块发起网络请求；")])]),_._v(" "),v("h2",{attrs:{id:"_4-2、阻塞和非阻塞i-o"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-2、阻塞和非阻塞i-o"}},[_._v("#")]),_._v(" 4-2、阻塞和非阻塞I/O")]),_._v(" "),v("p",[_._v("阻塞和非阻塞 I/O 其实是针对操作系统内核而言：")]),_._v(" "),v("ul",[v("li",[_._v("阻塞 I/O："),v("strong",[v("u",[_._v("一定要等到操作系统完成所有操作后才表示调用结束")])]),_._v("；")]),_._v(" "),v("li",[_._v("非阻塞 I/O："),v("strong",[v("u",[_._v("调用后立马返回不等操作系统内核完成操作")])]),_._v("；")])]),_._v(" "),v("p",[_._v("使用前者，在操作系统进行 I/O 操作过程中，应用程序实际一直处于等待状态；")]),_._v(" "),v("p",[_._v("使用后者，调用返回后 Node 应用程序可完成其他事情，而系统同时也在进行 I/O，充分利用等待时间，提高执行效率，但应用无法得知系统已完成 I/O 操作；")]),_._v(" "),v("p",[_._v("为让 Node 获悉操作系统已做完 I/O 操作，需要重复地去操作系统那里判断是否完成，这种重复判断的方式就是 "),v("strong",[v("u",[_._v("轮询")])]),_._v("，方案如下：")]),_._v(" "),v("ul",[v("li",[_._v("一直轮询检查I/O状态，直到 I/O 完成；"),v("strong",[v("u",[_._v("最原始的方式性能也最低")])]),_._v("，会让 CPU 一直耗用在等待上，效果等同于阻塞 I/O；")]),_._v(" "),v("li",[_._v("遍历 "),v("u",[_._v("文件描述符")]),_._v(" 来确定 I/O 是否完成，I/O 完成则 "),v("u",[_._v("文件描述符")]),_._v(" 的状态改变，缺点是 CPU 轮询消耗还是很大；\n"),v("ul",[v("li",[_._v("补充：文件描述符： 即 文件I/O 时操作系统与 Node 间的文件凭证；")])])]),_._v(" "),v("li",[_._v("epoll模式：即进入轮询时，若 I/O 未完成CPU就休眠，完成后再唤醒 CPU；")])]),_._v(" "),v("p",[v("strong",[v("u",[_._v("现实是：CPU要么重复检查I/O，要么重复检查文件描述符，要么休眠，均无高效利用；理想是：Node 应用发起 I/O 调用后，可直接去执行别的逻辑，操作系统默默地做完 I/O 后，给 Node 发送完成信号，Node 执行回调操作")])]),_._v("；")]),_._v(" "),v("h2",{attrs:{id:"_4-3、异步-i-o-本质"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-3、异步-i-o-本质"}},[_._v("#")]),_._v(" 4-3、异步 I/O 本质")]),_._v(" "),v("p",[_._v("上述理想般的实现，其实在 Linux 已原生实现—AIO，但两个致命缺陷:")]),_._v(" "),v("ul",[v("li",[_._v("只有 Linux 下存在，其他系统中没有异步 I/O 支持；")]),_._v(" "),v("li",[_._v("无法利用系统缓存；")])]),_._v(" "),v("h2",{attrs:{id:"_4-4、node-异步-i-o-实现"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-4、node-异步-i-o-实现"}},[_._v("#")]),_._v(" 4-4、Node 异步 I/O 实现")]),_._v(" "),v("p",[v("strong",[v("u",[_._v("上述情况单线程无解，但多线程可实现；所以可以让一个进程进行计算操作，另外一些进行 I/O 调用，当 I/O 完成后将信号传给计算的线程，进而执行回调；所以，异步 I/O 就是使用这样的线程池来实现；")])])]),_._v(" "),v("h3",{attrs:{id:"_4-4-1、系统支持"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-4-1、系统支持"}},[_._v("#")]),_._v(" 4-4-1、系统支持")]),_._v(" "),v("p",[_._v("只是在不同的系统下面表现会有所差异：")]),_._v(" "),v("ul",[v("li",[_._v("在 Linux 下可直接使用线程池来完成；")]),_._v(" "),v("li",[_._v("在 Window 下则采用 IOCP 这个系统 API (内部还是用线程池完成)；")])]),_._v(" "),v("p",[_._v("有了操作系统的支持，那 nodejs 如何来对接这些操作系统从而实现异步 I/O 呢？")]),_._v(" "),v("h3",{attrs:{id:"_4-4-2、libuv-兼容统一"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-4-2、libuv-兼容统一"}},[_._v("#")]),_._v(" 4-4-2、libuv 兼容统一")]),_._v(" "),v("p",[_._v("以文件 I/O 为例：")]),_._v(" "),v("div",{staticClass:"language-js extra-class"},[v("pre",{pre:!0,attrs:{class:"language-js"}},[v("code",[v("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("let")]),_._v(" fs "),v("span",{pre:!0,attrs:{class:"token operator"}},[_._v("=")]),_._v(" "),v("span",{pre:!0,attrs:{class:"token function"}},[_._v("require")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("(")]),v("span",{pre:!0,attrs:{class:"token string"}},[_._v("'fs'")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(")")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(";")]),_._v("\n\nfs"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(".")]),v("span",{pre:!0,attrs:{class:"token function"}},[_._v("readFile")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("(")]),v("span",{pre:!0,attrs:{class:"token string"}},[_._v("'/test.txt'")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(",")]),_._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("function")]),_._v(" "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("(")]),v("span",{pre:!0,attrs:{class:"token parameter"}},[_._v("err"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(",")]),_._v(" data")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(")")]),_._v(" "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("{")]),_._v("\n    console"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(".")]),v("span",{pre:!0,attrs:{class:"token function"}},[_._v("log")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("(")]),_._v("data"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(")")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(";")]),_._v(" \n"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("}")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(")")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(";")]),_._v("\n")])])]),v("p",[v("strong",[_._v("Node 执行代码的大致过程：")])]),_._v(" "),v("ul",[v("li",[_._v("首先，fs.readFile 调用 Node 核心模块 fs.js ；")]),_._v(" "),v("li",[_._v("然后，Node "),v("u",[_._v("核心模块调用内建模块")]),_._v(" node_file.cc，创建对应的文件 "),v("strong",[v("u",[_._v("I/O观察者对象")])])]),_._v(" "),v("li",[_._v("最后，根据不同平台，"),v("u",[_._v("内建模块")]),_._v(" 通过 "),v("strong",[v("u",[_._v("libuv 中间层")])]),_._v(" 进行系统调用(此处是利用 uv_fs_open()  实现)；")])]),_._v(" "),v("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200918140139.png"}}),_._v(" "),v("p",[v("strong",[_._v("libuv 的 uv_fs_open 进行系统调用的大致过程：")])]),_._v(" "),v("ul",[v("li",[_._v("首先，创建请求对象")])]),_._v(" "),v("p",[_._v("以 Windows 为例，在函数 uv_fs_open 的调用过程中，创建了一个 "),v("u",[_._v("文件I/O的")]),_._v(" "),v("strong",[v("u",[_._v("请求对象")])]),_._v("，并往里面注入了回调函数。")]),_._v(" "),v("div",{staticClass:"language-c++ extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[_._v("req_wrap->object_->Set(oncomplete_sym, callback);\n// req_wrap 即请求对象，req_wrap 中 object_ 的 oncomplete_sym 属性对应的值便是 Node 应用代码中传入的回调函数\n")])])]),v("ul",[v("li",[_._v("然后，推入线程池，调用返回")])]),_._v(" "),v("p",[_._v("上述请求对象包装完成后，"),v("code",[_._v("QueueUserWorkItem()")]),_._v(" 方法将此对象推进线程池中等待执行；")]),_._v(" "),v("p",[v("strong",[_._v("至此，现在 JS 的调用即直接返回，"),v("u",[_._v("JS 应用代码")]),_._v("可 "),v("u",[_._v("继续往下执行")]),_._v("；同时当前 "),v("u",[_._v("I/O 操作")]),_._v(" "),v("u",[_._v("也在线程池中将被执行")]),_._v("；异步目的实现；")])]),_._v(" "),v("ul",[v("li",[_._v("最后，回调通知\n"),v("ul",[v("li",[_._v("首先，当对应线程中的 I/O 完成后，会将获得的结果 "),v("u",[_._v("存储")]),_._v(" 起来，保存到  "),v("u",[v("strong",[_._v("相应的请求对象")])]),_._v(" 中；")]),_._v(" "),v("li",[_._v("然后调用 "),v("code",[_._v("PostQueuedCompletionStatus()")]),_._v(" 向 "),v("u",[_._v("IOCP")]),_._v(" 提交执行完成的状态，并将线程归还给系统；")]),_._v(" "),v("li",[_._v("随后，一旦 Node EvLoop 在轮询操作中，调用 "),v("code",[_._v("GetQueuedCompletionStatus")]),_._v(" 时检测到了完成状态，就会将 "),v("u",[v("strong",[_._v("请求对象")])]),_._v(" 塞给上述提及的 "),v("u",[v("strong",[_._v("I/O观察者对象")])]),_._v("；")]),_._v(" "),v("li",[_._v("最后，"),v("strong",[v("u",[_._v("I/O 观察者对象")])]),_._v(" 取出 "),v("strong",[v("u",[_._v("请求对象")])]),_._v(" 的 "),v("u",[_._v("存储结果")]),_._v("，同时也取出它的 "),v("code",[_._v("oncomplete_sym")]),_._v(" 属性，即回调函数，将前者(存储结果)作为函数参数传入后者(回调)，并执行后者，即执行回调函数；")]),_._v(" "),v("li",[_._v("补充： "),v("code",[_._v("GetQueuedCompletionStatus")]),_._v(" 和 "),v("code",[_._v("PostQueuedCompletionStatus")]),_._v(" "),v("ul",[v("li",[v("code",[_._v("GetQueuedCompletionStatus")]),_._v("：在 NodeEvLoop 的描述中("),v("u",[_._v("详看V8—EvLoop—NodeEvLoop小节")]),_._v(")，每一个 Tick 当中均会调用 "),v("code",[_._v("GetQueuedCompletionStatus")]),_._v("，以检查线程池中是否有执行完的请求，若有则表示时机已成熟，可执行回调；")]),_._v(" "),v("li",[v("code",[_._v("PostQueuedCompletionStatus")]),_._v("：负责向 IOCP 提交状态，告知当前 I/O 已完成；")])])])])])]),_._v(" "),v("h3",{attrs:{id:"_4-4-3、总结"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-4-3、总结"}},[_._v("#")]),_._v(" 4-4-3、总结")]),_._v(" "),v("p",[_._v("Node 中阻塞IO与异步IO的实现：")]),_._v(" "),v("ul",[v("li",[_._v("阻塞和非阻塞 I/O 其实是针对操作系统内核而言：\n"),v("ul",[v("li",[_._v("阻塞 I/O："),v("strong",[v("u",[_._v("一定要等到操作系统完成所有操作后才表示调用结束")])]),_._v("；")]),_._v(" "),v("li",[_._v("非阻塞 I/O："),v("strong",[v("u",[_._v("调用后立马返回不等操作系统内核完成操作")])]),_._v("；")])])]),_._v(" "),v("li",[_._v("Node 的异步 I/O 采用多线程的方式，由 "),v("code",[_._v("EventLoop")]),_._v("、"),v("code",[_._v("I/O 观察者")]),_._v("，"),v("code",[_._v("请求对象")]),_._v("、"),v("code",[_._v("线程池")]),_._v("四大要素相互配合，共同实现；")])])])}),[],!1,null,null,null);t.default=e.exports}}]);