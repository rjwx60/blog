(window.webpackJsonp=window.webpackJsonp||[]).push([[153],{590:function(_,v,e){"use strict";e.r(v);var l=e(4),i=Object(l.a)({},(function(){var _=this,v=_.$createElement,e=_._self._c||v;return e("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[e("h1",{attrs:{id:"三、模块机制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#三、模块机制"}},[_._v("#")]),_._v(" 三、模块机制")]),_._v(" "),e("h2",{attrs:{id:"_3-1、基本"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-1、基本"}},[_._v("#")]),_._v(" 3-1、基本：")]),_._v(" "),e("p",[_._v("Node 借鉴 CommonJS 的 Modules 规范实现自身模块系统；")]),_._v(" "),e("h2",{attrs:{id:"_3-2、分类"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-2、分类"}},[_._v("#")]),_._v(" 3-2、分类")]),_._v(" "),e("p",[_._v("3-2-1、核心模块：")]),_._v(" "),e("ul",[e("li",[_._v("描述：由 Node 自身提供，其在源码编译时即被编译进二进制执行文件，当进程启动时便被直接加载进内存；")]),_._v(" "),e("li",[_._v("注意：因上述原因，此类模块的引入/文件定位/编译执行步骤均可忽略，而在路径分析中，其优先级更高，加载速度也更快；")])]),_._v(" "),e("p",[_._v("3-2-2、文件模块：用户提供的，运行时加载的，速度比核心慢，需经过3阶段：路径分析、文件定位、编译执行；")]),_._v(" "),e("p",[_._v("3-2-3、模块异同：")]),_._v(" "),e("ul",[e("li",[_._v("相同：引入的模块均会进行缓存(缓存内容：编译 & 执行后的对象)，以减少二次引入时的开销；")]),_._v(" "),e("li",[_._v("不同：\n"),e("ul",[e("li",[_._v("缓存检查优先度中，核心模块依然优先于文件模块；")]),_._v(" "),e("li",[_._v("文件模块无须将源代码编译进 Node，而是通过 "),e("code",[_._v("dlopen")]),_._v(" 方法动态加载；")]),_._v(" "),e("li",[_._v("文件模块在编写时无须将源代码写入 Node 命名空间，也无需提供头文件；")])])])]),_._v(" "),e("h2",{attrs:{id:"_3-3、路径分析"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-3、路径分析"}},[_._v("#")]),_._v(" 3-3、路径分析")]),_._v(" "),e("p",[_._v("3-3-1、描述")]),_._v(" "),e("p",[_._v("模块标识符分析(require() 中的标识符参数分析)，基于此标识符进行模块查找；等同npm包路径分析；")]),_._v(" "),e("ul",[e("li",[e("p",[_._v("核心模块：http、fs、path 等；")])]),_._v(" "),e("li",[e("ul",[e("li",[_._v("首先，路径优先级最高，其次是缓存；")]),_._v(" "),e("li",[_._v("其次，无需定位、无需编译，直接使用；")])])]),_._v(" "),e("li",[e("p",[_._v("文件模块：以点开始的相对路径文件模块 & 以斜杠开始的绝对路径文件模块；")])]),_._v(" "),e("li",[e("ul",[e("li",[_._v("首先，"),e("code",[_._v("require")]),_._v(" 会将其转为真实路径，并以此作为索引；")]),_._v(" "),e("li",[_._v("然后，根据模块路径查找策略定位文件，并进行编译；")]),_._v(" "),e("li",[_._v("随后，将编译后的执行结果存放在缓存，以便二次加载更快；")])])]),_._v(" "),e("li",[e("p",[_._v("自定模块：非路径形式的文件模块，形式为文件/包，比如自定义 connect 模块；")])]),_._v(" "),e("li",[e("ul",[e("li",[_._v("首先，根据模块路径查找策略定位文件；")]),_._v(" "),e("li",[_._v("注意：自定义模块均在文件最外层，故加载速度最慢 (除非写在当前文件的 "),e("code",[_._v("node_modules")]),_._v(" 中..)；")])])])]),_._v(" "),e("p",[_._v("3-3-2、路径形式")]),_._v(" "),e("p",[_._v("模块路径具体表现为由路径组成的数组；")]),_._v(" "),e("ul",[e("li",[_._v("生成方式：创建任意 JS 文件，内容为 "),e("code",[_._v("console.log(module.paths)")]),_._v("，然后 "),e("code",[_._v("node 目标文件.js")]),_._v(" 即可输出；")])]),_._v(" "),e("p",[_._v("3-3-3、模块查找策略")]),_._v(" "),e("p",[_._v("加载过程中，Node 会逐个尝试模块路径中的路径，直到找到目标文件为止，路径越深，模块查找耗时越多；")]),_._v(" "),e("ul",[e("li",[_._v("搜寻当前文件目录下的 "),e("code",[_._v("node_modules")]),_._v(" 目录；")]),_._v(" "),e("li",[_._v("搜寻父级文件目录下的 "),e("code",[_._v("node_modules")]),_._v(" 目录；")]),_._v(" "),e("li",[_._v("搜寻爷级文件目录下的 "),e("code",[_._v("node_modules")]),_._v(" 目录；")]),_._v(" "),e("li",[_._v("沿路径向上逐级递归，直至根目录下的 "),e("code",[_._v("node_modules")]),_._v(" 目录；")])]),_._v(" "),e("h2",{attrs:{id:"_3-4、文件定位"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-4、文件定位"}},[_._v("#")]),_._v(" 3-4、文件定位")]),_._v(" "),e("p",[_._v("文件扩展名分析：")]),_._v(" "),e("p",[_._v("若不包含扩展名，则调用 fs 模块同步阻塞式判断文件是否存在，并按 "),e("code",[_._v(".js > .json > .node")]),_._v(" 顺序补足扩展名；")]),_._v(" "),e("ul",[e("li",[_._v("注意：对 node、json 文件，可在使用 require 时，顺带添加扩展名，以稍微提高速度；")]),_._v(" "),e("li",[_._v("注意：因缓存优化策略，二次引入时无需路径分析、文件定位、编译执行等过程；")])]),_._v(" "),e("p",[_._v("3-4-2、目录与包分析：")]),_._v(" "),e("p",[_._v("若通过文件扩展名分析后，仍无法找到对应文件(或得到一个目录<常见于自定义模块，逐个模块路径查找时>)，此时 Node 会将目录当作包来处理；")]),_._v(" "),e("ul",[e("li",[_._v("首先，在所在目录查找 "),e("code",[_._v("package.json")]),_._v("：\n"),e("ul",[e("li",[_._v("若有，则通过 "),e("code",[_._v("JSON.parse")]),_._v(" 解析出包描述对象，并取出 main 属性指定的文件名进行定位；\n"),e("ul",[e("li",[_._v("若缺少文件名扩展名，则进入文件扩展名分析流程；")]),_._v(" "),e("li",[_._v("若文件名错误，则将 index 作为默认文件名，依次查找 "),e("code",[_._v("index.js index.json index.node；")])])])]),_._v(" "),e("li",[_._v("若无，则将 index 作为默认文件名，依次查找 "),e("code",[_._v("index.js index.json index.node；")])])])]),_._v(" "),e("li",[_._v("最后，若还是没有成功定位任何文件，则继续查找下一个模块路径，直至路径数组遍历完毕，若依然没有找到，则向上抛出查找失败错误；")]),_._v(" "),e("li",[_._v("示例：\n"),e("ul",[e("li",[e("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200918140137.png",align:""}})])])])]),_._v(" "),e("h2",{attrs:{id:"_3-5、模块编译"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-5、模块编译"}},[_._v("#")]),_._v(" 3-5、模块编译")]),_._v(" "),e("p",[_._v("编译后进行加载并导出，此节亦是 CommonJS 模块规范的 Node 实现")]),_._v(" "),e("ul",[e("li",[e("p",[_._v("原理：编译过程中，Node 对获取到的 JS 文件，进行头尾包装，以实现每个模块文件的作用域隔离：")])]),_._v(" "),e("li",[e("ul",[e("li",[_._v("头部增加："),e("code",[_._v("(function(*exports*, *require*, *module*, *__filename*, *__dirname*){ \\n；")])]),_._v(" "),e("li",[_._v("尾部增加："),e("code",[_._v("\\n })")])])])]),_._v(" "),e("li",[e("p",[_._v("然后，通过执行 vm 原生模块的 "),e("code",[_._v("runInThisContext")]),_._v(" ，返回一个具体的 function 对象，并将当前模块的 exports、require、module(模块自身)、查找到的文件路径、文件目录作为参数传递此 function 执行；")])]),_._v(" "),e("li",[e("ul",[e("li",[_._v("这也是为何："),e("code",[_._v("require、exports、module")]),_._v(" 变量没有在模块中定义，却可在每个模块中存在的原因；")])])]),_._v(" "),e("li",[e("p",[_._v("最后，对象执行后，将模块的 "),e("code",[_._v("exports")]),_._v(" 属性返回给调用方，此后属性上的方法 & 属性，均可被外部调用，但其余变量则不可直接调用；")])]),_._v(" "),e("li",[e("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200918140138.png",align:""}})])]),_._v(" "),e("p",[_._v("3-5-1、文件模块编译")]),_._v(" "),e("ul",[e("li",[e("p",[_._v("普通文件模块：")])]),_._v(" "),e("li",[e("ul",[e("li",[e("p",[_._v("首先，定位到具体文件后，新建模块对象；")])]),_._v(" "),e("li",[e("p",[_._v("然后，按照路径 & 文件扩展名载入并进行相应编译 (具体编译实现看核心模块的JS模块编译)：")])]),_._v(" "),e("li",[e("ul",[e("li",[e("code",[_._v(".js")]),_._v("：用 fs 模块同步读取，随后编译执行；")]),_._v(" "),e("li",[e("code",[_._v(".json")]),_._v(" ：用 fs 模块同步读取并用 "),e("code",[_._v("JSON.parse")]),_._v(" 解析，将结果赋给模块对象的 "),e("code",[_._v("exports")]),_._v(" 供外部调用；")]),_._v(" "),e("li",[e("code",[_._v(".node")]),_._v(" ：使用 dlopen 方法加载最后编译生成的文件；")]),_._v(" "),e("li",[e("code",[_._v(".else")]),_._v("  ：处理同 "),e("code",[_._v(".js")]),_._v(" 文件；")])])]),_._v(" "),e("li",[e("p",[_._v("最后，编译成功的模块，将其文件路径作为索引，在 "),e("code",[_._v("Module._cache")]),_._v(" 对象上缓存以提高二次导入性能；")])])])]),_._v(" "),e("li",[e("p",[_._v("特殊文件模块：C/C++ 模块")]),_._v(" "),e("ul",[e("li",[_._v("描述：即上述提到的 node 文件，用于提升性能与执行效率；")])])]),_._v(" "),e("li",[e("ul",[e("li",[_._v("注意：使用 "),e("code",[_._v("dlopen")]),_._v(" 方法动态加载最后编译生成的文件；")]),_._v(" "),e("li",[_._v("注意："),e("code",[_._v("dlopen")]),_._v(" 的实现因平台而不同，但均通过 libux 兼容层封装统一；")]),_._v(" "),e("li",[_._v("注意：实际上，node 文件是用 C/C++ 编写的扩展文件，经编译后生产，故无需编译，只需加载 & 执行；")]),_._v(" "),e("li",[_._v("注意：执行时，模块的 exports 与 .node 模块相关联，然后返回给调用者；")])])]),_._v(" "),e("li",[e("p",[_._v("特殊文件模块：C/C++扩展模块")])]),_._v(" "),e("li",[e("ul",[e("li",[_._v("编写：与核心模块相比，无需编写如 node 命名空间，即 "),e("code",[_._v("namespace node { ..")])]),_._v(" "),e("li",[_._v("加载：仅通过 "),e("code",[_._v("process.dlopeen")]),_._v(" 动态加载；")]),_._v(" "),e("li",[_._v("导出：详看 31-33；")])])])]),_._v(" "),e("p",[_._v("3-5-2、核心模块编译")]),_._v(" "),e("p",[_._v("核心模块实际可分成 C/C++ 编写部分和 JS 编写两部分：")]),_._v(" "),e("ul",[e("li",[e("p",[_._v("核心模块 JS 编写部分：")])]),_._v(" "),e("li",[e("ul",[e("li",[e("p",[_._v("存储：在 lib 目录；")])]),_._v(" "),e("li",[e("p",[_._v("转换：使用 V8 的 "),e("code",[_._v("js2c.py")]),_._v(" 工具，将 JS 代码 ("),e("code",[_._v("src/node.js & lib/*.js")]),_._v(") 转换成 C++ 数组，生成 "),e("code",[_._v("node_natives.h")]),_._v(" 文件，并存储在 "),e("code",[_._v("NativeModule._source")]),_._v(" 中；")])]),_._v(" "),e("li",[e("ul",[e("li",[_._v("首先，通过 "),e("code",[_._v("process.binding(‘natives’)")]),_._v(" 取出上述通过 "),e("code",[_._v("js2c.py")]),_._v(" 转换的字符串数组，并将其重新转为普通字符串；")]),_._v(" "),e("li",[_._v("然后，进行头尾包装以导出 "),e("code",[_._v("export")]),_._v(" 对象；")]),_._v(" "),e("li",[_._v("最后，编译成功的模块，将其文件路径作为索引，缓存在 "),e("code",[_._v("NativeModule._cache")]),_._v(" 对象上；")]),_._v(" "),e("li",[_._v("注意：转换 JS 码时，JS 代码以字符串形式，存储在 node 命名空间中，不可直接执行；")]),_._v(" "),e("li",[_._v("注意：核心模块需编译，而文件模块还需进行路径分析、文件定位；")]),_._v(" "),e("li",[_._v("注意：文件模块缓存中在 "),e("code",[_._v("Module._cache")]),_._v(" 对象中；")]),_._v(" "),e("li",[_._v("注意：当 Node 进程启动时，JS 代码将直接加载进内存JS 核心模块经标识符分析后直接定位到内存；")])])])])]),_._v(" "),e("li",[e("p",[_._v("核心模块 C/C++ 编写部分：")])]),_._v(" "),e("li",[e("ul",[e("li",[e("p",[_._v("存储：在 src 目录；")])]),_._v(" "),e("li",[e("p",[_._v("转换：因原本即用 C/C++ 编写，随后又被编译成二进制文件，故无需再转换；")])]),_._v(" "),e("li",[e("ul",[e("li",[_._v("注意：当 Node 进程启动时，便被直接加载进内存，无需定位、分析、编译等步骤，直接可执行；")]),_._v(" "),e("li",[_._v("协助加载：在 Node 启动过程中，还会生成全局变量 "),e("code",[_._v("process")]),_._v("，其提供 "),e("code",[_._v("Binding")]),_._v(" 方法协助加载；")]),_._v(" "),e("li",[_._v("真正加载：此时，会先构建 "),e("code",[_._v("exports")]),_._v(" 对象，调用 "),e("code",[_._v("get_builtin_module")]),_._v(" 方法取出模块，执行 "),e("code",[_._v("register_func")]),_._v(" 填充 "),e("code",[_._v("exports")]),_._v(" 对象，最后 "),e("code",[_._v("exports")]),_._v(" 对象按模块名缓存，并返回给调用方完成导出；")])])])])])])])}),[],!1,null,null,null);v.default=i.exports}}]);