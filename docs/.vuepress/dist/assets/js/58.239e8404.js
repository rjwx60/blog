(window.webpackJsonp=window.webpackJsonp||[]).push([[58],{571:function(e,t,v){"use strict";v.r(t);var _=v(4),c=Object(_.a)({},(function(){var e=this,t=e.$createElement,v=e._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("p",[e._v("https://mp.weixin.qq.com/s/d9J-_aF9K8QTUtemol-EfQ")]),e._v(" "),v("p",[e._v("https://mp.weixin.qq.com/s/7NJv21Dz7eGFFt-c3qitWw")]),e._v(" "),v("p",[e._v("https://mp.weixin.qq.com/s/J1hMFK9LfzvTNvEtyOwE-Q")]),e._v(" "),v("p",[e._v("https://www.smashingmagazine.com/2020/01/front-end-performance-checklist-2020-pdf-pages/")]),e._v(" "),v("p",[e._v("preload,prefetch,dns-prefetch")]),e._v(" "),v("p",[e._v("https://juejin.im/post/6844903562070196237#heading-5")]),e._v(" "),v("ul",[v("li",[e._v("使用 preload 指令的好处包括：")]),e._v(" "),v("li",[e._v("允许浏览器来设定资源加载的优先级因此可以允许前端开发者来优化指定资源的加载。")]),e._v(" "),v("li",[e._v("赋予浏览器决定资源类型的能力，因此它能分辨这个资源在以后是否可以重复利用。")]),e._v(" "),v("li",[e._v("浏览器可以通过指定 as 属性来决定这个请求是否符合 content security policy。")]),e._v(" "),v("li",[e._v("浏览器可以基于资源的类型（比如 image/webp）来发送适当的 accept 头。")])]),e._v(" "),v("h2",{attrs:{id:"prefetch"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#prefetch"}},[e._v("#")]),e._v(" "),v("code",[e._v("Prefetch")])]),e._v(" "),v("ul",[v("li",[v("code",[e._v("Prefetch")]),e._v(" 是一个低优先级的资源提示，允许浏览器在后台（空闲时）获取将来可能用得到的资源，并且将他们存储在浏览器的缓存中。一旦一个页面加载完毕就会开始下载其他的资源，然后当用户点击了一个带有 prefetched 的连接，它将可以立刻从缓存中加载内容。")])]),e._v(" "),v("h2",{attrs:{id:"dns-prefetching"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#dns-prefetching"}},[e._v("#")]),e._v(" "),v("code",[e._v("DNS Prefetching")])]),e._v(" "),v("ul",[v("li",[v("code",[e._v("DNS prefetching")]),e._v(" 允许浏览器在用户浏览页面时在后台运行 DNS 的解析。如此一来，DNS 的解析在用户点击一个链接时已经完成，所以可以减少延迟。可以在一个 link 标签的属性中添加 rel=\"dns-prefetch'  来对指定的 URL 进行"),v("code",[e._v("DNS prefetching")]),e._v("，我们建议"),v("code",[e._v("Google fonts，Google Analytics")]),e._v(" 和"),v("code",[e._v("CDN")]),e._v(" 进行处理。")])]),e._v(" "),v("h1",{attrs:{id:"首屏加载优化"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#首屏加载优化"}},[e._v("#")]),e._v(" 首屏加载优化")]),e._v(" "),v("p",[e._v("(白屏时间是指浏览器从响应用户输入网址地址，到浏览器开始显示内容的时间。首屏时间是指浏览器从响应用户输入网址地址，到首屏内容渲染完成的时间，此时整个网页不一定要全部渲染完成，但在当前视窗的内容需要。白屏时间是首屏时间的一个子集。)")]),e._v(" "),v("ul",[v("li",[e._v("CDN分发")]),e._v(" "),v("li",[e._v("HTTP缓存方案：强缓存+hash文件")]),e._v(" "),v("li",[e._v("前端做好缓存方案，例如存储在内存(即保存变量)，另一个存储在LocalStorage")]),e._v(" "),v("li",[e._v("前端的动态资源加载：路由动态加载、组件动态加载")]),e._v(" "),v("li",[e._v("利用好"),v("code",[e._v("async")]),e._v("和"),v("code",[e._v("defer")]),e._v("两个属性")]),e._v(" "),v("li",[e._v("页面使用骨架屏")]),e._v(" "),v("li",[e._v("使用SSR渲染")]),e._v(" "),v("li",[e._v("利用好HTTP压缩，比如指定"),v("code",[e._v("Content-Encoding")]),e._v("首部字段为"),v("code",[e._v("gzip")])])]),e._v(" "),v("h1",{attrs:{id:"你们项目一般是如何做缓存的"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#你们项目一般是如何做缓存的"}},[e._v("#")]),e._v(" 你们项目一般是如何做缓存的")]),e._v(" "),v("ul",[v("li",[e._v("对于一些没有指纹信息的资源，例如"),v("code",[e._v("index.html")]),e._v("可以使用"),v("code",[e._v("Cache-Control: no-cache")]),e._v("开启协商缓存")]),e._v(" "),v("li",[e._v("对于带有指纹信息的资源，一般会使用splitChunksPlugin进行代码分割，来保证造成最小范围的缓存失效，再设置"),v("code",[e._v("Cache-Control: max-age=3153600")])]),e._v(" "),v("li",[e._v("不需要缓存的资源设置"),v("code",[e._v("Cache-Control: no-store")]),e._v("，即不强缓存也不进行协商缓存")])])])}),[],!1,null,null,null);t.default=c.exports}}]);