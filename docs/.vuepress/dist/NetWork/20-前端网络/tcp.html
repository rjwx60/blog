<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>一、历史 | Leibnize 个人学习笔记</title>
    <meta name="generator" content="VuePress 1.5.4">
    
    <meta name="description" content="素材整理自网络，仅供个人学习记录之用">
    <link rel="preload" href="/assets/css/0.styles.4c1fe16c.css" as="style"><link rel="preload" href="/assets/js/app.58d463af.js" as="script"><link rel="preload" href="/assets/js/3.5b6bd7ce.js" as="script"><link rel="preload" href="/assets/js/1.53e5735b.js" as="script"><link rel="preload" href="/assets/js/201.1e492eea.js" as="script"><link rel="prefetch" href="/assets/js/10.47a34be1.js"><link rel="prefetch" href="/assets/js/100.2f7c82fb.js"><link rel="prefetch" href="/assets/js/101.57a81617.js"><link rel="prefetch" href="/assets/js/102.8befc7fd.js"><link rel="prefetch" href="/assets/js/103.c690f409.js"><link rel="prefetch" href="/assets/js/104.c8b86b63.js"><link rel="prefetch" href="/assets/js/105.9bac0b69.js"><link rel="prefetch" href="/assets/js/106.77dcd9f8.js"><link rel="prefetch" href="/assets/js/107.305a0cd6.js"><link rel="prefetch" href="/assets/js/108.197f379c.js"><link rel="prefetch" href="/assets/js/109.ed1f6dd8.js"><link rel="prefetch" href="/assets/js/11.d67029e2.js"><link rel="prefetch" href="/assets/js/110.b10adffc.js"><link rel="prefetch" href="/assets/js/111.27cb5e44.js"><link rel="prefetch" href="/assets/js/112.598f5429.js"><link rel="prefetch" href="/assets/js/113.b7f9fe99.js"><link rel="prefetch" href="/assets/js/114.cb9df12d.js"><link rel="prefetch" href="/assets/js/115.4d812f2c.js"><link rel="prefetch" href="/assets/js/116.3a4f5195.js"><link rel="prefetch" href="/assets/js/117.be29161e.js"><link rel="prefetch" href="/assets/js/118.eb6b99b9.js"><link rel="prefetch" href="/assets/js/119.b3f342d7.js"><link rel="prefetch" href="/assets/js/12.f13f81de.js"><link rel="prefetch" href="/assets/js/120.f343ff14.js"><link rel="prefetch" href="/assets/js/121.5983ebbd.js"><link rel="prefetch" href="/assets/js/122.8dd46465.js"><link rel="prefetch" href="/assets/js/123.71ffc4a2.js"><link rel="prefetch" href="/assets/js/124.4e568dbe.js"><link rel="prefetch" href="/assets/js/125.43b22375.js"><link rel="prefetch" href="/assets/js/126.6522a7eb.js"><link rel="prefetch" href="/assets/js/127.8308b909.js"><link rel="prefetch" href="/assets/js/128.1fd06c87.js"><link rel="prefetch" href="/assets/js/129.91e28eff.js"><link rel="prefetch" href="/assets/js/13.ac76083d.js"><link rel="prefetch" href="/assets/js/130.5027f9f0.js"><link rel="prefetch" href="/assets/js/131.4554c2f2.js"><link rel="prefetch" href="/assets/js/132.c643aed4.js"><link rel="prefetch" href="/assets/js/133.5e499634.js"><link rel="prefetch" href="/assets/js/134.59b1b330.js"><link rel="prefetch" href="/assets/js/135.da46fa8a.js"><link rel="prefetch" href="/assets/js/136.3a67d738.js"><link rel="prefetch" href="/assets/js/137.4d5f5f5e.js"><link rel="prefetch" href="/assets/js/138.1fe93dba.js"><link rel="prefetch" href="/assets/js/139.d7f54242.js"><link rel="prefetch" href="/assets/js/14.8e5c3120.js"><link rel="prefetch" href="/assets/js/140.82be0f82.js"><link rel="prefetch" href="/assets/js/141.979c5a91.js"><link rel="prefetch" href="/assets/js/142.658ae82d.js"><link rel="prefetch" href="/assets/js/143.17532399.js"><link rel="prefetch" href="/assets/js/144.dc947607.js"><link rel="prefetch" href="/assets/js/145.fc89bd8c.js"><link rel="prefetch" href="/assets/js/146.a5e1b7eb.js"><link rel="prefetch" href="/assets/js/147.0f8384fc.js"><link rel="prefetch" href="/assets/js/148.fccbb459.js"><link rel="prefetch" href="/assets/js/149.d2d32bbc.js"><link rel="prefetch" href="/assets/js/15.e17af96c.js"><link rel="prefetch" href="/assets/js/150.73f88a17.js"><link rel="prefetch" href="/assets/js/151.dd85d521.js"><link rel="prefetch" href="/assets/js/152.ca632725.js"><link rel="prefetch" href="/assets/js/153.02b859a6.js"><link rel="prefetch" href="/assets/js/154.268e5dd0.js"><link rel="prefetch" href="/assets/js/155.0df9a80c.js"><link rel="prefetch" href="/assets/js/156.0e786e96.js"><link rel="prefetch" href="/assets/js/157.79cdcd86.js"><link rel="prefetch" href="/assets/js/158.8a131380.js"><link rel="prefetch" href="/assets/js/159.7aed0b17.js"><link rel="prefetch" href="/assets/js/16.472bfca7.js"><link rel="prefetch" href="/assets/js/160.31daa77a.js"><link rel="prefetch" href="/assets/js/161.a44e6bf4.js"><link rel="prefetch" href="/assets/js/162.86180287.js"><link rel="prefetch" href="/assets/js/163.c9fd632a.js"><link rel="prefetch" href="/assets/js/164.15e04e68.js"><link rel="prefetch" href="/assets/js/165.69bcb02b.js"><link rel="prefetch" href="/assets/js/166.084ab8e2.js"><link rel="prefetch" href="/assets/js/167.0f42977a.js"><link rel="prefetch" href="/assets/js/168.a4474b7b.js"><link rel="prefetch" href="/assets/js/169.3d05b3ba.js"><link rel="prefetch" href="/assets/js/17.f9d21c6e.js"><link rel="prefetch" href="/assets/js/170.484ffe30.js"><link rel="prefetch" href="/assets/js/171.01628965.js"><link rel="prefetch" href="/assets/js/172.2dc6c763.js"><link rel="prefetch" href="/assets/js/173.4fa13f79.js"><link rel="prefetch" href="/assets/js/174.5da03623.js"><link rel="prefetch" href="/assets/js/175.7c3cae2a.js"><link rel="prefetch" href="/assets/js/176.3df0d63b.js"><link rel="prefetch" href="/assets/js/177.3aa8d705.js"><link rel="prefetch" href="/assets/js/178.5b48450e.js"><link rel="prefetch" href="/assets/js/179.3a963dce.js"><link rel="prefetch" href="/assets/js/18.8314222e.js"><link rel="prefetch" href="/assets/js/180.d67c14c9.js"><link rel="prefetch" href="/assets/js/181.c7bf4046.js"><link rel="prefetch" href="/assets/js/182.4a4705fd.js"><link rel="prefetch" href="/assets/js/183.9183a7da.js"><link rel="prefetch" href="/assets/js/184.290760c3.js"><link rel="prefetch" href="/assets/js/185.64cd4609.js"><link rel="prefetch" href="/assets/js/186.2940410e.js"><link rel="prefetch" href="/assets/js/187.12b14c61.js"><link rel="prefetch" href="/assets/js/188.1fea2b8b.js"><link rel="prefetch" href="/assets/js/189.04b7d343.js"><link rel="prefetch" href="/assets/js/19.ed77427b.js"><link rel="prefetch" href="/assets/js/190.a7d6ec94.js"><link rel="prefetch" href="/assets/js/191.8ad7d925.js"><link rel="prefetch" href="/assets/js/192.2fd0c8f8.js"><link rel="prefetch" href="/assets/js/193.4f8a87cd.js"><link rel="prefetch" href="/assets/js/194.9e2e73ca.js"><link rel="prefetch" href="/assets/js/195.c6292340.js"><link rel="prefetch" href="/assets/js/196.b7ff135e.js"><link rel="prefetch" href="/assets/js/197.83a7d260.js"><link rel="prefetch" href="/assets/js/198.530f7c9c.js"><link rel="prefetch" href="/assets/js/199.c5048869.js"><link rel="prefetch" href="/assets/js/20.09503993.js"><link rel="prefetch" href="/assets/js/200.3435c341.js"><link rel="prefetch" href="/assets/js/202.f7b55746.js"><link rel="prefetch" href="/assets/js/203.08e404b6.js"><link rel="prefetch" href="/assets/js/204.1bc4bdd8.js"><link rel="prefetch" href="/assets/js/21.38c15b75.js"><link rel="prefetch" href="/assets/js/22.ae59de53.js"><link rel="prefetch" href="/assets/js/23.1c6d3160.js"><link rel="prefetch" href="/assets/js/24.28c7c43e.js"><link rel="prefetch" href="/assets/js/25.e53d1234.js"><link rel="prefetch" href="/assets/js/26.6fe14a49.js"><link rel="prefetch" href="/assets/js/27.910bdd9c.js"><link rel="prefetch" href="/assets/js/28.9d9cd019.js"><link rel="prefetch" href="/assets/js/29.525906aa.js"><link rel="prefetch" href="/assets/js/30.8a1a47c0.js"><link rel="prefetch" href="/assets/js/31.750a297b.js"><link rel="prefetch" href="/assets/js/32.290c8619.js"><link rel="prefetch" href="/assets/js/33.885855c1.js"><link rel="prefetch" href="/assets/js/34.fb5b3f84.js"><link rel="prefetch" href="/assets/js/35.22021291.js"><link rel="prefetch" href="/assets/js/36.6736dcbf.js"><link rel="prefetch" href="/assets/js/37.50fc071e.js"><link rel="prefetch" href="/assets/js/38.a6f00886.js"><link rel="prefetch" href="/assets/js/39.e5f0c600.js"><link rel="prefetch" href="/assets/js/4.4c62e10b.js"><link rel="prefetch" href="/assets/js/40.7eaf6de1.js"><link rel="prefetch" href="/assets/js/41.c55fd828.js"><link rel="prefetch" href="/assets/js/42.2c5aaafc.js"><link rel="prefetch" href="/assets/js/43.6c939d74.js"><link rel="prefetch" href="/assets/js/44.22ccc866.js"><link rel="prefetch" href="/assets/js/45.56a056b8.js"><link rel="prefetch" href="/assets/js/46.6901927f.js"><link rel="prefetch" href="/assets/js/47.78460423.js"><link rel="prefetch" href="/assets/js/48.12fddaae.js"><link rel="prefetch" href="/assets/js/49.55f5515e.js"><link rel="prefetch" href="/assets/js/5.97a7c0dc.js"><link rel="prefetch" href="/assets/js/50.5c665644.js"><link rel="prefetch" href="/assets/js/51.9fbd3941.js"><link rel="prefetch" href="/assets/js/52.f3a93332.js"><link rel="prefetch" href="/assets/js/53.f7c91d71.js"><link rel="prefetch" href="/assets/js/54.035bd227.js"><link rel="prefetch" href="/assets/js/55.9d4300de.js"><link rel="prefetch" href="/assets/js/56.1fa21a7d.js"><link rel="prefetch" href="/assets/js/57.c6af5e20.js"><link rel="prefetch" href="/assets/js/58.8c0baaa7.js"><link rel="prefetch" href="/assets/js/59.63f1befc.js"><link rel="prefetch" href="/assets/js/6.8e992509.js"><link rel="prefetch" href="/assets/js/60.35539f20.js"><link rel="prefetch" href="/assets/js/61.0872b63b.js"><link rel="prefetch" href="/assets/js/62.6749d184.js"><link rel="prefetch" href="/assets/js/63.0a8a07d3.js"><link rel="prefetch" href="/assets/js/64.a2eeb6f7.js"><link rel="prefetch" href="/assets/js/65.d78ecb46.js"><link rel="prefetch" href="/assets/js/66.1e1a87a2.js"><link rel="prefetch" href="/assets/js/67.b550d647.js"><link rel="prefetch" href="/assets/js/68.68258f2e.js"><link rel="prefetch" href="/assets/js/69.9f502a69.js"><link rel="prefetch" href="/assets/js/7.159745e4.js"><link rel="prefetch" href="/assets/js/70.c9b2fe76.js"><link rel="prefetch" href="/assets/js/71.b7b04483.js"><link rel="prefetch" href="/assets/js/72.edb7dfe5.js"><link rel="prefetch" href="/assets/js/73.869de1e4.js"><link rel="prefetch" href="/assets/js/74.7816f275.js"><link rel="prefetch" href="/assets/js/75.0457b07c.js"><link rel="prefetch" href="/assets/js/76.79a2eaee.js"><link rel="prefetch" href="/assets/js/77.66cfa995.js"><link rel="prefetch" href="/assets/js/78.9dd75caf.js"><link rel="prefetch" href="/assets/js/79.f6111e69.js"><link rel="prefetch" href="/assets/js/8.b79c23ae.js"><link rel="prefetch" href="/assets/js/80.fff0a469.js"><link rel="prefetch" href="/assets/js/81.42c5ebec.js"><link rel="prefetch" href="/assets/js/82.ca2f7f18.js"><link rel="prefetch" href="/assets/js/83.ed547319.js"><link rel="prefetch" href="/assets/js/84.377155d9.js"><link rel="prefetch" href="/assets/js/85.e5aab871.js"><link rel="prefetch" href="/assets/js/86.14705636.js"><link rel="prefetch" href="/assets/js/87.502cb8e9.js"><link rel="prefetch" href="/assets/js/88.d8f271ec.js"><link rel="prefetch" href="/assets/js/89.3e9deca1.js"><link rel="prefetch" href="/assets/js/9.23c0899b.js"><link rel="prefetch" href="/assets/js/90.4de4929c.js"><link rel="prefetch" href="/assets/js/91.307ce9fd.js"><link rel="prefetch" href="/assets/js/92.47e69683.js"><link rel="prefetch" href="/assets/js/93.34abda4c.js"><link rel="prefetch" href="/assets/js/94.00078270.js"><link rel="prefetch" href="/assets/js/95.4c9ca2ce.js"><link rel="prefetch" href="/assets/js/96.9121392c.js"><link rel="prefetch" href="/assets/js/97.41f6bdb8.js"><link rel="prefetch" href="/assets/js/98.4524a102.js"><link rel="prefetch" href="/assets/js/99.7d313788.js">
    <link rel="stylesheet" href="/assets/css/0.styles.4c1fe16c.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container" data-v-dad8a512><div data-v-dad8a512><div id="loader-wrapper" class="loading-wrapper" data-v-d48f4d20 data-v-dad8a512 data-v-dad8a512><div class="loader-main" data-v-d48f4d20><div data-v-d48f4d20></div><div data-v-d48f4d20></div><div data-v-d48f4d20></div><div data-v-d48f4d20></div></div> <!----> <!----></div> <div class="password-shadow password-wrapper-out" style="display:none;" data-v-64685f0e data-v-dad8a512 data-v-dad8a512><h3 class="title" style="display:none;" data-v-64685f0e data-v-64685f0e>Leibnize 个人学习笔记</h3> <!----> <label id="box" class="inputBox" style="display:none;" data-v-64685f0e data-v-64685f0e><input type="password" value="" data-v-64685f0e> <span data-v-64685f0e>Konck! Knock!</span> <button data-v-64685f0e>OK</button></label> <div class="footer" style="display:none;" data-v-64685f0e data-v-64685f0e><span data-v-64685f0e><i class="iconfont reco-theme" data-v-64685f0e></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-64685f0e>vuePress-theme-reco</a></span> <span data-v-64685f0e><i class="iconfont reco-copyright" data-v-64685f0e></i> <a data-v-64685f0e><span data-v-64685f0e>Leibnize 个人学习笔记</span>
            
          <!---->
          2020
        </a></span></div></div> <div class="hide" data-v-dad8a512><header class="navbar" data-v-dad8a512><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Leibnize 个人学习笔记</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/Basics/" class="nav-link"><i class="iconfont undefined"></i>
  基本
</a></div><div class="nav-item"><a href="/NetWork/" class="nav-link router-link-active"><i class="iconfont undefined"></i>
  网络
</a></div><div class="nav-item"><a href="https://github.com/rjwx60" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont undefined"></i>
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-dad8a512></div> <aside class="sidebar" data-v-dad8a512><div class="personal-info-wrapper" data-v-ca798c94 data-v-dad8a512><!----> <h3 class="name" data-v-ca798c94>
    Leibnize 个人学习笔记
  </h3> <div class="num" data-v-ca798c94><div data-v-ca798c94><h3 data-v-ca798c94>0</h3> <h6 data-v-ca798c94>Article</h6></div> <div data-v-ca798c94><h3 data-v-ca798c94>0</h3> <h6 data-v-ca798c94>Tag</h6></div></div> <hr data-v-ca798c94></div> <nav class="nav-links"><div class="nav-item"><a href="/Basics/" class="nav-link"><i class="iconfont undefined"></i>
  基本
</a></div><div class="nav-item"><a href="/NetWork/" class="nav-link router-link-active"><i class="iconfont undefined"></i>
  网络
</a></div><div class="nav-item"><a href="https://github.com/rjwx60" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont undefined"></i>
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav> <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>网络专题</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/NetWork/20-前端网络" class="sidebar-heading clickable open"><span>20-前端网络</span> <span class="arrow down"></span></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/NetWork/20-前端网络/base.html" class="sidebar-link">一、基本</a></li><li><a href="/NetWork/20-前端网络/ip.html" class="sidebar-link">二、IP</a></li><li><a href="/NetWork/20-前端网络/tcp.html" class="active sidebar-link">三、TCP</a></li><li><a href="/NetWork/20-前端网络/dns.html" class="sidebar-link">四、DNS</a></li><li><a href="/NetWork/20-前端网络/http.html" class="sidebar-link">五、HTTP</a></li><li><a href="/NetWork/20-前端网络/websocket.html" class="sidebar-link">六、Websocket</a></li><li><a href="/NetWork/20-前端网络/Summary.html" class="sidebar-link">七、Summary</a></li></ul></section></li></ul></section></li></ul> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-64685f0e data-v-dad8a512><h3 class="title" style="display:none;" data-v-64685f0e data-v-64685f0e></h3> <!----> <label id="box" class="inputBox" style="display:none;" data-v-64685f0e data-v-64685f0e><input type="password" value="" data-v-64685f0e> <span data-v-64685f0e>Konck! Knock!</span> <button data-v-64685f0e>OK</button></label> <div class="footer" style="display:none;" data-v-64685f0e data-v-64685f0e><span data-v-64685f0e><i class="iconfont reco-theme" data-v-64685f0e></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-64685f0e>vuePress-theme-reco</a></span> <span data-v-64685f0e><i class="iconfont reco-copyright" data-v-64685f0e></i> <a data-v-64685f0e><span data-v-64685f0e>Leibnize 个人学习笔记</span>
            
          <!---->
          2020
        </a></span></div></div> <div data-v-dad8a512><main class="page"><div class="page-title" style="display:none;"><h1>一、历史</h1> <div data-v-3b7f5bdf><i class="iconfont reco-account" data-v-3b7f5bdf><span data-v-3b7f5bdf>Leibnize 个人学习笔记</span></i> <!----> <!----> <!----></div></div> <div class="theme-reco-content content__default" style="display:none;"><h1 id="一、历史"><a href="#一、历史" class="header-anchor">#</a> 一、历史</h1> <h2 id="_1-1、tcp-ip-协议发展"><a href="#_1-1、tcp-ip-协议发展" class="header-anchor">#</a> 1-1、TCP/IP 协议发展</h2> <p>​	1973年，Vinton Gray Cerf 和 Robert Elliot Kahn 提出 TCP/IP 协议，此时的 TCP 协议包含 IP 功能，随后历经几次版本升级，并于1980 TCPv4 中进行协议分层，分层后如图2；</p> <ul><li>TCP：面向连接的、可靠的、基于字节流的传输层通信协议；</li> <li>IP：根据 IP 地址穿越网络传送数据；</li></ul> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200908000714.png" align="center" style="zoom:40%;"> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200908000854.png" align="center" style="zoom:50%;"> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200908000901.png" align="center" style="zoom:40%;"> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200919112326.png" align="center" style="zoom:50%;"> <h2 id="_1-2、ncp-协议"><a href="#_1-2、ncp-协议" class="header-anchor">#</a> 1-2、NCP 协议</h2> <p>TCP/IP 协议前身 ARPA</p> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200908000908.png" align="" style="zoom:50%;"> <h2 id="_1-3、tcp-ip-七个设计理念"><a href="#_1-3、tcp-ip-七个设计理念" class="header-anchor">#</a> 1-3、TCP/IP 七个设计理念</h2> <ul><li>Internet communication must continue despite loss of networks or gateways.</li> <li>The Internet must support multiple types of communications service.</li> <li>The Internet architecture must accommodate a variety of networks.</li> <li>The Internet architecture must permit distributed management of its resources.</li> <li>The Internet architecture must be cost effective.</li> <li>The Internet architecture must permit host attachment with a low level of effort.</li> <li>The resources used in the internet architecture must be accountable.</li> <li>More：https://zoo.cs.yale.edu/classes/cs633/Reviews/Cla88.msl38.html</li></ul> <h1 id="二、tcp-协议"><a href="#二、tcp-协议" class="header-anchor">#</a> 二、TCP 协议</h1> <p>​	<strong><u><em>互联网由用户网络、企业内部网络、骨干网等复数多个网络组成，IP 层及其之下的数据链路层负责如何选择和跨越不同网络，TCP 上层负责如何构造消息、TCP层则负责如何将任意长度的消息可靠有序发送，而 TCP 在 IP 协议之上，解决网络通讯可依赖问题，是面向连接的、可靠的、基于字节流的传输层通信协议；</em></u></strong></p> <ul><li>面向连接：一对一，客户端与服务器的连接，双方通信前需三次握手，UDP 没有建立连接过程；</li> <li>可靠传输：无论网络出现何种状况，均能保证信息可达(相应 UDP<code>无状态</code>, <code>不可控</code>)
<ul><li>有状态：记录已发送数据、对方已收数据、未收数据，并保证数据包按序到达，不丢包；</li> <li>可控制：自适应调整自身行为，配合网络环境控制发送行为；</li></ul></li> <li>基于字节流：
<ul><li>消息无边界：无论消息多长均能传输；</li> <li>有序；即便先到达，也不能交予应用层处理；</li></ul></li></ul> <h2 id="_2-1、协议特点"><a href="#_2-1、协议特点" class="header-anchor">#</a> 2-1、协议特点</h2> <ul><li>点对点：无法广播多播，面向连接，仅连接存在时才可传输数据；</li> <li>双向传递：即全双工；HTTP1.1协议实际为单向协议，只能 client 发送请求 server 响应；但TCP 是全双工
<ul><li>注意：Websocket 也是全双工(实际是将 TCP 全双工特点暴露到应用层中))；</li></ul></li> <li>字节流服务：将大块数据分割为以报文段为单位的数据包进行管理；打包成报文段、保证有序接收、重复报文自动丢弃
<ul><li>优点：不强制要求应用必须离散地创建数据块、不限制数据块大小；</li> <li>缺点：不维护应用报文边界(对比HTTP、GRPC)，需由上层协议定义结尾，比如 /n/n、contentLength；</li></ul></li> <li>流量缓冲：解决双方处理速度不匹配问题；</li> <li>可靠传输：保证可达，丢包时通过重发进而增加时延实现可靠性；</li> <li>拥塞控制：不仅解决通讯双方问题，双方通讯经由的网络也在考虑范围之内；</li></ul> <h3 id="_2-1-1、与-udp-区别"><a href="#_2-1-1、与-udp-区别" class="header-anchor">#</a> 2-1-1、与 UDP 区别</h3> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200919112327.png" align="" style="zoom:50%;"> <p>UDP 具有 <u>面向无连接</u>、<u>不可靠性</u>、<u>高效</u> 的特点，拥有单播，多播，广播的功能，适用于直播、游戏、实时性要求高的场景；</p> <ul><li><p>面向无连接：发送数据前无需进行三次握手建立连接，想发数据即发送，只搬运数据，不会对数据报文进行任何拆分和拼接操作；</p> <ul><li>在发送端，应用层将数据传递给传输层 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层；</li> <li>在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作；</li></ul></li> <li><p>不可靠性：体现在无连接上，通信无需建立连接，想发即发，收到什么数据就传递什么数据，也不会备份数据，发送数据也不会关心对方是否已正确接收；</p> <ul><li>且 UDP 因为没有拥塞控制，一直会以恒定速度发送数据：网络条件不好的情况下可能会导致丢包；</li></ul></li> <li><p>高效：UDP 的头部开销小，只有八字节，相比 TCP 的至少二十字节要少得多，在传输数据报文时是很高效的；</p></li> <li><p>其他：</p> <ul><li>TCP 协议在传送数据段的时候要给段标号；UDP 协议则不会；</li> <li>TCP 协议负载较高，采用虚电路；UDP 采用无连接；</li> <li>TCP 协议的发送方要确认接收方是否收到数据段(3次握手协议)；</li> <li>TCP 协议采用窗口技术和流控制；</li></ul></li></ul> <h2 id="_2-2、协议任务"><a href="#_2-2、协议任务" class="header-anchor">#</a> 2-2、协议任务</h2> <ul><li>主机内的进程寻址；</li> <li>处理并将字节流打包成报文段；</li> <li>创建、管理、终止连接；</li> <li>传输数据；</li> <li>保证可靠性与传输质量；</li> <li>流量控制与拥塞控制；</li></ul> <h2 id="_2-3、报文格式"><a href="#_2-3、报文格式" class="header-anchor">#</a> 2-3、报文格式</h2> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200919112328.png" align="" style="zoom:50%;"> <h3 id="_2-3-1、ip头部"><a href="#_2-3-1、ip头部" class="header-anchor">#</a> 2-3-1、IP头部</h3> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200919112329.png" align="" style="zoom:50%;"> <h3 id="_2-3-2、udp头部"><a href="#_2-3-2、udp头部" class="header-anchor">#</a> 2-3-2、UDP头部</h3> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200919112330.png" align="" style="zoom:50%;"> <h3 id="_2-3-3、tcp-头部字段"><a href="#_2-3-3、tcp-头部字段" class="header-anchor">#</a> 2-3-3、TCP 头部字段</h3> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200919112331.png" align="" style="zoom:50%;"> <h3 id="_2-3-3-1、源-目的端口"><a href="#_2-3-3-1、源-目的端口" class="header-anchor">#</a> 2-3-3-1、源/目的端口</h3> <p><strong><u><em>Source Port、Destination Port  用于定义 TCP 连接，通过 TCP 四元组唯一标识一个连接：源地址、源端口、目的地址、目的端口；</em></u></strong></p> <ul><li>注意：源地址、目的地址即源IP、目的IP，在 IP 层处理，TCP 层只需记录端口；</li> <li>注意：对于 IPv4 地址，单主机最大 TCP 连接数为 2^(32+16+32+16)；</li> <li>注意：并非都得通过四元组标识连接，还可使用 QUIC 协议标识；</li> <li><img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200919112332.png" align="" style="zoom:50%;"></li></ul> <h3 id="_2-3-3-2、seq、ack"><a href="#_2-3-3-2、seq、ack" class="header-anchor">#</a> 2-3-3-2、Seq、Ack</h3> <p><strong><u><em>SequenceNumber(序列号)、AcknowledgmentNumber(确认号)：用以唯一标识 TCP 报文，类似物流系统的订单号，ACK 还用于确认报文，以实现数据可达性；</em></u></strong></p> <ul><li>Seq：即报文段第一个字节的序列号；长度为 4 字节(32 位)的无符号整数，表示范围为 0 ~( 2^32 - 1)；若到达最大值则从 0 重新开始循环，作用有二：
<ul><li>以在 SYN 报文中交换彼此的初始序列号；</li> <li>用以保证数据包按正确的顺序组装；</li></ul></li> <li>Ack：表示下一个期望接收的序列号，同时表示 **<u>小于ACK</u>**的所有字节已全部收到；</li></ul> <h3 id="_2-3-3-3、isn"><a href="#_2-3-3-3、isn" class="header-anchor">#</a> 2-3-3-3、ISN</h3> <p>***<u>ISN-Initial Sequence Number(初始序列号)，因 TCP 报文段在经过网络路由后会存在延迟抵达或排序混乱情况，故需要 ISN，而注意：三次握手核心目的之一就是交换双方 ISN，交换后才可得知对方发送信息的初始位置</u>***；</p> <ul><li>注意：<u>ISN 的构建使用半随机方法构建(基于时钟+偏移量+加密散列函数+每隔 4 ms 加1)，以确保不同连接间唯一性，防止重叠，避免不同连接间的相互影响，也为了避免连接被攻击者预测、伪造报文</u>；</li></ul> <h3 id="_2-3-3-4、checksum"><a href="#_2-3-3-4、checksum" class="header-anchor">#</a> 2-3-3-4、Checksum</h3> <ul><li><strong><u><em>Checksum(校验和)：占 2 字节16 位，防止传输过程中数据包损坏，若此值校验错误，TCP 会直接丢弃并等待重传</em></u></strong>；</li> <li>注意：TCP Header 的校验和会对 TCP 数据、Header、和部分 IP 头部字段进行校验，此举是违反分层原则；</li> <li>补充：Pseudo-Header 是一虚拟的数据结构，其中的信息是从数据报所在IP分组头的分组头中提取，既不向下传送也不向上递交，而仅仅是为计算校验和。这样的校验和，既校验了 TCP&amp;UDP 用户数据的源端口号和目的端口号以及 TCP&amp;UDP 用户数据报的数据部分，又检验了 IP 数据报的源 IP 地址和目的地址；Pseudo-Header 保证 TCP&amp;UDP 数据单元到达正确的目的地址。因此，Pseudo-Header 中包含 IP 地址并且作为计算校验和需要考虑的一部分；最终目的端根据伪报头和数据单元计算校验和以验证通信数据在传输过程中没有改变而且到达了正确的目的地址；</li></ul> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200919112333.png" align="center" style="zoom:50%;"> <h3 id="_2-3-3-5、window"><a href="#_2-3-3-5、window" class="header-anchor">#</a> 2-3-3-5、Window</h3> <ul><li>Window：占 2 字节16 位，但实际中不够用，故 TCP 引入窗口缩放的选项(Options类)，作为窗口缩放的比例因子，此值范围在 0 ~ 14，比例因子可将窗口值扩大为原来的 2 ^ n 次方；</li></ul> <h3 id="_2-3-3-6、tcp-flags"><a href="#_2-3-3-6、tcp-flags" class="header-anchor">#</a> 2-3-3-6、TCP Flags</h3> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200919112334.png" align="center" style="zoom:50%;"> <p>常见标记位：SYN、ACK、FIN、RST、PSH、URG</p> <ul><li><p>ACK：该字段为一表示确认号字段有效；此外，TCP 还规定在连接建立后传送的所有报文段都必须把 ACK 置为一；</p></li> <li><p>SYN：当 SYN=1，ACK=0 时，表示当前报文段是一个连接请求报文。当SYN=1，ACK=1时，表示当前报文段是一个同意建立连接的应答报文；</p></li> <li><p><u>RST：即 Reset，重置报文标志，用来强制断开连接；</u></p></li> <li><p>RST：该字段为一表示当前 TCP 连接出现严重问题，可能需要重新建立 TCP 连接，也可以用于拒绝非法的报文段和拒绝连接请求；</p></li> <li><p>FIN： 即 Finish，结束报文标志，表示发送方准备断开连接；</p></li> <li><p>PSH： 即 Push，<u>告知对方此数据包收到后应马上交给应用层，而非等到缓冲区满后再提交(接收端收到报文时，接收方应尽快将缓冲区内容上交应用层处理)</u>；</p></li> <li><p>URG：终止行为，优先处理含此标志位的报文；比如 ctrl + C 取消 npm 包下载；</p></li></ul> <h3 id="_2-3-3-7、urgent-pointer"><a href="#_2-3-3-7、urgent-pointer" class="header-anchor">#</a> 2-3-3-7、Urgent Pointer</h3> <p>紧急指针，若设置 URG 位，则此域将被检查作为额外指令，告诉 CPU 从数据包的某个位置开始读取数据；</p> <h3 id="_2-3-3-8、tcp-options"><a href="#_2-3-3-8、tcp-options" class="header-anchor">#</a> 2-3-3-8、TCP Options</h3> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200919112335.png" align="center" style="zoom:50%;"> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200919112336.png" align="center" style="zoom:50%;"> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200919112337.png" align="center" style="zoom:40%;"> <ul><li><strong><em><u>TSOPT(TimeStamp)：时间戳项</u></em>：</strong> <ul><li>描述：种类为 8，总长为 10 字节，由 Options 通用格式知；TSOPT 值占 8 个字节，：<code>kind(1 字节) + length(1 字节) + info(8 个字节)</code>，其中 info 由 2 部分组成：<code>timestamp</code>、<code>timestamp echo</code>，各占 4 字节；作用有二：
<ul><li>计算 ***<u>往返时延 RTT(Round-Trip Time)</u>***；</li> <li><u>防止序列号回绕</u>；</li></ul></li> <li>作用A：计算往返时延 RTT(Round-Trip Time)；
<ul><li><img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200919112338.png" align="" style="zoom:50%;"></li> <li>问题：<u>若采用首次发包，则 RTT 偏大；若采用最近一次发包，则 RTT 偏小</u>，即<u>无法使用发包时间作为计算准确 RTT 的依据；</u></li> <li>解决：引入时间戳：比如：A 向 B 站发送报文 s1，B 站回复  A 一个 ACK 报文 s2 ，则：
<ul><li><strong>首先:</strong>  A 向 B 站发送时，<code>timestamp</code> 中存放 A 主机发送时的内核时刻 <code>tA-1</code>；</li> <li><strong>然后:</strong>  B 站向 A 回复 s2 报文时，<code>timestamp</code> 中存放 B 站主机时刻 <code>tB-1</code>，而 <code>timestamp echo</code> 存放从 s1 报文中解析出来的 <code>tA-1</code>；</li> <li><strong>最后:</strong>  A 收到 B站 s2 报文后，假设此时 A 主机内核时刻为 tA-2，则可从 s2 报文中的 <code>timestamp echo</code> 选项得到 <code>tA-1</code> 值，也即 s2 对应报文最初发送时刻；然后直接将 tA-2 和 tA-1相减即可得到准确的 RTT 值；</li></ul></li></ul></li> <li>作用B：防止序列号回绕；
<ul><li><img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200919112339.png" align="" style="zoom:50%;"></li> <li>问题：正如上文 2-3-3-2 SequenceNumber 的介绍一样，序列号是有值范围的(0~2^32-1)，若超出范围就会重新由 0 开始计算，但假若某序号报文滞留在网络中，当发生序列号回绕时，发出与滞留报文序列号相同的报文，此时网络中就会存在2个序号相同的报文，继而就会产生接收方的消息混乱；</li> <li>解决：引入时间戳；因每次发包时均将发包机器当前内核时间记录在报文中，则即使2次发包序列号相同，时间戳也不可能相同，如此即可区分数据报，解决回绕问题；</li></ul></li></ul></li> <li><strong><u><em>MSS：握手时发送端告知可接收最大报文段大小 / TCP 数据部分(不含头)最大值</em></u></strong>；
<ul><li>描述：种类2，长度4字节，仅指 TCP 承载数据，不包含 TCP 头部，默认大小 536 字节 (默认 MTU—IP数据包最大值，576 字节，含 20字节 IP 头部，含 20字节 TCP 头部)，MSS 在握手阶段协商，可进一步细分为：</li> <li><strong>发送方最大报文段SMSS(SENDER MAXIMUM SEGMENT SIZE)</strong>、<strong>接收方最大报文段 RMSS (RECEIVER MAXIMUM SEGMENT SIZE)</strong></li> <li><img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200919112340.png" align="" style="zoom:40%;"></li> <li><u>作用A：尽量让每个 Segment 报文段携带更多数据，减少头部空间占用比率；</u></li> <li><u>作用B：防止 Segment 被某个设备的 IP 层基于 MTU 分层</u>；
<ul><li>原因：TCP 面向字节流，不限传输长度，但发送报文时，所使用内存有限，TCP 下的网络层和数据链路层会限制报文长度；故 TCP 须将其从上层接收的、任意长度的字节流按 MSS (最大报文段大小)和流控(接收端能力) 拆分成许多 Segment 段；若不进行分层，则 IP 层一定会基于 MTU 进行拆分，而基于 MTU 拆分报文一旦丢失某一段就要重传所有报文，效率低下，故要避免；</li></ul></li> <li>比如：假如以太网 MTU = 1500，某次握手协商 MSS = 1460；
<ul><li>普通情况：1460 + 20(TCP头部) + 20(IP头部) = 1500 刚好满足无需 TCP IP 拆分；</li> <li>特殊情况：1460 + 24(TCP头部+扩展头部)，此时先拆分，再下发 IP 层；</li></ul></li></ul></li> <li><em><strong><u>SACK-Permitted：表明支持 SACK 选择性确认中间报文段功能</u></strong></em> <ul><li>描述：种类4，长度2字节；</li></ul></li> <li><strong><u><em>SACK：选择性确认窗口中间的 Segment 报文段</em></u></strong> <ul><li>描述：种类5，长度可变，选择确认，数据部分表示对方已收到的报文，以有效重传丢失报文段</li> <li>详见：<strong><u>四、超时重传的 SACK 小节</u></strong></li></ul></li> <li><strong><u><em>WSOPT：窗口缩放项：</em></u></strong></li> <li><strong><u><em>UTO：用户超时项：</em></u></strong></li> <li><strong><u><em>TCP-AO：TCP 认证选项：</em></u></strong></li></ul> <h1 id="三、连接创建、管理、终止"><a href="#三、连接创建、管理、终止" class="header-anchor">#</a> 三、连接创建、管理、终止</h1> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200919112341.png" style="zoom:50%;"> <h2 id="_3-1、三次握手"><a href="#_3-1、三次握手" class="header-anchor">#</a> 3-1、三次握手</h2> <h3 id="_3-1-1、握手目的"><a href="#_3-1-1、握手目的" class="header-anchor">#</a> 3-1-1、握手目的</h3> <ul><li><strong><u><em>交换双方 Squence 序列号 (初始序列号 ISN-Initaial Sequence Number)；</em></u></strong></li> <li><strong><u><em>交换 TCP 通讯参数；比如 MSS、窗口比例因子、选择性确认、指定校验和算法，确认对方通信能力；</em></u></strong> <ul><li>注意：每个初始序列号-ISN 均会标识一个字节 (面向字节流的字节)，而服务端与客户端所使用的初始序列号 ISN 不同，故需三次握手分别交换彼此 ISN；</li></ul></li></ul> <h3 id="_3-1-2、三次原因"><a href="#_3-1-2、三次原因" class="header-anchor">#</a> 3-1-2、三次原因</h3> <ul><li>若为 2 次握手：2次握手，<u>即服务端只要接收客户端请求回送 SYN/ACK 后即建立连接，并发送相应的数据，此时缺少客户端的再次确认环节(三握第三步)</u>；此时若关闭连接后，收到许久前滞留网络的握手请求，服务端就会再次建立连接，但实际上客户端并不需要数据，如此就会白白浪费服务器资源；总之，前两次握手是必须的，关键在第三步，第三步主要是防止已失效请求报文段突然又传送到服务端而产生连接的误判；</li> <li>若为 4 次握手：3次是最简、最优的建立 TCP 连接次数，3 次以上就会降低建立连接的效率</li></ul> <h3 id="_3-1-3、握手流程与状态变迁"><a href="#_3-1-3、握手流程与状态变迁" class="header-anchor">#</a> 3-1-3、握手流程与状态变迁</h3> <p>握手涉及 5 种状态：<code>CLOSED、LISTEN(服务器常驻状)、SYN-SENT、SYN-RECEIVED、ESTABLISHED(握手后)</code>，理解状态变迁对在复杂网络环境中定位问题很有帮助；</p> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200919112342.png" align="center" style="zoom:50%;"> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200919112343.png" align="center" style="zoom:50%;"> <ul><li>首先，双方都处于 <em><strong>CLOSED</strong></em> 状态，随后服务端开始监听端口，进入 <em><strong><u>LISTEN</u></strong></em> 状态；</li> <li>然后，客户端主动发起连接，发送 SYN报文，并由 <strong>CLOSED</strong> 进入 <strong>SYN-SENT</strong> 状态；
<ul><li>Flags SYN 置1，<strong><u><em>seq 设 x</em></u></strong>；</li> <li>“这是我这边的情况，现在我要你的数据，快给我”</li></ul></li> <li>然后，服务端收到后，回送 SYN/ACK报文 ，并由 <u><em><strong>LISTEN</strong></em></u> 常驻态进入 <u><em><strong>SYN-RECEIVED</strong></em></u> 状态；
<ul><li>Flags SYN 和 ACK 置1，<strong><u><em>seq 设 y，ack 设 x+1</em></u></strong>；</li> <li>“好的收到，这是我这边的情况，但你当真要我的数据？”</li></ul></li> <li>然后，客户端收到 SYN/ACK 后，回送 ACK 报文 ，并由 <strong>SYN-SENT</strong> 进入 <strong>ESTABLISHED</strong>态；
<ul><li>Flags ACK 置1，<strong><u><em>ack 设 y+1</em></u></strong></li> <li>“NNND，别磨磨唧唧的，是的，快给我”</li></ul></li> <li>最后，服务端收到 ACK 报文，进入 <u><em><strong>ESTABLISHED</strong></em></u> 状态；
<ul><li>注意：Passive Open 被动打开，Active Open 主动打开；</li> <li>注意：凡需要对端确认的一定要消耗 TCP 报文序列号，即发送 SYN 需要消耗序列号，而 ACK 不用；</li> <li>注意：TCB：TransmissionContril Block：保存连接使用的源端口、目的端口、目的IP、序号、应答序号、对/己方窗口大小、TCP状态、TCP输入输出队列、应用层输出队列、TCP重传相关变量等；</li> <li>注意：图1 中的服务端 TCB 建立在 LISTEN之前，是因被动监听的句柄也要建立 TCB，其不表达一具体连接，但必须存在才能维护建链过程的相关信息；</li></ul></li></ul> <p>补充：</p> <ul><li>客户端主动发起 SYN</li> <li>服务端收到并返回 SYN 以及 ACK 客户端的 SYN</li> <li>客户端收到服务端的 SYN 和 ACK 后，发送 ACK 的 ACK 给服务端，服务端收到后连接建立</li></ul> <div class="language- extra-class"><pre class="language-text"><code>Client -&gt; SYN -&gt; Server
Server -&gt; SYN/ACK -&gt; Client
Client -&gt; ACK -&gt; Server
</code></pre></div><h3 id="_3-1-3-1、同时连接"><a href="#_3-1-3-1、同时连接" class="header-anchor">#</a> 3-1-3-1、同时连接</h3> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200919112344.png" align="center" style="zoom:50%;"> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200919112345.png" align="center" style="zoom:30%;"> <ul><li>首先，情况发生在双方同时给对方发送 SYN 报文；</li> <li>然后，双方发送后，双方的状态均由 CLOSED 变为  SYN-SENT；</li> <li>然后，在各自收到对方的 SYN 后，回送对方 SYN/ACK，两者状态均由 SYN-SENT 变为 SYN-REVD；</li> <li>最后，双方接收到对方报文后，状态由 SYN-REVD 变为 ESTABLISHED；</li> <li><strong><u><em>注意：相比于常见连接，客户端多出 SYN-RECEIVED 状态，服务端多出 SYN-SENT 状态；</em></u></strong></li></ul> <h3 id="_3-1-4、握手报文"><a href="#_3-1-4、握手报文" class="header-anchor">#</a> 3-1-4、握手报文</h3> <ul><li>一次握手：SYN 报文：
<ul><li>描述：将 TCP 头部的 Flag 中的第7位置 1 即表示 SYN，在 Sequence 中填入客户端的序列号码 ISN：</li> <li><img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200919112346.png" align="" style="zoom:50%;"></li> <li><img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200919112347.png" align="" style="zoom:50%;"></li></ul></li> <li>二次握手：SYN/ACK 报文
<ul><li>描述：将 TCP  头部的 Flag 中的第 7 位置 1 即表示 SYN，将第 4 位置 1 即表示 ACK，在 Sequence 中填入服务端的序列号码ISN，在 Acknowlage number 中填入 (客户端 ISN+1)表示确认收到：</li> <li><img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200919112348.png" align="" style="zoom:50%;"></li> <li><img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200919112349.png" align="" style="zoom:50%;"></li></ul></li> <li>三次握手：ACK 报文
<ul><li>描述：将 TCP 头部的 Flag 中第4位置1表示 ACK，在 Acknowlage number 中填入 (服务端 ISN+1)表示确认收到；</li> <li><img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200919112350.png" align="" style="zoom:50%;"></li></ul></li></ul> <h3 id="_3-1-5、握手示例"><a href="#_3-1-5、握手示例" class="header-anchor">#</a> 3-1-5、握手示例</h3> <ul><li>通过 tcpdump 监听端口：tcpdump -i lo port 80 -c 3 -S
<ul><li><img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200919112351.png" alt=""></li> <li>注意：缩写表示：S=SYN，F=FIN，P=PUSH，R=RST，U=URG，W=ECN-CWR，E=ECN-Echo，'.'=ACK，'none'=无任何标志位；</li></ul></li> <li>通过 netstat 查看连接相关状态：netstat -anp | grep tcp
<ul><li><img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200919112352.png" alt=""></li> <li>注意：不同平台均可通过 netstat 工具查看相应状态</li></ul></li></ul> <h3 id="_3-1-6、性能优化-三次握手"><a href="#_3-1-6、性能优化-三次握手" class="header-anchor">#</a> 3-1-6、性能优化—三次握手</h3> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200919112353.png" align="" style="zoom:40%;"> <p>描述：三次握手前，服务端状态从<code>CLOSED</code>变为<code>LISTEN</code>，同时在内部创建2个队列：</p> <ul><li><strong>半连接队列/SYN队列</strong>：</li> <li>当客户端发送<code>SYN</code>到服务端，服务端收到后回复 <code>ACK</code>和<code>SYN</code>，状态由<code>LISTEN</code>变为<code>SYN_RCVD</code>，此时连接套接字就被推入半连接队列(SYN Queue)；</li> <li><strong>全连接队列/ACCEPT队列</strong>：</li> <li>当客户端返回<code>ACK</code>，服务端接收后，三次握手完成；此时连接套接字将被推入另一个 TCP 维护队列，也即全连接队列(Accept Queue)，并等待被具体应用调用 accept 方法取走；</li></ul> <h3 id="_3-1-6-1、调整超时与队列长度"><a href="#_3-1-6-1、调整超时与队列长度" class="header-anchor">#</a> 3-1-6-1、调整超时与队列长度</h3> <p><strong><u>调整超时时间与缓存队列长度</u></strong>：服务器三次握手示例如上 SYN 到达，插入 SYN 队列同时发送 SYN/ACK 分组，若 ACK 到达则取出连接套接字并插入 ACCEPT 队列，当上层应用程序需要时，则调用 accept 方法取出连接套接字供上层使用；而对于几十万数百万请求的网络环境，服务端SYN 和 ACCEPT 队列势必要延长(操作系统内核层级)，此外还可在客户端调整应用层 connect 超时时间(Connec Timeout)；</p> <ul><li>客户端可在应用层调整 connect 超时时间；</li> <li>服务端可调整操作系统内核限制：
<ul><li>服务端 SYN_RCV 状态：
<ul><li><code>net.ipv4.tcp_max_syn_backlog</code>：SYN_RCVD 状态连接的最大个数；</li> <li><code>net.ipv4.tcp_synack_retries</code>：被动建立连接时，发出 SYN/ACK 的重试次数；</li></ul></li> <li>客户端 SYN_SENT 状态：
<ul><li><code>net.ipv4.tcp_syn_retries = 6</code>：主动建立连接时，发 SYN 的重试次数；</li> <li><code>net.ipv4.ip_local_port_range = 32768 60999</code>：建立连接时的本地端口可用范围；</li></ul></li> <li>ACCEPT 队列设置</li></ul></li></ul> <h3 id="_3-1-6-2、tfo"><a href="#_3-1-6-2、tfo" class="header-anchor">#</a> 3-1-6-2、TFO</h3> <p>即快速建立立 TCP 连接，TFO-TCP-FastOpen：首次连接服务端多回送 Cookie 供客户端缓存，若后续再次建立连接时，客户端一并传送 Cookie，服务端识别后将 Data 随 SYN/ACK 报文回传；TFO 充分利用一个RTT，省去客户端 ACK 确保报文，降低二次连接时的时延，提前进行数据传输；过程如下：</p> <ul><li>首先，客户端发送 SYN；</li> <li>然后，服务器收到后，通过计算得到 SYN Cookie，并将此值存放到 TCP 的 FastOpen 选项中，回送客户端 SYN/ACK 报文；</li> <li>然后，客户端接收并缓存此 Cookie，回送 ACK 完成三次握手；</li> <li>然后，当客户端想再次建立握手建立连接，则将先前缓存的 Cookie 随 SYN 一并 HTTP GET发送给服务端；</li> <li>然后，服务端校验通过后，即可回送包含数据的 SYN/ACK 报文；</li></ul> <p>​	实现：开启系统 TFO 功能：<code>net.ipv4.tcp_fastopen</code>：关闭-0、作为客户端时可使用 TFO-1、作为服务端时可使用 TFO-2、无论哪端均可使用 TFO-3；</p> <p>​	注意：服务端为客户端建立 Cookie 的前提是双方均支持 TFO，随后当客户端再次向服务器建立连接时，则复用缓存 cookie，服务端验证通过后才能在首次握手中传递消息；</p> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200919112354.png" style="zoom:50%;"> <h3 id="_3-1-6-3、tcp-defer-accept"><a href="#_3-1-6-3、tcp-defer-accept" class="header-anchor">#</a> 3-1-6-3、TCP_DEFER_ACCEPT</h3> <p>当服务器收到 ACK 分组后，并将 SYN 放入相应 ACCEPT 队列中，但内核不立即激活相应应用程序，而是等待后续数据到达再激活，以提升效率；</p> <h3 id="_3-1-7、安全问题-三次握手"><a href="#_3-1-7、安全问题-三次握手" class="header-anchor">#</a> 3-1-7、安全问题—三次握手</h3> <h3 id="_3-1-7-1、syn-攻击"><a href="#_3-1-7-1、syn-攻击" class="header-anchor">#</a> 3-1-7-1、SYN 攻击</h3> <p>描述：典型的 DoS/DDoS 攻击，攻击者在短时间内，伪造大量不存在的 IP 地址的 SYN 报文 (可按照 TCP 协议格式来构造 SYN 帧，大多数编程语言都支持，在基于socket 编程时设置为 RAW_SOCKET 类似字样，此时相当于在 IP 层之上编程)；</p> <p>影响：</p> <ul><li>服务器回送 ACK 但无法收到对方 ACK，使 backlog (SYN)队列被大量处于<code>SYN_RCVD</code>状态的连接占满，无法处理正常的请求；</li> <li>服务端长时间收不到客户端<code>ACK</code>，导致服务端不断重发数据，耗费服务器资源；</li></ul> <p>防御：</p> <ul><li>方式1：调整 SYN 队列连接数
<ul><li><code>net.ipv4.tcp_max_syn_backlog</code>：SYN_RCVD 状态连接的最大个数；</li> <li><code>net.core.netdev_max_backlog</code>：接收来自网卡，但未被内核协议栈处理的报文队列长度；</li> <li><code>net.ipv4.tcp_abort_on_overflow</code>：超出处理能力时，对新来的 SYN 直接回包 RST，丢弃连接；</li></ul></li> <li>方式2：减少 SYN + ACK 重试次数，避免大量的超时重发；</li> <li>方式3：tcp_syncookies</li></ul> <p><img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200924092539.png" alt=""></p> <p>​	若应用程序过慢则导致 Accept 队列满，若受到 SYN 攻击则导致 SYN 队列满，此时可启用cookie：</p> <div class="language-http extra-class"><pre class="language-http"><code>net.ipv4.tcp_syncookies = 1
</code></pre></div><p>​	为连接生成唯一 cookie 并随 SYN/ACK 返回给客户端，客户端在随后的请求中携带 cookie 并由服务器认证并响应；即 SYN 队列满时亦可建立连接；</p> <p>​	注意：(感觉) syn_cookie 与 TFO 中的 cookie 不同，前者保证当前连接合法性、后者保证再次连接的合法性；</p> <h3 id="_3-1-8、其他问题-三次握手"><a href="#_3-1-8、其他问题-三次握手" class="header-anchor">#</a> 3-1-8、其他问题—三次握手</h3> <h3 id="_3-1-8-1、握手携带数据"><a href="#_3-1-8-1、握手携带数据" class="header-anchor">#</a> 3-1-8-1、握手携带数据</h3> <p>​	分情况，若为普通握手连接，则第三次可携带，前两次不可携带，以减少服务器被攻击风险，提升连接效率(三次握手时，客户端已处于 ESTABLISHED 状态，且已确认服务器收发能力，故可携带)；若为开启了 TFO 的握手连接，则二次建立连接时，首次握手可携带一次建立连接服务器下发的 cookie 认证信息，二次握手(服务端响应)则可携带响应相关数据，详见上述 TFO 内容；</p> <h3 id="_3-1-8-2、连接建立超时"><a href="#_3-1-8-2、连接建立超时" class="header-anchor">#</a> 3-1-8-2、连接建立超时</h3> <p>​	若连接不存在主机，则会先发生连接建立超时现象，后续客户端会收到“无法到达主机”消息；连接建立超时，若首次发送 SYN 失败，第二次尝试连接时间隔会变长，比如首次发送后，二次发送在 3 秒后，三次发送在6秒后，四次在 12 秒…此行为亦称 <em><u>指数回退</u></em> ；以太网中最大回退数值是上次的2倍，实际回退数值则会随机选取；系统可配置发送初始 SYN 的次数；</p> <ul><li>主动打开申请中尝试重新发送 SYN 的最大次数(默认5次)</li></ul> <div class="language-http extra-class"><pre class="language-http"><code>net.ipv4.tcp_syn_retries
</code></pre></div><ul><li>主动打开申请中尝试重新发送 SYN/ACK 的最大次数(默认5次)</li></ul> <div class="language-http extra-class"><pre class="language-http"><code>net.ipv4.tcp_synack_retries
</code></pre></div><h2 id="_3-2、四次挥手"><a href="#_3-2、四次挥手" class="header-anchor">#</a> 3-2、四次挥手</h2> <h3 id="_3-2-1、四次原因"><a href="#_3-2-1、四次原因" class="header-anchor">#</a> 3-2-1、四次原因</h3> <p>因服务端在接收到 FIN 后，往往不会立即返回 FIN，而须等到服务端将所有报文均发送完毕/处理请求完成后，才能发 FIN；此时先发送 ACK 表示已收到客户端的 FIN，等服务端处理完毕后才发 FIN，再加上客户端的 ACK 确认，导致四次挥手；</p> <ul><li>若为三次挥手：等同于服务端将 ACK 和 FIN 发送合二为一，某些情况可以实现，但更多的是其中的长时间延迟可能会导致客户端误以为 FIN 没有到达服务端而不断重发 FIN；</li></ul> <h3 id="_3-2-2、挥手流程与状态变迁"><a href="#_3-2-2、挥手流程与状态变迁" class="header-anchor">#</a> 3-2-2、挥手流程与状态变迁</h3> <p>​	挥手涉及的5种状态：CLOSE-WAIT、LAST-ACK、FIN-WAIT1、FIN-WAIT2、CLOSING、TIME-WAIT</p> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200919112356.png" style="zoom:50%;"> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200919112357.png" style="zoom:50%;"> <ul><li><p>首先，双方均处于 <em><strong>ESTABLISHED</strong></em> 状态，然后客户端想关闭连接，发送 FIN 报文，并改为 <strong>FIN-WAIT-1</strong>态；</p> <ul><li>注意：<u>此时客户端进入 half-close(半关闭)状态，只能接收而无法再向服务端发送消息</u>；</li></ul></li> <li><p>然后，服务端接收后，回送 ACK，并由 <strong><u><em>ESTABLISHED</em></u></strong> 进入**<u><em>CLOSED-WAIT</em></u>** 状态；</p></li> <li><p>然后，客户端收到服务端确认，并由 <strong>FIN-WAIT-1</strong> 进入 <strong>FIN-WAIT-2</strong> 态；</p></li> <li><p>随后，服务器向客户端发送 FIN 报文，并由  <strong><u><em>CLOSED-WAIT</em></u></strong> 进入 <strong><u><em>LAST-ACK</em></u></strong> 态；</p></li> <li><p>然后，客户端收到服务端 FIN，由 <strong>FIN-WAIT-2</strong>  进入 <strong>TIME-WAIT</strong> 态，并回送 ACK；</p> <ul><li>注意：<u>此时客户端可发送报文</u>；</li></ul></li> <li><p>注意：主动关闭连接一方此后会等待 <strong>2MSL(Maximum Lifetime，报文最大生存时间)</strong>；</p> <ul><li>此段期间若无收到服务端的重发请求，则表示 ACK 成功到达，挥手结束，否则客户端重发 ACK;</li></ul></li> <li><p>注意：等待 2MSL 原因：</p> <ul><li><img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200919112358.png" align="" style="zoom:50%;">
- 保证 TCP 协议全双工连接可靠关闭
  - 若客户端回送 ACK 后直接 CLOSED，此时，若出现网络原因导致 ACK 报文丢失，服务端则会在超时后重发 FIN，此时若客户端在原有端口上已建立别的连接，就会造成信息混乱；
- 保证至少一次报文往返时间内端口不可复用；
  - 若客户端回送 ACK 后直接 CLOSED，此时，若客户端重新向服务端发起连接，且若使用相同端口(新旧连接)建立连接，此时，若旧连接的数据仍滞留网络中，并在建立新连接后到达，则会误将旧数据包当作新连接，导致数据混淆；(若TIME_WAIT过短或没有，若后续复用端口，则会导致接收方数据错乱，TIME_WAIT 有保护作用，避免延迟到达数据扰乱新连接)
</li> <li><p>1 个 MSL 确保四次挥手中主动关闭方最后的 ACK 报文最终能达到对端；</p></li> <li><p>1 个 MSL 确保对端没有收到 ACK 重传的 FIN 报文可以到达；</p></li></ul></li> <li><p>注意：并非仅客户端关闭连接，服务端亦可主动关闭连接，比如短连接；如此可快速释放资源，此外当服务端发现请求有误，或处理过程出错，也会发送错误信息后主动关闭；</p></li> <li><p>注意：主动发起关闭方会经历 2MSL 时期，此时端口被占用，对要同时处理大量TCP连接的服务器是负担；</p></li> <li><p>注意：客户端复用 time_wait 端口风险较服务端小，因为前者概率小且 TCP 四元组作为客户端有 65535 种可能，且自身知道打开了 reuse 功能可控，而后者遇到同IP同端口客户端事件是不可控的，故需做处理；</p></li> <li><p>注意：若时机恰好，中间的 FIN 与 ACK 是可以合并发送的；</p></li> <li><p>注意：若出现数据包混乱，TCP 会直接发送 RST 重置报文；</p></li></ul> <p>补充：</p> <ul><li>客户端发送 FIN 给服务端</li> <li>服务端收到后发送 ACK 给客户端</li> <li>服务端发送 FIN 给客户端</li> <li>客户端收到后，发送 ACK 的 ACK 给服务端，服务端关闭，客户端等待 2MSL 后关闭</li></ul> <div class="language- extra-class"><pre class="language-text"><code>Client -&gt; FIN -&gt; Server
Server -&gt; ACK -&gt; Client
Server -&gt; FIN -&gt; Client
Client -&gt; ACK -&gt; Server -&gt; CLOSED
Client -&gt; 2MSL 的时间 -&gt; CLOSED
</code></pre></div><h3 id="_3-2-2-1、同时挥手"><a href="#_3-2-2-1、同时挥手" class="header-anchor">#</a> 3-2-2-1、同时挥手</h3> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200919112359.png" style="zoom:50%;"> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200919112400.png" style="zoom:50%;"> <h3 id="_3-2-3、性能优化-四次挥手"><a href="#_3-2-3、性能优化-四次挥手" class="header-anchor">#</a> 3-2-3、性能优化—四次挥手</h3> <p>主动发起关闭方会经历 2MSL 时期，期间端口被占用，若发起方为服务端则还需同时处理大量TCP连接，可通过几个方式优化关闭流程；</p> <h3 id="_3-2-3-1、tcp-tw-reuse"><a href="#_3-2-3-1、tcp-tw-reuse" class="header-anchor">#</a> 3-2-3-1、tcp_tw_reuse</h3> <div class="language-http extra-class"><pre class="language-http"><code>net.ipv4.tcp_tw_reuse = 1
</code></pre></div><ul><li>开启后，作为客户端时，新连接可以使用仍处于 TIME-WAIT 状态的端口；</li> <li>由于 timestamp 存在，操作系统可拒绝迟到报文：<code>net.ipv4.tcp_timestamps = 1</code> <ul><li>timestamp 扩展包含两字段：发送时间 &amp; ACK 时间，相减得到 RTT，可通过 RTT 判断是否是延迟报文；</li></ul></li></ul> <h3 id="_3-2-3-2、其他方式"><a href="#_3-2-3-2、其他方式" class="header-anchor">#</a> 3-2-3-2、其他方式</h3> <p><strong><u>tcp_tw_recycle &amp; tcp_max_tw_buckets</u></strong></p> <div class="language-http extra-class"><pre class="language-http"><code>net.ipv4.tcp_tw_recycle = 0
</code></pre></div><ul><li>开启后，客户端和服务器均可使用 TIME-WAIT 状态端口；</li> <li>不安全，无法避免报文延迟、重复等，会给新连接造成混乱；</li></ul> <div class="language-http extra-class"><pre class="language-http"><code>net.ipv4.tcp_max_tw_buckets = 262144
</code></pre></div><ul><li>控制 time_wait 状态连接的最大数量；</li> <li>超出后直接关闭连接；</li></ul> <h3 id="_3-2-4、重置报文"><a href="#_3-2-4、重置报文" class="header-anchor">#</a> 3-2-4、重置报文</h3> <p>当发现到达的报文段对相关连接而言是不正确时，TCP 会发出重置报文段，此会导致 TCP 连接的快速拆卸：</p> <ul><li>某连接请求到达本地却无相关进程在目的端口监听
<ul><li>具体表现为 UDP 协议会生成一个 ICMP 目的不可达信息，而 TCP 则使用重置报文段来代替完成；</li></ul></li> <li>替代 FIN 来终止连接
<ul><li>正常终止连接的方法是发送 FIN，此亦称为有序释放，而在任意时刻通过重置报文段来释放连接的则称终止释放，此时任何排队的数据都将会被抛弃；</li></ul></li> <li>半开连接
<ul><li>若 A 端在未告知 B 端情况下 A 关闭或终止连接，则称此 TCP 连接处于半开状态；半开通常发生在主机崩溃或非正常关机的情况下；TCP 规定接收方回复一个重置报文段作为响应；</li></ul></li> <li>时间等待错误
<ul><li>在 TIME_WAIT 期间收到连接的报文或更为特殊的 RST 重置报文段时，就会发生时间等待错误 TIME-WAIT Assassination-TWA，即 RST 能破坏 TIME_WAIT 状态并强制连接提前关闭；目前许多系统通过不对 TIME-WAIT 状态时收到的 RST 报文作出回应来规避上述问题；</li></ul></li></ul> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200919112401.png" style="zoom:50%;"> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200919112402.png" style="zoom:50%;"> <h1 id="四、超时重传"><a href="#四、超时重传" class="header-anchor">#</a> 四、超时重传</h1> <h2 id="_4-1、基本"><a href="#_4-1、基本" class="header-anchor">#</a> 4-1、基本</h2> <p>TCP 会将消息拆分成许多 Segment 段，此后 TCP 还必须保证每个发送的 Segment 段一定会到达对方；</p> <p>TCP 重传与确认思想，在后续演化为滑动窗口，并再演化为后来的序列号，确认序列号，以及序列号设计理念；</p> <ul><li>注意：检测超时后(RTO)，重传特定报文(SACK)</li></ul> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200919112403.png" style="zoom:50%;"> <h3 id="_4-1-1、arq"><a href="#_4-1-1、arq" class="header-anchor">#</a> 4-1-1、ARQ</h3> <p>疑问：<a href="https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5c447392e51d45524b02eaf5" target="_blank" rel="noopener noreferrer">ARQ<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h2 id="_4-2、超时计算"><a href="#_4-2、超时计算" class="header-anchor">#</a> 4-2、超时计算</h2> <p>​	重传间隔也叫做 <strong><u>超时重传时间(Retransmission TimeOut，简称RTO)</u></strong>，RTO 的设置是保证 TCP 性能的关键；</p> <ul><li>注意：因涉及重传，RTT 计算复杂，精准测量需通过数据包中的 Timestamp 选项 (Timestamp 会将发送时间、接收时间一并存放)；</li> <li>注意：严格说 RTT 针对的是网络特性，并不局限于 TCP，在需要测量报文往返时间的场景都会用到，HTTP/3 开始关注传输层和网络层，也可能引入RTT；</li></ul> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200919112404.png" align="" style="zoom:50%;"> <h3 id="_4-2-1、rto-计算"><a href="#_4-2-1、rto-计算" class="header-anchor">#</a> 4-2-1、RTO 计算</h3> <ul><li>RTO 应略大于 RTT</li> <li>RTO 应当平滑，降低瞬时变化：每产生一次新的 RTT，就根据一定的算法对 SRTT(Smoothed round-trip time—Smoothed RTT) 进行更新，因平滑因子 α 的范围是<code>0.8 ~ 0.9</code>，RTT 对于 RTO 的影响太小， 适用于 RTT 稳定地方 —&gt; <strong><u>经典方法</u></strong>；</li></ul> <div class="language- extra-class"><pre class="language-text"><code>// 经典方法
// SRTT 初始值 = 0, α 为平滑因子，范围是0.8 ~ 0.9，建议值是0.8;
// β 为加权因子，一般为1.3 ~ 2.0， lbound 是下界，ubound 是上界;

1、计算平滑 RTT
SRTT =  (α * SRTT) + ((1 - α) * RTT)  

2、计算 RTO
RTO = min(ubound, max(lbound, β * SRTT))
</code></pre></div><ul><li>RTO 应当对 RTT 变化敏感 —&gt; <strong><u>标准方法</u></strong>：</li></ul> <div class="language- extra-class"><pre class="language-text"><code>// 标准方法(Jacobson/Karels 算法)
// α = 1/8 = 0.125, β = 1/4 = 0.25, K = 4, µ = 1, G = 最小时间颗粒;

1、首次计算 RTO(R为首次测量得到的 RTT):
SRTT = R
RTTVAR(round-trip-time variation) = R/2
RTO = SRTT + max(G, K*RTTVAR)

2、后续计算 RTO(R'为最新测量得到的 RTT):
SRTT = (1 - α) * SRTT + α * R'

// 记录最新的 RTT 与当前 SRTT 间的差值
RTTVAR = (1 - β) * RTTVAR + β * (|R' - SRTT|)

// 在 SRTT 的基础上加上了最新 RTT 与 SRTT 的偏移, 从而感知 RTT 变化
RTO = µ * SRTT + K * RTTVAR 
</code></pre></div><ul><li>RTO 应有边界：测量 RTT 时，TCP 时钟始终处于运转状态，TCP 时钟通常为某个变量，其值随系统时钟变化而更新(但非一对一同步更新)；将 TCP 时钟一个滴答时间长度称为 <em><strong>粒度</strong></em>，粒度会影响 RTT 测量及 RTO 的设置，粒度用于优化 RTO 的更新情况，并给 RTO 设置了一个下界，计算公式如下：</li></ul> <div class="language- extra-class"><pre class="language-text"><code>// G = 计时器粒度, 1000ms 为整个 RTO 下界值, RTO 至少为 1s
RTO = max(srtt + max(G, 4(rttvar)), 1000);
</code></pre></div><ul><li>时间戳小选项使发送端即使在丢包、延时、失序的情况下也能测量 RTT，使得 RTO 的设置更为精确；</li></ul> <h2 id="_4-3、重传机制演变"><a href="#_4-3、重传机制演变" class="header-anchor">#</a> 4-3、重传机制演变</h2> <p>补充：为消息引入序列号，解决应用层字节流的可靠发送，引入 Sequence 序列号 / Acknowledge 序列号 ；</p> <ul><li><strong>设计目的：解决应用层字节流的可靠发送；</strong> <ul><li>跟踪应用层的发送端数据是否送达；</li> <li>确定接收端有序接收到字节流；</li></ul></li> <li><strong>序列号的值针对的是字节而非报文；</strong> <ul><li>即序列号的值与报文包含的字节长度相关，比如某报文序列号 = 100，字节数是 50，则确认序号只能是151，而不能是其他值；</li></ul></li></ul> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200919112405.png" align="" style="zoom:50%;"> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200919112406.png" align="" style="zoom:50%;"> <p>问题：序列号的复用-PAWS序列号回绕问题(达序列号最大值后，新序列号会进行复用)；</p> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200919112407.png" style="zoom:50%;"> <p>解决：timestamps，见 TCP Options timestamp 描述；</p> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200919112408.png" align="" style="zoom:40%;"> <h3 id="_4-3-1、par"><a href="#_4-3-1、par" class="header-anchor">#</a> 4-3-1、PAR</h3> <p>即 Positive Acknowledgement with Retransmisson(基于计时器的重传)</p> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200919112409.png" style="zoom:50%;"> <p>​	<strong><u>基于计时器重传-PAR</u></strong>，消息增加标识，服务端接收后回传须包含标识，当发送报文就开启以定时器，若一定时间内未收到包含发出信息标识的确认报文时，则执行重发；缺点是网络利用率和效率低下，且对方接收与处理能力有限，需增加 limit 字段限制发送方；</p> <h3 id="_4-3-2、提升并发能力的-par-改进版"><a href="#_4-3-2、提升并发能力的-par-改进版" class="header-anchor">#</a> 4-3-2、提升并发能力的 PAR 改进版</h3> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200919112410.png" style="zoom:50%;"> <p>​	注意：为消息增加标识仅作用于报文，但 TCP 是面向字节流的，解决的是应用层字节流的可靠发送，故后续 TCP 中引入序列号和窗口大小，序列号的值是对应字节，比如：发送 Seq Number = 569，即第569字节，Segment 长度为 1328，则下一 segment 段的 Seq Number = 569 + 1328 = 1897，即第1897字节；</p> <h3 id="_4-3-3、快速重传"><a href="#_4-3-3、快速重传" class="header-anchor">#</a> 4-3-3、快速重传</h3> <p>详看 6-2-3、快速重传</p> <h3 id="_4-3-4、sack-带选择确认的重传"><a href="#_4-3-4、sack-带选择确认的重传" class="header-anchor">#</a> 4-3-4、SACK-带选择确认的重传</h3> <p>即 TCP Selective Acknowledgement；</p> <p>问题：TCP 序列号采用累积确认方式，当接收方没有收到报文5，但收到报文6、7、8，接收方只能反复告知发送方缺失报文5，但发送方无法立即获悉此情况，也立即无法得知报文6、7、8是否被对方接收到；此时 Server 发送窗口/Client 接收窗口停止；</p> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200919112411.png" style="zoom:70%;"> <p>此时发送方：</p> <ul><li>要么采用积极悲观 <em><strong><u>Go-Back-N</u></strong></em> 策略重传报文所有报文(5678)，但可能浪费带宽；</li> <li>要么采用保守乐观 <strong><u><em>Selective repeat ARQ (亦称 Selective Reject (SREJ))</em></u></strong> 策略只重传报文5，但大量丢包时效率低下；</li> <li>详见：https://tools.ietf.org/html/rfc3366#page-8；</li></ul> <p>​    解决：引入选择性确认 SACK，以更有效重传丢失报文段；</p> <p>比如：下述 SACK 表明报文3未收到，报文 4 已收到，此时 server 可单纯发送 3 即可，避免陷入上述两策略问题；</p> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200919112412.png" style="zoom:70%;"> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200919112413.png" style="zoom:50%;"> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200919112414.png" style="zoom:50%;"> <h3 id="_4-3-x、tcp-new-reno"><a href="#_4-3-x、tcp-new-reno" class="header-anchor">#</a> 4-3-x、TCP New Reno</h3> <h1 id="五、流量控制"><a href="#五、流量控制" class="header-anchor">#</a> 五、流量控制</h1> <p>​	TCP 需要把发送的数据放到<strong>发送缓存区</strong>, 将接收的数据放到<strong>接收缓存区</strong>，流量控制即通过控制接收缓存区的大小，来间接控制发送方的发送；若对方的接收缓存区满，则不能再继续发送；</p> <h2 id="_5-1、交互式通信"><a href="#_5-1、交互式通信" class="header-anchor">#</a> 5-1、交互式通信</h2> <h2 id="_5-2、延时确认与-nagle-算法"><a href="#_5-2、延时确认与-nagle-算法" class="header-anchor">#</a> 5-2、延时确认与 Nagle 算法</h2> <h2 id="_5-3、滑动窗口"><a href="#_5-3、滑动窗口" class="header-anchor">#</a> 5-3、滑动窗口</h2> <ul><li>注意：MSS 是防止报文在 IP 层分段；因每个路由器的分段标准都不同，若任由其基于IP分段，则效率低下；而滑动窗口为了告知对方，自身缓冲区还有多少，告知对方自身处理能力，此值大小可大于MSS的值；</li></ul> <h3 id="_5-3-1、发送端窗口"><a href="#_5-3-1、发送端窗口" class="header-anchor">#</a> 5-3-1、发送端窗口</h3> <p>描述：包含已发送且已确认、已发送但未确认、未发送但可以发送、未发送也不可以发送；</p> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200919112415.png" align="" style="zoom:50%;"> <ul><li>发送窗口：已发送但未确认部分 + 未发送但可以发送部分；</li> <li>可用窗口：未发送但可以发送部分，大小为 <code>SND.UNA + SND.WND - SND.NXT</code> <ul><li>SND 即 <code>send</code></li> <li>WND 即 <code>window</code></li> <li>UNA 即 <code>unacknowledged</code>，表示未被确认</li> <li>NXT 即 <code>next</code>，表示下一个发送的位置</li></ul></li></ul> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200919112416.png" align="" style="zoom:50%;"> <h3 id="_5-3-2、接收端窗口"><a href="#_5-3-2、接收端窗口" class="header-anchor">#</a> 5-3-2、接收端窗口</h3> <p>描述：约等于对端发送窗口的接收窗口大小，约等于是因为程序处理可能快速，此时 window 变大，但为告知对方己方窗口大小有延迟(传输)，故存在偏差；</p> <ul><li>REV 即 <code>receive</code></li> <li>NXT 表示下一个接收的位置</li> <li>WND 表示接收窗口大小</li></ul> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200919112417.png" align="" style="zoom:50%;"> <h3 id="_5-3-3、窗口滑动与流量控制"><a href="#_5-3-3、窗口滑动与流量控制" class="header-anchor">#</a> 5-3-3、窗口滑动与流量控制</h3> <p>​	客户端发送窗口大小等于服务端接收窗口大小，服务端发送窗口大小等于客户端接收窗口大小；</p> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200919112418.png" align="center" style="zoom:50%;"> <p>假设双方三次握手，初始化各自窗口大小均为 200 个字节(例子与上图无关)：</p> <ul><li>首先，此时若 A 给 B 发送 100 字节，则 A 的SND.NXT 右移 100 字节，即 A 当前的<strong>可用窗口</strong>减少 100 字节；</li> <li>然后，100 字节到达 B 端，并被放入 B 的缓冲队列中，但假若 B 目前无法处理那么多字节，只能处理 40 个字节，那么其余 60 个字节被留在缓冲队列中；因处理能力低下，故 B 的接收窗口应缩小，比如这里应缩小 60 字节，由 200 变为 140 字节，因缓冲队列还有 60 个字节没被处理；所以，B 在接下来的 ACK 报文中携带上缩小后的滑动窗口大小，即140；</li> <li>然后，A 端收到后，确认 B 已处理 40 字节，SND.UNA 右移 40 字节，并调整发送窗口大小为 140 字节；</li> <li>最后，如此往复；</li></ul> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200919112419.png" align="center" style="zoom:50%;"> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200919112420.png" align="center" style="zoom:50%;"> <h3 id="_5-3-4、系统缓冲区与滑动窗口关系"><a href="#_5-3-4、系统缓冲区与滑动窗口关系" class="header-anchor">#</a> 5-3-4、系统缓冲区与滑动窗口关系</h3> <p>注意：下图中发送与接收窗口大小不变，实际中，两窗口所存放字节数均存放在系统缓冲区中，系统会自动对缓冲区进行调整，或应用程序不及时处理也会对其造成影响；</p> <ul><li>应用层没有及时读取缓存，导致发送停滞
<ul><li><img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200919112421.png" align="" style="zoom:50%;"></li></ul></li> <li>收缩窗口导致丢包：应先收缩窗口，再减少缓存；并在窗口关闭后，定时探测窗口大小
<ul><li><img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200919112422.png" align="" style="zoom:50%;"></li></ul></li></ul> <p>飞行中报文的适合数量 = 最大接收窗口 = BPS *  RTT` ，相同带宽下，若 RTT 越大，接收窗口越大，应配置更大滑动窗口：</p> <div class="language-nginx extra-class"><pre class="language-nginx"><code><span class="token operator">/</span><span class="token operator">/</span> Linux 下调整接收窗口与应用缓存
net<span class="token punctuation">.</span>ipv4<span class="token punctuation">.</span>tcp_adv_win_scale <span class="token operator">=</span> <span class="token number">1</span>
应用缓存 <span class="token operator">=</span> buffer <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">^</span>tcp_adv_win_scale<span class="token punctuation">)</span>

<span class="token operator">/</span><span class="token operator">/</span> Linux 中对 TCP 缓冲区的调整方式
net<span class="token punctuation">.</span>ipv4<span class="token punctuation">.</span>tcp_rmem <span class="token operator">=</span> <span class="token number">4096</span> <span class="token number">87380</span> <span class="token number">6291456</span>
<span class="token operator">/</span><span class="token operator">/</span> 读缓存最小值、默认值、最大值，单位字节，覆盖 net<span class="token punctuation">.</span>core<span class="token punctuation">.</span>rmem_max
net<span class="token punctuation">.</span>ipv4<span class="token punctuation">.</span>tcp wmem <span class="token operator">=</span> <span class="token number">4096</span> <span class="token number">16384</span> <span class="token number">4194304</span>
<span class="token operator">/</span><span class="token operator">/</span> 写缓存最小值、默认值、最大值，单位字节，覆盖net<span class="token punctuation">.</span>core<span class="token punctuation">.</span>wmem_max
net<span class="token punctuation">.</span>ipv4<span class="token punctuation">.</span>tcp mem <span class="token operator">=</span> <span class="token number">1541646</span> <span class="token number">2055528</span> <span class="token number">3083292</span>
<span class="token operator">/</span><span class="token operator">/</span> 系统无内存压力、启动压力模式阀值、最大值，单位为页的数量
net<span class="token punctuation">.</span>ipv4<span class="token punctuation">.</span>tcp_moderate_rcvbuf <span class="token operator">=</span> <span class="token number">1</span>
<span class="token operator">/</span><span class="token operator">/</span> 开启自动调整缓存模式
</code></pre></div><h2 id="_5-4、性能优化"><a href="#_5-4、性能优化" class="header-anchor">#</a> 5-4、性能优化</h2> <p>描述：现实中，不仅需要考虑发送窗口的可用窗口，还需考虑发送效率；当有效信息比重低时，网络传输效率低下，比如 <strong>SWS(Silly Window  syndrome) 糊涂窗口综合征</strong>，应当在合理范围内大量传输小报文；</p> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200919112423.png" style="zoom:50%;"> <ul><li><p>策略1：<strong><u><em>SWS避免算法</em></u></strong>：</p> <ul><li>等待服务端，使其有时间处理缓冲区内容，避免频繁、值也愈发小的窗口大小调整，从而提升效率；</li> <li><img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200919112424.png" align="" style="zoom:40%;"></li></ul></li> <li><p>策略2：<strong><u><em>TCP delayed acknowledgment 延迟确认</em></u></strong></p> <ul><li><img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200919112425.png" align="" style="zoom:40%;"></li> <li>问题：上述策略共用存在问题：前者Nagle 发送后，后者 Delay 延迟确认，导致 Nagle 无法及时发送剩余消息；解决：关闭其中一个；</li> <li><img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200919112426.png" align="" style="zoom:40%;"></li></ul></li> <li><p>策略3：<strong><u><em>TCP_CORK</em></u></strong>，Nagle 允许有一个已发送但未确认小报文，而 <u><em><strong>TCP_CORK</strong></em></u> 要求所有必须大报文，但要求结合 <code>sendfile</code> 零拷贝技术实现；</p> <ul><li>普通场景：文件从磁盘拷贝到内存，再从内存发给 Linux Core TCP缓冲区，经过发送窗口再发往用户;</li> <li><code>sendfine</code> 场景： 直接由内核将磁盘文件读入到TCP发送缓冲区中直接发送，减少2次拷贝；</li></ul></li></ul> <h2 id="_5-5、安全问题"><a href="#_5-5、安全问题" class="header-anchor">#</a> 5-5、安全问题</h2> <p>TCP 窗口管理可能受到多种攻击，主要形式为资源耗尽，而较小的窗口会使得 TCP 传输减慢，且会更长地占用资源比如存储空间；</p> <ul><li>比如 LaBrea tarpit 程序在完成 TCP 三次握手后，要么不做任何行为，要么只产生些最小应答，不断减慢发送速率；
<ul><li>本质是减慢蠕虫传播速度，能防御流量攻击(防御工具被用于其他的攻击..)；</li></ul></li> <li>比如基于已知的持续计时器的缺陷，采用客户端 多 SYN Cookie 技术；
<ul><li>当推断出现资源耗尽时，允许其他进程关闭 TCP 连接以解决此类问题；</li></ul></li></ul> <h1 id="六、拥塞控制"><a href="#六、拥塞控制" class="header-anchor">#</a> 六、拥塞控制</h1> <h2 id="_6-1、基本"><a href="#_6-1、基本" class="header-anchor">#</a> 6-1、基本</h2> <p>​	TCP 负责控制发送接收两端间的流量，也要负责监控整个网络的拥塞情况并加以管理，而 TCP 协议向应用层提供不定长的字节流发送服务，就表明 TCP 协议先天性就有意愿占满网络中的带宽，当网络中许多 TCP 连接同时试图占满整个带宽时，有可能发生恶性拥塞事件，所以有必要启用拥塞控制，以减少拥塞情况，提升网络整体速度；</p> <ul><li>拥塞：路由器因无法处理高速率到达的流量而被迫丢弃数据信息的现象；</li> <li>指标：过去判断拥塞发生与否的指标：<em><strong>丢包</strong></em>、<em><strong>时延测量</strong></em>、<em><strong>显式拥塞通知(ECN)</strong></em> 等；</li> <li>注意：有线网络中，出现在路由器或交换机中的拥塞是造成丢包的主要原因；而无线网中，传输和接收错误是导致丢包的重要因素；</li></ul> <h3 id="_6-1-1、拥塞窗口"><a href="#_6-1-1、拥塞窗口" class="header-anchor">#</a> 6-1-1、拥塞窗口</h3> <p>​	根据接收方剩余缓存空间大小，在 TCP 头部设置了<u><em>通知窗口大小</em></u> 字段，该数值是 TCP 发送方调节发送速率的依据，即当接收速率或网络传输速率过慢时，就需要降低发送速率，而为实现此操作，在发送端引入一窗口控制变量，以确保发送窗口大小不超过接收端接收能力和网络传输能力，即  ***<u>TCP 发送端的发送速率 = min(接收速率，传输速率)</u>***；这个反映网络传输能力的变量称为 <strong><u><em>拥塞窗口 cwnd (congestion window)</em></u></strong> ，因此，<strong>发送端实际(可用)窗口 <em>W</em></strong> 即接收端通知窗口 awnd 和拥塞窗口 cwnd 的较小者：<code>W = min(cwnd，awnd)</code>，理论值。</p> <p>​	实际情况中，网络和接收端状况会随时间变化，awnd 与 cwnd 值也会随之改变，且由于缺少显示拥塞的明确信号，TCP 发送方无法直接获得 cwnd 准确值，因此 W、cwnd、awnd 的值均需根据经验设定并动态调节；此外为使网络资源得到高效利用，W 的值(反映网络中可存储的待发送数据量的大小)应接近 <u><em><strong>带宽延迟积(Bandwidth-Delay Product-BDP)，亦称最佳窗口大小</strong></em></u>。W的计算值等于 RTT 与链路中最小通行速率(即发送端与接收端传输路径中的”瓶颈“)的乘积；但 W 又不可过大以免引入不必要的时延；</p> <p>​	综述：发送方维持一个**<u><em>拥塞窗口 cwnd (congestion window)</em></u>** 的状态变量；其会动态变化，值的大小取决于网络的拥塞程度；发送方让自身发送窗口等于拥塞窗口，而其控制原则是：</p> <ul><li>若网络不拥塞则增大拥塞窗口以发送更多分组；</li> <li>若网络拥塞则减小拥塞窗口以减少注入网络的分组；</li></ul> <p>注意：此外，还有TCP 报文头部的 window 字段即 <strong><u><em>通告窗口</em></u></strong>，也即对方的 <strong><u><em>接收窗口</em></u></strong>；</p> <p>注意：若无丢包情况下(无拥塞)，<strong><u><em>拥塞窗口</em></u></strong> 大小是会以指数方式快速变大；</p> <ul><li><img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200919112427.png" align="" style="zoom:50%;"></li></ul> <h3 id="_6-1-2、拥塞控制发展"><a href="#_6-1-2、拥塞控制发展" class="header-anchor">#</a> 6-1-2、拥塞控制发展</h3> <ul><li>以丢包作为拥塞依据：
<ul><li>New Reno：RFC6582</li> <li>BIC：Linux 2.6.8 - 2.6.18</li> <li>CUBIC (RFC8312)：Linux 2.6.19</li></ul></li> <li>以探测带宽作为拥塞依据：
<ul><li>BBR：Linux 4.9</li></ul></li> <li>以延迟作为拥塞依据
<ul><li>Vegas：[BP95]</li> <li>FAST</li> <li>TCP Westwood &amp; Westwood+</li> <li>复合 TCP</li></ul></li></ul> <h2 id="_6-2、以丢包作为拥塞依据"><a href="#_6-2、以丢包作为拥塞依据" class="header-anchor">#</a> 6-2、以丢包作为拥塞依据</h2> <p>​	<strong><u>TCP 拥塞控制操作是基于数据包守恒原理运行的</u></strong>：TCP 发送方的拥塞控制操作是由 ACK 的接收来驱动或控制：当 TCP 传输处于稳定阶段，接收到 ACK 回复表明发送的数据包已被成功接收否则不能，继而推理知，稳定状态下的 TCP 拥塞行为，实际是试图使在网络传输路径上的数据包守恒；而 TCP 拥塞控制的两个核心算法：<strong><u>慢启动和拥塞避免，是基于包守恒和 ACK 时钟原理</u></strong>，注意此两算法不可同时运行，但可相互切换；</p> <h3 id="_6-2-1、慢启动"><a href="#_6-2-1、慢启动" class="header-anchor">#</a> 6-2-1、慢启动</h3> <p>当新的 TCP 连接建立、检测到由重传超时 RTO 导致的丢包、发送端长时处于空闲状态时，需要执行慢启动；</p> <p>慢启动目的是使 TCP 在用拥塞避免探寻可用带宽前得到 cwnd 值，以及帮助 TCP 建立 ACK 时钟；<strong>注意：慢启动并非指 cwnd 增长速率慢，而是指初始值小</strong>；</p> <ul><li><p>首先：TCP 刚开始传输数据时，并不清楚此时的网络状态，可先保守地缓慢地由小到大增大发送窗口，即逐渐增大拥塞窗口值；即 TCP 以发送一定数目的数据段开始慢启动，此时的窗口称为  <u>***初始窗口 IW (Initial Window)(拥塞窗口-cwnd)***</u> ，过去 IW 值初始设为 1SMSS (发送方的最大段大小)(<u>即 TCP 连接初始的 cwnd = 1SMSS，初始可用窗口 W 也为 1SMSS</u>)，现逐渐变迁如下：</p> <ul><li><img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200919112428.png" align="" style="zoom:40%;"></li> <li>注意：<strong>SMSS (SENDER MAXIMUM SEGMENT SIZE)</strong>：最大发送 Segment 段大小；</li> <li>注意：<strong>MSS (Maximum Segment Size)：</strong> 基本单位，值为 1460 字节或 576 字节；</li></ul></li> <li><p>然后：在接收到一个数据段的 ACK 后，cwnd 值由 1(SMSS) 变 2，随即发送两个数据段；若成功接收到相应新的 ACK，cwnd 便会由 2 变 4，以此类推，若一直未发生丢包且每个数据包都有相应 ACK，则 k 轮后 W 值为 W = 2^k，k = log2W，增长极快；</p> <ul><li><img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200919112429.png" align="" style="zoom:50%;"></li> <li>首先，三次握手，交换信息(含双方<strong>接收窗口大小 (rwnd)</strong>)；</li> <li>然后，双方各自初始化 <strong>拥塞窗口 (cwnd)</strong> 大小；</li> <li>然后，开始传输，每经过一<strong>传输轮次(RTT)</strong>，则将<strong>拥塞窗口(cwnd) 加倍 (每收到一 ACK，cnwd + 1，共有 cnwd 个 segment，故一轮下来 cnwd 将增加 cnwd 即翻倍)</strong>，以指数方式增长，直至触碰 <strong>慢启动阀值</strong>；</li></ul></li> <li><p>然后：cwnd 会快速增长，并同时确立一个慢启动阀值，一旦到达阀值，则进入拥塞避免阶段(避免后续因增长速度极大占用大量网络资源、增加网络不稳定性)，此时 cwnd 增长模式由指数级切换为线性级；</p> <ul><li><img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200919112430.png" style="zoom:50%;"></li></ul></li></ul> <h3 id="_6-2-2、拥塞避免"><a href="#_6-2-2、拥塞避免" class="header-anchor">#</a> 6-2-2、拥塞避免</h3> <p>​	而为防止 <strong>cwnd</strong> 增长过大引起网络拥塞，慢启动阶段还需计算并设置 <strong><u><em>慢启动阀值/门限 (ssthresh-slow start threshold)</em></u></strong> 状态量，当到达此值时则启用<strong>拥塞避免</strong>算法，以线性方式增加 cwnd，让 cwnd 缓慢增大，而非无节制增长：</p> <ul><li>慢启动与拥塞避免的最大区别在于：在新的 ACK 到达时，cwnd 怎么增长；</li></ul> <div class="language- extra-class"><pre class="language-text"><code>// 标准 TCP:
// 每接收到一个新的 ACK，cwnd 会做以下更新:
// 若 cwnd &lt; ssthresh 慢启动
cwnd += SMSS
// 若 cwnd &gt; ssthhresh 拥塞避免
cwnd += SMSS * SMSS / cwnd
</code></pre></div><p>​</p> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200919112430.png" style="zoom:50%;"> <p>​	具体表现为每经过一<strong>传输轮次(RTT)</strong>，则将<strong>拥塞窗口 cwnd + 1 (每收到一个 ACK，cnwd += 1/cnwd ，一共有 cnwd 个 segment，故一轮下来 cnwd 将加 1)</strong>，而非加倍，以线性方式增长；</p> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200919112431.png" style="zoom:40%;"> <p>​	无论在慢启动阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞(RTO)，则将设置**慢启动阀值/门限(ssthresh)**为出现拥塞时的，发送窗口值的一半(但不能小于2)，然后将拥塞窗口 cwnd 重新设置为 IW，再次进入慢启动，以迅速减少主机发送的分组数，使发生拥塞的节点有充足时间将队列中积压的分组处理完毕；</p> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200919112432.png" style="zoom:50%;"> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200919112433.png" style="zoom:50%;"> <p>注意：同一时刻只运行单个算法，但算法间可相互切换：</p> <ul><li>当 cwnd &lt; ssthresh 时，使用慢启动算法；</li> <li>当 cwnd = ssthresh 时，可使用慢启动算法，亦可使用拥塞避免算法；</li> <li>当 cwnd &gt; ssthresh 时，使用拥塞避免算法；</li></ul> <p><video src="/Image/NetWork/tcp/120.mov" align="" style="zoom:50%;"></video></p> <h3 id="_6-2-3、快速重传"><a href="#_6-2-3、快速重传" class="header-anchor">#</a> 6-2-3、快速重传</h3> <p>失序数据段产生原因：</p> <ul><li>若报文丢失，将产生连续失序 ACK 段；</li> <li>若网络路径与设备导致数据段失序，将产生少量失序 ACK 段；</li> <li>若报文重复，将产生少量失序 ACK 段；</li></ul> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200919112434.png" style="zoom:50%;"> <p>​	拥塞控制主要解决丢包问题，即场景一问题；在过去没有快速重传时，须等待 RTO，再发送 pkt1，效率低下，快速重传要求接收方每收到一个 <strong>失序报文</strong> 即立刻发出重复确认，而不用等到接收方自己发送数据时才进行捎带确认，以让发送方及早获悉有报文段没有到达；比如下图：</p> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200919112435.png" style="zoom:50%;"> <p>​	情景：B 端收到 M1M2 并回送确认 ACK，但未收到 M3，此时收到 M4M5：</p> <ul><li>过去：因 M4M5 为失序报文，根据可靠传输原理，B 端可什么都不做，也可在适当时机重发对 M2 的 ACK；</li> <li>现在：因使用快速重传算法，B 端应及时发送对 M2 的确认 ACK，以让发送方及早获悉 M3 没有到达，无论 B 端收到多少新报文，但均为失序报文，均继续发送对 M2 的确认 ACK；当 A 端收到 3 个重复 ACK 时，意识到丢包，并马上进行重传，而不用等待 RTO 时间到期才重传，由于发送方尽早重传未被确认报文段，因此采用此算法后可让整个网络吞吐量提高约 20%；</li></ul> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200919112436.png" style="zoom:50%;"> <ul><li>问题：无法得知具体缺失报文，是仅重传 M3，还是重传所有未确认报文，前者在大量丢包时效率低下，后者可能浪费带宽；</li> <li>解决：选择性重传(SACK，Selective Acknowledgment)，在 TCP 头部选项，通过 SACK 的 <code>left edge</code>、<code>right edge</code> 告知发送端已收到的区间的数据报，以更有效地重传；</li> <li>注意：<strong>快速重传</strong>，解决的是<strong>是否需要重传</strong>的问题；<strong>选择性重传(SACK，Selective Acknowledgment)</strong>，解决的是<strong>如何重传</strong>的问题；</li> <li>注意：快速重传意味着丢包，但收到重复 ACK，意味着网络仍在流动，没必要马上进入慢启动，因其会突然减少数据流，在正常且未失序 ACK 段到达前，启动快速恢复，更好利用网络资源；</li></ul> <h3 id="_6-2-4、快速恢复"><a href="#_6-2-4、快速恢复" class="header-anchor">#</a> 6-2-4、快速恢复</h3> <p>快恢复算法与快速重传配合使用：</p> <ul><li>首先，当发送方连续收到3个重复确认时，就执行“乘法减小”算法，将 <strong>慢启动阀值/门限 (ssthresh)</strong> 减半，但注意并非执行慢启动算法，而是将 cwnd 值设置为 <strong>慢启动阀值/门限 (ssthresh)</strong> 减半后的数值；</li> <li>然后，开始执行<strong>拥塞避免算法</strong> (“加法增大”)，使拥塞窗口缓慢地线性增大；总结即：
<ul><li>**慢启动阀值/门限 (ssthresh)**降低为 <strong>拥塞窗口(cwnd)</strong> 的一半</li> <li><strong>拥塞窗口(cwnd)</strong> 大小变为 <strong>慢启动阀值/门限 (ssthresh)</strong></li> <li><strong>拥塞窗口(cwnd)</strong> 线性增加</li></ul></li></ul> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200919112437.png" style="zoom:50%;"> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200919112438.png" style="zoom:50%;"> <ul><li><p>注意：快速恢复时 cwnd 为 ssthresh + 3 * MSS 是当时调研网络环境得出的经验数据；</p></li> <li><p>注意：不管单丢包还是连续丢包，每次仍返回应收但未收的 Seq ACK；</p></li> <li><p>注意：接收端中，当接收到的包的 Sequence number 与接收窗口中的 rcv.nxt 一样，才讲 ACK 的 Acknowledge number 更新为 rcv.nxt 值；否则 ack number 一直不变，此时发送端在连续收到含有不变 ack number 的 ACK，就可断定某包未被对方收到，从而启动快速重传；</p></li></ul> <h3 id="_6-2-5、tcp-发展历程"><a href="#_6-2-5、tcp-发展历程" class="header-anchor">#</a> 6-2-5、TCP 发展历程</h3> <h3 id="_6-2-5-1、tahoe、reno"><a href="#_6-2-5-1、tahoe、reno" class="header-anchor">#</a> 6-2-5-1、Tahoe、Reno</h3> <p>​	慢启动与拥塞避免算法，组成了 TCP 拥塞控制算法的一部分。它们于 20 世纪 80 年代末期在加州大学伯克利分校的 4.2 UNIX 版本中被提出，称为伯克利软件、或 BSD UNIX、或 Tahoe，此包含的 TCP 版本，在连接之初处于慢启动阶段，若检测到丢包，不论由于超时还是快速重传，都会重新进入慢启动状态，而出现丢包时，则简单地讲 cwnd 减为初始值以达到慢启动目的，直至 cwnd 增长为 ssthresh；</p> <ul><li><p>问题：对于有较大 BDP 的链路来说，宽带利用率低下 (丢包导致慢启动，但慢启动的 cwnd 初始值设置过小)；</p></li> <li><p>解决：针对不同丢包情况，重新考虑是否需要重回慢启动状态。若由重复 ACK 引起的丢包，则将 cwnd 值设为上一个 ssthresh，而非初始值 (绝大多数 TCP 版本中，超时仍是引发慢启动的主要原因)；</p> <p>在有较大 BDP 链路的情况，结合包守恒原理：只要收到 ACK，则有可能传输新的数据包。BSD UNIX 的 4.3 BSD Reno 版本中的快速重传机制即基于上述结论。恢复阶段，每收到一 ACK，cwnd 就能增长 1SMSS，即能发送新的数据包。因此拥塞窗口会在一段时间内急速增长，直到收到不重复的 ACK (表明 TCP 结束恢复阶段，拥塞已减少到之前状态)；</p></li></ul> <h3 id="_6-2-5-2、标准-tcp"><a href="#_6-2-5-2、标准-tcp" class="header-anchor">#</a> 6-2-5-2、标准 TCP</h3> <p>慢启动与拥塞避免算法通常结合使用，[RFC5681] 给出了基本方法(去实现)，而 TCP 的实现过程仅利用其核心思想，总结其中的结合算法，在TCP连接建立之初首先是慢后动阶段（cwnd = IW)，此时 ssthresh 通常取一较大值(至少为 awnd)，当接收到一个好的 ACK 表明新的数据传输成功时，cwnd 会作相应更新：</p> <div class="language- extra-class"><pre class="language-text"><code>cwnd += SMSS(若 cwnd&lt;ssthresh)慢启动

cwnd += SMSS*SMSS/cwnd(若cwnd&gt;ssthresh)拥塞避免
</code></pre></div><p>当收到三次重复 ACK (或其他表明需要快速重传的信号)时，会执行以下行为：</p> <ol><li>ssthresh 更新为大于等式 <code>ssthresh = max(在外数据值/2，2*SMSS)</code> 中的值</li> <li>启用快速重传算法，将 cwnd 设为  <code>(ssthresh + 3 * SMSS)</code></li> <li>每接收一个重复ACK，cwnd 值暂时增加 1SMSS</li> <li>当接收到一个好的ACK，将 cwnd 重设为 ssthresh</li></ol> <p>上述 2-3 步构成了**<u>快速恢复</u>**：</p> <ul><li>步骤 2 设置 cwnd 大小，首先 cwnd 减为先前值的一半；然后每接收一个重复ACK(意味着相应的数据包已成功传输，故新的数据包就有发送机会)，cwnd 值会相应地暂时增大；注意：此步也可能出现 cwnd 加速递减的情况，因为通常 cwnd 会乘以某个值来形成新的 cwnd；</li> <li>步骤 3 维持 cwnd 的增大过程，使得发送方在不超过awnd的情况下，可继续发送新的数据包；</li> <li>步骤 4 假设 TCP 已完成恢复阶段，故 cwnd 的临时膨胀也消除(收缩)；</li></ul> <p>以下两种情况总会执行**<u>慢启动</u>**：新连接的建立以及出现重传超时；当发送方长时间处于空闲状态，或有理由怀疑cwnd不能精确反映网络当前拥塞状态时，也可能引发慢启动。此时 cwnd 初始值将被设为重启窗口(RW)；在文献[RFC5681]中，推荐 RW 值为 RW=min(IW,cwnd)，其他情况下，慢启动中 cwnd 初始设为 IW.</p> <h3 id="_6-2-5-2-1、改进-newreno"><a href="#_6-2-5-2-1、改进-newreno" class="header-anchor">#</a> 6-2-5-2-1、改进-NewReno</h3> <p><strong><u>快速恢复带来问题</u></strong>：当一个传输窗口出现多个数据包丢失时，一旦其中一个包重传成功，发送方就会接收到一个好的ACK，这样快速恢复阶段中 cwnd 窗口的暂时膨胀就会停止，而事实上其他丢失的数据包可能并未完成重传；导致出现这种状况的 ACK 称为 ***局部 ACK(partial ACK)***；Reno 算法在接收到局部 ACK 后就停止拥塞窗口膨胀阶段，并将其减小至特定值，这种做法可能导致在重传计时器超时前，传输通道一直处于空闲状态，因为无选择确认机制的 TCP 需要通过 3 个(或重复阈值)重复 ACK 包作为信号才能触发快速重传机制。假如网络中没有足够的数据包在传输，则就不可能因丢包而触发快速重传，最终导致重传计时器超时，引发慢启动操作，从而严重影响网络吞吐性能。</p> <ul><li>同一窗口—多个包丢失—接收到局部 ACK—快速恢复阶段 cwnd 暂时固定—但其他数据包可能未完成重传—重传计时器超时—慢启动—影响性能</li></ul> <p><strong><u>为解决上述问题，[RFC3782] 提出改进算法 NewReno</u></strong>：该算法对快速恢复做出了改进，其<u>记录上一个数据传输窗口的最高序列号，仅当接收到序列号不小于恢复点的 ACK，才停正快速恢复阶段，如此 TCP 发送方每收一个 ACK 后就能继续发送一个新数据段，从而减少重传超时的发生</u>，特别针对一个窗口出现多个包丢失的情况时，NewReno 是现在比较常用的一个 TCP 版本，它不会出现经典快速重传的问题，实现起来也没有选择确认 (SACK) 复杂。然而，当出现上述多个丢包情况时，利用 SACK 机制能比 NewReno 获得更好的性能；</p> <h3 id="_6-2-5-2-2、改进-sack-与选择重复"><a href="#_6-2-5-2-2、改进-sack-与选择重复" class="header-anchor">#</a> 6-2-5-2-2、改进-SACK 与选择重复</h3> <h3 id="_6-2-5-2-3、改进-fack-与速率减半"><a href="#_6-2-5-2-3、改进-fack-与速率减半" class="header-anchor">#</a> 6-2-5-2-3、改进-FACK 与速率减半</h3> <h3 id="_6-2-5-2-4、改进-限制传输"><a href="#_6-2-5-2-4、改进-限制传输" class="header-anchor">#</a> 6-2-5-2-4、改进-限制传输</h3> <h3 id="_6-2-5-2-5、改进-拥塞窗口校验"><a href="#_6-2-5-2-5、改进-拥塞窗口校验" class="header-anchor">#</a> 6-2-5-2-5、改进-拥塞窗口校验</h3> <h3 id="_6-2-5-3、bic"><a href="#_6-2-5-3、bic" class="header-anchor">#</a> 6-2-5-3、BIC</h3> <p>使用二分搜索增大和加法增大两种算法来修改标准  TCP 发送端，使用阀值 Smax 控制算法的调用；</p> <h3 id="_6-2-5-4、cubic"><a href="#_6-2-5-4、cubic" class="header-anchor">#</a> 6-2-5-4、CUBIC</h3> <p>对 BIC 做改进，形成 CUBIC，使用高阶多项式函数控制窗口则增大；</p> <h2 id="_6-3、以探测带宽作为拥塞依据"><a href="#_6-3、以探测带宽作为拥塞依据" class="header-anchor">#</a> 6-3、以探测带宽作为拥塞依据</h2> <p><a href="https://queue.acm.org/detail.cfm?id=3022184" target="_blank" rel="noopener noreferrer">BBR论文<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>​	前述拥塞控制算法均基于丢包实现，不丢包不启用，2016年 Google 提出基于带宽探测的拥塞控制，极大提升了 TCP 的拥塞控制性能；</p> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200919112439.png" style="zoom:50%;"> <p>​	网络中的瓶颈路由器：当其等待队列全满或过载时就会发送拥塞，下图为大管道向小管道传输数据引发拥堵；</p> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200919112440.png" style="zoom:50%;"> <h3 id="_6-3-1、传统拥塞控制算法问题"><a href="#_6-3-1、传统拥塞控制算法问题" class="header-anchor">#</a> 6-3-1、传统拥塞控制算法问题</h3> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200919112441.png" style="zoom:50%;"> <ul><li>传统拥塞算法问题：变化不平滑；</li></ul> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200919112442.png" style="zoom:50%;"> <ul><li>CUBIC 拥塞控制算法变化平滑，但也基于丢包驱动，带来的时延也很大；</li></ul> <h3 id="_6-3-2、bbr-控制算法"><a href="#_6-3-2、bbr-控制算法" class="header-anchor">#</a> 6-3-2、BBR 控制算法</h3> <h3 id="_6-3-2-1、最佳控制点"><a href="#_6-3-2-1、最佳控制点" class="header-anchor">#</a> 6-3-2-1、最佳控制点</h3> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200919112443.png" style="zoom:50%;"> <ul><li>上图：y 轴 RTT，一开始，RTT不变，带宽增加，表示应用端进程并未开足马力发送数据，故 RRT 不变，带宽增加；等达到最大带宽后，路由器开始挤压队列，此后 RTT 开始变大；</li> <li>下图：y 轴 带宽，一开始带宽利用增加，到后面因达到最大带宽而不变，此时出现挤压；</li> <li>结论：传统拥塞控制在丢包时进行控制，但更好控制位置应在 RTT 开始变化时，此时控制发送速率，可享受最大带宽，且拥有最小时延和最低丢包率；</li> <li>问题：难以测量此控制点在哪；</li> <li>解决：目标是将路由器的缓冲队列降至 0，而关注路由器发现，刚开始挤压时即最佳控制点，即空队列时；</li> <li>注意：上述图表中，RTT 与 BW 独立变化，即 RTT 变慢时，BW 吞吐量可维持不变；同理，RTT 不变时，BW 可升高或降低；</li></ul> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200919112444.png" style="zoom:50%;"> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200919112445.png" style="zoom:50%;"> <h3 id="_6-3-2-2、bbr-基本"><a href="#_6-3-2-2、bbr-基本" class="header-anchor">#</a> 6-3-2-2、BBR 基本</h3> <p>BBR(TCP Bottleneck Bandwidth and Round-trip propagation time)  由 Google 于 2016 年发布，Linux 4.9 内核引入，QUIC 使用；但注意 QUIC 需要客户端支持，BBR 则无需终端支持，因其采用不同策略面对路由器上缓存队列产生的拥塞；</p> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200919112446.png" style="zoom:50%;"> <p>BBR 在 Youtube 上的应用结果：吞吐量提升、RTT 时延减少、重新缓冲时间间隔变长  (时延结果差异巨大，是因为每个国家路由器的缓冲队列长度不一样)；</p> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200919112447.png" style="zoom:50%;"> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200919112448.png" style="zoom:50%;"> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200919112449.png" style="zoom:50%;"> <h3 id="_6-3-2-3、bbr-原理"><a href="#_6-3-2-3、bbr-原理" class="header-anchor">#</a> 6-3-2-3、BBR 原理</h3> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200919112450.png" style="zoom:50%;"> <h3 id="_6-3-2-3-1、最佳控制点的寻找"><a href="#_6-3-2-3-1、最佳控制点的寻找" class="header-anchor">#</a> 6-3-2-3-1、最佳控制点的寻找</h3> <ul><li>RTT 中含有排队噪声 (ACK 延迟确认、网络设备排队等)，若能将 RTT 的排队噪声去除，剩下的即为 RTprop；RTprop：从发送数据到接收数据整个链路时间；</li> <li>若反复、多次测量 RTT，并取噪声最小值，则近似得出 RTprop；</li> <li>若反复、多次测量发送速率，取最大值，则近似得出 BtlBw；由此2个值找到最佳控制点；</li></ul> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200919112451.png" style="zoom:50%;"> <h3 id="_6-3-2-3-2、pacing-gain-调整"><a href="#_6-3-2-3-2、pacing-gain-调整" class="header-anchor">#</a> 6-3-2-3-2、pacing_gain 调整</h3> <ul><li>问题：TCP 链路发生变化，最佳控制点则会发生变化；</li> <li>解决：引入 pacing_gain，其用于检测带宽变化和线路变换，以迅速寻找最佳控制点；</li> <li>原理：pacing_gain 会进行周期性改变发送速率，来观察带宽与 RTT 的关系：
<ul><li>若检测时提升速率，带宽增加且 RTT 没有变化则可认为线路发生变化，直到RTT变化，此时降低发送速率，若 RTT 回归，则表示达到新链路的最佳控制点；</li> <li>若线路切换低速线路则过程大致同上；</li></ul></li> <li>循环：后续过程中，会不断进行周期性改变发送速率以检测变化，在拥塞的边缘来回不断试探；</li></ul> <p>下图是在10Mbps、40-ms 的链路环境下的 700ms 内的测量：</p> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200919112452.png" style="zoom:50%;"> <h3 id="_6-3-2-3-3、bbr-执行方式"><a href="#_6-3-2-3-3、bbr-执行方式" class="header-anchor">#</a> 6-3-2-3-3、BBR 执行方式</h3> <p>1、收到ACK时，更新 RTprop、BtlBw，找出最小 RTT，更新，计算发送速率，若带宽上升，则更新 BtlBw;</p> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200919112453.png" style="zoom:50%;"> <p>2、发送数据时，若超出带宽，则等待一段时间，发送时也会使用 pacing_gain 来探测有无带宽发生变化；</p> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200919112454.png" style="zoom:50%;"> <h3 id="_6-3-2-4、bbr-与-cubic-对比"><a href="#_6-3-2-4、bbr-与-cubic-对比" class="header-anchor">#</a> 6-3-2-4、BBR 与 CUBIC 对比</h3> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200919112455.png" style="zoom:50%;"> <ul><li>上图 y 轴：数据发送和接收的字节数，单位为MB，蓝线为收到的 ACK 确认；</li> <li>下图 y 轴：RTT；绿线为基于 BBR 发送字节数，红线为基于 CUBIC 发送字节数；</li> <li>结论：BBR 能及时排空瓶颈路由挤压队列数据，CUBIC 则无法实现，而且进入了拥塞控制阶段；</li></ul> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200919112456.png" style="zoom:50%;"> <ul><li>多条初始速度不同的 TCP 链路快速平均分享带宽(使用 BBR 后最后因 pacing_gain 的调整，最后均分带宽)；</li></ul> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200919112457.png" style="zoom:50%;"> <ul><li>Google B4 WAN 实践；</li></ul> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200919112458.png" style="zoom:50%;"> <ul><li>RTT 大幅下降</li></ul> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200919112459.png" style="zoom:50%;"> <ul><li>不同丢包率下的吞吐量：CUBIC VS BBR</li></ul> <h1 id="七、额外功能"><a href="#七、额外功能" class="header-anchor">#</a> 七、额外功能</h1> <h2 id="_7-1、保活机制-keepalive"><a href="#_7-1、保活机制-keepalive" class="header-anchor">#</a> 7-1、保活机制-KeepAlive</h2> <p>​	TCP Keep-Alive 是对长时间未发送数据的连接进行关闭处理(双向，两方均可检测，探测对端连接是否仍然有效)，以减少内存和端口等资源占用，关闭流程：若达到关闭条件，则向对方发送探测包：</p> <ul><li>若收到对方应答则表示此连接仍活跃，此时进入下一潜伏状态；</li> <li>若无收到对方应答，则间隔一定时间后再发送，若上述探测达到一定次数则关闭连接；</li></ul> <div class="language- extra-class"><pre class="language-text"><code>// 发送心跳周期(探测包)(单位: s)
net.ipv4.tcp_keepalive_time = 7200
// 探测包重试次数
net.ipv4.tcp_keepalive_probes = 9
// 探测包发送间隔(单位: s)
net.ipv4.tcp_keepalive_intvl = 75
</code></pre></div><p>​    查看 tcp keep-alive 相关状态：<code>sudo sysctl -a | grep keepalive</code>，但实际中大部分应用并无默认开启 TCP 的 <code>keep-alive</code>选项，原因是检测期太长(7200s=2h)，而若时间自定过短也失去此功能的原有意义；</p> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200919112500.png" align="center" style="zoom:50%;"> <h2 id="_7-2、多路复用-multiplexing"><a href="#_7-2、多路复用-multiplexing" class="header-anchor">#</a> 7-2、多路复用-Multiplexing</h2> <h3 id="_7-2-1、基本"><a href="#_7-2-1、基本" class="header-anchor">#</a> 7-2-1、基本</h3> <p>​	TCP 是面向字节流的不定长的协议，较难实现 TCP 多路复用，但可从编程层面实现 TCP 多路复用；</p> <ul><li>多路复用：在一个信道上传输多路信号或数据流的过程和技术</li> <li><img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200919112501.png" align="" style="zoom:50%;"></li> <li>HTTP2 的多路复用是基于 TCP 连接上的多路复用</li> <li><img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200919112502.png" align="" style="zoom:50%;"></li></ul> <h3 id="_7-2-2、编程实现"><a href="#_7-2-2、编程实现" class="header-anchor">#</a> 7-2-2、编程实现</h3> <ul><li>1、非阻塞 socket：同时处理多个 TCP 连接</li></ul> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200919112503.png" align="" style="zoom:50%;"> <ul><li>2、epoll + 非阻塞 socket</li></ul> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200919112504.png" align="" style="zoom:50%;"> <ul><li>2-1、红黑树存放所有连接，(发生变化)事件触发，存放队列中；</li></ul> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200919112505.png" align="" style="zoom:50%;"> <ul><li>3、epoll + 非阻塞 socket + 同步编程 = 协程</li></ul> <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200919112506.png" align="" style="zoom:50%;"> <h2 id="_6-x、总结"><a href="#_6-x、总结" class="header-anchor">#</a> 6-X、总结</h2> <ul><li>滑动窗口解决了数据的丢包、顺序不对和流量控制问题</li> <li>拥塞窗口实现了对流量的控制，保证在全天候环境下最优的传递数据</li></ul> <p>拥塞处理包括了四个算法，分别为：慢开始，拥塞避免，快速重传，快速恢复：</p> <ul><li><p>慢开始算法：在传输开始时将发送窗口慢慢指数级扩大，从而避免一开始就传输大量数据导致网络拥塞；</p> <ul><li>连接初始设置拥塞窗口（Congestion Window） 为 1 MSS (一个分段的最大数据量)；</li> <li>每过一个 RTT 就将窗口大小乘二；</li> <li>指数级增长肯定不能没有限制的，所以有一个阈值限制，当窗口大小大于阈值时就会启动拥塞避免算法；</li></ul></li> <li><p>拥塞避免算法：每过一个 RTT 窗口大小只加一，这样能够避免指数级增长导致网络拥塞，慢慢将大小调整到最佳值；在传输过程中可能定时器超时的情况，这时候 TCP 会认为网络拥塞了，会马上进行以下步骤：</p> <ul><li>将阈值设为当前拥塞窗口的一半</li> <li>将拥塞窗口设为 1 MSS</li> <li>启动拥塞避免算法</li></ul></li> <li><p>快速重传：一般和快恢复一起出现；一旦接收端收到的报文出现失序的情况，接收端只会回复最后一个顺序正确的报文序号。如果发送端收到三个重复的 ACK，无需等待定时器超时而是直接启动快速重传算法。具体算法分为两种：</p> <ul><li>TCP Taho：
<ul><li>将阈值设为当前拥塞窗口的一半</li> <li>将拥塞窗口设为 1 MSS</li> <li>重新开始慢开始算法</li></ul></li> <li>TCP Reno：
<ul><li>拥塞窗口减半</li> <li>将阈值设为当前拥塞窗口</li> <li>进入快恢复阶段（重发对端需要的包，一旦收到一个新的 ACK 答复就退出该阶段），这种方式在丢失多个包的情况下就不那么好了</li> <li>使用拥塞避免算法</li></ul></li> <li>TCP NewReno：
<ul><li>改进了之前 TCP Reno 算法的缺陷：快恢复中只要收到一个新的 ACK 包，就会退出快恢复，在  TCP New  Reno 中，TCP 发送方先记下三个重复 ACK 的分段的最大序号；比如：假如我有一个分段数据是 1 ~ 10 这十个序号的报文，其中丢失了序号为 3 和 7 的报文，那么该分段的最大序号就是 10。发送端只会收到 ACK 序号为 3 的应答。这时候重发序号为 3 的报文，接收方顺利接收的话就会发送 ACK 序号为 7 的应答。这时候 TCP 知道对端是有多个包未收到，会继续发送序号为 7 的报文，接收方顺利接收并会发送 ACK 序号为 11 的应答，这时发送端认为这个分段接收端已经顺利接收，接下来会退出快恢复阶段；</li></ul></li></ul></li></ul> <h1 id="x、转载"><a href="#x、转载" class="header-anchor">#</a> X、转载</h1> <ul><li><a href="https://time.geekbang.org/course/intro/175" target="_blank" rel="noopener noreferrer">Web协议详解与抓包实战—陶辉<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://book.douban.com/subject/26790659/" target="_blank" rel="noopener noreferrer">《TCP/IP详解：卷1》<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://book.douban.com/subject/30280001/" target="_blank" rel="noopener noreferrer">《计算机网络：自顶向下方法》<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://juejin.im/post/5e527c58e51d4526c654bf41" target="_blank" rel="noopener noreferrer">TCP文章—神三元<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div> <footer class="page-edit" style="display:none;"><!----> <div class="last-updated"><span class="prefix">最后更新: </span> <span class="time">9/27/2020, 11:17:54 AM</span></div></footer> <!----> <!----> <!----></main> <!----></div></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div></div></div>
    <script src="/assets/js/app.58d463af.js" defer></script><script src="/assets/js/3.5b6bd7ce.js" defer></script><script src="/assets/js/1.53e5735b.js" defer></script><script src="/assets/js/201.1e492eea.js" defer></script>
  </body>
</html>
