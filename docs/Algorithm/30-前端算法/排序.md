# 一、基本排序

**<u>*基本排序的基本思想非常类似：重排列时用的技术基本都是一组嵌套的for循环: 外循环遍历数组的每一项，内循环则用于比较元素*</u>**

```js
/**
 * 输出类
 */
function Logger(func, target) {
  console.log(`输入内容: ${target}`);
  console.log(`输出结果: ${func} 排序:`, sort[func](target), '\n');
}

function Sort() {}
const sort = new Sort();
```



## 1-1、冒泡排序-BubbleSort

![](https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200921074158.gif )

```js
/**
 * 1-冒泡排序-BubbleSort
 * 原理: 遍历所有元素，前后两两比较，小的前置，大的后置，直至遍历完成
 * 实现: 内外两层循环，外层循环控制次数；内层循环比较前后值，若前值小于后值则交换位置，重复比对直至达到外层循环值
 * 核心: 前后两两交换
 */
Sort.prototype.BubbleSort = function(array) {
  // 外层循环，从最大值开始递减，因内层两两比较，故最外层当 >=2 时即可停止
  for(let outer = array.length; outer >= 2; outer--) {
    let finishFlag = true;
    // 优化1: 每外层循环1次，最右侧便可获取1最大值，即内层循环可以少1次，不明白可以看图
    for(let inner = 0; inner < outer - 1; inner++) {
      if(array[inner] > array[inner + 1]) {
        finishFlag = false;
        [array[inner], array[inner+1]] = [array[inner+1], array[inner]];
      }
    }
    // 优化2: 若1次内循环中没有前值小于后值的情况，则表示全部已为顺序，即可返回结果了
    if(finishFlag) {
      return array;
    }
  }
  return array;
}
Logger('BubbleSort', [10, 2, 7, 4, 6, 1, 9]);
```







## 1-2、选择排序-SelectionSort

![](https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200921074204.gif )

```js
/**
 * 2-选择排序-SelectionSort
 * 原理: 从数组的开头开始，将首个元素与其他元素比较，检查完所有元素后，最小的放在首位；然后按相同逻辑处理后续元素直到最后
 * 实现: 外层循环控制次数，内层负责存改变 min 值，一旦发现比当前索引值的值小，就交换位置
 * 核心: 找到比开头小的，互换位置或记录最小值索引循环后才交换位置;
 */
Sort.prototype.SelectionSort = function(array) {
  for(let outer = 0; outer < array.length - 1; outer++) {
    let min = outer;
    // 优化1: 左侧是已排序完了的，索引从 outer + 1 开始
    for(let inner = outer + 1; inner <= array.length - 1; inner++) {
      if(array[min] > array[inner]) {
        // 优化2: 只记录最小值索引，比较完成才一次性交换值
        min = inner;
      }
    }
    [array[outer], array[min]] = [array[min], array[outer]];
  }
  return array;
}
Logger('SelectionSort', [10, 2, 7, 4, 6, 1, 9]);
```





## 1-3、插入排序-InsertionSort

![](https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200921074205.gif )



```js
/**
 * 3-插入排序-InsertionSort
 * 原理: 遍历，抽出，与前面的内容逐个比较，若抽出值比某项大，则插入其后面
 * 实现: 外层循环控制次数，内层循环控制与前面的值的比较与插入
 * 核心: 扑克牌思想, 抽出值小于前一个值，则让前一个值占据抽出值的位置，自己占据前值位置，循环往复
 */
Sort.prototype.InsertionSort = function(array) {
  for(let outer = 1; outer < array.length; outer++) {
    const target = array[outer];
    for(let inner = outer; inner > 0; inner--) {
      if(target <= array[inner-1]) {
        array[inner] = array[inner - 1];
        array[inner - 1] = target;
      }
    }
    // 或
    // while (inner > 0 && (arr[inner - 1] >= target)) {
    //   arr[inner] = arr[inner - 1]
    //   --inner
    // }
    // arr[inner] = target
  }
  return array;
}
Logger('InsertionSort', [10, 2, 7, 4, 6, 1, 9]);
```





## 1-X、时间复杂度对比

| 排序算法     | 平均时间复杂度 | 最坏时间复杂度 | 空间复杂度 | 是否稳定 |
| ------------ | :------------: | :------------: | :--------: | :------: |
| 冒泡排序     |     O(n²)      |     O(n²)      |    O(1)    |    是    |
| 选择排序     |     O(n²)      |     O(n²)      |    O(1)    |   不是   |
| 直接插入排序 |     O(n²)      |     O(n²)      |    O(1)    |    是    |

- 注意：插入排序时，若序列逆序，则每次插入都要一次次交换，此时速度和冒泡排序是一样，时间复杂度O(n²)；
- 注意：基本排序算法 ：基本思想就是两层循环嵌套，第一遍找元素O(n),第二遍找位置O(n)，所以这几种方法，时间复杂度就可以这么简便记忆啦!
- 注意：排序数据较多时，插入排序最快，选择排序第二，冒泡排序最慢；





# 二、高级排序

如果所有排序都像上面的基本方法一样，那么对于大量数据的处理，将是灾难性的



## 2-1、快速排序-QuickSort

![](https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200921074206.gif )

```js
// 快排是处理大数据最快的排序算法之一；而对前端来说，快排是最最最最重要的排序算法，没有之一
/**
 * 1-快速排序—QuickSort
 * 原理: 分而治之思想，通过递归方式，将数据依次分解为包含较小元素和较大元素的不同子序列；
 * 实现: 找一个数作为参考数 A，比这它大的数放在 A 左边，比它小的放在 A 右边； 然后分别再对左边和右边的序列做相同的操作:
 * 核心: 递归 + 拼接
 * 特点: 非常适用于大型数据集合；在处理小数据集时性能反而会下降；
 */
Sort.prototype.QuickSort = function(array) {
  if(array.length <= 1) {
    return array;
  };
  let left = [], right = [], basePoint = array.splice(0, 1);
  for(let i = 0; i < array.length; i++) {
    // 左塞右塞
    array[i] < basePoint ? left.push(array[i]) : right.push(array[i]);
  }
  return sort.QuickSort(left).concat(basePoint, sort.QuickSort(right));
}
Logger('QuickSort', [10, 2, 7, 4, 6, 1, 9]);
```



### 2-1-1、Array Sort 快排体现

### 2-1-1-1、V8 实现思路

V8 源码中排序的思路：假设要排序的元素个数是 n：

- 当 n <= 10 时，采用 **<u>插入排序</u>**；
- 当 n > 10 时，采用 **<u>三路快速排序</u>**：
  - 10 < n <= 1000，<u>采用中位数作为哨兵元素</u>；
  - n > 1000，每隔 200~215 个元素挑出一个元素，放到一个新数组，然后对它排序，找到中间位置的数，以此作为中位数

- 注意：虽 <u>插入排序</u> 理论上是 O(n^2) 算法，<u>快速排序</u> 是 O(nlogn) 级算法；但实际情况中，当 n 越小，快排优势会越来越小，若 n 足够小，插入甚至会比快排高效；因此，对于很小的数据量，V8 应用的是 插入排序；
- 注意：费力选择哨兵元素的原因是避免快排效率退化：快排性能瓶颈在于递归的深度，最坏的情况是每次的哨兵都是最小元素或最大元素，此时进行 partition时(一边是小于哨兵的元素，另一边是大于哨兵的元素)，就会有一边是空的，如此下去，递归层数就达到 n 次，而每一层的复杂度是 O(n)，因此快排此时会退化成 O(n^2) 级别；
- 所以：让哨兵元素尽可能地处于数组中间位置，让最大或最小的情况尽可能减少；所以 V8 才做了如此多的优化；

### 2-1-1-2、插入排序及优化

```js
// 插入排序
const insertSort = (arr, start = 0, end) => {
  end = end || arr.length;
  for(let i = start; i < end; i++) {
    let j;
    for(j = i; j > start && arr[j - 1] > arr[j]; j --) {
      let temp = arr[j];
      arr[j] = arr[j - 1];
      arr[j - 1] = temp;
    }
  }
  return;
}

// 交换元素会有相当大的性能消耗，可用变量覆盖的方式代替

// 排序优化
const insertSort = (arr, start = 0, end) => {
  end = end || arr.length;
  for(let i = start; i < end; i++) {
    let e = arr[i];
    let j;
    for(j = i; j > start && arr[j - 1] > e; j --)
      arr[j] = arr[j-1];
    arr[j] = e;
  }
  return;
}
```

### 2-1-1-3、哨兵元素

```js
// sort 基本骨架
Array.prototype.sort = (comparefn) => {
  let array = Object(this);
  let length = array.length >>> 0;
  return InnerArraySort(array, length, comparefn);
}

const InnerArraySort = (array, length, comparefn) => {
  // 比较函数未传入
  if (Object.prototype.toString.call(callbackfn) !== "[object Function]") {
    comparefn = function (x, y) {
      if (x === y) return 0;
      x = x.toString();
      y = y.toString();
      if (x == y) return 0;
      else return x < y ? -1 : 1;
    };
  }
  const insertSort = () => {
    //...
  }
  const getThirdIndex = (a, from, to) => {
    // 元素个数大于1000时寻找哨兵元素
  }
  const quickSort = (a, from, to) => {
    //哨兵位置
    let thirdIndex = 0;
    while(true) {
      if(to - from <= 10) {
        insertSort(a, from, to);
        return;
      }
      if(to - from > 1000) {
        thirdIndex = getThirdIndex(a, from , to);
      }else {
        // 小于1000 直接取中点
        thirdIndex = from + ((to - from) >> 2);
      }
    }
    //下面开始快排
  }
}

// 哨兵位置寻找实现
const getThirdIndex = (a, from, to) => {
  let tmpArr = [];
  // 递增量，200~215 之间，因为任何正数和15做与操作，不会超过15，当然是大于0的
  let increment = 200 + ((to - from) & 15);
  let j = 0;
  from += 1;
  to -= 1;
  for (let i = from; i < to; i += increment) {
    tmpArr[j] = [i, a[i]];
    j++;
  }
  // 把临时数组排序，取中间的值，确保哨兵的值接近平均位置
  tmpArr.sort(function(a, b) {
    return comparefn(a[1], b[1]);
  });
  let thirdIndex = tmpArr[tmpArr.length >> 1][0];
  return thirdIndex;
}
```

### 2-1-1-4、快速排序

```js
const _sort = (a, b, c) => {
  let arr = [a, b, c];
  insertSort(arr, 0, 3);
  return arr;
}

const quickSort = (a, from, to) => {
  //...
  // 上面我们拿到了thirdIndex
  // 现在我们拥有三个元素，from, thirdIndex, to
  // 为了再次确保 thirdIndex 不是最值，把这三个值排序
  [a[from], a[thirdIndex], a[to - 1]] = _sort(a[from], a[thirdIndex], a[to - 1]);
  // 现在正式把 thirdIndex 作为哨兵
  let pivot = a[thirdIndex];
  // 正式进入快排
  let lowEnd = from + 1;
  let highStart = to - 1;
  // 现在正式把 thirdIndex 作为哨兵, 并且lowEnd和thirdIndex交换
  let pivot = a[thirdIndex];
  a[thirdIndex] = a[lowEnd];
  a[lowEnd] = pivot;
  
  // [lowEnd, i)的元素是和pivot相等的
  // [i, highStart) 的元素是需要处理的
  for(let i = lowEnd + 1; i < highStart; i++) {
    let element = a[i];
    let order = comparefn(element, pivot);
    if (order < 0) {
      a[i] = a[lowEnd];
      a[lowEnd] = element;
      lowEnd++;
    } else if(order > 0) {
      do{
        highStart--;
        if(highStart === i) break;
        order = comparefn(a[highStart], pivot);
      }while(order > 0)
      // 现在 a[highStart] <= pivot
      // a[i] > pivot
      // 两者交换
      a[i] = a[highStart];
      a[highStart] = element;
      if(order < 0) {
        // a[i] 和 a[lowEnd] 交换
        element = a[i];
        a[i] = a[lowEnd];
        a[lowEnd] = element;
        lowEnd++;
      }
    }
  }
  // 永远切分大区间
  if (lowEnd - from > to - highStart) {
    // 继续切分lowEnd ~ from 这个区间
    to = lowEnd;
    // 单独处理小区间
    quickSort(a, highStart, to);
  } else if(lowEnd - from <= to - highStart) {
    from = highStart;
    quickSort(a, from, lowEnd);
  }
}
```

### 2-1-1-5、完整实现

```js
const sort = (arr, comparefn) => {
  let array = Object(arr);
  let length = array.length >>> 0;
  return InnerArraySort(array, length, comparefn);
}

const InnerArraySort = (array, length, comparefn) => {
  // 比较函数未传入
  if (Object.prototype.toString.call(comparefn) !== "[object Function]") {
    comparefn = function (x, y) {
      if (x === y) return 0;
      x = x.toString();
      y = y.toString();
      if (x == y) return 0;
      else return x < y ? -1 : 1;
    };
  }
  const insertSort = (arr, start = 0, end) => {
    end = end || arr.length;
    for (let i = start; i < end; i++) {
      let e = arr[i];
      let j;
      for (j = i; j > start && comparefn(arr[j - 1], e) > 0; j--)
        arr[j] = arr[j - 1];
      arr[j] = e;
    }
    return;
  }
  const getThirdIndex = (a, from, to) => {
    let tmpArr = [];
    // 递增量，200~215 之间，因为任何正数和15做与操作，不会超过15，当然是大于0的
    let increment = 200 + ((to - from) & 15);
    let j = 0;
    from += 1;
    to -= 1;
    for (let i = from; i < to; i += increment) {
      tmpArr[j] = [i, a[i]];
      j++;
    }
    // 把临时数组排序，取中间的值，确保哨兵的值接近平均位置
    tmpArr.sort(function (a, b) {
      return comparefn(a[1], b[1]);
    });
    let thirdIndex = tmpArr[tmpArr.length >> 1][0];
    return thirdIndex;
  };

  const _sort = (a, b, c) => {
    let arr = [];
    arr.push(a, b, c);
    insertSort(arr, 0, 3);
    return arr;
  }

  const quickSort = (a, from, to) => {
    //哨兵位置
    let thirdIndex = 0;
    while (true) {
      if (to - from <= 10) {
        insertSort(a, from, to);
        return;
      }
      if (to - from > 1000) {
        thirdIndex = getThirdIndex(a, from, to);
      } else {
        // 小于1000 直接取中点
        thirdIndex = from + ((to - from) >> 2);
      }
      let tmpArr = _sort(a[from], a[thirdIndex], a[to - 1]);
      a[from] = tmpArr[0]; a[thirdIndex] = tmpArr[1]; a[to - 1] = tmpArr[2];
      // 现在正式把 thirdIndex 作为哨兵
      let pivot = a[thirdIndex];
      [a[from], a[thirdIndex]] = [a[thirdIndex], a[from]];
      // 正式进入快排
      let lowEnd = from + 1;
      let highStart = to - 1;
      a[thirdIndex] = a[lowEnd];
      a[lowEnd] = pivot;
      // [lowEnd, i)的元素是和pivot相等的
      // [i, highStart) 的元素是需要处理的
      for (let i = lowEnd + 1; i < highStart; i++) {
        let element = a[i];
        let order = comparefn(element, pivot);
        if (order < 0) {
          a[i] = a[lowEnd];
          a[lowEnd] = element;
          lowEnd++;
        } else if (order > 0) {
          do{
            highStart--;
            if (highStart === i) break;
            order = comparefn(a[highStart], pivot);
          }while (order > 0) ;
          // 现在 a[highStart] <= pivot
          // a[i] > pivot
          // 两者交换
          a[i] = a[highStart];
          a[highStart] = element;
          if (order < 0) {
            // a[i] 和 a[lowEnd] 交换
            element = a[i];
            a[i] = a[lowEnd];
            a[lowEnd] = element;
            lowEnd++;
          }
        }
      }
      // 永远切分大区间
      if (lowEnd - from > to - highStart) {
        // 单独处理小区间
        quickSort(a, highStart, to);
        // 继续切分lowEnd ~ from 这个区间
        to = lowEnd;
      } else if (lowEnd - from <= to - highStart) {
        quickSort(a, from, lowEnd);
        from = highStart;
      }
    }
  }
  quickSort(array, 0, length);
}
```

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200908100706.png" style="zoom:50%;" align=""/>

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200908100707.png" style="zoom:50%;" align=""/>

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200908100708.png" style="zoom:50%;" align=""/>

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200908100709.png" style="zoom:50%;" align=""/>





## 2-2、希尔排序-ShellSort

希尔排序是插入排序的改良算法，但是核心理念与插入算法又不同，它会先比较距离较远的元素，而非相邻的元素；

![](https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200921074207.gif )

```js
// 插入排序
function insertSort(arr) {
    for(let i = 1; i < arr.length - 1; i++) {  //外循环从1开始，默认arr[0]是有序段
        for(let j = i; j > 0; j--) {  //j = i,将arr[j]依次插入有序段中
            if(arr[j] < arr[j-1]) {
                [arr[j],arr[j-1]] = [arr[j-1],arr[j]];
            } else {
                continue;
            }
        }
    }
    return arr;
}

// 希尔排序
// 不同之处: 让步长按照 3、2、1 来进行比较，相当于是三层循环和嵌套
insertSort(arr,[3,2,1]);
function shellSort(arr,gap) {
  	// 观察过程
    console.log(arr) 
  	// 最外层循环，一次取不同的步长，步长需要预先给出
    for(let i = 0; i<gap.length; i++) {  
      	//步长为 n
        let n = gap[i]; 
      	// 接下类和插入排序一样，j 循环依次取后面的数 - 插入排序部分，但区别是 1 变为了 n
      	// 也即三层循环的内两层完全就是一个插入排序，但略有不同
        for(let j = i + n; j < arr.length; j++) { 
          	// k 循环进行比较，和直接插入的唯一区别是 1 变为了 n
            for(let k = j; k > 0; k-=n) { 
                if(arr[k] < arr[k-n]) {
                    [arr[k],arr[k-n]] = [arr[k-n],arr[k]];
                  	// 观察过程
                    console.log(`当前序列为[${arr}] \n 交换了${arr[k]}和${arr[k-n]}`)
                } else {
                    continue;
                }
            }
        }
    }
    return arr;
}

// 运行
var arr = [3, 2, 45, 6, 55, 23, 5, 4, 8, 9, 19, 0];
var gap = [3,2,1];
console.log(shellSort(arr,gap))
// (12) [3, 2, 45, 6, 55, 23, 5, 4, 8, 9, 19, 0] // 初始值
// 当前序列为[3,2,23,6,55,45,5,4,8,9,19,0] 
//  交换了45和23
// 当前序列为[3,2,23,5,55,45,6,4,8,9,19,0] 
//  交换了6和5
// 当前序列为[3,2,23,5,4,45,6,55,8,9,19,0] 
//  交换了55和4
// 当前序列为[3,2,23,5,4,8,6,55,45,9,19,0] 
//  交换了45和8
// 当前序列为[3,2,8,5,4,23,6,55,45,9,19,0] 
//  交换了23和8
// 当前序列为[3,2,8,5,4,23,6,19,45,9,55,0] 
//  交换了55和19
// 当前序列为[3,2,8,5,4,23,6,19,0,9,55,45] 
//  交换了45和0
// 当前序列为[3,2,8,5,4,0,6,19,23,9,55,45] 
//  交换了23和0
// 当前序列为[3,2,0,5,4,8,6,19,23,9,55,45] 
//  交换了8和0
// 当前序列为[0,2,3,5,4,8,6,19,23,9,55,45] 
//  交换了3和0
// 当前序列为[0,2,3,5,4,8,6,9,23,19,55,45] 
//  交换了19和9
// 当前序列为[0,2,3,4,5,8,6,9,23,19,55,45] 
//  交换了5和4
// 当前序列为[0,2,3,4,5,6,8,9,23,19,55,45] 
//  交换了8和6
// 当前序列为[0,2,3,4,5,6,8,9,19,23,55,45] 
//  交换了23和19
// 当前序列为[0,2,3,4,5,6,8,9,19,23,45,55] 
//  交换了55和45



function shellSort(arr,gaps) {
  // 遍历间隔序列
  for(let g=0; g<gaps.length; g++) {
    let gap = gaps[g]
    // 使用间隔遍历数据
    for(let i=gap; i<arr.length; i++) {
      // 以下是插入操作
      // 例如[1,3,4,2]，其中最后一个数字2是带插入[1,3,4]中的数据，间隔如果是1
      // 先将2和4比较，因为2小于4，则4后移变成[1,3,4,4]
      // 再将2和3比较，因为2小于3，则3后移变成[1,3,3,4]
      // 再将2和1比较，因为2大于1，移动结束，将2插入最后一个移动的数字所在的位置，变成[1,2,3,4]
      let temp = arr[i]
      for(j=i; j>=gap && arr[j-gap] > temp; j-=gap) {
        arr[j] = arr[j - gap]
      }
      arr[j] = temp
    }
  }
}
```



## 2-3、归并排序-MergeSort

归并排序是建立在归并操作上的一种有效的排序算法，采用分治法(Divide and Conquer)思想实现；

- 分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之；

将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。

分割操作：

- 将数组从中点进行分割，分为左、右两个数组
- 递归分割左、右数组，直到数组长度小于`2`

归并操作：

- 若需合并，则左右两数组已有序；
- 创建一临时存储数组`temp`，比较两数组第一个元素，将较小的元素加入临时数组；
- 若左右数组有一个为空，则此时另一数组一定大于 `temp` 中的所有元素，直接将其所有元素加入 `temp`；

![](https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200921074208.gif )



```js
// Way - 1
// 分割数组时直接将数组分割为两个数组，合并时直接合并数组。
// 优点：思路简单，写法简单 
// 缺点：空间复杂度略高，需要复制多个数组
function mergeSort(array) {
  if (array.length < 2) {
    return array;
  }
  const mid = Math.floor(array.length / 2);
  const front = array.slice(0, mid);
  const end = array.slice(mid);
  return merge(mergeSort(front), mergeSort(end));
}

function merge(front, end) {
  const temp = [];
  while (front.length && end.length) {
    if (front[0] < end[0]) {
      temp.push(front.shift());
    } else {
      temp.push(end.shift());
    }
  }
  while (front.length) {
    temp.push(front.shift());
  }
  while (end.length) {
    temp.push(end.shift());
  }
  return temp;
}




// Emmm...
function mergeSort (arr) {
  // 只有一个数组元素不需要排序
  if(arr.length < 2) {
    return
  }
  let left, right, step = 1
  // 如果 step 超过了数组长度，那么不需要拆分了
  // 例如以上示例中的第四趟，step = 8，但是数组长度只有7，因此已经排好序了，不需要在遍历了
  while(step < arr.length) {
    left = 0
    right = step
    // 第一次 step = 1，将一个数组拆分被只有一个元素的多个数组
    // 第二次 step = 2, 将拆分的只有一个元素的数组合并成排好序的只有2个元素的多个数组
    // ...
    // 注意: 这里考虑的是左右数组元素个数一致的情况
    while(right + step <= arr.length) {
      mergeArrays(arr, left, left+step, right, right+step)
      left = right + step
      right = left + step
    }
    // 注意: 这里考虑的是左右数组元素个数不一致的情况
    if(right < arr.length) {
      mergeArrays(arr, left, left+step, right, arr.length)
    }
    // 第一次step = 1,
    // 第二次step = 2, 因此进行两两合并，只是合并的每个数组长度是1
    // 第三次step = 4, 仍然进行两两合并，只是合并的每个数组长度是2
    step *= 2
  }
}
function mergeArrays(arr, leftStart, leftEnd, rightStart, rightEnd) {
  let rightArr = new Array(rightEnd - rightStart + 1)
  let leftArr = new Array(leftEnd - leftStart + 1)
  let k = rightStart

  // 对需要排序的数组按照 step 进行数组拆分，拆分成一个个小数组
  for(let i=0; i<rightArr.length - 1; i++) {
    rightArr[i] = arr[k]
    ++k
  }
  k = leftStart
  for(let i=0; i<leftArr.length - 1; i++) {
    leftArr[i] = arr[k]
    ++k
  }
  rightArr[rightArr.length-1] = Infinity // 哨兵值
  leftArr[leftArr.length-1] = Infinity // 哨兵值
  // 对拆分的数组进行从小到大排序
  let m=0, n=0;
  for(let k = leftStart; k < rightEnd; k++) {
    // 如果左数组小于右数组则当前序列插入左数组值
    // 需要如果右数组已经插入完毕了，那么右数组的值是Infinity，此时始终会插入左数组值
    if(leftArr[m] <= rightArr[n]) {
      arr[k] = leftArr[m]
      m++
    // 否则插入右数组值  
    // 如果左数组已经插入完毕，那么左数组的最后值是Infinity，此时始终会插入右数组值
    } else {
      arr[k] = rightArr[n]
      n++
    }
  }    
} 






// Way - 2
// 记录数组的索引，使用 left、right 两个索引来限定当前分割的数组。
// 优点：空间复杂度低，只需一个 temp 存储空间，不需要拷贝数组
// 缺点：写法复杂
function mergeSort(array, left, right, temp) {
  if (left < right) {
    const mid = Math.floor((left + right) / 2);
    mergeSort(array, left, mid, temp)
    mergeSort(array, mid + 1, right, temp)
    merge(array, left, right, temp);
  }
  return array;
}

function merge(array, left, right, temp) {
  const mid = Math.floor((left + right) / 2);
  let leftIndex = left;
  let rightIndex = mid + 1;
  let tempIndex = 0;
  while (leftIndex <= mid && rightIndex <= right) {
    if (array[leftIndex] < array[rightIndex]) {
      temp[tempIndex++] = array[leftIndex++]
    } else {
      temp[tempIndex++] = array[rightIndex++]
    }
  }
  while (leftIndex <= mid) {
    temp[tempIndex++] = array[leftIndex++]
  }
  while (rightIndex <= right) {
    temp[tempIndex++] = array[rightIndex++]
  }
  tempIndex = 0;
  for (let i = left; i <= right; i++) {
    array[i] = temp[tempIndex++];
  }
}
```



## 2-4、堆排序-HeapSort-MB

堆排序是指利用堆这种数据结构所设计的一种排序算法；

堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点；



创建一个大顶堆，大顶堆的堆顶一定是最大的元素。

交换第一个元素和最后一个元素，让剩余的元素继续调整为大顶堆。

从后往前以此和第一个元素交换并重新构建，排序完成



- 将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；
- 将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]<=R[n]；
- 由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。

![](https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200921074209.gif )

```js
function heapSort(array) {
  creatHeap(array);
  console.log(array);
  // 交换第一个和最后一个元素，然后重新调整大顶堆
  for (let i = array.length - 1; i > 0; i--) {
    [array[i], array[0]] = [array[0], array[i]];
    adjust(array, 0, i);
  }
  return array;
}
// 构建大顶堆，从第一个非叶子节点开始，进行下沉操作
function creatHeap(array) {
  const len = array.length;
  const start = parseInt(len / 2) - 1;
  for (let i = start; i >= 0; i--) {
    adjust(array, i, len);
  }
}
// 将第target个元素进行下沉，孩子节点有比他大的就下沉
function adjust(array, target, len) {
  for (let i = 2 * target + 1; i < len; i = 2 * i + 1) {
    // 找到孩子节点中最大的
    if (i + 1 < len && array[i + 1] > array[i]) {
      i = i + 1;
    }
    // 下沉
    if (array[i] > array[target]) {
      [array[i], array[target]] = [array[target], array[i]]
      target = i;
    } else {
      break;
    }
  }
}
```





## 2-X、时间复杂度对比

| 排序算法     | 平均时间复杂度 | 最坏时间复杂度 | 空间复杂度 | 是否稳定 |
| ------------ | :------------: | :------------: | :--------: | :------: |
| 冒泡排序     |     O(n²)      |     O(n²)      |    O(1)    |    是    |
| 选择排序     |     O(n²)      |     O(n²)      |    O(1)    |   不是   |
| 直接插入排序 |     O(n²)      |     O(n²)      |    O(1)    |    是    |
| 快速排序     |    O(nlogn)    |     O(n²)      |  O(logn)   |   不是   |
| 希尔排序     |    O(nlogn)    |     O(n^s)     |    O(1)    |   不是   |
| 归并排序     |    O(nlogn)    |    O(nlogn)    |    O(n)    |    是    |
| 堆排序       |    O(nlogn)    |    O(nlogn)    |    O(1)    |   不是   |

- 注意：时间复杂度记忆
  - 冒泡、选择、直接 排序需要两个for循环，每次只关注一个元素，平均时间复杂度为O(n²)(一遍找元素O(n)，一遍找位置O(n)）
  - 快速、归并、希尔、堆基于二分思想，log以2为底，平均时间复杂度为O(nlogn)(一遍找元素O(n)，一遍找位置O(logn))





## 2-Y、注意事项

### 2-Y-1、稳定性

若不考虑稳定性，快排似乎是近乎完美的方法之一，但它不稳定的：稳定性：通俗的讲：有两个相同的数 A 和 B，在排序前 A 在 B 前面，而经过排序后，B 变成在 A 的前面；此种情况就称：**<u>*排序的不稳定性*</u>**，而快排在对存在相同数进行排序时就有可能发生这种情况；

- 比如：对 (5，3A，6，3B ) 进行排序，排序前相同的数 3A 与 3B，A 在 B 前面，经过排序后会变成 (3B，3A，5，6)
- 危害：在前端领域，不稳定排序或操作将会使本身不需要变化的东西变化，比如 ul 的列表项快排，虽然相同但交换位置，导致重新渲染，带来性能损耗；



