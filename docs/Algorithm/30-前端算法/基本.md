# 一、基本

## 1-1、数据结构

### 1-1-1、定义

相互间存在一或多种特定关系的数据元素的集合；

- 数据元素：组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理；一个数据元素可由若干个数据项组成；
  - 比如禽类的数据元素是鸡、鸭、鹅，人类则是人；
- 数据项：数据不可分割的最小单位；
  - 比如人类的数据项是手、脚、身；
- 数据：描述客观事物的符号，是计算机中可操作的对象，能被计算机识别，并输入给计算机处理的符号集合；
  - 注意：数据的子集—数据对象，即性质相同的数据元素集合；

### 1-1-2、逻辑结构

指数据对象中数据元素间的相互关系；

- 集合结构：数据元素除了同属一个集合外，无任何关系；
- 线性结构：数据元素间呈一对一关系；
- 树形结构：数据元素间呈一对多关系；
- 图形结构：数据元素间呈多对多关系；

### 1-1-3、物理结构

指数据的逻辑结构再计算机中的存储形式；

- 顺序存储结构：将数据元素存放在地址连续的存储单元中，而数据间的逻辑关系与物理关系一致；
- 链式存储结构：将数据元素存放在任意(可连续可不连续)的存储单元中，数据间的逻辑关系与物理关系并不一定一致；



## 1-2、算法

### 1-2-1、定义

解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，且每条指令表示一或多个操作；

### 1-2-2、特性

- 输入输出
- 有穷性：算法在执行有限步骤后，自动结束而不会出现无限循环，且每个步骤在可接受的时间内完成；
- 确定性：算法每一步骤具有确定含义，不会出现二义性；
- 可行性：算法每一步均须可行，均能通过执行有限次数完成；

### 1-2-3、设计要求

- 正确性、可读性、健壮性、高效率、低存储

### 1-2-4、效率度量

- 事后统计方法、事前分析估算

### 1-2-5、复杂度与分析

定义：数据结构和算法解决是“如何让计算机更快时间、更省空间的解决问题”。因此需从执行时间和占用空间两个维度，来评估数据结构和算法性能。分别用时间复杂度和空间复杂度两个概念来描述性能问题，二者统称为复杂度。**复杂度描述的是算法执行时间(或占用空间)与数据规模的增长关系**；

意义：与性能测试相比，复杂度分析有不依赖执行环境、成本低、效率高、易操作、指导性强的特点；且掌握复杂度分析，将能编写出性能更优的代码，有利于降低系统开发和维护成本；

分析：**<u>*大O表示法：描述的是算法的运行时间和输入数据之间的关系；*</u>**或描述一个算法或操作的渐进时间复杂度，即此算法和操作消耗的时间与输入数据规模的关系，描述 n 趋于无穷的时间复杂度；通常 O(x) 指渐进时间复杂度，描述当 n 趋近于无穷时不同算法的性能(忽略低阶项和常数)，比如 O(1) 表示算法或操作消耗时间与输入规模无关；来源：算法的执行时间与每行代码的执行次数成正比，用 `T(n) = O(f(n))` 表示，其中 T(n) 表示算法执行总时间，f(n) 表示每行代码执行总次数，而 n 往往表示数据的规模；

特点：以时间复杂度为例，由于时间复杂度描述的是算法执行时间与数据规模的增长变化趋势，所以常量阶、低阶以及系数实际上对这种增长趋势不产决定性影响，故在做时间复杂度分析时忽略这些项；种类如下：

- **<u>多项式阶</u>**：随数据规模增长，算法执行时间和空间占用，按照多项式比例增长；包括：
  - O(1)(常数阶-Constant)
  - O(logn)(对数阶-Logarithmic)
  - O(n)(线性阶-Linear)
  - O(nlogn)(线性对数阶-LinearLog)
  - O(n^2)(平方阶-Square)
  - O(n^3)(立方阶)
- **<u>非多项式阶</u>**：随数据规模增长，算法执行时间与空间占用增加，此类算法性能极差；包括：
  - O(2^n)：指数阶-Exponential Growth；
  - O(n!)；阶乘阶-Factorial

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20201003064111.png" style="zoom:50%;" align=""/>

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20201004072547.png" alt="截屏2020-10-04 上午7.25.43" style="zoom:40%;" />

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20201004072612.png" alt="截屏2020-10-04 上午7.26.07" style="zoom:40%;" />



- **<u>*复杂度分析法则*</u>**
  - 单段代码看高频：比如循环；
  - 多段代码取最大：比如一段代码中有单循环和多重循环，那么取多重循环的复杂度；
  - 嵌套代码求乘积：比如递归、多重循环等；
  - 多个规模求加法：比如方法有两个参数控制两个循环的次数，那么这时就取二者复杂度相加；

- **<u>*时间复杂度*</u>**：反映程序运行从开始到结束所需时间；将算法中基本操作重复执行次数(频度)，作为算法时间复杂度；时间复杂度计算示例如下：

```js
// Ex1:
// 时间复杂度为 O(n²): 总执行次数 T(n) = 1 + 1 + (n+1) + n + n + n + n*(n+1) + n*n + n*n = 3n^2 + 5n + 3
// 取 n 趋于无穷大，常数、常数系数忽略不计，只保留次数最高那一项，结果为 n²
function traverse(arr) {
    const outLen = arr.length // 1
    // 1 n+1 n
    for(let i=0;i<outLen;i++) {
      	// 1
        const inLen = arr[i].length
        // n  n*(n+1)  n*n
        for(let j=0;j<inLen;j++) { 
            console.log(arr[i][j])
        }
    }
}

// Ex2:
// 时间复杂度为 O(logn)
function fn(arr) {
    const len = arr.length  
    for(let i=1;i<len;i=i*2) {
        console.log(arr[i])
    }
}
```

**<u>*空间复杂度*</u>**：指对一算法在运行过程中临时占用存储空间大小的量度；据此可对程序运行所需内存多少有预先估计；常见的空间复杂度有 `O(1)`、`O(n)` 和 `O(n^2)`；注意：与时间复杂度相似，但其描述的是内存增长的**<u>趋势</u>**；空间复杂度计算示例如下：

- 注意：程序执行时，需要存储本身所用指令/常数/变量和输入数据的空间/对数据进行操作的工作单元/存储一些为现实计算所需信息的辅助空间等；

```javascript
// Ex1:
// 占用空间的有以下变量：arr、len、i，而后面尽管有很多次循环，但是这些都是时间上的开销。循环体在执行时，并没有开辟新的内存空间。因此整个函数对内存的占用量是恒定的，其对应的空间复杂度就是 O(1)
function traverse(arr) {
    const len = arr.length
    for(let i=0;i<len;i++) {
        console.log(arr[i])
    }
}

// Ex2:
// 占用空间的有以下变量：arr、n、i，此处的 arr，并非一成不变，其最终大小是由输入的 n 决定，即会随着 n 的增大而增大，此方法的空间复杂度就是 O(n)。而类似的，若初始化规模为 n*n 的数组，则其空间复杂度就是 O(n^2)；
function init(n) {
    let arr = []
    for(let i=0;i<n;i++) {
        arr[i] = i
    }
    return arr
}
```

**<u>*时间复杂度分类：*</u>**因同一段代码在不同情况下，时间复杂度会出现量级差异(大多数情况无需区分)，为更全面和准确描述代码的时间复杂度，引入以下概念：

- 最坏情况时间复杂度：代码在最理想情况下执行的时间复杂度；
- 最好情况时间复杂度：代码在最坏情况下执行的时间复杂度；
- 平均时间复杂度：用代码在所有情况下执行的次数的加权平均值表示；
- 均摊时间复杂度：在代码执行的所有复杂度情况中，若绝大部分是低级别的复杂度，且个别情况是高级别复杂度且发生具有时序关系时，则可将个别高级别复杂度均摊到低级别复杂度上，此时的均摊结果就等于低级别复杂度；比如：动态数组中，resize 时操作复杂度为 O(n)，但由于 addLast 的复杂度为 O(1)，且非每次 addLast 都会触发 resize，故采用均摊结果 O(1)；





# 二、题集

| 顺序            | 题目                                                         | 类型                     | 解题 |
| --------------- | ------------------------------------------------------------ | ------------------------ | ---- |
| 0001            | [TwoSum](https://leetcode-cn.com/problems/two-sum/)          | Array、HashMap           |      |
| 0015            | [3Sum](https://leetcode-cn.com/problems/3sum/)               | Array、HashMap、双向指针 |      |
| 0017            | [Letter Combinations of a Phone Number](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/) | Array                    |      |
| 0018            | [4Sum](https://leetcode-cn.com/problems/4sum/)               | Array、HashMap、双向指针 |      |
| 0035            | [Search Insert Position](https://leetcode-cn.com/problems/search-insert-position/) | Array                    |      |
| 0724            | [find-pivot-index](https://leetcode-cn.com/problems/find-pivot-index/) | Array、HashMap           |      |
|                 |                                                              |                          |      |
|                 |                                                              |                          |      |
|                 |                                                              |                          |      |
|                 |                                                              |                          |      |
| 剑指Offer-0021  | [调整数组顺序使奇数位于偶数前面 LCOF](https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/) | Array、双向指针          |      |
| 剑指Offer-0029  | [顺时针打印矩阵](https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/) | Array、多维数组          |      |
| 剑指Offer-0057  | [和为s的两个数字](https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/) | Array、双向指针          |      |
| 剑指Offer-0057Ⅱ | [II. 和为s的连续正数序列](https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/) | Queue、双向指针          |      |
| 剑指Offer-0066  | [构建乘积数组](https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof/) | Array、多维数组          |      |









































**线性表**(List)：零或多个数据元素的*有限* *序列*；线性表元素的个数 n (n≥0) 定义为线性表的长度，当 n =  0  时，称为空表。每个线性表上的数据最多只有前和后两个方向；链表、队列、栈等也是线性表结构，与之相对的是非线性表，数据之间并不是简单的前后关系，比如二叉树、堆、图等；





<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20201003064113.png" style="zoom:50%;" align="" />

**线性表的顺序存储结构**：指的是用一段地址连续的存储单元依次存储线性表的数据元素；

​	一般用一维数组实现顺序存储结构；注意：数组长度不等同线性表长度，前者是指存放线性表的存储空间的长度(分配后即值固定)，后者是指线性表中数组元素的个数(值变化)；任意时刻，线性表长度应小于等于数组长度；

- 描述顺序存储结构的三个属性：
  - 存储空间的起始位置；
  - 线性表的最大存储容量；
  - 线性表的当前长度；
- 优点：
  - 无须为表示表中元素之间的逻辑关系而增加额外的存储空间
  - 可快速存取表中任一位置的元素；
- 缺点：
  - 插入与删除操作须移动大量元素；
  - 当线性表长度变化较大时，难以确定存储空间容量；
  - 容易造成存储空间的碎片化；

**线性表的链式存储结构**：指的是用一组任意的存储单元存储线性表的数据元素，这组存储单元可连续亦可不连续；

​	线性表的链式存储结构，即链表由一或多个结点链结组成，结点由数据域和指针域组成，前者是存储数据元素信息的域，后者是存储直接后继位置的域，指针域中存储的信息被称为指针或链；若链表每个结点只包含一个指针域，则称单链表；

- 头结点：为方便对链表进行操作，在单链表的首个结点前附设的结点，其数据域一般无意义(亦可用于存放链表长度)；
  - 注意：若线性表为空，则头结点的指针域为空，表示空链表；
  - 注意：有了头结点，对链表首个元素进行前插入和删除操作就与其他节点相统一，但头结点非链表必须元素；
- 头指针：链表的首个结点的存储位置，头指针在头结点内；
  - 注意：无论链表是否为空，头指针均不为空，头指针是链表的必须元素；



**顺序与链式优缺点：**

- 存储分配方式
  - 顺序存储结构用一段连续的存储单元依次存储线性表的数据元素；
  - 单链表采用链式存储结构，用一组任意的存储单元存放线性表的元素；
- 时间性能
  - 查找
    - 顺序存储结构0(1)；
    - 单链表O(n)；
  - 插入和删除
    - 顺序存储结构需要平均移动表长一半的元素，时间为O(n)；
    - 单链表在线出某位置的指针后，插入和删除时间仅为0(1)；
- 空间性能
  - 顺序存储结构需要预分配存储空间，分大了浪费，分小了易发生上溢；
  - 单链表不需要分配存储空间，只要有就可以分配，元素个数也不受限制



**顺序与链式应用场景：**

- 若线性表需要频繁查找，很少进行插入和删除操作时，宜采用顺序存储结构；若需要频繁插入和删除时，宜采用单链表结构；
- 当线性表中的元素个数变化较大或者根本不知道有多太时，宜用单链表结构，如此无需考虑存储空间的大小问题。而若事先知道线性表的大致长度，则使用顺序存储结构效率会高很多；



