# 一、基本

## 1-1、数据类型

基本数据类型

- boolean
- null
- undefined
- number
- string
- symbol
- bigInt

引用数据类型：对象 Object，包含

- 普通对象-Object；
- 数组对象-Array；
- 正则对象-RegExp；
- 日期对象-Date；
- 数学函数-Math；
- 函数对象-Function；



### 1-1-1、示例

```js
const a = {}
const b = Symbol('1')
const c = Symbol('1')
a[b] = '子君'
a[c] = '君子'

// 输出子君
console.log(a[b])

const d = {}
const e = {key: '1'}
const f = {key: '2'}
d[e] = '子君'
d[f] = '君子'

// 输出君子
console.log(d[e])
// 对于第一个输出，Symbol()函数会返回「symbol」类型的值，而Symbol函数传的参数仅仅是用于标识的，不会影响值的唯一性
// 对于第二个输出， 因为e和f都是对象，而对象的key只能是数值或字符，所以会将对象转换为字符，对象的toString方法返回的是[object Object], 所有输出的是君子
```





## 1-X、注意事项

### 1-X-1、null

虽然 typeof null 会输出 object，但这只是 JS 存在的一个悠久 Bug：

- JS 的最初版本中使用是 32 位系统，为性能考虑使用低位1-3位存储变量的类型信息，000 开头代表是对象然而 null 表示为全零；
- 比如：000 —> 对象；010 —> 浮点数；100 —> 字符串；110 —> 布尔值；
- 然而：null 的所有机器码均为 0，故导致了 typeof 误判，且现有代码已经严重依赖这一bug表现，已永远不可能被修复：
- 详情：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof

与 undefiend 区别：

- 前者表示一个"无"的对象，也即**<u>*此处不应该有值*</u>**；而 undefined 表示**<u>*未定义*</u>**。
- 在转换为数字时结果不同，Number(null) 为 0，而 undefined 为 NaN；

使用场景上：

- 前者作为函数的参数，表示该函数的参数不是对象；
- 前者作为对象原型链的终点；

- 后者在变量被声明但没有赋值时，就等于 undefined；
- 后者调用函数时，应该提供的参数没有提供，该参数等于 undefined；
- 后者对象没有赋值属性，该属性的值为 undefined；
- 后者函数没有返回值时，默认返回 undefined；



### 1-X-2、基本包装类型

```js
// '1'.toString() 之所以能执行
// 是因为语句运行的过程中做了这样几件事情:

// 1、创建 Object 类实例
// 注意: 目前 ES6 规范不建议用 new 来创建基本类型的包装类；而由于 Symbol 和 BigInt 的出现，对它们调用 new 都会报错
var s = new Object('1');
// 2、调用实例方法
s.toString();
// 3、执行完方法立即销毁这个实例
s = null;
```

过程体现 **<u>基本包装类型</u>** 的性质，而基本包装类型恰恰属于基本数据类型，包括 Boolean、Number、String；



### 1-X-3、精度问题

⼗进制整数转⼆进制⽅法：除2取余；⼗进制⼩数转⼆进制⽅法：乘2除整 ⼗进制0.1转换成⼆进制，乘2取整过程：

```js
0.1 * 2 = 0.2 # 0
0.2 * 2 = 0.4 # 0
0.4 * 2 = 0.8 # 0
0.8 * 2 = 1.6 # 1
0.6 * 2 = 1.2 # 1
0.2 * 2 = 0.4 # 0

.....
```

0.1的二进制格式是：0.0001100011....，是一个**二进制无限循环小数**，但计算机内存有限，不能用储存所有的小数位数，所以会在某个精度点直接舍弃；代价是，0.1 在计算机内部根本就不是精确的 0.1，而是一个有舍入误差的 0.1；当代码被编译或解释后，0.1已经被四舍五入成一个与之很接近的计算机内部数字，以至于计算还没开始，一个很小的舍入错误就已产生了。这也就是 0.1 + 0.2 不等于0.3 的原因；

注意：而 0.1 + 0.1 为何等于0.2 是：两个有舍⼊误差的值在求和时，相互抵消，但这种负负得正，相互抵消不⼀定都可靠，当这两个数字是⽤不同⻓度数位来表示的浮点数时，舍⼊误差可能不会相互抵消；⼜如：0.1 + 0.3 ，结果其实并不是 0.4，但 0.4 是最接近真实结果的数，⽐其它任何浮点数都更接近；许多语⾔也就直接显示结果为 0.4 了，⽽不展示⼀个浮点数的真实结果；

注意：⼆进制能精确地表示位数有限且分⺟是2的倍数的⼩数，⽐如 0.5(1/2)，0.5 在计算机内部就没有舍⼊误差；故 0.5 + 0.5 === 1;



### 1-X-3-1、精度现状

JS中，所有的数字都以双精度 64 位浮点格式表示，这导致 JS 中的 Number 无法精确表示非常大的整数，还会将非常大的整数四舍五入；

即 JS 的 Number 类型只能安全地表示 `-9007199254740991 (-(2^53-1)) 和  9007199254740991 ((2^53-1))间的数`，任何超出此范围的整数值都可能失精；

```js
console.log(999999999999999);  //=>10000000000000000
// 并有一定的安全性问题:
9007199254740992 === 9007199254740993;    // → true
```





### 1-X-3-1、精度解决—BigInt

BigInt 是一种新的数据类型，用于当整数值大于 Number 数据类型支持的范围时；这种数据类型允许安全地对 `大整数`  执行算术操作，表示高分辨率的时间戳，使用大整数 id 等等，而不需要使用库；

### 1-X-3-1-1、创建

```js
// 1、在数字末尾追加 n 创建 BigInt
console.log( 9007199254740995n );    // → 9007199254740995n	
console.log( 9007199254740995 );     // → 9007199254740996
// 2、使用 BigInt() 构造函数创建 BigInt
BigInt("9007199254740995");    // → 9007199254740995n
```

### 1-X-3-1-2、使用

```js
10n + 20n;    // → 30n	
10n - 20n;    // → -10n	
+10n;         // → TypeError: Cannot convert a BigInt value to a number	
-10n;         // → -10n	
10n * 20n;    // → 200n	
20n / 10n;    // → 2n	
23n % 10n;    // → 3n	
10n ** 3n;    // → 1000n	

const x = 10n;	
++x;          // → 11n	
--x;          // → 9n
console.log(typeof x);   //"bigint"
```

### 1-X-3-1-3、注意事项

- BigInt 不支持一元加号运算符，可能是某些程序可能依赖于 + 始终生成 Number 的不变量，或抛出异常；另外，更改 + 的行为也会破坏 asm.js 代码；
- 因隐式类型转换可能丢失信息，故不允许在 bigint 和 Number 间进行混合操作；
  - 当混合使用大整数和浮点数时，结果值可能无法由 BigInt 或 Number 精确表示；

```
10 + 10n;    // → TypeError
```

- 不能将 BigInt 传递给 Web api 和内置的 JS 函数，这些函数需要一个 Number 类型的数字；尝试这样做会报 TypeError 错误；

```
Math.max(2n, 4n, 6n);    // → TypeError
```

- 当 Boolean 类型与 BigInt 类型相遇时，BigInt 的处理方式与 Number 类似，即只要不是 0n，BigInt 即会被视为 truthy 值；

```
if(0n){ // 条件判断为false
}
if(3n){ // 条件为true
}
```

- 元素均为 BigInt 的数组可进行 sort；
- BigInt 可正常地进行位运算，如|、&、<<、>>、^；



### 1-X-3-1-4、兼容性

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200919145910.png" style="zoom:50%;" align="" />





