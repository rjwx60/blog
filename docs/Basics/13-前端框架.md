---
typora-root-url: ../../../BlogImgsBed/Source
---



## 一、总结

### 1-1、实现原理

#### 1-1-1、Vue 实现原理

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200908132749.png" style="zoom:50%;" />

注意：此处描述的是 Vue 2.x 的运行机制 (并注意分析的是 Runtime + Compiler)

补充：**<u>*完整版*</u>** = 运行时版 + Compiler (将字符串模板 template 编译为 render 函数)；若在运行时处理 template 则需要 compiler 编译，但 compiler 非必需，可通过在脚手架配置 vue-loader 插件辅助编译，不自带 Compiler 而将编译交给构建工具的即为 **<u>*运行时版*</u>**；

- entry-runtime 没有包含 compiler，最后直接输出 Vue 实例，将其交由构建工具的编译器即可；使用运行时版，配置 vue-loader 便可实现，若使用 template 特性，又可在打包时减少 30% 的项目体积；
- entry-runtime-with-compiler 包含 compiler，挂载前需要做编译处理，所以其重写了 Vue.prototype.$mount 方法，并添加了 Vue.compile 全局API；使用完整版，允许在代码运行的时现场编译模板，在不配合构建工具的情况下可直接使用；
- <u>意即：运行时版需要构建工具配合，但打包体积小；完整版无需构建工具配合，但打包体积大；</u>

**<u>*初始化流程*</u>**：

- 创建 Vue 实例对象
- `init` 过程初始化生命周期、事件中心和渲染、执行 `beforeCreate` 周期函数、初始化 `data`、`props`、`computed`、`watcher`、执行 `created` 周期函数等
  - 注意：此处的初始化阶段，并无详细描述数据的响应式过程，此流程见下方描述：
  - 注意：初始化阶段为 Vue 原型添加属性和方法，即实例属性和实例方法，并添加全局的API，也就是静态的方法和属性：
    - 初始化原型链属性 sateMixin：`$data(只读属性)、$props(只读属性)、$set、$delete、$watch`；
    - 初始化原型链方法(事件) eventsMixin：`$on、$once、$off、$emit`；
    - 初始化原型链方法(生命周期) lifecycleMixin：`_update、$forceUpdate、$destory`；
    - 初始化(渲染函数) renderMixin：`installRenderHelpers、_render、nextTick`；
    - 在 Vue 构造函数上添加全局 API，类似整理 Vue.prototype 上的属性和方法：
      - 比如：get(只读)、util(独立、非公共API)、set、util、set、delete、nextTick、options；
      - 比如：Vue.use Vue.component、Vue.directive、Vue.filter、Vue.mixin、Vue.extend；
    - 并设置平台化的 Vue.config；
      - Vue.options：混合2个指令(directives)：model、show；
      - Vue.options：混合2个组件(components)：Transition、TransitionGroup；
      - Vue.prototype：2个方法：`__patch__`、$mount；
- 初始化后，调用 `$mount` 方法对 Vue 实例进行挂载(挂载的核心过程包括：**<u>模板编译、渲染、更新</u>**  三个过程)；
- 注意：若无在 Vue 实例上定义 `render` 方法而定义了 `template`，则需要经历编译阶段：先将 `template字符串` 编译成 `render function`；编译步骤如下 ：
  - 首先，`parse `正则解析 `template` 字符串形成 AST(抽象语法树，源代码的抽象语法结构的树状表现形式)
  - 然后，`optimize ` 标记静态节点跳过 Diff 算法 (Diff 算法是逐层进行比对，只有同层级的节点进行比对，因此时间的复杂度只有 O(n)；
  - 最后，`generate` 将 AST 转化成 `render function` 字符串；
- 然后，编译成 `render function` 后，调用 `$mount` 的 `mountComponent `方法，先执行 `beforeMount` 钩子函数，然后核心是实例化一个 `渲染Watcher`，在它的回调函数(初始化时执行，及组件实例中监测到数据发生变化时执行)中调用 `updateComponent` 方法(此法调用 `render` 方法生成 `虚拟Node`，最终调用 `update` 方法更新 DOM，见下方)；
- 调用 `render` 方法将 `render function` 渲染成 `虚拟Node` ，`render` 方法的第一个参数是 `createElement` (或说是 `h` 函数)；
  - 注意：真实 DOM 元素非常庞大，因浏览器的标准就把 DOM 设计的非常复杂；倘若频繁做 DOM 更新，会产生一定的性能问题，而 `虚拟DOM` 就是用一原生 JS 对象去描述 DOM 节点，所以它比创建一个 DOM 的代价要小很多，而且修改属性也很轻松，并能实现跨平台兼容；
- 然后，生成 `虚拟DOM树` 后，需要将 `虚拟DOM树` 转化成 `真实DOM节点`，此时需要调用 `update` 方法，`update `方法又会调用 `pacth` 方法将 `虚拟DOM` 转换成 真正DOM 节点；(注意上图忽略了新建真实 DOM 的情况—若无旧的虚拟 Node，则可直接通过 `createElm` 创建真实 DOM 节点)，而此处重点分析在已有虚拟 Node 的情况下，会通过 `sameVnode` 判断当前需要更新的 Node节点，是否与旧的 Node 节点相同(比如若设置的 `key` 属性发生了变化，则节点显然不同—所以 key 作用在于节点的最大化复用)，若节点不同则利用新节点替换旧节点，若相同且存在子节点，则需调用 `patchVNode ` 方法执行 Diff 算法更新 DOM，从而提升 DOM 操作的性能；

**<u>*响应式流程*</u>**：

- 在 `Init` 初始化过程中会利用  `Object.defineProperty` 方法(不兼容 IE8)，以监听 Vue 实例的响应式数据的变化从而实现数据劫持能力 (利用了 JS 对象的访问器属性 `Get/Set`，而在 Vue3 中则使用了 ES6 的 `Proxy` 来优化响应式原理)；然后在初始化流程中的编译阶段，当 `render function` 被渲染时，会读取Vue 实例中和视图相关的响应式数据，此时便会触发 `getter`  函数进行 **<u>依赖收集</u>** (将观察者 `Watcher` 对象存放到当前闭包的订阅者 `Dep` 的 `subs` 中)，此时的数据劫持功能和观察者模式就实现了一个 MVVM 模式中的  **<u>Binder</u>**，之后就是正常的渲染和更新流程；
- 然后，当数据发生变化或视图导致的数据发生了变化时，会触发数据劫持的 `setter` 函数，`setter ` 会通知初始化 **<u>依赖收集</u>** 中的 `Dep` 中的与视图相应的`Watcher`，告知需要重新渲染视图，`Wather` 就会再次通过 `update` 方法来更新视图；

- 注意：可发现只要视图中添加监听事件(Get/Set+处理函数)，自动变更对应的数据变化时，就可实现数据和视图的双向绑定；



#### 1-1-2、Angular 实现原理

Angular 的应用可分为三部分组成：

- Angular 编译器—Angular Compiler(核心) 编译出的代码；

- Angular 提供的运行时—Angular Runtime(核心) 代码；
- 用户提供的业务代码；

Compiler负责去解析开发应用中的html模板、typescript代码、 样式，提取元数据，模板表达式等必要的信息，然后将其转化、优化最终生成实际运行的代码；

Runtime会去消费生成的代码，将其组织并运行起来；此两个部分是耦合一起共同工作，组合起来称为 渲染器 Render；



##### 1-1-2-1、Compiler

编译器是什么，简而言之就是开发者代码和最终运行时代码之间的一切工作，Angular编译器（NGC)包括以下过程：

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200908132957.png" alt="" style="zoom:50%;" align="left"/>

```js
@Component({
  selector: 'hello-user',
  template: `
    <form>
      <div>Hello {{user.name}}</div>
      <input ngModel>
    </form>`,
})
export class HelloUserComponent {
  user = {name: 'TLP'};}
}
```

##### 1-1-2-1-1、解析

代码 parse 过程包括对 ts 代码、模板，样式的解析，最终得到抽象语法树-AST，[ASTExplore](https://astexplorer.net/)

代码的解析，不同形式的代码最终会成为语法树节点的一部分，可以作为一个 JSON 结构继续处理；

注意：区别于TC39的装饰器提案，Angular 的装饰器语法在于添加注解-annotation，用来定义类型的 metadata；

注意：模板解析是理解框架工作的关键；其目标是将 Angular 定义的模板语法最终编译成可创建视图和更新视图的 JS 代码，而相比于将模板交给浏览器解析，Angular 自定义实现过程能更好地：支持跨平台，服务端渲染，模板静态检查以及更多的扩展语法等等；

```
{
	text: '',
	expr: {
		propPath: ['user', 'name'],
		line: 2, col: 14
	}
}
{	
	name: 'input', attrs: [['ngModel': '']],
	directives: [{
		ctor: NgModel,
		deps: [NgForm]
	}]
}
// AST 记录了对应的数据检索路径
// 行数记录方便编译报错寻址
// 元素上的指令 ngModel 会被映射到对应类 NgForm，并标识出依赖注入
```

##### 1-1-2-1-2、转换

先补充 NGC(AngularCompiler) 历史：从 Angular2 发布至今，NGC 已有三代版本：

**<u>*第一代*</u>**：Angular2 采用的编译器叫 **Template Compiler**，编译产物代码巨多：

- Template Compiler 会对每个@Component 和 @NgModule 装饰类，生成一个 ngFactory.ts，且对应的 Component & NgModule 会被引入到此文件中；

- ngFactory 负责描述类的使用方式：比如需 import 的内容、元数据使用、如何实例化、DI的处理、生命周期钩子调用时机、如何渲染(含宿主、子组件渲染)；

- 模板被解析成 renderer 中的函数调用，包括创建视图的 createInternal 及变更检测 detectChangesInternal；

  - 注意：此种处理 DOM 的模式经由 Ng 团队反复测试，性能十分高效；

  - ```js
    const parentRenderNode:any = this.renderer.createViewRoot(this.parentElement);
        this._el_0 = import3.createRenderElement(this.renderer,parentRenderNode,'h1',import3.EMPTY_INLINE_ARRAY,(null as any));
        this._text_1 = this.renderer.createText(this._el_0,'',(null as any));
        this._text_2 = this.renderer.createText(parentRenderNode,'\n',(null as any));
        this.init((null as any),((<any>this.renderer).directRenderer? (null as any): [
          this._el_0,
          this._text_1,
          this._text_2
        ]
        ),(null as any));
    ```

**<u>*第二代*</u>**，Angular4 开始采用编译器 **View Engine**，其解决：Template Compiler 中的生成的视图操作过于太繁杂，随 web 工程日益庞大，相应代码量也随之增加，相对于其他框架(Vue)劣势明显；于是 View Engine 不再直接生成 render 的指令，而是在编译时生成定义的视图结构，在运行时 runtime 会去解释它们；

- **<u>*View Engine 中 Angular 做的事情就是定义 VIEW，即定义 Node 的结构*</u>**

- 对于 component，angular 会定义一个 componentname_view(后改名 view_component) 函数，通过 viewDef 返回 ViewDefinition，即 component  对应的 view 结构，而 ViewDefinition 是 **<u>*由一个个 Node 来组成*</u>**，Node 可能是元素，指令，插值，ngContent 等等；
- **<u>*NodeDef 描绘了*</u>** 节点的数据结构，其含有大量的属性值，详细描述了节点所有需数据；
- **<u>*每种 Node 对应不同的 Def 函数*</u>**，这些函数也有足够复杂的入参，来**<u>*最终返回出NodeDef*</u>**；

注意：ViewDefinition 对于每个 component 类只会创建一个，但对于不同的实例，实际运行时需要保存 runtime 相关数据，此部分数据放在 ViewData 的数据结构中，即 ViewData 会有多个 (ViewDefinition 每个 component 类只有一个，但 ViewData 会有多个)；

示例：下图是 View Engine 的元素创建、指令、及数据绑定大概过程；

- 观察 Node 的定义函数(NodeDef) 可知，它们详细描述了结点父子关系，对应类，属性，事件，依赖注入关系，生命周期调用情况等等；
- 通过这种方式，极大减少编译产物的代码量，当然因为此种更直接(更注理解)，此方案性能上不如一代，可这是多方面取舍后的结果；
- 补充：AOT、JIT 区别：后者会将编译器放入 vendor 中，在浏览器中运行编译过程；前者则在本地编译好才放入浏览器中，因而性能更好，打包体积更小。

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200908135942.png" alt="2020-09-08 下午1.59.35" style="zoom:50%;"  />

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200908140039.png" alt="2020-09-08 下午2.00.35" style="zoom:50%;"  />

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200908140116.png" alt="2020-09-08 下午2.01.13" style="zoom:50%;"  />

**<u>*第三代*</u>**，IVY 是 Angular 的新一代编译器，其目标在于：减少打包代码体积(质的飞跃)，提升速度，使生成代码友好阅读从而方便调试修改(使用过 Angular2 编译生成出代码，结果…阿巴阿巴)，并且在元编程，高阶组件 HOC 方面给出了极大的支持，给angular开发更强的扩展性；

- 首先，在编译产物上做了大幅优化；基于 Locality 宗旨，即 component 的编译结果可以自己提供运行时所需要的信息，而不是用 ngFactory 来使用它；即不再生成 ngFactory，取而代之的是：**<u>*在类的编译产中一个新的定义函数，对不同装饰器对应的类不同*</u>**，分别为：component => ngComponentDef、Directive => ngDirectiveDef、Injectable => ngInjectableDef，**<u>*即现在每个 component 就是自身的 componentFactory*</u>**；

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200908141036.png" alt="截屏2020-09-08 下午2.10.31" style="zoom:50%;" />

- 另外，对于模板编译的结果，则会被放入 ngComponentDef 定义函数的 template 中，称为 template function；template由两个 if 构成两个主要部分，一个是 view creation 部分，一个是 change detection；此外，还重新回归二代的编译到指令的方式，但远远不同二代中的 renderer API，IVY 的 template 函数由许多内置定义好的 Instructions 集组成，指令集详细定义每种元素对应的各种处理；
  - 之前结构过于笼统，存在大量 if-else；而指令集精准定义渲染器需要的操作，优化代码量，且取消之前的 factory-component 的映射关系，而动态组件需要 resolveComponentFactorylveComponentFactory 也取消了；

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200908141736.png" alt="截屏2020-09-08 下午2.15.08" style="zoom:50%;" />



##### 1-1-2-2、Runtime

编译好的代码在 IVY 的 runtime 下运行，在应用运行时包括以下三个阶段：

- Module Steup—模块启动：框架实例化应用的 Modules 并于此同时设置相关的依赖注入器(Injector)；
- View Creation—视图创建：创建 DOM 实例化 directive；
- Change Detection—变更检测：检查绑定值(Binding value)，如果需要做相应更新；

##### 1-1-2-2-1、模块启动阶段

以根组件的启动为例，事实上框架主要做了以下4个步骤

Bootstrap ->Locate root element -> Instantiate root component -> Render the root component

- bootstrap 时框架会寻找在 AppModule 的NgModule 中设置的组件，即根组件，这部分在 main.ts 中定义；
- 框架会在 index.html 中根据 tagName 寻找 root elemnt，确定应用渲染的正确位置；
- 调用组件的 factory，其中会检查注入器树，通过 Token 获取到正确的依赖注入参数，最终实例化 root component；
- 交给组件的 template 的 View Creation 部分，开始创建视图；

##### 1-1-2-2-2、视图创建阶段

此阶段会从父组件开始，递归调用子组件的 template function；

template function 是由许多指令(instruction)组成，instruction 是由 Angular 声明的一系列函数；

大致分为两类：Creation Instructions 与 Update Instructions 分别用于创建和更新元素；

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200908142845.png" alt="截屏2020-09-08 下午2.28.28" style="zoom:50%;" align="left"/>

不同模板编译的结果，template function 会包含不同的 Instructions，映射过程示例如下：

注意：Angular 创建 DOM 元素的方式没有使用 innerHTML，而是对元素一个个的创建，原因可以看tosiba相关说明

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200908144158.png" alt="截屏2020-09-08 下午2.41.53" style="zoom:50%;" align="left"/>

```js
// 上面用到的 element 函数伪码
// 详见 packages\core\src\render3\instructions\element.ts
function element(index, tag, attrs) {
  const el = document.createElement(tag);
  const parent = getCurrentParent();
  setAttributes(el, attrs);
  parent.appendChild(el);
  const lview = getLView();
  // 注意: Angular 会记录创建的所有元素，将其放入内部的数组 LView 中
  // 此后在 change detection 中更新这些元素时便于获取他们，相对于使用 DOM API 重新 querySelectorX，此种方式会高效的多
  lview[index] = el;
}
```

**<u>*补充：LView：*</u>**意即 logic view；对于每个 template 或者 component 实例，框架都会创建一个 LView 数组实例；LView 中包含 DOM 元素、绑定值和Directive 的实例，方便变更检测及设置输入属性；

**<u>*补充：Directives 工作：*</u>** 在编译阶段，将会根据 component 的装饰器和 ngmodule 的 module scope 确定组件中使用的 Directive，保存在组件的定义(ComponentDef)中；在使用 instruction 创建视图时，将会通过 selector，将创建的视图同保存在 ComponentDef 中的 Directives 比较，若匹配成功则需实例化对应的Directive(实例化通过调用对应的 componentDef 中的 factory 方法)，实例化成功后将其放入LView中；

注意：不要将 Directives 与 instruction混淆；前者是 angular定义给开发者的类型，后者是创建 DOM 的一些 help function；

注意：component 是 Directive 的子类，所以 component 也是在这个阶段一并处理，后续流程如不明确区分，directive 相关操作中中包含 component；

**<u>*补充：TView：*</u>**

对组件的每个实例都做上述操作代价十分高昂，有必要对同一组件共性的数据做缓存处理，即有 TView 概念；

TView 意即 template view，template 对同一组件的所有实例只创建一个共享实例；共享实现如下：

- TView 会保存在 ComponentDef 中；Directive 实例将保存在 LView 中；而将 Directive的定义函数放入TView，并且同一 Directive 在两者的 Index 是一致；
- 除了 Directive 在创建 DOM 时也把对应的Node(TNode) 放入TView中，TNode 中还包含着要创建的 DOM 元素的元数据(metadata)，比如tagName，匹配的Directive等；
- 通过此方式 angular 再次调用 Instruction 创建 DOM 实例时，就会去 TView 中确认保存的数据，这样就能立刻做后续的操作；

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200908160826.png" alt="img" style="zoom:50%;" />

##### 1-1-2-2-3、变更检测阶段

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200908144158.png" alt="截屏2020-09-08 下午2.41.53" style="zoom:50%;" align="left"/>

即检测绑定数据变化和新数据渲染到视图的过程；与 view creation 阶段非常相似，该阶段主要调用 template function 来重新渲染；但不同的是：变更检测，使用的是 template function 的第二部分，即 RenderFlag.Update；此阶段，无需将每个 node 映射到 Instruction 中来，而是为那些需要更新的 node 提供指令；

- 首先需要记录两笔数据：
  - 1.当前处理的 node 在 LView 中的索引位置 cursor；
  - 2.绑定的值对应的新旧两组值；
- 然后，关注 advance function：
  - advance 中，可确认当前处理 node 在 LView 中的索引位置，advance(2) 意即当前 LView 对应数据向下前进两位；然后会发现一个 text node 和一个插值语法，对应运行 textInterpolate1 instruction，在这个 instruction 中确定绑定数据 header 是否有变化；
  - 注意首次执行时将 old value 传入空值，即必定更新一次，后续会缓存绑定的 value，接着调用 advance(1) 即再向下前进一位，将会找到 info-card，执行property instruction，这里找到的是一个子组件，因而是将值传递给组件的输入中；

***<u>注意：change detection的顺序问题</u>***

IVY 中，变更检测是按照 template 中 nodes 的顺序从上到下执行的，但是之前的 angular 版本并非如此；

- 之前变更检测存在两个独立的过程：
  - 1.对 directive inputs 做相应检测
  - 2.对 element 和 text 的绑定做相应检测，在之前这样的处理会让使用者非常困惑，因而在这个版本做了修复；

![img](https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200908152042.jpg)

注意：虽然在 node 层，IVY 保证了变更检测执行顺序与用户写的 template 一致，<u>但对于同一 node 的每个绑定值却并非如此</u>：同一 node 的多绑定值：property  提升，变更检测会先检查此；

![img](https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200908152047.jpg)

通过在 instruction 将自身返回出来，可实现类似的 property 链式操作，从而做到代码优化；



**<u>*补充：生命周期钩子调用时机*</u>**

生命周期的钩子是在变更检测的不同阶段 emit 出来；



参考：https://zhuanlan.zhihu.com/p/93242237

参考：https://www.zhihu.com/question/58083132/answer/155731764





















### 1-2、数据绑定/更新机制

#### 1-2-1、Vue 数据绑定机制

**<u>*一句话总结*</u>**：Vue 采用数据劫持+发布订阅模式，通过 Object.defineproperty 劫持各个属性的 Set/Get，在数据变动时发布消息给订阅者，触发响应的监听回调；

**<u>*双向数据绑定*</u>**：指数据变化更新视图，视图变化更新数据；比如：

- View => Data：输入框内容变化时，Data 数据同步变化；
- Data => View：Data 数据变化时，文本节点内容同步变化；

**<u>*Vue2.x 响应式数据原理*</u>**

Vue 在初始化数据时，会使用 Object.defineProperty 重新定义 data 中的所有属性，当页面使用对应属性时，首先会进行依赖收集(收集当前组件
的 watcher )，如果属性发生变化，就会通知相关依赖进行更新操作(发布订阅)；

- Object. property 方法使用：
  - object. property(参数1, 参数2, 参数3)；
    - 参数1为该对象(obj)
    - 参数2为要定义或修改的对象的属性名
    - 参数3为属性描述符(对象，主要有两种形式：数据描述符和存取描述符)；
  - 返回值：直接在一个对象上定义一个新属性或者修改对象上的现有属性，并返回该对象 obj；

- Object.defineProperty 优势如下：
  - 兼容性好，支持IE9，而 Proxy 的存在浏览器兼容性问题，且无法用 polfill 磨平；
- Object.defineProperty 问题有三：
  - 不能监听数组的变化；
  - 必须遍历对象的每个属性；
  - 必须深层遍历嵌套的对象；

**<u>*Vue3.x 响应式数据原理*</u>**
用 Proxy 替代 Object. defineProperty；因 Proxy 可直接监听对象和数组变化，并有多达13种拦截方法，作为新标准还受到浏览器厂商重点持续的性能优化；

- 注意：Proxy 只会代理对象第一层，但 Vue3 通过判断当前 Reflect. get 返回值是否为 Object，是则再通过 reactive 方法做代理，实现深度观测；
- 注意：监测数组时可能触发多次 Get/Set，Vue3 通过判断 key 是否为当前被代理对象 target 自身属性，或判断旧值与新值是否相等，来执行 trigger；
- Proxy 在 ES2015 规范中被正式加入，特点如下：
  - 可直接监听对象而非属性，针对整个对象，而非对象某个属性，无需对 keys 进行遍历；
  - 可直接监听数组的变化，无需像 Object.defineProperty 对数组的方法进行重载，省去了众多 hack，减少代码量，减少了维护成本；
  - 有多达13种拦截方法，不限于apply、 ownKeys、 deleteProperty、 has 等等，而这是 Object.defineProperty 所不具备的；
  - 返回的是一个新对象,我们可以只操作新的对象达到目的,而Object.defineProperty只能遍历对象属性直接修改；
  - 作为新标准受到浏览器厂商重点关注和性能优化；

**<u>*Vue2 双绑实现要点：*</u>**

- 监听器 Observer：
  - 对数据对象进行遍历，包括子属性对象的属性，利用 Object.defineProperty 对属性都加上 Get/Set，用于依赖收集和派发更新；
- 解析器 Compile：
  - 解析 Vue 模板指令，将模板中的变量都替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添
    加监听数据的订阅者，一旦数据有变动，收到通知，调用更新函数进行数据更新；
- 订阅者 Watcher：
  - Watcher 是前两者间的通信桥梁，主要负责：订阅 Observer 中的属性值变化消息，当收到属性值变化消息时，触发解析器 Compile 中对应的更新函数；实际上 Watcher 实例分为渲染 watcher (render watcher)、计算属性 watcher (computed watcher)、侦听器 watcher (user watcher)三种；
- 订阅器 Dep：
  - 订阅器采用发布-订阅设计模式，用来收集订阅者 Watcher，以对监听器 Observer 和订阅者 Watcher 进行统一管理(每个响应式对象包括子对象，都拥有一个 Dep 实例(里面的 subs 是存放 Watcher 实例的数组)，当数据有变更时，会通过 dep.notify 通知各个 watcher)；
  - 上述两者关系：Watcher 中实例化了 dep 并向 dep.subs 中添加了订阅者 watcher，而 dep 通过 notify 遍历了 dep.subs 通知每个 watcher 更新；

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200908132750.png" style="zoom:50%;" />

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200908132751.png" style="zoom:50%;" />

**<u>*依赖收集过程*</u>**：

1. initState 时，对 computed 属性初始化时触发 computed watcher 依赖收集；
2. initState 时，对侦听属性初始化时，触发user watcher 依赖收集；
3. render 过程，触发render watcher 依赖收集；
4. re-render 时，vm.render 再次执行，会移除所有 subs 中的 watcer 的订阅，重新赋值；

**<u>*触发更新*</u>**：

1. 组件中对响应的数据进行了修改，触发 setter 逻辑；
2. 调用 dep.notify，遍历所有的 subs (Watcher 实例)，最后调用每一个 watcher 的 update 方法；

**<u>*响应原理*</u>**：
创建 Vue 实例时，Vue 会遍历 data 选项的属性，并利用 Object.defineProperty 为属性添加 Set/Get，以对数据读写进行监听 (Get 用来依赖收集，Setter
用来派发更新)，并且在内部追踪依赖，在属性被访问和修改时通知变化；
然后，每个组件实例会有相应的 watcher 实例，其会在组件渲染的过程中，记录依赖的所有数据属性(进行依赖收集还有 computed watcher,user watcher实例) ,之后依赖项被改动时，setter 方法会通知依赖与此 data 的 watcher 实例重新计算(派发更新)，从而使它关联的组件重新渲染；

```html
<div id="myapp">
  <input v-model="message" /><br>
  <span v-bind="message"></span>
</div>
<script type="text/javascript">
  var model = {
    message: ""
  };
  var models = myapp.querySelectorAll(" [v-mode l=message]");
  for (var i = 0; i < models.length; i++) {
    models[ i ].onkeyup = function () {
      model[ this.getAttribute("v-model") ] = this.value;
    }
  }
  // 观察者模式/钩子函数
  // defineProperty 来定义一个对象的某个属性
  Object.defineProperty(model, "message", {
    set: function (newValue) {
      var binds = myapp.querySelectorAll(" [v-bind=message]");
      for (var i = 0; i < binds.length; i++) {
        binds[ i ].innerHTML = newValue;
      };
      var models = myapp.querySelectorAll(" [v-mode l=message]");
      for (var i = 0; i < models.length; i++) {
        models[ i ].value = newValue;
      };
      this.value = newValue;
    },
    get: function () {
      return this.value;
    }
  }
</script>
```



#### 1-2-2、Vue 数组与对象监听

Vue 通过遍历数组/对象(若数组/对象中包含着引用类型， 则会对其中的引用类型再次递归遍历)，从而实现对数组和对象内部属性数据进行监听；

而对于数组的操作监听则通过劫持方式，重写数组方法：push、pop、shift、unshift、splice、sort、reverse；

Vue 将 data 中的数组进行了原型链重写，使其指向自定义的数组原型方法；此后当调用上述数组方法时，便可通知依赖更新；

```ts
const arrayProto = Array.prototype;
export const arrayMethods = Object.create(arrayProto);
const methodsToPatch = [
  "push",
  "pop",
  "shift",
  "unshift",
  "splice",
  "sort",
  "reverse"
];
/**
* Intercept mutating methods and emit events
*/
methodsToPatch.forEach(function(method) {
  // cache original method
  const original = arrayProto[method];
  def(arrayMethods, method, function mutator(...args) {
    const result = original.apply(this, args);
    const ob = this.ob;
    let inserted;
    switch
    (method) {
      case "push":
      case "unshift":
        inserted = args;
        break
      case "splice":
        inserted = args.slice(2);
        break;
    }
    if (inserted) ob.observeArray(inserted);
    // notify change
    ob.dep.notify();
    return result;
  });
});
/**
* Observe a list of Array item
*/
Observer.prototype.observeArray = function observeArray(items) {
  for (var i = 0, l = items.length; i < l; i++) {
    observe(items[i]);
  };
};

// ...

// Observe a list of Array items.
observeArray(items: Array<any>) {
  for (let i = 0; (l = items.length), i < l; i++) {
    observe(items[i]); // observe 功能为监测数据的变化
  }
}

// 对属性进行递归遍历
let child0b = !shallow && observe(val); // observe 功能为监测数据的变化

// ...
```

- 注意：由于 JS 限制，Vue 不能检测到以下数组的变动：

  - 当利用索引直接设置一个数组项时，比如：`vm. items[indexOfItem] = newValue`

  - 当修改数组长度时，比如：`vm.items.length = newLength`

  - ```js
    // 为解决第一个问题，Vue 提供了以下操作方法:
    // Vue. set
    Vue.set(vm.items, index0fItem, newValue)
    // vm. $set, Vue.setá)- ↑5I5
    vm.$set(vm.items, index0fItem, newValue)
    // Array. prototype.splice
    vm.items.splice(indexOfItem, 1, newValue)
    
    //为解决第二个问题，Vue 提供了以下操作方法:
    // Array. prototype. splice
    vm.items.splice(newlength)
    ```

- 注意：之所以数组长度没有 Set/Get，是因为：如果知道数组长度，理论上可以预先给所有的索引设置 Set/Get，但实际场景中往往并不知道数组长度(且很多时候是不固定的)，且若是大数组，预先加 Set/Get 成本过大；可通过 Proxy 改进；



#### 1-2-3、<u>Vue.$set</u> (Vue.set == vm.$set 实现原理)

```ts
export function set(target: Array<any> | Object, key: any, val: any): any {
  // 若 target 为数组
  if (Array.isArray(target) && isValidArrayIndex(key)) {
    // 修改数组的长度，避免索引>数组长度导致 splcie 执行有误
    target.length = Math.max(target.length, key)
    // 利用数组的 splice 变异方法触发响应式
    target.splice(key, 1, val)
    return val
  }
  // 若 key 已存在，则直接修改属性值
  if (key in target && !(key in object.prototype)) {
    target[key] = val
    return va1
  }
  const ob = (target: any).__ob__
  // 若 target 非响应式数据，则直接赋值
  if (!ob) {
    target[key] = val
    return val
  }
  // 对属性进行响应式处理
  defineReactive(ob.value, key, val)
  ob.dep.notify()
  return val
}
```

1. 若目标是数组，使用 vue 实现的数组重载方法 splice 实现响应式；
2. 若目标是对象，判断属性存在，若存在即为响应式，直接赋值；
3. 若 target 本身就不是响应式，则直接赋值；
4. 若属性非响应式，则调用 defineReactive 方法进行响应式处理；





#### 1-2-4、Vue v-model 原理

v-model 指令在表单 input、textarea、 select 等元素上创建双向数据绑定，v-model 本质是一个语法糖，可看成是 value + input 方法的语法糖；可通过 model 属性的 prop 和 event 属性来进行自定义；原生的 v-model，会根据标签的不同生成不同的事件和属性；

- text、textarea元素使用 value 属性和 input 事件；
- checkbox、radio使用 checked 属性和 change 事件；
- select 字段将 value 作为 prop 并将 change 作为事件；

```html
// 1、表单元素 input
<input *v-model*=' something'>
// 相当于
<input *v-bind:* *va* *lue*="something" *v-on:* *input*="something = $event. target.value">

// 2、自定义组件，v-model 默认会利用名为 value 的 prop 和 input 事件
// 父组件:
<*ModelChild* *v-mode* *l*="message"></*ModelChild*>
// 子组件:
<div>{{value}}</div>
props:{
	value: *String*
}
methods: {
	test1(){
	this. $emit('input', 'TLP')
},
```



#### 1-2-X、Angular 变更检测机制

通过 zone 触发检测机制，并通过深度优先遍历组件，与存储旧值比对实现更新，详看另一章的"前端框架"一文



#### 1-2-Z、Vue & Angular 对比

前者核心利用 Object.defineProperty 触发变化通知，然后 DOM Diff 负责值判断和视图刷新；

后者利用 Zone 对异步事件进行劫持，捕获变化通知，触发变更检测，深度优先遍历，利用组件视图中存储的旧值进行比对，然后更新视图；



### 1-3、生命周期

#### 1-3-1、Vue 生命周期

Vue 实例有一个完整的生命周期，也即从开始创建、初始化数据、编译模版、挂载DOM->渲染、更新->渲染、卸载等一系列过程，称之为 Vue 的生命周期；

vue 生命周期总共分为8个阶段：创建前/后，载入前/后， 更新前/后，销毁前/后：

- 创建前/后：
  - beforeCreate：vue 实例的挂载元素 `$el` 和数据对象 data 都是 undefined，尚未初始化；
  - created：完成 data 数据初始化，但 `$el` 还未初始化；
- 载入前/后：
  - beforeMount：vue 实例的 `$el` 和 data 均已初始化，相关 render 函数首次被调用；实例已完成以下配置：编译模板，将 data里的数据和模板生成html；但注意此时还未挂载 html 到页面上；
  - mounted：`el` 被新创建的 `vm.$el` 替换，并挂载到实例上后调用；实例已完成以下配置：用上面编译好的 html 内容替换 `el` 属性指向的 DOM 对象；完成将模板中的 html 渲染到 html 页面；此过程中进行 ajax 交互；
- 更新前/后：
  - beforeUpdate：在数据更新前调用，发生在虚拟 DOM 重新渲染和打补丁前；可在此钩子中进一步地更改状态，且不会触发额外的重渲染过程；
  - updated：在由于数据更改导致的虚拟 DOM 重新渲染和打补丁后调用；调用时，组件 DOM 已更新，故可执行依赖于 DOM 的操作；但注意：大多数情况下，应避免在此期间更改状态，因可能会导致更新无限循环(使用 this.$nextTick 缓解)；该钩子在服务器端渲染期间不被调用；
- 销毁前/后：
  - beforeDestroy：在实例销毁前调用；实例仍然完全可用；
  - destroyed：在实例销毁后调用；调用后所有的事件监听器会被移除，所有子实例也会被销毁；该钩子在服务器端渲染期间不被调用；

| 生命周期      | 描述                                                         |
| ------------- | ------------------------------------------------------------ |
| beforeCreate  | 组件实例被创建之初，组件的属性生效前                         |
| Reated        | 组件实例已经完全创建，属性也绑定，但真实dom还没有生成，`$el` 还不可用 |
| beforeMount   | 在挂载开始之前被调用：相关的 render 函数首次被调用           |
| mounted       | el 被新创建的 vm.$el 替换，并挂载到实例上，之后调用该钩子    |
| beforeUpdate  | 组件数据更新之前调用，发生在虚拟 DOM 打补丁前                |
| update        | 组件数据更新之后                                             |
| activited     | keep-alive 专属，组件被激活时调用                            |
| deactivated   | keep-alive 专属，组件被销毁时调用                            |
| beforeDestory | 组件销毁前调用                                               |
| destoryed     | 组件销毁后调用                                               |

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200908132752.png" style="zoom:50%;" />

- 注意：发起异步请求和操作DOM时机
  - <u>异步请求</u>：可在钩子函数 created、beforeMount、 mounted 中进行调用，这三个钩子中，data 已经创建，可将服务端端返回的数据进行赋值；而在 created 钩子中调用异步请求还有以下优点：
    - 更快获取到服务端数据，减少页面 loading 时间；
    - ssr不支持 beforeMount、mounted 钩子函数，放在 created 有助于确保一致性；
  - <u>操作DOM</u>：在钩子函数 mounted 被调用前，Vue 已将编译好的模板挂载到页面上，故在 mounted 中即可访问操作 DOM；



#### 1-3-1、Vue 父子组件生命周期执行顺序

Vue 父组件和子组件生命周期钩子函数执行顺序可为以下 4 部分：

- 加载渲染过程：父beforeCreate ->父created ->父beforeMount ->子beforeCreate ->子created ->子beforeMount ->子mounted ->父mounted；
- 子组件更新过程：父beforeUpdate ->子beforeUpdate ->子updated ->父updated；
- 父组件更新过程：父beforeUpdate ->父updated；
- 销毁过程：父beforeDestroy ->子beforeDestroy ->子destroyed ->父destroyed

总结即：组件的调用顺序都是：先父后子，渲染完成顺序则是：先子后父；

总结即：组件销毁顺序是：先父后子，销毁完成顺序是：先子后父；

- 注意：父组件监听子组件生命钩子调用方式：

- ```html
  // 方式1: 通过 $emit 触发父组件事件
  // Parent.vue
  <Child @mounted="doSomething"/>
  // Child. vue
  mounted() {
  	this.$emit("mounted”); 
  }
  
               
  // 方式2: 在父组件引用子组件时, 通过 @hook 监听
  // Parent. vue
  <Child @hook :mounted="doSomething"></Child>
  doSomething() {
  	// ... B
  }
  // Child. vue
  mounted(){
  	// ... A
  },
  // 以上输出顺序为: A -> B
  // @hook 方法不仅可监听 mounted, 还可监听其它生命周期事件，比如 created, updated 等
  ```



#### 1-3-X、Angular 生命周期

生命周期的钩子是在变更检测的不同阶段 emit 出来触发调用，而非变更检测则次序执行；

- **<u>*constructor*</u>**：是 ES6 中 class 中新增的属性，当 class 类实例化的时候调用 constructor，来初始化类；
  - Angular 组件的构造函数会在所有的生命周期钩子之前被调用，它主要用于依赖注入或执行简单的数据初始化操作；

- **<u>*ngOnChanges*</u>**：当数据绑定输入属性值发生变化时调用；首次调用一定会发生在 ngOnInit() 前(随后 ngOnInit 不调用(只调1次)，OnChanges 则继续调用)；
  - Angular 将会主动调用 ngOnChanges 方法；它会获得一个 SimpleChanges 对象，包含绑定属性的新值和旧值，它主要用于监测组件输入属性的变化；当 Angular(重新)设置数据绑定输入属性时响应；该方法接受当前和上一属性值的 SimpleChanges 对象；
- **<u>*ngOnInit*</u>**：在第一次 ngOnChanges 执行之后调用，且只被调用一次；主要用于执行组件的其它初始化操作或获取组件输入的属性值；
  - 适用于在构造函数之后马上执行复杂的初始化逻辑、或在 Angular 设置完输入属性后，对该组件进行准备；
- ngDoCheck：当组件的输入属性发生变化时，将会触发 ngDoCheck 方法；在每个 Angular 变更检测周期中调用；
  - 多用于自定义检测逻辑，用于检测和处理值的改变；
- ngAfterContentInit：在组件内容初始化之后调用；
  - 当在组件使用 ng-content 指令的情况下，Angular 会在将外部内容放到视图后用；
  - 主要用于获取通过 @ContentChild 或 @ContentChildren 属性装饰器查询的内容视图元素；
  - 当把内容投影进组件之后调用。第一次ngDoCheck()之后调用，只调用一次；
- ngAfterContentChecked：组件每次检查内容时调用；
  - 在组件使用 ng-content 指令的情况下，Angular 会在检测到外部内容的绑定或者每次变化的时候调用；每次完成被投影组件内容的变更检测之后调用。ngAfterContentInit() 和每次 ngDoCheck() 后调用；
- ngAfterViewInit：组件相应的视图初始化后调用；
  - 主要用于获取通过 @ViewChild 或 @ViewChildren 属性装饰器查询的视图元素；
  - 初始化完组件视图及其子视图后调用；第一次ngAfterContentChecked()之后调用，只调用一次；
  - 与 AfterContent 相似，区别如下：
    - 前者关心的是 ViewChildren，这些子组件的元素标签会出现在该组件的模板里面；
    - 后者关心的是 ContentChildren，这些子组件被Angular投影进该组件中；
- ngAfterViewChecked：组件每次检查视图时调用；
  - 即每次做完组件视图和子视图的变更检测之后调用；ngAfterViewInit() 和每次 ngAfterContentChecked 后调用；
- **<u>*ngOnDestroy*</u>** - 指令销毁前调用；
  - 主要用于执行一些清理操作，比如：移除事件监听、清除定时器、退订 Observable 等，以防内存泄漏





### 1-4、组件通信方式

#### 1-4-1、Vue 组件间通信方式

Vue组件间通信只要指以下3类通信：父子组件通信、隔代组件通信、兄弟组件通信；

**<u>*父子组件通信*</u>**：

- 父—>子 `props`；

- ```js
  // 父子单向传值 data
  <template>
    <div>
      <div>爸爸:{{date}}</div>
      <Son1 :date="date"></Son1>
    </div>
  </template>
  <script>
  import Son1 from "./son1";
  export default {
    components: { Son1 },
    data() {
      return {
        date: 1,
      };
    },
  };
  </script>
  // 子组件接收传值 prop
  <template>
    <div>儿子:{{date}}</div>
  </template>
  <script>
  export default {
    props: {
      date: {
        type: Number, //校验类型
        default: "1",
      },
    },
  };
  </script>
  ```

- 子—>父一 `$on、$emit`

- ```js
  // 使用1
  // 子组件
  // 通过触自身的方法来触发 $emit 方法, 再触发父组件的方法, 通过回调传参的方式将修改的内容传递给父组件
  <template>
    <div>
      <div>儿子:{{date}}</div>
      <button @click="changeNum">修改</button>
    </div>
  </template>
  <script>
  export default {
    props: {
      date: {
        type: Number,
        default: "1",
      },
    },
    methods: {
      changeNum() {
        this.$emit("changeNum", 2);
      },
    },
  };
  </script>
  // 父组件
  // 接受回调params参数，即爸爸需要给儿子绑定了一个自定义的事件，$on("changeNum",params)
  <template>
    <div>
      <div>爸爸:{{date}}</div>
      <Son1 :date="date" @changeNum="changeNum"></Son1>
    </div>
  </template>
  <script>
  import Son1 from "./son1";
  export default {
    components: { Son1 },
    data() {
      return {
        date: 1,
      };
    },
    methods: {
      changeNum(params) {
        this.date = params;
      },
    },
  };
  </script>
  
  
  
  // 使用2 .sync
  // 子组件通过$emit("update:xxx")发射事件
  <template>
    <div>
      <div>儿子:{{date}}</div>
      <button @click="changeNum">修改</button>
    </div>
  </template>
  <script>
  export default {
    props: {
      date: {
        type: Number,
        default: "1",
      },
    },
    methods: {
      changeNum() {
        this.$emit("update:date", 2);
      },
    },
  };
  </script>
  // 父组件通过:xxx.sync="xxx"接受参数
  <template>
    <div>
      <div>爸爸:{{date}}</div>
      <Son1 :date.sync="date"></Son1>
    </div>
  </template>
  <script>
  import Son1 from "./son1";
  export default {
    components: { Son1 },
    data() {
      return {
        date: 1,
      };
    },
  };
  </script>
  <Son1 :date.sync="date"></Son1>
  //这个写法是上面的替代品 默认组件内部触发 update:count 规定写法
  <Son1 :date="date" @update:date="val=>date=val"></Son1>
  
  
  
  // 使用3 v-model
  // 注意: v-model 局限只能传递一个属性 如果只有一个 可以使用v-model 多个依然需要使用.sync
  // 子组件触发的事件只能是input事件,接收props的属性名只能叫value
  <template>
    <div>
      <div>儿子:{{value}}</div>
      <button @click="changeNum">修改</button>
    </div>
  </template>
  <script>
  export default {
    props: {
      value: {
        type: Number,
        default: 1,
      },
    },
    methods: {
      changeNum() {
        this.$emit("input", 2);
      },
    },
  };
  </script>
  // 父组件通过v-model接收参数
  <template>
    <div>
      <div>爸爸:{{value}}</div>
      <Son1 v-model="value"></Son1>
    </div>
  </template>
  <script>
  import Son1 from "./son1";
  export default {
    components: { Son1 },
    data() {
      return {
        value: 1,
      };
    },
  };
  </script>
  <Son1 :value="value" @input="val=>value=val"></Son1>
  //这个写法是上面的替代品 默认组件内部触发 input 规定写法
  <Son1 v-model="value"></Son1>
  
  ```

- 获取父子组件实例 `$parent、 $children`、`ref & $parent/$children`

  - `ref` 获取实例的方式调用组件的属性或方法；若在普通 DOM 元素上使用，引用指向即 DOM 元素；若在子组件上，引用则指向组件实例；

  - ```js
    // 父级
    <template>
      <div>
        <div>爸爸</div>
        <Son1 ref="son"></Son1>
      </div>
    </template>
    <script>
    import Son1 from "./son1";
    export default {
      components: { Son1 },
      mounted() {
        this.$refs.son.show();
      },
    };
    </script>
    
    // 子级
    <template>
      <div>
        <div>儿子</div>
      </div>
    </template>
    <script>
    export default {
      methods: {
        show() {
          console.log(1);
        },
      },
    };
    </script>
    ```

  - `$parent | $children`：访问父/子实例；

  - ```js
    // 孙子想要给爷爷传递数据,孙子需要找到爷爷身上的事件去传递$parent.$emit
    // 孙级
    <template>
      <div>
        <div>孙子{{value}}</div>
        <button @click="$parent.$emit('change',3)">修改</button>
      </div>
    </template>
    <script>
    export default {
      props: {
        value: {
          type: Number,
          default: "",
        },
      },
    };
    </script>
    // 子级
    // 儿子组件使用孙子组件
    <template>
      <div>
        <div>儿子:{{value}}</div>
        <grandson1 :value="value"></grandson1>
      </div>
    </template>
    <script>
    import grandson1 from "./grandson1";
    export default {
      components: {
        grandson1,
      },
      props: {
        value: {
          type: Number,
          default: 1,
        },
      },
    };
    </script>
    // 父级
    // 爸爸身上给孙子自定义change事件
    <template>
      <div>
        <div>爸爸:{{value}}</div>
        <Son1 @change="val=>value=val" :value="value"></Son1>
      </div>
    </template>
    <script>
    import Son1 from "./son1";
    export default {
      components: { Son1 },
      data() {
        return {
          value: 1,
        };
      },
    };
    </script>
    // 注意: 如果层级很深那么就会出现$parent.$parent.....我们可以封装一个$dispatch方法向上进行派发
    Vue.prototype.$dispatch = function $dispatch(eventName, data) {
      let parent = this.$parent;
      while (parent) {
        parent.$emit(eventName, data);
        parent = parent.$parent;
      }
    };
    // 注意: 相同的道理，如果既然能够向上寻找父亲，就能向下寻找儿子，也可以封装一个向下派发的方法$broadcast
    Vue.prototype.$broadcast = function $broadcast(eventName, data) {
      const broadcast = function () {
        this.$children.forEach((child) => {
          child.$emit(eventName, data);
          if (child.$children) {
            $broadcast.call(child, eventName, data);
          }
        });
      };
      broadcast.call(this, eventName, data);
    };
    ```

    

**<u>*兄弟组件通信*</u>**：

- `EventBus` 实现跨组件通信 ` Vue.prototype.$bus = new Vue` ；
  
  - 通过一空 Vue 实例作为中央事件总线(事件中心)，用它来触发事件和监听事件，从而实现任何组件间通信，包括父子、隔代、兄弟组件；
  
  - ```js
    Vue.prototype.$bus = new Vue();
    
    // 发布者
    <template>
      <div>孙子1</div>
    </template>
    <script>
    export default {
      mounted() {
        this.$nextTick(() => {
          this.$bus.$emit("test", "go");
        });
      },
    };
    </script>
    
    // 订阅者
    <template>
      <div>儿子2</div>
    </template>
    <script>
    export default {
      mounted() {
        this.$bus.$on("test", (data) => {
          console.log(data);
        });
      },
    };
    </script>
    ```

**<u>*跨级组件通信*</u>**：

- `Vuex`；
- `$attrs、$listeners`；
  - `$attrs` ：包含父作用域中不被 prop 所识别且获取的特性绑定(class 和style除外)；
  
    - `$attrs`批量向下传入属性；
  
    - 若一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定( class和style除外)，并可通过 `v-bind="$attrs"` 传入内部组件；
  
    - 通常配合 inheritAttrs 选项一起使用；
  
    - ```js
      // 父级
      <template>
        <div>
          <div>爸爸:{{value}}</div>
          <Son1 @change="val=>value=val" :value="value"></Son1>
        </div>
      </template>
      <script>
      import Son1 from "./son1";
      export default {
        components: { Son1 },
        data() {
          return {
            value: 1,
          };
        },
      };
      </script>
      // 子级
      // 在儿子组件中使用 $attrs 属性, 配合 v-bind 可将属性继续向下传递
      <template>
        <div>
          <div>儿子:{{$attrs.value}}</div>
          <grandson1 v-bind="$attrs"></grandson1>
        </div>
      </template>
      <script>
      import grandson1 from "./grandson1";
      export default {
        components: {
          grandson1,
        },
        mounted() {
          console.log(this.$attrs);
        },
      };
      </script>
      // 注意：在使用 $attrs 时，如果组件中使用了 props 就会将属性从当前 attrs 移除掉
      // 在孙子组件中使用 $attrs属性,可以将属性继续向下传递
      <template>
        <div>
          <div>孙子{{$attrs.value}}</div>
        </div>
      </template>
      <script>
      export default {
        //props: {
        //  value: Number,
        //},
        mounted() {
          console.log(this.$attrs);
        },
      };
      </script>
      // 如果爸爸传递给儿子元素, 儿子有三个属性用不到， 孙子传递给孙子，但是不想在页面上这个属性，可以设置inheritAttrs: false
      ```
  
  - `$listeners` ：包含父作用域中的 v-on 事件监听器(不含.native 修饰器)；它可通过 `v-on="$listeners"` 传入内部组件；
  
    - `$listeners`批量向下传入方法
  
    - ```js
      // 父级
      <template>
        <div>
          <div>爸爸:{{value}}</div>
          <Son1 @click="change" :value="value"></Son1>
        </div>
      </template>
      <script>
      import Son1 from "./son1";
      export default {
        components: { Son1 },
        data() {
          return {
            value: 1,
          };
        },
      
        methods: {
          change() {
            this.value = 2;
          },
        },
      };
      </script>
      // 子级
      // 可在 son1 组件中使用 $listeners 属性, 配合 v-on 可将方法继续向下传递
      <template>
        <div>
          <div>儿子:{{$attrs.value}}</div>
          <grandson1 v-bind="$attrs" v-on="$listeners"></grandson1>
        </div>
      </template>
      <script>
      import grandson1 from "./grandson1";
      export default {
        components: {
          grandson1,
        },
        mounted() {
          console.log(this.$attrs);
          console.log(this.$listeners);
        },
      };
      </script>
      // 孙级
      // 孙子组件可以直接使用 $listeners 上的方法
      <template>
        <div>
          <div>孙子{{$attrs.value}}</div>
          <button @click="$listeners.click"></button>
        </div>
      </template>
      <script>
      export default {
        mounted() {
          console.log(this.$attrs);
          console.log(this.$listeners);
        },
      };
      </script>
      ```
  
      
  
- `Provide、inject；`
  
  - 祖先组件中通过 provider 来提供变量，然后在子孙组件中通过 inject 注入变量；
  
  - provide / inject API 主要解决跨级组件间通信问题，但其使用场景，主要是子组件获取上级组件状态，此模式建立了一种主动提供&依赖注入关系；
  
  - ```js
    // 父级声明
    export default {
      provide() {
        return { vm: this };
      },
    };
    // 子级注入
    <template>
      <div>
        <div>孙子</div>
      </div>
    </template>
    <script>
    export default {
      inject: ["vm"],
      mounted() {
        console.log(this);
      },
    };
    </script>
    ```
  
    

**<u>*其他方式*</u>**：

- Pub / Sub
- Element UI dispatch / broadcast
- Observable
- Vue-rx



##### 1-4-1、事件绑定与 on/off/emit/once

原生事件绑定是通过 addEventListener 绑定给真实元素，组件事件绑定是通过 Vue自定义的 `$on` 实现；手写 `$on,$off,$emit,$once`

```js
class Vue {
  constructor () {
    // 事件通道调度中心
    this._events = Object.create(null);
  }
  $on(event, fn) {
    if (Array.isArray(event)) {
      event.map(item => {
        this.$on(item, fn);
      })
    } else {
      (this._events[event] || (this._events[event] = [])).push(fn)
      return this;
    }
  }
  $once(event, fn) {
    function on() {
      this.$off(event, on);
      fn.apply(this, arguments);
    }
    on.fn = fn;
    this.$on(event, on);
    return this;
  }
  $off(event, fn) {
    if (!arguments.length) {
      this.events =
        object.create(null);
      return this;
    }
    if (Array.isArray(event)) {
      event.map(item => {
        this.$off(item, fn);
      });
      return this;
    }
    const cbs = this._events[event];
    if (!cbs) {
      return this;
    }
    if (!fn) {
      this._events[event] = null;
      return this;
    }
    let cb;
    let i = cbs.length;
    while (i--) {
      cb = cbs[i];
      if (cb === fn || cb.fn === fn) {
        cbs.splice(i, 1);
        break;
      }
      return this;
    }
  }
  $emit(event) {
    let cbs = this._events[event];
    if (cbs) {
      const args = [].slice.call(arguments, 1);
      cbs.map(item => {
        args ? item.apply(this, args) : item.call(this);
      });
    }
    return this;
  }
}
```



##### 1-4-2、Vuex

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200908132753.png" style="zoom:50%;" />

Vuex 是一个专为 Vue 应用开发的状态管理库；也可以说 Vuex 就是一放了很多对象的仓库；其中 state 就是数据源存放地，对应于一般 vue 对象里面的 data，state 中存放的数据是响应式的，vue 组件从 store 读取数据，若 store 中的数据发生改变，依赖这相数据的组件也会发生更新；

- 可通过 mapState 将全局 state 和 getters 映射到当前组件的 computed 计算属性中；

- 改变 store 中状态的唯一途径：显式地提交(commit) mutation，如此可方便地跟踪每一个状态的变化；
- State：定义应用状态的数据结构，可在这里设置默认的初始状态；
  - 注意：Vuex 使用单一状态树，即每个应用仅包含一个 store 实例，但单一状态树与模块化并不冲突；存放的数据状态，不可直接修改其中的数据；
- Getter：允许组件从 Store 中获取数据，类似 vue 计算属性，主用来过滤数据；
  - 注意 mapGetters 辅助函数仅将 store 中的 getter 映射到局部计算属性；
- Mutation：是唯一能更改 store 中数据状态的方法，且必须是同步函数；
- Action：可理解为：通过将 mutations 中，处里数据的方法变成可异步的处理数据的方法，即异步操作数据；view 层通过 store.dispath 来分发 action；
- Module:允许将单- -的 Store拆分为多个store且同时保存在单一的状态树中 。

Vuex 一般用于中大型 web 单页应用中对应用的状态进行管理，对于某些组件间关系较为简单的小型应用，使用 Vuex 必要性不是很大，因为完全可以用组件 prop 属性或事件来完成父子组件间的通信，Vuex 更多地用于解决跨组件通信以及作为数据中心集中式存储数据；

- 使用 Vuex 解决非父子组件间通信问题：Vuex 是通过将 state 作为数据中心、各个组件共享 state 实现跨组件通信，此时的数据完全独立于组件，因此将组件间共享的数据置于 State中，能有效解决多层级组件嵌套的跨组件通信问题；
- Vuex 作为数据存储中心：Vuex 的 State 在单页应用的开发中本身具有一个"数据库"的作用，可将组件中用到的数据存储在 State 中，并在 Action 中封装数据读写的逻辑；通常个主要有两种数据会使用 Vuex 进行管理：
  - 组件间全局共享的数据；
  - 通过后端异步请求的数据；比如：加入购物车、登录状态等都可以使用 Vuex 来管理数据状态；

Vuex 项目中注意的问题：

- 开发时，改变数组或对象的数据，但是页面没有更新如何解决？
- vue 弹窗后如何禁止滚动条滚动?
- 如何在 vue 项目里正确地引用 jquery 和 jquery-ui 插件?



#### 1-4-2、Angular 组件通信方式

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200908132754.png" style="zoom:50%;" align="left"/>

通过输入型绑定把数据从父组件传到子组件 - @Input

- 通过 setter 截听输入属性值的变化
- 通过 ngOnChanges() 来截听输入属性值的变化

父组件监听子组件的事件 - @Output

父组件与子组件通过本地变量互动；

父组件调用@ViewChild()

父组件和子组件通过服务来通讯

**<u>*方式1+2：Input、Output：*</u>**

- 被 @Input 修饰的 ParentData 为输入属性，被 @Output 修饰的为输出属性，输入输出相对于当前组件角度，输出属性一般通过事件形式，将数据通过 EventEmitter 发射出去；
- 而对于输入属性，有两种操作可实现数据的拦截：setter、ngOnChanges，以可二次处理，确保可控；

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200908132755.png" style="zoom:50%;" align="left"/>

拦截方式1：set，set & get 须成对出现：

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200908132756.png" style="zoom:50%;" align="left"/>

拦截方式2：ngOnChanges 是组件生命周期之一，发生在 ngOninit 之前，输入值(指通过@Input 装饰器显式指定的变量)，发生变化时会触发，可用于检测数据前后变化，但有性能问题，不推荐使用；

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200908132757.png" style="zoom:50%;" align="left"/>

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200908132758.png" style="zoom:50%;" align="left"/>

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200908132759.png" style="zoom:50%;" align="left"/>



**<u>*方式3+4：通过变量“映射” & ViewChild*</u>**

- 父组件不能使用数据绑定来读取子组件的属性或调用子组件的方法；
- 但可在父组件模板里，新建本地变量来代表子组件，然后利用这个变量来读取子组件的属性和调用子组件的方法，比如下面的 son 变量；
- 缺点：通过变量连接的行为，须在父组件的模板中进行，父组件本身代码，无法访问子组件；

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200908132800.png" style="zoom:50%;" align="left"/>

改进：若想实现父组件类访问子组件方法和属性，须使用 @ViewChild 装饰器，将子组件作为 ViewChild，注入父组件中；

导入对装饰器 [ViewChild](https://angular.cn/api/core/ViewChild) 、导入生命周期钩子 [AfterViewInit](https://angular.cn/api/core/AfterViewInit) 引用、通过 @[ViewChild](https://angular.cn/api/core/ViewChild) 属性装饰器，将子组件注入到私有属性中；

使用 ngAfterViewInit 的目的是将更新主动延迟一轮，因 Ng 单向数据流规则会阻止在同一个周期内更新父组件视图 (AfterViewInit 再更新就太晚了)

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200908132801.png" style="zoom:50%;" align="left"/>



**<u>*方式5：通过服务跨组件通讯 (实际上能作为第三方的均可实现：存储、Rxjs等)；*</u>**

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200908132802.png" style="zoom:50%;" align="left"/>



### 1-5、虚拟 DOM 与 Diff

#### 1-5-1、虚拟DOM

优点：

- 保证性能下限：虚拟DOM 需要适配任何上层 API 可能产生的操作，其一些 DOM 操作的实现必须是普适的，所以性能并非最优；但与真实 DOM 操作性能相比仍要好得多；虛拟DOM 可以保证在无需手动优化的情况下，依然可以提供不错性能，即保证性能下限; .
- 无需手动操作DOM：无需手动操作DOM，只需要写好 View-Model 代码逻辑，框架会根据虚拟 DOM & 数据双向绑定，辅助更新视图，极大提高开发效率; 
- 跨平台：真实 DOM 与平台强相关，而虚拟 DOM 本质上是 JS 对象，可进行更方便地跨平台操作；

缺点:

- 无法进行极致优化：虽虚拟DOM +合理优化，足以应对绝大部分应用的性能需求，但在某些性能要求极高的应用，虚拟DOM无法进行针对性的极致优化；

原理：

- 用 JS 对象模拟真实 DOM树，对真实DOM进行抽象；
- 用 Diff 算法比较两棵虚拟DOM树间的差异；
- 用 pach 算法将两个虚拟 DOM 对象的差异，应用到真正的DOM树；

示例：

- Vue2 的 Virtual DOM 借鉴了开源库 snabbdom 的实现；
- Vue2 的 VirtualDOM 映射到真实DOM 要经历 VNode 的 create、diff 、patch等阶段；



#### 1-5-2、Diff

##### 1-5-1、Diff 过程

正常 Diff 两个树的时间复杂度是 O(n^3)(旧树、新树、真实树)， 但实际情况中很少会进行跨层级的 DOM 移动，所以 Vue 将传统 Diff 过程进行了优化，使其时间复杂度从O(n^3) 降至 O(n)，只有当新旧 children 都为多个子节点时，才需要用核心的 Diff 算法进行同层级比较；

Vue2 核心Diff算法采用双端比较的算法：同时从新旧 children 的两端开始进行比较，并借助 key 值找到可复用节点，再进行相关操作；

Vue3.x 借鉴了 ivi 算法和 inferno 算法：在创建 VNode 时就确定其类型，以及在 mount/patch 过程中采用位运算，来判断 VNode 类型，在此基础之上再配合核心的 Diff 算法，使其性能较 Vue2.x 有进一步提升；该算法中还运用了动态规划的思想求解最长递归子序列；

Vue2 Diff 实现主要通过两个方法：patchVnode 与 updateChildren：

- patchVnode：有两个参数：老节点oldVnode,新节点vnode；主要分五种情况：
  - if (oldVnode === vnode)，引用一致，则可认为无变化；
  - if(oldVnode.text !== null && vnode.text !== null && oldVnode.text !== vnode.text)，文本节点比较，需修改则调用 Node.textContent = vnode.text；
  - if( oldCh && ch && oldCh !== ch)，两个节点均有子节点且不一样，则调用 updateChildren 函数比较子节点(此乃 diff 核心)；
  - if (ch)，只有新节点有子节点，则调用 createEle(vnode)，vnode.el 已引用了老的 dom节点，createEle 函数会在老dom节点上添加子节点；
  - if (oldCh)，新节点没有子节点，老节点有子节点，则直接删除老节点；
- updateChildren：方法关键，过程可概括如下：
  - oldCh 和 newCh 各有两个头尾的变量 oldStartIndex、oldEndIndex & newStartIndex、newEndIndex，它们之间两两相互比较，共有 4种比较方式，若4种比较均无匹配，且若设置了 key，就会利用 key 进行比较，在比较过程中，变量会往中间靠拢，一旦 Startldx > Endldx 则表明 oldCh 和 newCh 至少有一个已经遍历完了，就会结束比较；

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200908132803.png" style="zoom:50%;" />





##### 1-5-2、Vue 中 key 的作用

key 是 Vue 中 vnode 的唯一标记，通过 key，在 diff 操作时可以更准确、更快速；

- 注意：对于简单列表页渲染来说，diff 节点也更快，但可能会产生隐藏副作用；比如不产生过渡效果、某些节点有绑定数据(表单)状态、状态错位等；

通过观察前面 Diff 过程，可得出 Vue 中 key 的作用是：key 是 Vue 中 vnode 的唯一标记， 通过 key，在 diff 操作时可更准确、更快速：

- 更准确：因带 key 就不是就地复用了，在 sameNode 函数 a.key === b. key 对比中，可避免就地复用，所以会更加准确；
- 更快速：利用 key 的唯一性，生成 map 对象，来获取对应节点，比遍历方式更快；

补充：key 的作用是尽可能的复用DOM元素

- 新旧 children 中的节点只有顺序是不同时，最佳操作应是通过移动元素位置来实现更新目的；
- 在新旧 children 节点中保存映射关系，以便能够在旧 children 节点中找到可复用节点，而 key 也就是 children 中节点的唯一标识；

```js
function createKeyToOldIdx (children, beginIdx, endIdx) {
  let i, key
	const map = {}
	for (i = beginIdx; i <= endIdx; ++i) {
		key = children [i].key
		if (isDef(key)) map[key] = i
	}
	return map 
}
```









### 1-6、KeepAlive

keep-alive 可实现组件缓存，在组件切换时不会对当前组件进行卸载(即将组件包含在 keep-alive 元素，组件就会被缓存，在组件切换时就不会重新渲染而是直接使用，响应速度也更快)；keep-alive 是 Vue内置的一个组件，可使被包含的组件保留状态，避免重新渲染，一般结合路由和动态组件一起使用，用于缓存组件：

- 常用的两个属性 include/exclude 允许组件有条件的进行缓存，两者都支持字符串或正则表达式
  - include 表示只有名称匹配的组件会被缓存；
  - exclude 表示任何名称匹配的组件都不会被缓存，其中 exclude 优先级比 include 高；
- 两个钩子函数 activated/deactivated，用来得知当前组件是否处于活跃状态；
  - 当组件被激活时，触发钩子函数 activated，当组件被移除时，触发钩子函数 deactivated；

**<u>*KeepAlive 实现原理与缓存策略*</u>**：

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200908132804.png" style="zoom:50%;" align="left" />

- 首先，获取 keep-alive 包裹着的第一个子组件对象及其组件名：getFirstComponentChild；
- 然后，根据设定的 include/exclude 进行条件匹配，决定是否缓存；不匹配，则直接返回组件实例；
- 然后，根据组件 ID 和 tag 生成缓存 Key，并在缓存对象中查找是否已缓存过该组件实例；
  - 若存在，则直接取出缓存值并更新该 key 在 this.keys 中的位置 (更新 key 的位置是实现 LRU 置换策略的关键)
- 然后，在 this.cache 对象中存储该组件实例并保存 key 值；
- 然后，检查缓存的实例数量是否超过 max 设置值，若超过则根据 LRU 置换策略删除最近最久未使用的实例(即是下标为0的那个key)；
  - LRU(Least recently used)，缓存淘汰算法，根据数据历史访问记录来进行淘汰数据，核心思想是"若数据最近被访问过，则将来被访问的几率也更高"
  - keep-alive 的实现正是利用了 LRU 策略，将最近访问的组件 push 到 this.keys 末尾，this.keys[0] 也即最久没被访问的组件；
- 最后，将组件实例的 keepAlive 属性设置为 true，此在渲染和执行被包裹组件的钩子函数会用到；

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200908132805.png" style="zoom:50%;" align="" />



### 1-7、VueRouter

Vue-router 有3种路由模式: hash、history、 abstract：

- hash：使用 URL hash 值来作路由；支持所有浏览器，包括不支持HTML5 History Api的浏览器；
- history：依赖 HTML5 History API 和服务器配置；具体可以查看HTML5 History模式；
- abstract：支持所有 JS 运行环境，如 Node.js 服务器端；若发现没有浏览器的API，则会自动强制进入此模式；

```js
switch (mode) {
  case 'history':
    this.history = new HTML5History(this, options.base)
    break
  case 'hash':
    this.history = new HashHistory(this, options.base, this.fallback)
    break
  case 'abstract':
    this.history = new AbstractHistory(this, options.base)
    break
  default:
    if (process.env.NODE__ENV !== 'production') {
      assert(false, `invalid mode: ${mode}`);
    }
}
```

**<u>*hash 模式的实现原理*</u>**
早期前端路由的实现就是基于 location.hash，location.hash 值即 URL 中 # 后面的内容(含符号#)；hash 路由模式实现基于以下几个特性

- URL 中 hash值只是客户端的一种状态，也即当向服务器端发出请求时，hash 部分不会被发送；
- hash 值的改变，都会在浏览器访问历史中增加记录；因此能通过浏览器回退、前进按钮控制 hash 的切换；
- 可通过 a 标签，并设置 href 属性，当用户点击标签后，URL 的 hash 值就会发生改变；
- 或可通过 JS 来对 loaction.hash 进行赋值，改变 URL 的 hash值；
- 可使用 hashchange 事件来监听 hash 值变化，从而对页面进行跳转(渲染)；

***<u>history 模式的实现原理</u>***
H5 提供 History API 来实现 URL 变化；其中最主要的API有：historv.pushState()—新增历史记录、historv.repalceState()—直接替换当前的历史记录；此两个 API 可在不进行刷新的情况下，操作浏览器的历史纪录；history 路由模式实现基于以下几个特性：

- pushState 和 repalceState 操作实现 URL 变化；
- 使用 popstate 事件来监听 url 变化，从而对页面进行跳转(渲染)；
- 注意：history.pushState() 或 history.replaceState() 不会触发 popstate 事件，所以需要手动触发页面跳转(渲染)；

```js
window.history.pushState(null, null, path);
window.history.replaceState(null, null, path);
```





### 1-8、Compiler & Render

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200908132806.png" style="zoom:50%;" align="" />

#### 1-8-1、Compiler

模板解析这种事，本质是将数据转化为一段html，最开始出现在后端，经过各种处理吐给前端；但随着各种 mv* 兴起，模板解析交由前端处理；

1、Vue complier 将 template 转化成一个 render 函数字符串，编译过程如下：

- parse函数：负责解析 template，利用正则生成 AST；
- optimize 函数：负责优化静态节点(标记不需要每次都更新的内容，diff 算法会直接跳过静态节点，从而减少比较过程，优化 patch 性能)；
- generate 函数：生成 render 函数字符串；

2、调用 new Watcher 函数，监听数据的变化，当数据发生变化时，Render 函数执行生成 vnode 对象；

3、调用 patch 方法，对比新旧 vnode 对象，通过DOM diff 算法添加、修改、删除真正的 DOM 元素；





### 1-9、nextTick

#### 1-9-1、异步更新队列与 nextTick

Vue 在更新 DOM 时是异步执行的；

- 首先，只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环下所发生的所有数据变更；假若同一个 watcher 被多次触发，则只会被推入到队列中一次；这种在缓冲时，去除重复数据能避免不必要的计算和 DOM 操作；
- 然后，在下一个的事件循环 Tick 中，Vue 刷新队列并执行实际已去重的工作；
  - 回顾：主线程的执行过程就是一个 tick，而所有的异步结果都是通过"任务队列"来调度；比如消息队列中存放的是一个个的任务 (task) 。规范中规定task分为两大类，分别是 macro task 和 micro task，且每个 macro task 结束后，都要清空所有的 micro task；
- Vue 内部对异步队列，会依次尝试使用原生 Promise.then、MutationObserver、setlmmediate，若执行环境均不支持，则会采用 setTimeout(fn, 0)代替；在vue2.5的源码中，macrotask 降级的方案依次是：setlmmediate、 MessageChannel、 setTimeout；

Vue 的 nextTick 方法的实现原理：

- Vue 用异步队列方式，来控制 DOM 更新和 nextTick 回调分别先后执行；
  - nextTick 在下次DOM更新循环结束后执行延迟回调；主要使用了宏&微任务，并根据环境分别尝试使用 Promise、MutationObserver、setlmmediate、setTimeout；
- microtask 因其高优先级特性，能确保队列中的微任务在一次事件循环前被执行完毕；
- 考虑兼容问题，Vue 对 microtask 做了向 macrotask 降级的方案；











### 1-X、其他

#### 1-X-1、Prop & Data

##### 1-X-1-1、单向数据流

所有 prop 都使得其 父子 prop 间形成一个**<u>*单向下行*</u>**：绑定父级的 prop 的更新会向下传递到子组件中，反之则不行，以防止从子组件意外改变父级组件状态；

- 注意：每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新值；即不应在子组件内部改变 prop；若子组件想修改，则只能通过 $emit 派发自定义事件，父组件接收到后，由父组件修改；即谁负责的数据谁管理；以下是两种试图改变 prop 的情形：

  - ```js
    // 情形1：
    // 下面的 prop 用来传递初始值; 而子组件希望将其作为本地的 prop 数据来使用; 此时应定义一本地 data 属性将此 prop 用作其初始值:
    props: [ 'initialCounter'] ,
    data: function () {
    	return {
    		counter: this.initialCounter
    	}
    }
    
    // 情形2：
    // 下面的 prop 以一种原始值传入且需要进行转换；此时应使用这个 prop 的值来定义一个计算属性
    props: ['size'],
    computed: (
    	normalizedSize: function () {
    		return this.size.trim().toLowerCase()
    	}
    }
    ```

- 注意：prop 指定类型

  - ```js
    props: {
      accountNumber: {
      	type: Number,
      	required: true
      },
      name: {
      	type:
      	String,
      	required: true
      },
      favoriteColors: Array
    }
    ```

    



##### 1-X-1-2、组件 data 与 实例 data

组件 data 与 实例 data，前者为函数，后者为对象；

因为组件是用来复用的，某组件被复用多次， 也就会创建多个实例，而本质上，这些实例用的都是同一个构造函数；若组件中的 data 是一个对象(引用类型)，子组件中的 data 属性值就会相互影响；而若组件中 data 选项是函数，则每个实例就可以维护一 份被返回对象的独立的拷贝，组件实例间的 data 属性值也不会互相影响；但是 new Vue 的实例，不会被复用的，不存在引用对象问题；

```js
// 组件 data
data() {
	return {
		name: 'TLP'
	}
}

// 实例 data
new Vue({
	el: "#app",
	router,
	store,
	template: '<App/>',
	components: { App }
})
```



#### 1-X-2、常用指令

##### 1-X-2-1、v-if 与 v-show 区别

前者，是真正的条件渲染，其会确保在切换过程中，条件块内的事件监听器和子组件适当地被销毁和重建，也即惰性的：若初始渲染时条件为假，则什么都不做直到条件首次变为真时，才会开始渲染条件块；

后者，不管初始条件是什么，元素总是会被渲染，然后只是简单地基于 CSS 的 "display" 属性进行切换；
所以，前者适用于在运行时很少改变条件，无需频繁切换条件的场景；后者则适用于需要非常频繁切换条件的场景；



#### 1-X-3、watch/computed/methods

三者区别：

- computed：计算属性，依赖其它属性值，且 computed 有缓存性，只有它依赖的属性值发生改变，下一次获取 computed 时才会重新计算新值；
  - 本质是一个惰性求值的观察者，其内部实现了一个具有缓存功能的 watcher，也即 computed watcher，watcher 不会立刻求值，同时其持有一个 dep 实例；实例内部通过 this.dirty 属性标记计算属性是否需要重新求值；然后，当 computed 的依赖状态发生改变时，就会通知这个惰性的 watcher；然后，computed watcher 通过  this.dep.subs.length 判断有没有订阅者：
    - 若有则会重新计算，然后对比新旧值，有变化就会重新渲染；注意：Vue 想确保不仅是计算属性依赖的值发生变化就触发渲染，而是当计算属性最终计算的值发生变化，才会触发渲染 watcher 重新渲染，本质上是一种优化；
    - 若无则仅将 this.dirty = true；注意：当计算属性依赖于其他数据时，属性并不会立即重新计算，只有之后其他地方需要读取属性时，它才会真正计算，即具备 lazy 特性；
  - 注意：computed 是在 DOM加载后马上执行，比如赋值操作；
  - 注意：计算属性计算时所依赖的属性一定是响应式依赖，否则计算属性不会执行；
  - 注意：计算属性是基于依赖进行缓存，若依赖无更新，调用计算属性并不会重新计算，因此可减少开销，只有在其依赖的属性值改变后的下一次获取computed 值时才会重新调用对应的 getter 来计算出相应新值；
- watch：侦听器，更多起观察作用，无缓存性，可以监听某些数据执行回调，每当监听的数据变化时，都会执行回调进行后续操作；
  - 注意：当需要进行深度监听对象中属性时，可打开 deep: true 选项，这样便会对对象中的每一项进行监听，虽会带来性能问题，但可使用字符串形式监听来优化；此外如果没有写到组件中，需要注意使用 unWatch 手动注销；
- methods：方法，无缓存性，不像 computed 在 DOM 加载后可自动执行，必须有一定触发条件才被执行，如点击事件等；
  - 区别：与 computed 区别在于：前者必须有一定的触发条件才能执行，比如重渲染，异步绑定事件等；而后者则基于它的依赖进行缓存，若多次访问的时候(值不变情况下)，计算属性会立即返回数据，而不必再次执行函数，另外还可自动执行(依赖变化且被读取)；

使用场景:

- 当数值计算并依赖于其它数据、计算耗性能的计算场景、模板表达式过于复杂时、复杂渲染数据的计算、不必重新计算数值，可利用 computed 缓存特性，避免每次获取值时都重新计算；
- 当需要在数据变化时执行异步或开销较大操作时，可使用 watch，注意限制执行该操作的频率，并在得到最终结果前，设置中间状态；
- 注意：能使用 watch 属性的场景基本上都可使用 computed 属性，且 computed 属性开销小性能高，故因尽量使用 computed 属性，除非要执行异步或昂贵的操作以响应不断变化的数据；
- 比如：点击搜索按钮的时候才进行数据的响应和操作，使用 computed；获取当前时间，使用 methods；



#### 1-X-4、SSR

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200908132807.png" style="zoom:50%;" align="" />

VueSSR 即 Vue 在客户端将标签渲染成的整个 html 片段的工作在服务端完成，服务端将形成的 html 片段直接返回给客户端的过程就叫做服务端渲染；

服务端渲染的优点：

- 更好的SEO：SPA 页面的内容通过 Ajax 获取，而搜索引擎爬取工具并不会等待 Ajax 异步完成后再抓取页面内容；而 SSR 是直接由服务端返回已渲染好的页面(数据已经包含在页面中)，所以搜索引擎爬取工具可以抓取渲染好的页面；
- 更快的内容到达时间(首屏加载更快)：SPA 会等待所有 Vue 编译后的 JS 文件都下载完成后，才开始进行页面渲染，文件下载等需要一定的时间，所以首屏渲染需要一定时间；而 SSR 则直接由服务端渲染好页面直接返回显示，无需等待下载 JS 文件及再去渲染等，所以 SSR 有更快的内容到达时间；

服务端渲染的缺点：

- 更多的开发条件限制：比如服务端渲染只支持 beforCreate 和 created 两个钩子函数，导致一些外部扩展库需要特殊处理才能在 SSR 应用中运行；且与可以部署在任何静态文件服务器上的完全静态单页面应用 SPA 不同，服务端渲染应用需要处于 Node.js server 运行环境；
- 更多的服务器负载：在 Node 中渲染完整的应用，显然会比仅仅提供静态文件的 server 更大量占用 CPU 资源(CPU-intensive - CPU密集)；若想在高流量环境( high traffic )下使用，请先提供服务器负载，并明智地采用缓存策略；

服务端渲染基本原理： 

- app.js 作为客户端与服务端的公用入口，导出 Vue 根实例，供客户端 entry 与服务端 entry 使用；
  - 客户端 entry 主要作用挂载到 DOM 上；
  - 服务端 entry 除创建和返回实例，还进行路由匹配与数据预获取；
- webpack 为客服端打包一个Client Bundle，为服务端打包一个Server Bundle； 
- 服务器接收请求时，会根据 url，加载相应组件，获取和解析异步数据，创建一个读取 Server Bundle 的 BundleRenderer，然后生成 html 发送给客户端；
- 客户端混合，客户端收到从服务端传来的 DOM 与自己的生成的 DOM 进行对比，将不相同的DOM激活，使其能够响应后续变化，这个过程称为客户端激活；为确保混合成功，客户端与服务器端需共享同一套数据；在服务端，可在渲染前获取数据并填充到 stroe 中；如此，在客户端挂载到DOM前，便可直接从 store 里取数据。首屏的动态数据通过 window._ INITIAL_ STATE__ 发送到客户端；

Vue SSR 的实现，主要是将 Vue 的组件输出成完整 HTML(vue-server-renderer 负责这项功能)；纯客户端输出过程有一 complier 过程，其主要作用是将 template 转化成 render字符串；而 Vue SSR 则还需负责：输出完整HTML、complier -> vnode、数据获取填充至 HTML、客户端混合(hydration) 、 缓存等等；



#### 1-X-5、SPA

SPA(single-page application)，仅在Web页面初始化时加载相应的 HTML、Js 和 CSS；一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载；

优点:

- 用户体验好、快，内容改变无需重载整个页面，避免不必要的跳转和渲染，对服务器压力小；
- 前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；

缺点：

- 初次加载耗时多：为实现单页Web应用功能及显示效果，需在加载页面时将 JS、CSS 统一加载，部分页面按需加载；
- 前进后退路由管理：由于单页应用在一个页面中显示所有内容，所以不能使用浏览器的前进后退功能，所有页面切换需要自己建立堆栈管理；
- SEO难度较大：由于所有的内容都在一个页面中动态替换显示，在SEO上其有着天然弱势；



#### 1-X-6、性能优化

- 编码阶段：
  - keep-alive
  - 防抖、节流
  - 使用事件代理
  - 采用keep-alive缓存组件
  - v-if 和 v-show 区分使用场景
  - computed 和 watch区分使用场景
  - 长列表性能优化，滚动到可视区域动态加载、优化无限列表性能
  - v-for 遍历必须为 item 添加 key，key 保证唯一， v-if 和 v-for 不同用
  - 三方模块按需导入、图片懒加载、路由懒加载、异步组件、事件的销毁
  - 尽量减少 data 中的数据，data 中的数据都会增加 Get/Set，会收集对应的 watcher

- SEO优化
  - 预渲染
  - 服务端渲染SSR

- 打包优化：
  - splitChunks提取公共代码、压缩代码、图片压缩、提取组件的CSS、优化SourceMap
  - Tree Shaking/Scope Hoisting、多线程打包happypack、模板预编译、构建结果输出分析
  - 使用cdn加载第三方模块、减少ES6转为ES5的冗余代码
- 网络优化
  - 开启gzip压缩
  - 浏览器缓存
  - 使用 CDN
  - 使用 Chrome Performance 查找性能瓶颈
- 用户体验
  - 骨架屏
  - PWA





响应式依赖扁平化

减少非必要的响应式依赖

Object.freeze

DOM 滚动加载

事件销毁（防止内存泄漏）

组件按需引入

预渲染

按需 Polyfill

模板预编译

渲染函数

官方风格指南 + 官方 ESLint 插件



#### 1-X-X、MS

- Vue.js 源码的入口主要做了些什么处理？
  - 各种初始化，各种属性方法的添加(静态 & 原型)；
- Vue 的整个框架的实现原理大致可分为哪几个部分？
  - 详看 1-1 实现原理；
- Vue.js 中的数据劫持是怎么实现的？浏览器兼容性呢？
  - 详看数据绑定小节 & 源码小节；通过  Object.defineProperty 实现，最低支持 IE8；
- Vue.js 中的依赖收集是怎么处理的？和闭包有什么关联吗？
  - 详看数据绑定小节 & 源码小节；Dep 内部通过闭包获取 watcher，Watcher 内部通过闭包获取 dep；
- Vue.js 中的模板解析需要经历哪几个阶段？
  - parse，optimize，generate，解析模板，生成渲染模板的 render
  - 注意：optimize 标记了静态节点(没有绑定任何动态数据)，在页面需要更新时，VueDiff 时会直接此部分 DOM 的处理，从而达到性能优化的目的；
- Vue.js 中的虚拟节点优势是什么？
  - 详看 DOM Diff 小节；无需频繁操作 DOM，性能优异、本质为 JS 对象，可跨平台处理；
- Vue.js 中的 DIFF 算法是怎么处理的？
  - 详看生命周期小节与源码解析部分小节；
- Vue.js 中 DIFF 算法的时间复杂度是多少？为什么？
  - O(n)，同时比较，同层比较，而非传统的多层嵌套比较；
- Vue.js 中 `computed` / `watch` 实现的原理是什么？
  - 前者是带有 dirty 属性的 watch，通过 dirty 标记位，阻止页面刷新渲染时计算值，而只有相关值变化时才触发；
- Vue.js 中有哪些周期函数？这些周期函数都是在什么时机执行的？
  - 详看生命周期小节；
- Vue.js 中的 `$nextTick` 的原理是什么？它主要经历了哪些变化？为什么？
  - 详看源码解析部分小节；
- Vue.js 对 DOM 的更新做了哪些标记优化处理？
  - 静态节点标记忽略、key 标记复用节点
- Vue.js 在语法层面可以做哪些优化处理？
  - Keep-alive、使用 key、使用 jsx render 形式、编写规范的 data、prop 等属性形式
- Vue.js 2.x 中的 Proxy 代理主要做了些什么工作？
  - 通过 Object.defineProperty 实现，将 data 属性代理到 vm 实例上(this.key == this.data.key)；
- Vue 3.x 的源码相对 Vue 2.x 主要做了哪些变化？
  - 见上方；
- Vue 2.x 中的数据劫持能否采用发布 / 订阅模式实现？采用观察者模式带来的优势和劣势有哪些？
  - 
- Vue.js 中的 M / V / VM 分别指的是哪些？简述 MVC / MVP / MVVM 的区别？
  - Model、View、ViewMode，详见前端设计一章
- 发布 / 订阅模式和观察者模式的区别是什么？手写一个发布 / 订阅模式？
  - 
- Vue.js 报 error / warning 的时有深入追踪错误栈的习惯吗，如何追踪；
  - 
- Polyfill 是什么？Vue 支持哪些相关的可配置化信息？
  - 
- Vue.js 2.x 中如何支持 TypeScript ?
  - 
- Vue.js 如何做 ESLint 校验？
  - 
- Vue.js 如何做单元测试？
  - 没做过
- 了解过 Vue-Router  / Vuex 的源码吗？
  - 了解过；详见源码分析；
- Vue-loader 主要有哪些特性？
  - 
- Vue 路由懒加载是如何实现的？
  - 
- Coding Split 和哪些 Webpack 配置相关？
  - SplitChunkPlugin；
- Vue 中可以使用 JSX 吗？
  - 可以；
- 设置了 `keep-alive` 之后对组件渲染的生命周期有什么影响？
- `keep-alive` 有哪些特性？





参考：https://juejin.im/post/6844904093425598471





### 1-Z、代码风格

#### 1-Z-1、Vue 代码风格



#### 1-Z-2、Angular 代码风格

https://angular.cn/guide/styleguide

https://juejin.im/post/6844904122718617608

使用 [TSQuery](https://tsquery-playground.firebaseapp.com/) 自定义 tsLint：https://medium.com/@phenomnominal/custom-typescript-lint-rules-with-tsquery-and-tslint-144184b6ff2d

上述补充：https://medium.com/angular-in-depth/bending-tslint-to-your-needs-6ae0a51e633

TSLint：https://palantir.github.io/tslint/rules/

