---
typora-root-url: ../../../BlogImgsBed/Source
---



### 一、基本

#### 1-1、数据类型

基本数据类型

- boolean
- null
- undefined
- number
- string
- symbol
- bigInt

引用数据类型：对象 Object，包含

- 普通对象-Object；
- 数组对象-Array；
- 正则对象-RegExp；
- 日期对象-Date；
- 数学函数-Math；
- 函数对象-Function；



##### 1-1-1、示例

```js
const a = {}
const b = Symbol('1')
const c = Symbol('1')
a[b] = '子君'
a[c] = '君子'

// 输出子君
console.log(a[b])

const d = {}
const e = {key: '1'}
const f = {key: '2'}
d[e] = '子君'
d[f] = '君子'

// 输出君子
console.log(d[e])
// 对于第一个输出，Symbol()函数会返回「symbol」类型的值，而Symbol函数传的参数仅仅是用于标识的，不会影响值的唯一性
// 对于第二个输出， 因为e和f都是对象，而对象的key只能是数值或字符，所以会将对象转换为字符，对象的toString方法返回的是[object Object], 所有输出的是君子
```





#### 1-X、注意事项

##### 1-X-1、null

虽然 typeof null 会输出 object，但这只是 JS 存在的一个悠久 Bug：

- JS 的最初版本中使用是 32 位系统，为性能考虑使用低位1-3位存储变量的类型信息，000 开头代表是对象然而 null 表示为全零；
- 比如：000 —> 对象；010 —> 浮点数；100 —> 字符串；110 —> 布尔值；
- 然而：null 的所有机器码均为 0，故导致了 typeof 误判，且现有代码已经严重依赖这一bug表现，已永远不可能被修复：
- 详情：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof

与 undefiend 区别：

- 前者表示一个"无"的对象，也即**<u>*此处不应该有值*</u>**；而 undefined 表示**<u>*未定义*</u>**。
- 在转换为数字时结果不同，Number(null) 为 0，而 undefined 为 NaN；

使用场景上：

- 前者作为函数的参数，表示该函数的参数不是对象；
- 前者作为对象原型链的终点；

- 后者在变量被声明但没有赋值时，就等于 undefined；
- 后者调用函数时，应该提供的参数没有提供，该参数等于 undefined；
- 后者对象没有赋值属性，该属性的值为 undefined；
- 后者函数没有返回值时，默认返回 undefined；



##### 1-X-2、基本包装类型

```js
// '1'.toString() 之所以能执行
// 是因为语句运行的过程中做了这样几件事情:

// 1、创建 Object 类实例
// 注意: 目前 ES6 规范不建议用 new 来创建基本类型的包装类；而由于 Symbol 和 BigInt 的出现，对它们调用 new 都会报错
var s = new Object('1');
// 2、调用实例方法
s.toString();
// 3、执行完方法立即销毁这个实例
s = null;
```

过程体现 **<u>基本包装类型</u>** 的性质，而基本包装类型恰恰属于基本数据类型，包括 Boolean、Number、String；



##### 1-X-3、精度问题

⼗进制整数转⼆进制⽅法：除2取余；⼗进制⼩数转⼆进制⽅法：乘2除整 ⼗进制0.1转换成⼆进制，乘2取整过程：

```js
0.1 * 2 = 0.2 # 0
0.2 * 2 = 0.4 # 0
0.4 * 2 = 0.8 # 0
0.8 * 2 = 1.6 # 1
0.6 * 2 = 1.2 # 1
0.2 * 2 = 0.4 # 0

.....
```

0.1的二进制格式是：0.0001100011....，是一个**二进制无限循环小数**，但计算机内存有限，不能用储存所有的小数位数，所以会在某个精度点直接舍弃；代价是，0.1 在计算机内部根本就不是精确的 0.1，而是一个有舍入误差的 0.1；当代码被编译或解释后，0.1已经被四舍五入成一个与之很接近的计算机内部数字，以至于计算还没开始，一个很小的舍入错误就已产生了。这也就是 0.1 + 0.2 不等于0.3 的原因；

注意：而 0.1 + 0.1 为何等于0.2 是：两个有舍⼊误差的值在求和时，相互抵消，但这种负负得正，相互抵消不⼀定都可靠，当这两个数字是⽤不同⻓度数位来表示的浮点数时，舍⼊误差可能不会相互抵消；⼜如：0.1 + 0.3 ，结果其实并不是 0.4，但 0.4 是最接近真实结果的数，⽐其它任何浮点数都更接近；许多语⾔也就直接显示结果为 0.4 了，⽽不展示⼀个浮点数的真实结果；

注意：⼆进制能精确地表示位数有限且分⺟是2的倍数的⼩数，⽐如 0.5(1/2)，0.5 在计算机内部就没有舍⼊误差；故 0.5 + 0.5 === 1;



##### 1-X-3-1、精度现状

JS中，所有的数字都以双精度 64 位浮点格式表示，这导致 JS 中的 Number 无法精确表示非常大的整数，还会将非常大的整数四舍五入；

即 JS 的 Number 类型只能安全地表示 `-9007199254740991 (-(2^53-1)) 和  9007199254740991 ((2^53-1))间的数`，任何超出此范围的整数值都可能失精；

```js
console.log(999999999999999);  //=>10000000000000000
// 并有一定的安全性问题:
9007199254740992 === 9007199254740993;    // → true
```





##### 1-X-3-1、精度解决—BigInt

BigInt 是一种新的数据类型，用于当整数值大于 Number 数据类型支持的范围时；这种数据类型允许安全地对 `大整数`  执行算术操作，表示高分辨率的时间戳，使用大整数 id 等等，而不需要使用库；

##### 1-X-3-1-1、创建

```js
// 1、在数字末尾追加 n 创建 BigInt
console.log( 9007199254740995n );    // → 9007199254740995n	
console.log( 9007199254740995 );     // → 9007199254740996
// 2、使用 BigInt() 构造函数创建 BigInt
BigInt("9007199254740995");    // → 9007199254740995n
```

##### 1-X-3-1-2、使用

```js
10n + 20n;    // → 30n	
10n - 20n;    // → -10n	
+10n;         // → TypeError: Cannot convert a BigInt value to a number	
-10n;         // → -10n	
10n * 20n;    // → 200n	
20n / 10n;    // → 2n	
23n % 10n;    // → 3n	
10n ** 3n;    // → 1000n	

const x = 10n;	
++x;          // → 11n	
--x;          // → 9n
console.log(typeof x);   //"bigint"
```

##### 1-X-3-1-3、注意事项

- BigInt 不支持一元加号运算符，可能是某些程序可能依赖于 + 始终生成 Number 的不变量，或抛出异常；另外，更改 + 的行为也会破坏 asm.js 代码；
- 因隐式类型转换可能丢失信息，故不允许在 bigint 和 Number 间进行混合操作；
  - 当混合使用大整数和浮点数时，结果值可能无法由 BigInt 或 Number 精确表示；

```
10 + 10n;    // → TypeError
```

- 不能将 BigInt 传递给 Web api 和内置的 JS 函数，这些函数需要一个 Number 类型的数字；尝试这样做会报 TypeError 错误；

```
Math.max(2n, 4n, 6n);    // → TypeError
```

- 当 Boolean 类型与 BigInt 类型相遇时，BigInt 的处理方式与 Number 类似，即只要不是 0n，BigInt 即会被视为 truthy 值；

```
if(0n){ // 条件判断为false
}
if(3n){ // 条件为true
}
```

- 元素均为 BigInt 的数组可进行 sort；
- BigInt 可正常地进行位运算，如|、&、<<、>>、^；



##### 1-X-3-1-4、兼容性

<img src="/Image/Basics/Special/Mode/3.png" style="zoom:50%;" align="left" />



### 二、数据检测

#### 2-1、type of

**<u>对于原始类型，除 null 外，均可显示正确类型；</u>**

```js
typeof 1 					// 'number'
typeof '1' 				// 'string'
typeof undefined 	// 'undefined'
typeof true 			// 'boolean'
typeof Symbol() 	// 'symbol'
typeof Symbol.iterator 	// 'symbol'
typeof NaN 				// 'number'
typeof Infinity 	// 'number'
typeof Date() 		// 'string' 因 Date 调用后返回字符串
typeof Math.sin() // 'number' 因 Math.sin 调用后返回数字
```

**<u>对于引用数据类型，除函数外，均显示 `"object"`</u>**

```js
typeof [] 					// 'object'
typeof {} 					// 'object'
typeof console.log 	// 'function'
typeof new xxx() 		// 'object'
```

**<u>使用 instance of 判断基本类型值</u>** [MDN上关于hasInstance的解释](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/hasInstance)

```js
class PrimitiveNumber {
  static [Symbol.hasInstance](x) {
    return typeof x === 'number'
  }
}
console.log(111 instanceof PrimitiveNumber) // true
// 原理是使用 instanceof 方法重定义，换成 typeof
```

##### 2-1-1、示例

```js
// 输出 function
console.log(typeof (() => {}))
// 输出 object
console.log(typeof ['前端有的玩','公众号'])
// 输出 object
console.log(typeof null)
// 输出 undefined
console.log(typeof undefined)
// 输出 function 
console.log(typeof Function.prototype)
// 输出 false
console.log('子君' instanceof String)
// 输出 true
console.log(new Date() instanceof Date)
```



#### 2-2、instance of

详看原型链



#### 2-3、万能法

- 基本类型 `null`：使用 `String(null)`
- 基本类型 (`string / number / boolean / undefined`) + `function`：直接使用 `typeof`；
- 其余引用类型(`Array / Date / RegExp Error`)：调用 `toString` 后根据 `[object XXX]` 进行判断；

```js
let class2type = {}
'Array Date RegExp Object Error'.split(' ').forEach(e => class2type[ '[object ' + e + ']' ] = e.toLowerCase()) 

function type(obj) {
    if (obj == null) return String(obj)
    return typeof obj === 'object' ? class2type[ Object.prototype.toString.call(obj) ] || 'object' : typeof obj
}
```

- 终极大法：Object.prototype.toString.call

<img src="/Image/Basics/Special/Data/2.png" style="zoom:50%;" align="left" />

<img src="/Image/Basics/Special/Data/3.png" style="zoom:50%;" align="left" />

```js
const whichType = target => Object.prototype.toString.call(target).slice(8, -1).toLowerCase()
// whichType() -> "undefined"
// whichType([]) -> "array"
```



#### 2-4、示例

```js
// https://blog.csdn.net/mevicky/article/details/50353881
// ex1
var x = 1;
if(function f(){}) {
	x += typeof f;
}
x;
"1function"

// ex2
(function(){
	return typeof arguments
})();
"object"
```



### 三、数据转换

#### 3-1、基本

##### 3-1-1、基本

JS 中通常将，类型转换/强制类型转换，统称为，强制类型转换；

- 分类：表现不明显的隐式强制类型转换、表现明显的显式强制类型转换；

JS 中强制类型转换总是返回基本类型值；

- 比如：字符串、数字、布尔值，但注意不会返回对象&函数；



##### 3-1-2、内部流程

##### 3-1-2-1、ToPrimitive

原始值则直接输出；否则对象流程如下：

- 首先：调用 valueOf，若结果为基本类型值，则输出；
- 否则：调用 toString，若结果为基本类型值，则输出；
- 注意：其余抛出 TypeError 异常；
- 注意：用 Object.create(null) 创建出来的对象，[[Prototype]] 属性为null，没有 valueOf、toString 方法

##### 3-1-2-2、ToBoolean

假值为 false；其他值为 true；

- 比如：**<u>undefined、null、false、+0、-0、NaN、空字符串、浏览器自行添加的假值对象</u>**；
- 注意：浏览器在某些特定的情况下，会建立别的假值对象，目的是为了判断是否为老版本的浏览器，如 document.all；

##### 3-1-2-3、ToNumber

对象值：进行 ToPrimitive 转换；

特殊值：**<u>null -> 0、false -> 0、true -> 1、undefined -> NaN</u>**；

普通值：String 类型，遵循数字常量相关规则/语法，处理失败时转为 NaN；

- 比如：空字符串 -> 0、"1A" -> NaN；

<img src="/Image/Basics/Special/Data/10.png" style="zoom:50%;" align="left" />

##### 3-1-2-4、ToString

普通值：直接输出字符串；

特殊值：**<u>null -> "null"、undefined -> "undefined"、true -> "true"、(1.07*10^21).toString() -> "1.07e21"</u>**

对象值：普通对象：调用内部 toString()，返回内部属性 [[Class]] 的值，(自定义方法的另计)；

对象值：数组对象：同上，但数组 toString 经重新定义，所有元素字符串化会以逗号连接：比如：[1,2,3].toString() -> "1,2,3

- 注意：**<u>JSON.stringify() 转换过程使用了 toString；</u>**
  - 对特殊值的处理：undefined、function、symbol、包含循环引用的对象：
    - 或报错：循环引用的对象；
    - 或忽略跳过：对象中的值；
    - 或返回 null：Symbol、空函数、undefined
    - 或返回 string：循环引用的对象且有 toJSON 方法；
  - 对原始值处理：string、number、boolean、 null 与 toString 基本一致；
  - 对对象值处理：先调用内部 toJSON()，再调用 toString()；
  - <img src="/Image/Basics/Special/Data/11.png" style="zoom:50%;" align="left" />
  - <img src="/Image/Basics/Special/Data/12.png" style="zoom:50%;" align="left" />
- 注意：字符串转数字方式：**<u>*(/)、parseInt()、 parseFloat()、Number() 、new Number()</u>** 
  - 其中 parse 前缀方法是解析，其余才是转换；
  - 两者区别：对非字符串部分的容忍度不同：Number 可用于任何数据类型，new Number 对于同样的输入会有返回不同结果；
  - 性能比较：**<u>*(/) > Number > parseInt / parseFloat > new Number</u>**

<img src="/Image/Basics/Special/Data/13.png" style="zoom:50%;" align="left" />



##### 3-1-3、注意事项

##### 3-1-3-1、条件控制语句

- if while do-while()语句内部，会对值进行 ToBoolean 操作；
- isNaN 参数会先经过 toNumber 操作(故不可靠)；
- for( ..; ..; ..; )中的条件判断表达式，第二个；
- ? : 中的条件判断表达式；
- if 中的条件判断表达式；
- || 和 && 左边的操作数；

```
isNaN('1') // false
```

##### 3-1-3-2、ToPrimitive 操作

- 选择机制优先度(一般值)：valueOf > toString：
  - <img src="/Image/Basics/Special/Data/15.png" style="zoom:50%;" align="left" />
- 选择机制优先度(Date对象)：valueOf < toString：若强制使用 Date 的 valueOf，则须使用一元加号 (+)，强制转换它为数字类型：
  - <img src="/Image/Basics/Special/Data/16.png" style="zoom:50%;" align="left" />
- 强制将某对象的 valueOf、toString 方法，均覆写为返回值为对象会报错；
  - <img src="/Image/Basics/Special/Data/17.png" style="zoom:50%;" align="left" />
- 引入 Symbol 类型后，JS 会优先调用对象的 [Symbol.toPrimitive]，来转为原始类型：
  - <img src="/Image/Basics/Special/Data/18.png" style="zoom:50%;" align="left" />
  - <img src="/Image/Basics/Special/Data/19.png" style="zoom:50%;" align="left" />
- 空对象与空数组的 valueOf & toString 方法；
  - <img src="/Image/Basics/Special/Data/20.png" style="zoom:50%;" align="left" />
- 特殊：引擎会将 花括号开头 { 视为一个区块语句的开头而忽略掉；
  - 故例1实际效果为+{} 但不同浏览器引擎对此种处理不一致，有些返回 NaN，有些返回 "[object Object][object Object]"
  - <img src="/Image/Basics/Special/Data/21.png" style="zoom:50%;" align="left" />
- 其他示例
  - <img src="/Image/Basics/Special/Data/22.png" style="zoom:50%;" align="left" />



##### 3-1-3-3、JSON.stringify 操作

- 空函数、undefined、Symbol 返回 null、循环引用报错、含 toJSON 则调用
  - <img src="/Image/Basics/Special/Data/23.png" style="zoom:50%;" align="left" />



##### 3-1-3-4、ToString 操作

<img src="/Image/Basics/Special/Data/24.png" style="zoom:50%;" align="left" />



##### 3-1-3-5、ToNumber 操作

- \+ 操作符转换规则：
  - 一有对象，则进行 toPrimitive 操作，即 valueOf toString；
  - 一有字符，则进行字符串拼接；
  - 若均没有，则进行加法运算；
    - 注意：操作符的顺序；比如：1+2+'3' == '33'； 1+'2'+3 == '123'；
    - 注意：+ Date对象，转换成数字，从而获得当前时间的时间戳(微秒)；
    - 注意："x + ''  相当于 String(x)
    - <img src="/Image/Basics/Special/Data/25.png" style="zoom:50%;" align="left" />
    - <img src="/Image/Basics/Special/Data/32.png" style="zoom:50%;" align="left" />

- \+ 操作符不一定返回 number，但 ++ 操作符一定返回 number

  - ```js
    ++[[]][0] // 1
    ```

- \+ x 或 x - 0 或 x * 1 或 x / 1 相当于 Number( x ) ；且 ++ 加变量，而不能加常量；

  - <img src="/Image/Basics/Special/Data/26.png" style="zoom:50%;" align="left" />

- null 在计算时候转换为0，效果等同 0；

  - <img src="/Image/Basics/Special/Data/27.png" style="zoom:50%;" align="left" />

- \>、<、<=、>= 转换规则；

  - <img src="/Image/Basics/Special/Data/28.png" style="zoom:50%;" align="left" />
  - <img src="/Image/Basics/Special/Data/29.png" style="zoom:50%;" align="left" />

- ~x 相当于 -(x+1)；!!x 相当于 Boolean( x )；

  - <img src="/Image/Basics/Special/Data/30.png" style="zoom:50%;" align="left" />

- 其他示例：

  - <img src="/Image/Basics/Special/Data/31.png" style="zoom:50%;" align="left" />



##### 3-1-3-6、&&  和 || 转换

- && 前假返前，前真返后，亦称守护运算符
  - 只要 "&&" 前面是 false，无论 "&&" 后面是 true 还是 false，结果都将返 "&&" 前面的值；
  - 只要 "&&" 前面是 true，无论 "&&" 后面是 true 还是 false，结果都将返 "&&" 后面的值；
    - 所以：a && b 大致相当于 a ? b : a；
    - 比如：1&&2 返回 2

- || 前假返后，前真返前
  - 只要"||"前面为 false，不管"||"后面是 true 还是 false，都返回"||"后面的值；
  - 只要"||"前面为 true，不管"||"后面是 true 还是 false，都返回"||"前面的值；
    - 所以：a || b 大致相当于  a ? a : b
    - 比如：0||1  返回 1



##### 3-1-3-X、其他

<img src="/Image/Basics/Special/Data/33.png" style="zoom:50%;" align="left" />

<img src="/Image/Basics/Special/Data/34.png" style="zoom:50%;" align="left" />







#### 3-X、总结

##### 3-1-1、基本

JS中，类型转换只有三种：

- 转换成数字
- 转换成布尔值
- 转换成字符串

<img src="/Image/Basics/Special/Data/1.png" style="zoom:50%;" align="left" />



##### 3-1-2、运算符转换

JS 中在使用运算符号或者对比符时，会自带隐式转换，规则如下:

- -、*、/、% ：一律转换成数值后计算
- +：
  - 数字 + 字符串 = 字符串， 运算顺序是从左到右
  - 数字 + 对象， 优先调用对象的`valueOf` -> `toString`
  - 数字 + `boolean/null` -> 数字
  - 数字 + `undefined` -> `NaN`
- `[1].toString() === '1'`
- `{}.toString() === '[object object]'`
- `NaN` !== `NaN` 、`+undefined 为 NaN`













#### 3-2、相等性判断

##### 3-2-1、JS 4种相等算法

抽象相等比较、严格相等比较、同值零、同值( 用于所有其他地方)

- 第二种：Array.prototype.indexOf、Array.prototype.lastIndexOf、case-matching 使用到；
- 第三种：%TypedArray%、ArrayBuffer 构造函数、Map、Set操作、String.prototype.includes 使用到；



##### 3-2-2、JS3种值比较操作

严格相等、宽松相等、[Object.is](http://Object.is)



##### 3-2-3、双等判断

特点：值相等；进行类型转换操作，转换规则如下

- 两边类型是否相同，相同则比较值是否相同；
- 若类型是 null 和 undefined，则返回 true；
- 若其中一方是 Boolean、String，且另一方为 Number，则将 Boolean、String 转换成 Number，再进行比较；
- 若其中一方为 Object，且另一方为 String、Number、Symbol，则将 Object 转换成字符串，再进行比较；
  - **<u>对象转原始类型</u>**：会调用内置的 [ToPrimitive] 函数，函数操作逻辑如下：
    - 若存在 Symbol.toPrimitive() 方法，则优先调用并返回；
    - 调用 valueOf，若转换为原始类型，则返回；
    - 调用 toString，若转换为原始类型，则返回；
    - 注意：若上述方法均无返回原始类型，会报错；

```js
// Ex1:
console.log({a: 1} == true);							// false
console.log({a: 1} == "[object Object]");	//true

// Ex2:
var obj = {
  value: 3,
  valueOf() {
    return 4;
  },
  toString() {
    return '5'
  },
  [Symbol.toPrimitive]() {
    return 6
  }
}
console.log(obj + 1); // 输出7


// Ex3:
var a = {
  value: 0,
  valueOf: function() {
    this.value++;
    return this.value;
  }
};
console.log(a == 1 && a == 2); // true

// Ex4:
[] == ![] // true
// == 中，左右两边都需要转换为数字然后进行比较。
// [] 转换为数字为 0；
// ![] 首先是转换为布尔值，由于 [] 作为一个引用类型转换为布尔值为 true, 因此 ![] 为 false，进而在转换成数字，变为 0
```

<img src="/Image/Basics/Special/Data/4.png" style="zoom:50%;" align="left" />

- 其他：数组，调用valueOf、再调用toString，比如：空数组转为空字符串，再转换为数字0；
- 其他：null 与 undefined 相等，不会做隐式类型转换； 
- 其他：转换优先级：对象 > 布尔值 > 字符串；
- 其他：遇到 ! 先使用 toBoolean 转换；

<img src="/Image/Basics/Special/Data/5.png" style="zoom:50%;" align="left" />

<img src="/Image/Basics/Special/Data/6.png" style="zoom:50%;" align="left" />



##### 3-2-4、三等判断

特点：严格相等；不进行类型转换、先后比较类型和值

<img src="/Image/Basics/Special/Data/7.png" style="zoom:50%;" align="left" />



##### 3-2-5、Object.is 

行为与全等类似，但只用于 NaN 和 -0 和 +0 的特殊用途判断：

Object 在严格等于的基础上修复了一些特殊情况下的失误，具体来说就是 +0 和 -0，NaN 和 NaN；

<img src="/Image/Basics/Special/Data/8.png" style="zoom:50%;" align="left" />



##### 3-2-6、总结

<img src="/Image/Basics/Special/Data/9.png" style="zoom:50%;" align="left" />



##### 3-2-7、示例

- 示例1：

```js
// title
var a = ?;
if(a == 1 && a == 2 && a == 3) => true

// Way1
// 由对象的隐式转换 toPrimitive 操作机制知，用自增改动 valueOf 即可
a = Object.create({
  count: 0,
  valueOf: function() {
    return ++this.count;
  },
  toString: function(){
    return ++this.count;
  }
})

// Way2
// 直接定义 get ；此外此法还适用于：(a === 1 && a === 2 && a ===3)
Object.defineProperty(global, 'a', {
  get: function() {
    return this.value = this.value ? (this.value += 1) : 1;
  }
});

// Way3
// 由对象的隐式转换 toPrimitive 操作机制知，用 Generator 改动 valueOf ；
a = {
  gn: (function* () {
    yield 1;
    yield 2;
    yield 3;
  })(),
  valueOf() {
    return this.gn.next().value;
  }
}

// Way4
// 直接重定义 toPrimitive 操作；
a = {
  [ Symbool.toPromitive ]: () => this.__val__ = (this.__val__ || 0) % 3 + 1
}

// Way5
// 对象 -> toPrimitive操作 -> toString -> 
// 注意：数组对象，toString 方法返回字符串，元素由逗号隔开；
var a = [1, 2, 3];
a.join = a.shift;
```



- 示例2：

```js
if([] == false) console.log(1);
if({} == false) console.log(2);
if([]) console.log(3);
if([1] == [1]) console.log(4);

// 1 3
// 题1和题2左右均被转成数字   
// 题3被转成boolean   
// 题4 地址不一样，两 Object 双等即全等比较，比较的是地址；
```





#### 四、优先级

<img src="/Image/Basics/Special/Data/35.png" style="zoom:70%;" align="left" />

- JS 表达式包含表达式时，运算顺序是从左至右；

- 加号优先级 > 三目运算符 

  - <img src="/Image/Basics/Special/Data/36.png" style="zoom:50%;" align="left" />

- 模数运算保留符号，注意后2个，前者结果为-1，后者结果为NaN

  - <img src="/Image/Basics/Special/Data/37.png" style="zoom:50%;" align="left" />

- ! 优先级 > in

  - ```js
    if(!'a' in window){}
    ```

- ++ 优先级 > ==

  - ```js
    var i = 2; ++i == 2; // false
    ```

- 三目运算符优先级 > 赋值运算符；

  - ```js
    b = a === false ? false : true // true
    ```



#### 五、自测题

<img src="/Image/Basics/Special/Data/38.png" style="zoom:50%;" align="left" />

<img src="/Image/Basics/Special/Data/39.png" style="zoom:50%;" align="left" />

<img src="/Image/Basics/Special/Data/40.png" style="zoom:50%;" align="left" />

```js
console.log([] + [])
console.log({} + [])
console.log([] == ![])
console.log(true + false)

// 1、
// 输出 "" 空字符串
console.log([] + [])
// 输出的是空字符串""， 包装类型在运算的时候，会先调用valueOf方法，如果valueOf返回的还是包装类型，那么再调用toString方法
// 还是 数组
const val = [].valueOf()
// 数组 toString 默认会将数组各项使用逗号 "," 隔开, 比如 [1,2,3].toSting 变成了"1,2,3",空数组 toString 就是空字符串
const val1 = val.toString() // val1 是空字符串


// 2、
// 输出 "[object Object]"
console.log({} + [])


// 3、
// 这个输出 false
console.log(![])
// 套用上面第三条 将 false 转换为 数值
// 这个输出 0
console.log(Number(false))
// 包装类型与 基本类型 == 先将包装类型通过 valueOf toString 转换为基本类型 
// 输出 ""
console.log([].toString())
// 套用第2条， 将空字符串转换为数值、
// 输出 0
console.log(Number(""))
// 所以
console.log(0 == 0)



// 4、
// 两个基本类型相加，如果其中一方是字符，则将其他的转换为字符相加，否则将类型转换为Number,然后相加, Number(true) 是1, Number(false)是0, 所以结果是 1
```

