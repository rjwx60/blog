# 一、SSR/CSR

## 1-1、SSR

Server Side Rendering(服务端渲染)，将渲染工作放在服务端进行并回传客户端，后者得到完整结构后就可直接进行 DOM 解析/构建/资源加载及渲染；

- 优点：首屏加载快、对搜索引擎友好，利于 SEO;

- 缺点：访问量较大时，对服务器造成较大压力、页面间频繁刷新跳转体验不友好；


## 1-2、CSR

Client Side Rendering(客户端渲染)，服务器返回初始 HTML 内容，然后通过 JS 异步加载数据，完成页面渲染；

- 优点：页面路由放在客户端，页面间切换快、数据渲染放在客户端大为降低服务器压力；

- 缺点：首屏渲染较慢或出现白屏现象、不利于 SEO；



## 1-3、两者结合的方案

首页基于SSR，后续点击等事件交互基于 CSR 渲染，可避免首页加载较慢，又能解决SEO问题；**<u>*对于客户端和服务端代码采用同构；*</u>**

```js
// 服务端采用 react-dom/server 的 renderToString 方法，将 Index 组件直出：
const { renderToString}  = require( 'react-dom/server');
const http = require('http');

// Index 组件
class Index extends React.Component{
    constructor(props){
        super(props);
    }

    render(){
        return <h1>{this.props.data.title}</h1>
    }
}

// server服务
http.createServer((req, res) => {
    if (req.url === '/') {
        res.writeHead(200, {
            'Content-Type': 'text/html'
        });
        const html = renderToString(<Index />);
        res.end(html);
    }
}).listen(8080);
```

```js
// 客户端使用 react-dom 的 ReactDOM.hydrate 方法替代 ReactDOM.render 方法
// 它用于在 ReactDOMServer 渲染的容器中对 HTML 的内容进行 hydrate 操作 React 会尝试在已有标记上绑定事件监听器。
import ReactDOM from 'react-dom';
// 绑定 Index 组件的事件监听到页面
ReactDom.hydrate(<Index />, document.getElementById('root'));
```





# 二、CIDI 流程

[引自文章1](https://juejin.im/post/6870325047324573710#comment)、[详看文章2](https://juejin.im/post/6844904080230334477)

## 2-1、过往部署

流程：构建打包—压缩丢包—登录服务器解压—配置Nginx访问

- 本地执行 `npm run build` 构建项目；
  - npm install
  - num run build
- 压缩编译好的资源文件，并将压缩包丢到远程服务器；
  - zip dist.zip /dist
  - scp -r /project/dist root@192.168.2.1:/etc/frontend/
- 登录到远程服务器，解压压缩包；
  - ssh root@192.168.2.1
  - unzip test.zip 
- 配置 nginx 代理访问；



## 2-2、目前部署

增加对代码健壮性、功能完整性的验证，在发布流程中，加入单元测试和代码扫描，验证后在服务器中，手动拉取最新代码再 build，最后配置 Nginx；

流程：代码扫描—单元测试—提交远程仓库—登录服务器拉取代码并构建—配置Nginx访问

- 代码扫描检查代码是否规范；
  -  npm run lint 
- 本地跑单元测试检查单元测试结果；
  - npm run unit
- git 提交测试通过的代码到远程仓库 gitlab；
- 登录到远程服务器，拉取仓库代码，构建项目
  - git clone xxx
  - npm install
  - npm run build



## 2-3、最新部署

CICD：即持续集成(Continuous Integration)和持续交付(Continuous Delivery)，将上述手动部署构建环节自动化；比如：Jenkins CI/CD  和 Travis CI

- 持续集成：当代码仓库代码发生变更，就会自动对代码进行测试和构建，反馈运行结果；
- 持续交付：持续交付是在持续集成的基础上，可以将集成后的代码依次部署到测试环境、予发布环境、生产环境等中；

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20201001081927.png" alt="截屏2020-10-01 上午8.19.23" style="zoom:50%;" />



## 2-4、Travis CI 

[详看](https://juejin.im/post/6870325047324573710#heading-3)

## 2-5、Jenkins CI/CD 

[详看](https://juejin.im/post/6870325047324573710#heading-3)





# 三、Linux

[Linux过去及基本使用(看此即可)](https://juejin.im/post/6844903634036064269)、[这个也是极简—基本使用](https://juejin.im/post/6844903863925882894)、[这个也是极简—网络使用](https://juejin.im/post/6844903864739561480)、[这个就有点繁多了](https://juejin.im/post/6844903801283952653#comment)





# 三、Nginx

[转自](https://juejin.im/post/6844904102447546382)、[更多代理配置](https://juejin.im/post/6844903711639093262)、[某方向深入](https://juejin.im/post/6846687599663251470)、[补充](https://juejin.im/post/6844903733860499469)、[补充—HTTPS](https://juejin.im/post/6844904063688179720)、[基操](https://juejin.im/post/6844904000769245191)、[基操2](https://juejin.im/post/6844903999485771784)、[基操3](https://juejin.im/post/6844904192146931719)

- 启动：sudo nginx
- 修改：修改 nginx.conf 配置：/usr/local/etc/nginx/nginx.conf
- 检查：检查语法是否正常：sudo nginx -t
- 重启：重启 Nginx：sudo nginx -s reload
- 关闭：关闭 Nginx：sudo nginx -s stop
- 软链：创建软链，用于管理多应用 nginx
  - 首先，多网站 nginx 配置文件统一存放在：/nginx/conf.d/；
  - 然后，创建软链： 比如：ln -s /home/app/app.example.com.nginx.conf /etc/nginx/conf.d/app.nginx.conf
  - 随即，更改应用配置文件，/etc/nginx/conf.d/ 下与之对应的配置文件也会被修改，修改后重启 nginx 就能够使新的 ngxin 配置生效；



## 3-1、功能

### 3-1-1、负载均衡

当一应用单位时间内访问量激增，服务器带宽及性能受到影响，若影响超过自身承受能力时，就会发生宕机，为防止此种情况发生，及更好的用户体验，可配置 Nginx 负载均衡，分配其他服务器给用户，来分担服务器压力，极大增加网站稳定性；当用户访问时，首先访问到的是负载均衡器，再通过负载均衡器将请求转发给后台服务器；

- ```nginx
  // nginx.config
  // 方式1: 轮询: 略
  upstream backserver {
      server 192.168.0.1;
      server 192.168.0.2;
  }
  // 方式2: 按权重 weight 分配
  // 指定不同 ip 权重，权重与访问比成正相关，权重越高，访问越大，适用于不同性能的机器
  upstream backserver {
      server 192.168.0.1 weight=2;
      server 192.168.0.2 weight=8;
  }
  // 方式3: 按响应时间分配
  // 公平竞争，谁相应快，谁处理，但需要依赖与安装三方插件 nginx-upstream-fair
  upstream backserver {
      server 192.168.0.1;
      server 192.168.0.2;
      fair;
  }
  server {
      listen 80;
      server_name localhost; 
      location / {
        proxy_pass  http://backserver;
      }
  }
  // 其他: 健康检查
  // Nginx 自带的健康检测模块: ngx_http_upstream_module, 本质上服务器心跳检查，通过定期轮询，向集群里的服务器发送健康检查请求,来检查集群中是否有服务器处于异常状态；若检测出其中某台服务器异常, 则在通过客户端请求 nginx 反向代理进来的请求将不再发送到该服务器上；直至下次轮询健康检查正常；
  upstream backserver{
      server 192.168.0.1  max_fails=1 fail_timeout=40s;
      server 192.168.0.2  max_fails=1 fail_timeout=40s;
  }
  server {
      listen 80;
      server_name localhost; 
      location / {
        proxy_pass http://backend;
      }
  }
  fail_timeout : 设定服务器被认为不可用的时间段以及统计失败尝试次数的时间段，默认为10s
  max_fails : 设定Nginx与服务器通信的尝试失败的次数，默认为：1次
  ```



### 3-1-2、反向代理

当一客户端发送请求，想要访问服务器上内容，但将被该请求先发送到一个代理服务器 proxy(nginx)，服务器将请求代理到与自身同属一个局域网下的，内部服务器上，即代理服务器充当中间人角色，起分配与沟通作用；与正向代理区别在于，正向代理是帮助用户更针对性访问(翻墙工具)，反向代理则是帮助服务器更针对性地被用户访问；一般具有以下作用：

- 防火墙：不直接暴露，过滤掉无权限或非法请求，保障内部服务安全；

- 负载均衡：本质上负载均衡即反向代理的一种应用场景；

```nginx
// nginx.config
// 通过 location 功能匹配指定的 URI，然后把接收到的符合匹配 URI的请求通过 proxy_pass 转移给之前定义好的 upstream 节点池
server  {
  listen 80;
  server_name localhost;
  location / {
    proxy_pass http://127.0.0.1:8000;（upstream）
  }
}
```



### 3-1-3、HTTPS 配置

Nginx 配置 Https 认证，主要有两个步骤：

- 签署第三方可信任的 SSL 证书：配置 HTTPS 要用：私钥 example.key 文件、example.crt 证书文件；申请证书文件时要用：example.csr 文件
- 配置 HTTPS：开启 HTTPS 服务，在配置文件信息块(server)，须使用监听命令 listen 的 ssl 参数，和定义服务器证书文件和私钥文件

```nginx
server {
   #ssl参数
   listen              443 ssl; // 监听443端口，https 默认端口; 80 为 http 默认端口
   server_name         example.com;
   #证书文件
   ssl_certificate     example.com.crt;
   #私钥文件
   ssl_certificate_key example.com.key;
}
// ssl_certificate: 证书的绝对路径
// ssl_certificate_key: 密钥的绝对路径;
```





## 3-2、常见配置

### 3-2-1、白名单

配置 nginx 白名单，规定有哪些 IP 可访问服务器，防爬虫；

```nginx
// 使用1: 基本
server {
  location / {
    deny  192.168.0.1; // 禁止该ip访问
    deny  all; // 禁止所有
  }
}


// 使用2: 外部文件
// vim /etc/nginx/white_ip.conf
 ...
192.168.0.1 1; 
 ...
// nginx.conf
// geo 指令主要是可根据指定变量的值映射出一个新变量；若不指定变量，则默认为 $remote_addr
geo $remote_addr $ip_whitelist{
    default 0;
    include ip.conf;
}


// 使用3:
// 其他配置使用
server {
    location / {
        if ( $ip_whitelist = 0 ){
            return 403; //不在白名单返回 403
        }
        index index.html;
        root /tmp;
    }
}
```



### 3-2-2、适配PC与移动端

当用户从移动端打开PC端 bilibili.com 场景时，将自动跳转指移动端 m.bilibili.com，本质上是 Nginx 可通过内置变量 $http_user_agent，获取到请求客户端的 userAgent，从而知道当前用户当前终端是移动端还是PC，进而重定向到H5站还是PC站；所以用 mediaQuery 简直弱爆了；

```nginx
server {
 location / {
        // 移动、pc 设备 agent 获取
        if ($http_user_agent ~* '(Android|webOS|iPhone)') {
            set $mobile_request '1';
        }
        if ($mobile_request = '1') {
            rewrite ^.+ http://m.baidu.com;
        }
    } 
}
```



### 3-2-3、Gzip 

基操，不解释，开启 Nginx gzip，压缩后，静态资源的大小会大大的减少，可节约大量带宽(节省成本)，提高传输效率，带来更好响应和体验；但比不上 HTTP2 的内容减少带来的效益明显；

```nginx
server{
    gzip on; //启动
    gzip_buffers 32 4K;
    gzip_comp_level 6; //压缩级别，1-10，数字越大压缩的越好
    gzip_min_length 100; //不压缩临界值，大于100的才压缩，一般不用改
    gzip_types application/javascript text/css text/xml;
    gzip_disable "MSIE [1-6]\."; // IE6对Gzip不友好，对Gzip
    gzip_vary on;
}
```



### 3-2-4、跨域配置

基操，不解释，当出现 403 跨域错误时，还有 No 'Access-Control-Allow-Origin' header is present on the requested resource 报错等，即需要为 Nginx 服务器配置响应的 header 参数

```nginx
location / {  
    add_header Access-Control-Allow-Origin *;
    add_header Access-Control-Allow-Methods 'GET, POST, OPTIONS';
    add_header Access-Control-Allow-Headers 'DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization';
    if ($request_method = 'OPTIONS') {
        return 204;
    }
} 
```



