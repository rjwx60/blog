# 八、常见实现

## 8-1、instance of

```js
// 原理：L 的 __proto__  是不是等于 R.prototype ，不等于再找 L.__proto__.__proto__ ..... 直到 L....__proto__ 为 null


// 实现1
function myInstanceof(left, right) {
    // 基本数据类型直接返回 false
    if(typeof left !== 'object' || left === null) return false;
    // getProtypeOf 是 Object 对象自带的一个方法，能够拿到参数的原型对象
    let proto = Object.getPrototypeOf(left);
    while(true) {
        // 查找到尽头，还没找到
        if(proto == null) return false;
        // 找到相同的原型对象
        if(proto == right.prototype) return true;
        proto = Object.getPrototypeOf(proto);
    }
}

// 实现2
const myInstanceof = function (left, right) {
  if(typeof left !== 'object' || left === null) return false;
  right = right.prototype;
  left = left.__proto__;
  while (true) {
    if (left === null) return false;
    if (right === left) return true;
    left = left.__proto__;
  }
};

// 实现3
// L 表示左表达式，R 表示右表达式
function instance_of(L, R) {
  var O = R.prototype;
  L = L.__proto__;
  while (true) {
    if (L === null) return false;
    // 这里重点：当 O 严格等于 L 时，返回 true
    if (O === L) return true;
    L = L.__proto__;
  }
}
```

## 8-2、Object

### 8-2-1、Object.is

```js
function is(x, y) {
  if (x === y) {
    // 1/+0 = +Infinity， 1/-0 = -Infinity, 是不一样
    // +0 和 -0 应该不等
    return x !== 0 || y !== 0 || 1 / x === 1 / y;
  } else {
    // NaN===NaN 是 false, 这是不对的，在这里做一个拦截，x !== x，那么一定是 NaN, y 同理
    // 两个都是 NaN 时返回 true
    return x !== x && y !== y;
  }
}
```

### 8-2-2、Object.create

```js
// 新建一个空的构造函数 F ，然后让 F.prototype 指向 obj，最后返回 F 的实例
const myCreate = function (obj) {
  function F() {};
  F.prototype = obj;
  return new F();
}

// 实现2
if (typeof Object.create !== "function") {
  Object.create = function (prototype, properties) {
    if (typeof prototype !== "object") { throw TypeError(); }
    function Ctor() {}
    Ctor.prototype = prototype;
    var o = new Ctor();
    if (prototype) { o.constructor = Ctor; }
    if (properties !== undefined) {
      if (properties !== Object(properties)) { throw TypeError(); }
      Object.defineProperties(o, properties);
    }
    return o;
  };
}
```



### 8-2-3、Object.assign

用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象（请注意这个操作是浅拷贝）

```js
Object.defineProperty(Object, 'assign', {
  value: function(target, ...args) {
    if (target == null) {
      return new TypeError('Cannot convert undefined or null to object');
    }
    
    // 目标对象需要统一是引用数据类型，若不是会自动转换
    const to = Object(target);

    for (let i = 0; i < args.length; i++) {
      // 每一个源对象
      const nextSource = args[i];
      if (nextSource !== null) {
        // 使用for...in和hasOwnProperty双重判断，确保只拿到本身的属性、方法（不包含继承的）
        for (const nextKey in nextSource) {
          if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
            to[nextKey] = nextSource[nextKey];
          }
        }
      }
    }
    return to;
  },
  // 不可枚举
  enumerable: false,
  writable: true,
  configurable: true,
})
```





### 8-2-4、getOwnPropertyNames

注意：不能拿到不可枚举的属性

```js
if (typeof Object.getOwnPropertyNames !== 'function') {
  Object.getOwnPropertyNames = function(o) {
    if (o !== Object(o)) {
      throw TypeError('Object.getOwnPropertyNames called on non-object');
    }
    var props = [],
      p;
    for (p in o) {
      if (Object.prototype.hasOwnProperty.call(o, p)) {
        props.push(p);
      }
    }
    return props;
  };
}
```





## 8-3、Array

### 8-3-1、Array.isArray

```js
Array.myIsArray = function(o) {
  return Object.prototype.toString.call(Object(o)) === '[object Array]';
};

console.log(Array.myIsArray([])); // true
```





## 8-4、this 绑定

### 8-4-1、new

new 被调用后做了如下事情：

- 让实例可以访问到私有属性
- 让实例可以访问构造函数原型(constructor.prototype)所在原型链上的属性
- 若构造函数返回的结果不是引用数据类型

```js
// 实现1
function newOperator(ctor, ...args) {
    if(typeof ctor !== 'function') throw 'newOperator function the first param must be a function';

    let obj = Object.create(ctor.prototype);
    let res = ctor.apply(obj, args);
    
    let isObject = typeof res === 'object' && res !== null;
    let isFunction = typoof res === 'function';
    return isObect || isFunction ? res ：obj;
};
  
// 实现2
function myNew(Func, ...args) {
  const instance = {};
  if (Func.prototype) {
    Object.setPrototypeOf(instance, Func.prototype)
  }
  const res = Func.apply(instance, args)
  if (typeof res === "function" || (typeof res === "object" && res !== null)) {
    return res
  }
  return instance
}

// 测试
function Person(name) {
  this.name = name
}
Person.prototype.sayName = function() {
  console.log(`My name is ${this.name}`)
}
const me = myNew(Person, 'Jack')
me.sayName()
console.log(me)
```

- 它创建了一个全新的对象
- 它会被执行[[Prototype]]（也就是__proto__）链接
- 它使this指向新创建的对象
- 通过new创建的每个对象将最终被[[Prototype]]链接到这个函数的prototype对象上
- 如果函数没有返回对象类型Object(包含Functoin, Array, Date, RegExg, Error)，那么new表达式中的函数调用将返回该对象引用



- `Constructor` 就是 `new` 时传入的第一个参数，剩余的 `arguments` 是其他的参数
- 使用`obj.__proto__ = Constructor.prototype` 继承原型上的方法
- 将剩余的 `arguments` 传给 `Contructor` ，绑定 `this` 指向为 `obj`，并执行
- 如果构造函数返回的是引用类型，直接返回该引用类型，否则返回 `obj`

```js
const myNew = function () {
  let Constructor = Array.prototype.shift.call(arguments);
  let obj = {};
  obj.__proto__ = Constructor.prototype;
  let res = Constructor.apply(obj, arguments);
  return res instanceof Object ? res : obj;
};
```

- 创建一个新对象；
- 将构造函数的作用域赋给新对象 (因此 this 就指向了这个新对象)；
- 执行构造函数中的代码 (为这个新对象添加属性)；
- 返回新对象；

```js
function myNew() {
  // 创建一个实例对象
  var obj = new Object();
  // 取得外部传入的构造器
  var Constructor = Array.prototype.shift.call(arguments);
  // 实现继承，实例可以访问构造器的属性
  obj.__proto__ = Constructor.prototype;
  // 调用构造器，并改变其 this 指向到实例
  var ret = Constructor.apply(obj, arguments);
  // 如果构造函数返回值是对象则返回这个对象，如果不是对象则返回新的实例对象
  return typeof ret === 'object' && ret !== null ? ret : obj;
}
// 测试
// ========= 无返回值 =============
const testNewFun = function(name) {
  this.name = name;
};
const newObj = myNew(testNewFun, 'foo');
console.log(newObj); // { name: "foo" }
console.log(newObj instanceof testNewFun); // true
// ========= 有返回值 =============
const testNewFun = function(name) {
  this.name = name;
  return {};
};
const newObj = myNew(testNewFun, 'foo');
console.log(newObj); // {}
console.log(newObj instanceof testNewFun); // false



// 实现2
function create () {
  // 1. 获取构造函数，并且删除 arguments 中的第一项
  var Con = [].shift.call(arguments);
  // 2. 创建一个空的对象并链接到构造函数的原型，使它能访问原型中的属性
  var obj = Object.create(Con.prototype);
  // 3. 使用apply改变构造函数中this的指向实现继承，使obj能访问到构造函数中的属性
  var ret = Con.apply(obj, arguments);
  // 4. 优先返回构造函数返回的对象
  return ret instanceof Object ? ret : obj;
}
// 构造函数中有返回值且为对象，那么创建的实例就只能访问到返回对象中的属性，所以要判断一下ret的类型，如果是对象的话，则返回这个对象。
// 构造函数中没有返回值，那么创建的实例就能访问到这个构造函数中的所有属性了，此时ret就会为undefined，所以返回obj。
// 构造函数中有返回值但是返回值是undefined以外的其它基本类型(比如字符串)，这种情况当成第二种情况(没有返回值)来处理。
```





### 8-4-2、bind

总体：call、apply、bind 本质都是改变 `this` 的指向，不同点 call、apply 是直接调用函数，bind 是返回一个新的函数；而 call 跟 apply 就只有参数上不同；

原理：bind 方法会创建一个新的函数，在 bind 被调用时，此新函数的 this 被指定为 bind 的第一个参数，而其余参数将作为新函数的参数，供调用时使用；

语法：`function.bind(thisArg, arg1, arg2, ...)` ，从用法上看，似乎给 call/apply 包一层 function 即可实现，但：

- <u>参数接收</u>：bind 除了 this 还接收其他参数，bind 返回的函数也接收参数，这两部分的参数都要传给返回的函数；
- <u>改变指向</u>：new 会改变 this 指向：若 bind 绑定后的函数被 new 构造调用，则 this 指向也会发生改变，指向当前函数的实例；即`new绑定` 的优先级高于 `显式绑定` 和 `硬绑定`，而函数作为构造函数用 `new` 关键字调用时，不应该改变其 `this` 指向；
- <u>箭头函数</u>：箭头函数的 `this` 永远指向它所在的作用域；
- 没有保留原函数在原型链上的属性和方法；

所以要确保 bind 被调用后做如下事情：

- 对于普通函数，绑定 this 指向
- 对于构造函数，要保证原函数的原型对象上的属性不能丢失

```js
// 简易版
Function.prototype.myBind = function (thisArg, ...args) {
    var self = this
    // new 优先级
    var fbound = function () {
        self.apply(this instanceof self ? 
                   this : 
                   thisArg, args.concat(Array.prototype.slice.call(arguments)));
    }
    // 继承原型上的属性和方法
    fbound.prototype = Object.create(self.prototype);
    return fbound;
}

// 完整版
Function.prototype.bind = function (context, ...args) {
    // 异常处理
    if (typeof this !== "function") {
      throw new Error("Function.prototype.bind - what is trying to be bound is not callable");
    }
    // 保存this的值，它代表调用 bind 的函数
    var self = this;
  
  	// 处理实现1:
    var fNOP = function () {};
    var fbound = function () {
        self.apply(this instanceof self ? 
            this :
            context, args.concat(Array.prototype.slice.call(arguments)));
    }
    fNOP.prototype = this.prototype;
    fbound.prototype = new fNOP();
  
  	// 处理实现2:
  	var fbound = function () {
        self.apply(this instanceof self ? 
            this :
            context, args.concat(Array.prototype.slice.call(arguments)));
    }
    fbound.prototype = Object.create(self.prototype);
  
    return fbound;
}

// 完整版2
Function.prototype.mybind = function(thisArg) {
  if (typeof this !== 'function') {
    throw TypeError("Bind must be called on a function");
  }
  // 拿到参数，为了传给调用者
  const args = Array.prototype.slice.call(arguments, 1),
        // 保存 this
        self = this,
        // 构建一个干净的函数，用于保存原函数的原型
        nop = function() {},
        // 绑定的函数
        bound = function() {
          // this instanceof nop, 判断是否使用 new 来调用 bound
          // 如果是 new 来调用的话，this的指向就是其实例，
          // 如果不是 new 调用的话，就改变 this 指向到指定的对象 o
          return self.apply(
            this instanceof nop ? this : thisArg,
            args.concat(Array.prototype.slice.call(arguments))
          );
        };

  // 箭头函数没有 prototype，箭头函数this永远指向它所在的作用域
  if (this.prototype) {
    nop.prototype = this.prototype;
  }
  // 修改绑定函数的原型指向
  bound.prototype = new nop();
  return bound;
}
// 测试：
const bar = function() {
  console.log(this.name, arguments);
};
bar.prototype.name = 'bar';
const foo = {
  name: 'foo'
};
const bound = bar.mybind(foo, 22, 33, 44);
new bound(); // bar, [22, 33, 44]
bound(); // foo, [22, 33, 44]
```

- `bind` 的参数可以在绑定和调用的时候分两次传入
- `bindArgs` 是绑定时除了第一个参数以外传入的参数，`args` 是调用时候传入的参数，将二者拼接后一起传入
- 如果使用 `new` 运算符构造绑定函数，则会改变 `this` 指向，`this` 指向当前的实例
- 通过 `Fn` 链接原型，这样 `fBound` 就可以通过原型链访问父类 `Fn` 的属性

```js
Function.prototype.mybind = function (context) {
  let that = this;
  let bindArgs = Array.prototype.slice.call(arguments, 1);
  function Fn() {}
  function fBound(params) {
    let args = Array.prototype.slice.call(arguments);
    return that.apply(
      this instanceof fBound ? this : context,
      bindArgs.concat(args)
    );
  }
  Fn.prototype = this.prototype;
  fBound.prototype = new Fn();
  return fBound;
};
```

- 函数内的`this`表示的就是调用的函数
- 可以将上下文传递进去, 并修改`this`的指向
- 返回一个函数
- 可以传入参数
- 柯里化
- 一个绑定的函数也能使用`new`操作法创建对象, 且提供的`this`会被忽略

```js
Function.prototype.bind2 = function(context) {
  // 1. 判断调用bind的是不是一个函数
  if (typeof this !== "function") {
    throw new Error(
      "Function.prototype.bind - what is trying to be bound is not callable"
    );
  }
  // 2. 外层的this指向调用者(也就是调用的函数)
  var self = this;
  // 3. 收集调用bind时的其它参数
  var args = Array.prototype.slice.call(arguments, 1);

  // 4. 创建一个返回的函数
  var fBound = function() {
    // 6. 收集调用新的函数时传入的其它参数
    var innerArgs = Array.prototype.slice.call(arguments);
    // 7. 使用apply改变调用函数时this的指向
    // 作为构造函数调用时this表示的是新产生的对象, 不作为构造函数用的时候传递context
    return self.apply(
      this instanceof fNOP ? this : context,
      args.concat(innerArgs)
    );
  };
  // 5. 创建一个空的函数, 且将原型指向调用者的原型(为了能用调用者原型中的属性)
  // 下面三步的作用有点类似于 fBoun.prototype = this.prototype 但有区别
  var fNOP = function() {};
  fNOP.prototype = this.prototype;
  fBound.prototype = new fNOP();
  // 8. 返回最后的结果
  return fBound;
};



Function.prototype.bind2 = function(context) {
    var _this = this;
    var argsParent = Array.prototype.slice.call(arguments, 1);
    return function() {
        var args = argsParent.concat(Array.prototype.slice.call(arguments)); //转化成数组
        _this.apply(context, args);
    };
}
// 2
Function.prototype.bind1 = function(context) {
  var that = this
  return function() {
    that.apply(context, arguments)
  }
}
// 最简版
Function.prototype.myBind = function(content, ...args) {
  return () => this.apply(content, args);
};
// ES6
Function.prototype.bind2 = function() {
    var fn = this;
    var argsParent = [...arguments];
    return function() {
        fn.call(...argsParent, ...arguments);
    };
}



// MDN
//  Yes, it does work with `new (funcA.bind(thisArg, args))`
if (!Function.prototype.bind) (function(){
  var ArrayPrototypeSlice = Array.prototype.slice;
  Function.prototype.bind = function(otherThis) {
    if (typeof this !== 'function') {
      // closest thing possible to the ECMAScript 5
      // internal IsCallable function
      throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');
    }

    var baseArgs= ArrayPrototypeSlice.call(arguments, 1),
        baseArgsLength = baseArgs.length,
        fToBind = this,
        fNOP    = function() {},
        fBound  = function() {
          baseArgs.length = baseArgsLength; // reset to default base arguments
          baseArgs.push.apply(baseArgs, arguments);
          return fToBind.apply(
                 fNOP.prototype.isPrototypeOf(this) ? this : otherThis, baseArgs
          );
        };

    if (this.prototype) {
      // Function.prototype doesn't have a prototype property
      fNOP.prototype = this.prototype; 
    }
    fBound.prototype = new fNOP();

    return fBound;
  };
})();


// 实现X
Function.prototype.myBind = function (context = globalThis) {
  const fn = this
  const args = Array.from(arguments).slice(1)
  const newFunc = function () {
    const newArgs = args.concat(...arguments)
    if (this instanceof newFunc) {
      // 通过 new 调用，绑定 this 为实例对象
      fn.apply(this, newArgs)
    } else {
      // 通过普通函数形式调用，绑定 context
      fn.apply(context, newArgs)
    }
  }
  // 支持 new 调用方式
  newFunc.prototype = Object.create(fn.prototype)
  return newFunc
}

// 测试
const me = { name: 'Jack' }
const other = { name: 'Jackson' }
function say() {
  console.log(`My name is ${this.name || 'default'}`);
}
const meSay = say.myBind(me)
meSay()
const otherSay = say.myBind(other)
otherSay()





// 实现X+1
Function.prototype.bind = function(context, ...args) {
  if (typeof this !== 'function') {
    throw new Error("Type Error");
  }
  // 保存this的值
  var self = this;

  return function F() {
    // 考虑new的情况
    if(this instanceof F) {
      return new self(...args, ...arguments)
    }
    return self.apply(context, [...args, ...arguments])
  }
}
```





### 8-4-3、call/apply

总体：call、apply、bind 本质都是改变 `this` 的指向，不同点 call、apply 是直接调用函数，bind 是返回一个新的函数；而 call 跟 apply 就只有参数上不同；总结是：`bind` 是封装了 `call` 方法改变了 `this` 的指向并返回一个新的函数；

原理：在方法调用模式下，`this` 总是指向调用它所在方法的对象，`this` 的指向与所在方法的调用位置有关，而与方法的声明位置无关 (箭头函数特殊)；而 call 方法使用一个指定的 this 值和单独给出的一个或多个参数来调用一个函数；

语法：`function.call(thisArg, arg1, arg2, ...)`，而由于函数 this 指向其直接调用者，故变更调用者即完成 this 指向的变更

```js
// 最简版
Function.prototype.myCall = function(thisArg, ...args) {
    thisArg.fn = this              // this 指向调用 call 的对象, 即要改变 this 指向的函数
    return thisArg.fn(...args)     // 执行函数并 return 其执行结果
}

// 完整版1
Function.prototype.myCall = function(thisArg, ...args) {
    const fn = Symbol('fn')        // 声明一个独有的 Symbol 属性, 防止 fn 覆盖已有属性
    thisArg = thisArg || window    // 若没有传入 this, 则默认绑定 window 对象
    thisArg[fn] = this              // this 指向调用 call 的对象, 即要改变 this 指向的函数
    const result = thisArg[fn](...args)  // 执行当前函数
    delete thisArg[fn]              // 删除声明的 fn 属性
    return result                  // 返回函数执行结果
}

// 完整版2
const foo = { name: 'foo' };
foo.fn = function() {
  // 这里的 this 指向了 foo
  // 因为 foo 调用了 fn，
  // fn 的 this 就指向了调用它所在方法的对象 foo 上
  console.log(this.name); // foo
};
// 利用 this 机制实现 call
Function.prototype.mycall = function(thisArg) {
  // this 指向调用 call 的对象
  if (typeof this !== 'function') {
    // 调用 call 的若不是函数则报错
    throw new TypeError('Error');
  }
  // 声明一个 Symbol 属性，防止 fn 被占用
  const fn = Symbol('fn')
  const args = [...arguments].slice(1);
  thisArg = thisArg || window;
  // 将调用 call 函数的对象添加到 thisArg 的属性中
  thisArg[fn] = this;
  // 执行该属性
  const result = thisArg[fn](...args);
  // 删除该属性
  delete thisArg[fn];
  // 返回函数执行结果
  return result;
}
// 测试
const bar = function() {
  console.log(this.name, arguments);
};
bar.prototype.name = 'bar';
const foo = {
  name: 'foo'
};
bar.mycall(foo, 1, 2, 3); // foo [1, 2, 3]
bar.myapply(foo, [1, 2, 3]); // foo [1, 2, 3]



// 完整版3
Function.prototype.call = function (context) {
    let context = context || window;
    let fn = Symbol('fn');
    context.fn = this;
    let args = [];
    for(let i = 1, len = arguments.length; i < len; i++) {
        args.push('arguments[' + i + ']');
    }
    let result = eval('context.fn(' + args +')');
    delete context.fn
    return result;
}

// ES6 版本
Function.prototype.call = function (context, ...args) {
  let context = context || window;
  let fn = Symbol('fn');
  context.fn = this;
  let result = eval('context.fn(...args)');
  delete context.fn
  return result;
}

// Else
Function.prototype.myCall = function (context = globalThis) {
  // 关键步骤，在 context 上调用方法，触发 this 绑定为 context，使用 Symbol 防止原有属性的覆盖
  const key = Symbol('key')
  context[key] = this
  // es5 可通过 for 遍历 arguments 得到参数数组
  const args = [...arguments].slice(1)
  const res = context[key](...args)
  delete context[key]
  return res
};

// 测试
const me = { name: 'Jack' }
function say() { console.log(`My name is ${this.name || 'default'}`); }
say.myCall(me)
```

- `context` 存在就使用 `context`，否则是 `window`
- 使用 `Object(context)` 将 `context` 转换成对象，并通过 `context.fn` 将 `this` 指向 `context`
- 循环参数，注意从 `1` 开始，第 `0` 个是上下文，后面才是我们需要的参数
- 将参数字符串 `push` 进 `args`
- 字符串和数组拼接时，数组会调用 `toString` 方法，这样可以实现将参数一个个传入，并通过 `eval` 执行
- 拿到结果返回前，删除掉 `fn`

```js
Function.prototype.call = function (context) {
  context = context ? Object(context) : window;
  context.fn = this;
  let args = [];
  for (let i = 1; i < arguments.length; i++) {
    args.push("arguments[" + i + "]");
  }
  let res = eval("context.fn(" + args + ")");
  delete context.fn;
  return res;
};


Function.prototype.call = function(context = window, ...args) {
  if (typeof this !== 'function') {
    throw new TypeError('Type Error');
  }
  const fn = Symbol('fn');
  context[fn] = this;

  const res = this[fn](...args);
  delete this.fn;
  return res;
}
```







apply 方法调用一个具有给定 this 值的函数，以及作为一个数组(或类似数组对象)提供的参数；
语法：`func.apply(thisArg, [argsArray])`，实际上 apply 与 call 类似，区别在于 call 接收参数列表，而 apply 接收一个参数数组，所以在 call 的实现上简单改一下入参形式即可：

```js
// 完整版1
Function.prototype.myApply = function(thisArg, args) {
    const fn = Symbol('fn')        // 声明一独有的 Symbol 属性, 防止 fn 覆盖已有属性
    thisArg = thisArg || window    // 若无传入 this, 则默认绑定 window对象
    thisArg[fn] = this              // this 指向调用 call 的对象, 即要改变 this 指向的函数
    const result = thisArg[fn](...args)  // 执行当前函数
    // 说明: 虽 apply 接收的是一个数组，但在调用原函数时，依然要展开参数数组, 可对照原生 apply，原函数接收到展开的参数数组;
    delete thisArg[fn]              // 删除声明的 fn 属性
    return result                  // 返回函数执行结果
}

// 完整版2
Function.prototype.myapply = function(thisArg) {
  if (typeof this !== 'function') {
    throw this + ' is not a function';
  }
  const args = arguments[1];
  const fn = Symbol('fn')
  thisArg[fn] = this;

  const result = thisArg[fn](...arg);
  delete thisArg[fn];
  return result;
};
// 测试
const bar = function() {
  console.log(this.name, arguments);
};
bar.prototype.name = 'bar';
const foo = {
  name: 'foo'
};
bar.mycall(foo, 1, 2, 3); // foo [1, 2, 3]
bar.myapply(foo, [1, 2, 3]); // foo [1, 2, 3]


// ES6 版本
Function.prototype.apply = function (context, args) {
  let context = context || window;
  context.fn = this;
  let result = eval('context.fn(...args)');

  delete context.fn
  return result;
}


// Else
Function.prototype.myApply = function (context = globalThis) {
  // 关键步骤，在 context 上调用方法，触发 this 绑定为 context，使用 Symbol 防止原有属性的覆盖
  const key = Symbol('key')
  context[key] = this
  let res
  if (arguments[1]) {
    res = context[key](...arguments[1])
  } else {
    res = context[key]()
  }
  delete context[key]
  return res
}

// 测试
const me = { name: 'Jack' }
function say() {
  console.log(`My name is ${this.name || 'default'}`);
}
say.myApply(me)
```

- `apply` 无需循环参数列表，传入的 `args` 就是数组
- 但是 `args` 是可选参数，如果不传入的话，直接执行

```js
Function.prototype.apply = function (context, args) {
  context = context ? Object(context) : window;
  context.fn = this;
  if (!args) {
    return context.fn();
  }
  let res = eval("context.fn(" + args + ")");
  delete context.fn;
  return res;
};


Function.prototype.apply = function(context = window, args) {
  if (typeof this !== 'function') {
    throw new TypeError('Type Error');
  }
  const fn = Symbol('fn');
  context[fn] = this;

  const res = context[fn](...args);
  delete context[fn];
  return res;
}
```



- call、apply 实现

- 考点：在于 this 上下文怎么绑定到目标函数，即 this 的指向性问题；

  - 将函数设为对象的属性

  - 执行 & 删除这个函数

  - 指定 this 到函数并传入给定参数执行函数

  - 若不传入参数，默认指向为 window

  - 注意：eval 固然性能不好，但兼容性好且能达到实现本题效果；

  - ```js
    Function.prototype.call2 = function(context) {
        var context = context || window; // 因传进来的 context 有可能是 null
        context.fn = this;
        var args = [];
        for (var i = 1; i < arguments.length; i++) {
            args.push("arguments[" + i + "]"); // 否则字符串的引号会被自动去掉 变成了变量 导致报错
        }
        args = args.join(",");
    
        var result = eval("context.fn(" + args + ")"); // 相当于执行 context.fn(arguments[1], arguments[2]);
    
        delete context.fn;
        return result; // 因有可能 this 函数会有返回值 return
    }
    
    // 2
    Function.prototype.call2 = function(context, ...args) {
      // 因为传进来的 context 有可能是 null
      context = context || window;
      // Function.prototype this 为当前运行的函数
      // 让 fn 的上下文为 context
      context.fn = this;
      const result = context.fn(...args);
      delete context.fn;
      return result;
    };
    
    function test(a, b, c) {
      console.log(this, a, b, c);
      return this;
    }
    test.call2({ test: 22 }, 1, 2, 3);
    
    // 3
    Function.prototype.call2 = function (context) {
        var context = context || window;
        context.fn = this;
    
        var args = [];
        for(var i = 1, len = arguments.length; i < len; i++) {
            args.push('arguments[' + i + ']');
        }
    
        var result = eval('context.fn(' + args +')');
    
        delete context.fn
        return result;
    }
    
    
    // ES5 实现 call
    function fnFactory(context) {
      var unique_fn = "fn";
      while (context.hasOwnProperty(unique_fn)) {
        unique_fn = "fn" + Math.random();
      }
      return unique_fn;
    }
    Function.prototype.call2 = function(context) {
      // 1. 若是传入的context是null或者undefined时指向window;
      // 2. 若是传入的是原始数据类型, 原生的call会调用 Object() 转换
      context = context ? Object(context) : window;
      // 3. 创建一个独一无二的fn函数的命名
      var fn = fnFactory(context);
      // 4. 这里的this就是指调用call的那个函数
      // 5. 将调用的这个函数赋值到context中, 这样之后执行context.fn的时候, fn里的this就是指向context了
      context[fn] = this;
      // 6. 定义一个数组用于放arguments的每一项的字符串: ['agruments[1]', 'arguments[2]']
      var args = [];
      // 7. 要从第1项开始, 第0项是context
      for (var i = 1, l = arguments.length; i < l; i++) {
        args.push("arguments[" + i + "]");
      }
      // 8. 使用eval()来执行fn并将args一个个传递进去
      var result = eval("context[fn](" + args + ")");
      // 9. 给context额外附件了一个属性fn, 所以用完之后需要删除
      delete context[fn];
      // 10. 函数fn可能会有返回值, 需要将其返回
      return result;
    };
    // ES6 实现 call
    Function.prototype.call3 = function(context) {
      context = context ? Object(context) : window;
      var fn = Symbol();
      context[fn] = this;
    
      let args = [...arguments].slice(1);
      let result = context[fn](...args);
    
      delete context[fn];
      return result;
    };
    ```

  - ```js
    Function.prototype.apply2 = function(context, arr) {
        var context = context || window; // 因传进来的 context 有可能是 null
        context.fn = this;
        var args = [];
        var params = arr || [];
        for (var i = 0; i < params.length; i++) {
            args.push("params[" + i + "]"); // 否则字符串的引号会被自动去掉 变成了变量 导致报错
        }
        args = args.join(",");
    
        var result = eval("context.fn(" + args + ")"); // 相当于执行 context.fn(arguments[1], arguments[2]);
    
        delete context.fn;
        return result; // 因有可能 this 函数会有返回值 return
    }
    // 2
    Function.prototype.apply2 = function(context, arr) {
        let context = context || window; 
        context.fn = this;
        arr = arr || [];
        const result = context.fn(...arr); 
        delete context.fn;
        return result; // 因有可能 this 函数会有返回值 return
    }
    // 3
    Function.prototype.apply = function (context, arr) {
        var context = Object(context) || window;
        context.fn = this;
        var result;
        if (!arr) {
            result = context.fn();
        }
        else {
            var args = [];
            for (var i = 0, len = arr.length; i < len; i++) {
                args.push('arr[' + i + ']');
            }
            result = eval('context.fn(' + args + ')')
        }
        delete context.fn
        return result;
    }
    
    // ES5 实现 apply
    function fnFactory(context) {
      var unique_fn = "fn";
      while (context.hasOwnProperty(unique_fn)) {
        unique_fn = "fn" + Math.random();
      }
      return unique_fn;
    }
    Function.prototype.apply2 = function(context, arr) {
      // 1. 若是传入的context是null或者undefined时指向window;
      // 2. 若是传入的是原始数据类型, 原生的call会调用 Object() 转换
      context = context ? Object(context) : window;
      // 3. 创建一个独一无二的fn函数的命名
      var fn = fnFactory(context);
      // 4. 这里的this就是指调用call的那个函数
      // 5. 将调用的这个函数赋值到context中, 这样之后执行context.fn的时候, fn里的this就是指向context了
      context[fn] = this;
    
      var result;
      // 6. 判断有没有第二个参数
      if (!arr) {
        result = context[fn]();
      } else {
        // 7. 有的话则用args放每一项的字符串: ['arr[0]', 'arr[1]']
        var args = [];
        for (var i = 0, len = arr.length; i < len; i++) {
          args.push("arr[" + i + "]");
        }
        // 8. 使用eval()来执行fn并将args一个个传递进去
        result = eval("context[fn](" + args + ")");
      }
      // 9. 给context额外附件了一个属性fn, 所以用完之后需要删除
      delete context[fn];
      // 10. 函数fn可能会有返回值, 需要将其返回
      return result;
    };
    // ES6 实现 apply
    Function.prototype.apply3 = function(context, arr) {
      context = context ? Object(context) : window;
      let fn = Symbol();
      context[fn] = this;
    
      let result = arr ? context[fn](...arr) : context[fn]();
      delete context[fn];
      return result;
    };
    ```

  - call、apply 对比

    - Function.prototype.apply 和 Function.prototype.call 作用一样，区别在于传入参数的不同；
    - 第一个参数均为，指定函数体内this的指向；
    - 第二个参数则不同：
      - 前者传入带下标的集合，数组或类数组，并将其作为参数传给函数；
      - 前者从第二个开始传入的参数是不固定的，都会传给函数作为参数；
    - call 比 apply 的性能要好，平常可多用 call，call 传入参数的格式正是内部所需要的格式；
    - 注意：平时开发中不必过分关注 call 和 apply 的性能问题，但可尽量使用 call，而因为 ES6 的 reset 解构支持，call 基本可代替 apply；
    - 补充：lodash 源码中并无直接用 Function.prototype.apply，而是在参数较少时(1-3)采用 call 方式调用，也因 lodash 中没有超过 4 个参数方法；
    - 此外：若一函数设计超过4个入参，则需要考虑重构了；















# 八-2、常用实现

## 2-1、arguments 转换

arguments 本身无法调用数组方法，因其是类数组：属性从 0 开始排序，并有 callee、length属性；常见的类数组还有：

- 用 getElementsByTagName/ClassName() 获得的 HTMLCollection；
- 用 querySelector 获得的 nodeList；

类数组无法使用数组方法，但必要时可将它们转换成数组：

### 2-1-1、Array.prototype.slice.call

```js
function sum(a, b) {
  let args = Array.prototype.slice.call(arguments);
  console.log(args.reduce((sum, cur) => sum + cur));// args可以调用数组原生的方法啦
}
sum(1, 2);// 3
```

### 2-1-2、Array.from

```js
function sum(a, b) {
  let args = Array.from(arguments);
  console.log(args.reduce((sum, cur) => sum + cur));// args可以调用数组原生的方法啦
}
sum(1, 2);// 3
```

这种方法也可以用来转换Set和Map哦！

### 2-1-3、ES6 展开运算符

```js
function sum(a, b) {
  let args = [...arguments];
  console.log(args.reduce((sum, cur) => sum + cur));// args可以调用数组原生的方法啦
}
sum(1, 2);// 3
```

### 2-1-4、利用 concat + apply

```js
function sum(a, b) {
  let args = Array.prototype.concat.apply([], arguments);// apply方法会把第二个参数展开
  console.log(args.reduce((sum, cur) => sum + cur));// args可以调用数组原生的方法啦
}
sum(1, 2);// 3
```



## 2-2、深浅拷贝

### 2-2-1、浅拷贝

以赋值的形式拷贝引用对象，仍指向同一个地址，**修改时原对象也会受到影响**

### 2-2-1-1、手动实现

```js
const shallowClone = (target) => {
  if (typeof target === 'object' && target !== null) {
    const cloneTarget = Array.isArray(target) ? []：{};
    for (let prop in target) {
      if (target.hasOwnProperty(prop)) {
          cloneTarget[prop] = target[prop];
      }
    }
    return cloneTarget;
  } else {
    return target;
  }
}
```

### 2-2-1-2、Object.assign

```js
let obj = { name：'sy', age：18 };
const obj2 = Object.assign({}, obj, {name：'sss'});
console.log(obj2); // { name：'sss', age：18 }
// 注意：Object.assgin() 拷贝的是对象的属性的引用，而非对象本身；
```

### 2-2-1-3、concat 浅拷贝数组

```js
let arr = [1, 2, 3];
let newArr = arr.concat();
newArr[1] = 100;
console.log(arr); // [ 1, 2, 3 ]
```

### 2-2-1-4、slice 浅拷贝

```js
let arr = [1, 2, 3];
let newArr = arr.slice();
newArr[0] = 100;
console.log(arr); // [1, 2, 3]
```

### 2-2-1-5、ES6 展开运算符

```js
let arr = [1, 2, 3];
let newArr = [...arr]; // 跟 arr.slice() 一样效果
```




### 2-2-2、深拷贝

完全拷贝一个新对象，**修改时原对象不再受到任何影响**；

区别：深拷贝和浅拷贝是针对复杂数据类型来说的，浅拷贝只拷贝一层，而深拷贝是层层拷贝

- 浅拷贝：是会将对象的每个属性进行依次复制，但是当对象的属性值是引用类型时，实质复制的是其引用，当引用指向的值改变时也会跟着变化；
- 深拷贝：复制变量值，对于非基本类型的变量，则递归至基本类型变量后，再复制。 深拷贝的结果与原来对象完全隔离、互不影响；



### 2-2-2-1、简易版

```js
JSON.parse(JSON.stringify()); // 性能最快
```

- 无法解决 <u>循环引用</u> 的问题：`const a = {val:2};  a.target = a;`，会出现无限递归，导致系统栈溢出，并报错；
- 无法拷贝某些特殊对象，诸如 RegExp、Date、Set、Map 等 与特殊值 undefined 等；
- 无法拷贝原型链上的属性；
- 无法拷贝函数；

```js
const deepClone = (target) => {
  // 引用类型判断
  if (typeof target === 'object' && target !== null) {
    // 初始值选取
    const cloneTarget = Array.isArray(target) ? []：{};
    // 迭代操作
    for (let prop in target) {
      if (target.hasOwnProperty(prop)) {
          cloneTarget[prop] = deepClone(target[prop]);
      }
    }
    return cloneTarget;
  } else {
    return target;
  }
}
```



### 2-2-2-2、解决循环引用

关键：创建 Map，记录已拷贝过的对象，若已拷贝过则直接返回；

```js
// 判断
const isObject = (target) => (typeof target === 'object' || typeof target === 'function') && target !== null;
const deepClone = (target, map = new Map()) => { 
  // 若已拷贝过则直接返回
  if(map.get(target)) return target; 
  if (isObject(target)) { 
    // 记录已拷贝过的对象
    map.set(target, true); 
    // 迭代操作
    const cloneTarget = Array.isArray(target) ? []：{}; 
    for (let prop in target) { 
      if (target.hasOwnProperty(prop)) { 
          cloneTarget[prop] = deepClone(target[prop],map); 
      } 
    } 
    return cloneTarget; 
  } else { 
    return target; 
  } 
}

// 测试
const a = {val:2};
a.target = a;
let newA = deepClone(a);
console.log(newA) // { val：2, target：{ val：2, target：[Circular] } }
```

**<u>*强引用与 WeakMap*</u>**

上面 map 上的 key 与 map 构成了 <u>强引用关系</u>：

- 在计算机程序设计中，<u>弱引用与强引用相对</u>， 是指不能确保其引用的对象不会被垃圾回收器回收的引用； <u>一个对象若只被弱引用所引用，则被认为是不可访问（或弱可访问）的，并因此可能在任何时刻被回收</u>；
- 即**<u>被弱引用的对象可在任何时候被回收</u>**，**<u>但对于强引用来说，只要这个强引用还在，那么对象无法被回收</u>**；比如 map 和 a 一直是强引用的关系， 在程序结束之前，a 所占的内存空间一直不会被释放；

所以，使 map 上的 key 与 map 构成弱引用关系即可，可利用 ES6 WeakMap 实现，WeakMap 是一种特殊的Map, 其中的键是`弱引用`的；<u>其键必须是对象，而值可以是任意的</u>；

```js
// 判断
const isObject = (target) => (typeof target === 'object' || typeof target === 'function') && target !== null;
const deepClone = (target, map = new WeakMap()) => { 
  // 若已拷贝过则直接返回
  if(map.get(target)) return target; 
  if (isObject(target)) { 
    // 记录已拷贝过的对象
    map.set(target, true); 
    // 迭代操作
    const cloneTarget = Array.isArray(target) ? []：{}; 
    for (let prop in target) { 
      if (target.hasOwnProperty(prop)) { 
          cloneTarget[prop] = deepClone(target[prop],map); 
      } 
    } 
    return cloneTarget; 
  } else { 
    return target; 
  } 
}
```



### 2-2-2-3、实现特殊对象拷贝

### 2-2-2-3-1、可继续遍历对象

关键：鉴别对象并进行分类处理；

```js
const getType = Object.prototype.toString.call(obj);
const isObject = (target) => (typeof target === 'object' || typeof target === 'function') && target !== null;

// 可继续遍历
const canTraverse = {
  '[object Map]'：true,
  '[object Set]'：true,
  '[object Array]'：true,
  '[object Object]'：true,
  '[object Arguments]'：true,
};

const deepClone = (target, map = new Map()) => {
  if(!isObject(target)) return target;
  let type = getType(target);
  let cloneTarget;
  if(!canTraverse[type]) {
    // 处理不能遍历的对象
    return;
  } else {
    // 这波操作相当关键，可以保证对象的原型不丢失！
    let ctor = target.prototype;
    cloneTarget = new ctor();
  }

  if(map.get(target)) return target;
  map.put(target, true);

  // 处理Map
  if(type === mapTag) {
    target.forEach((item, key) => {
      cloneTarget.set(deepClone(key), deepClone(item));
    })
  }
  
  // 处理Set
  if(type === setTag) {
    target.forEach(item => {
      target.add(deepClone(item));
    })
  }

  // 处理数组和对象
  for (let prop in target) {
    if (target.hasOwnProperty(prop)) {
        cloneTarget[prop] = deepClone(target[prop]);
    }
  }
  return cloneTarget;
}
```



### 2-2-2-3-2、不可继续遍历对象

```js
const boolTag = '[object Boolean]';
const numberTag = '[object Number]';
const stringTag = '[object String]';
const dateTag = '[object Date]';
const errorTag = '[object Error]';
const regexpTag = '[object RegExp]';
const funcTag = '[object Function]';

const handleRegExp = (target) => {
  const { source, flags } = target;
  return new target.constructor(source, flags);
}

const handleFunc = (target) => {
  // 待会的重点部分
}

const handleNotTraverse = (target, tag) => {
  const Ctor = targe.constructor;
  switch(tag) {
    case boolTag:
    case numberTag:
    case stringTag:
    case errorTag：
    case dateTag:
      return new Ctor(target);
    case regexpTag:
      return handleRegExp(target);
    case funcTag:
      return handleFunc(target);
    default:
      return new Ctor(target);
  }
}
```



### 2-2-2-4、实现函数拷贝

函数也是对象，但因过于特殊，故单独拆解，JS 有两种函数：一种是普通函数，另一种是箭头函数；每个普通函数都是 Function 的实例，而箭头函数不是任何类的实例，每次调用都是不一样的引用；所以**<u>只需处理普通函数的情况，箭头函数直接返回它本身即可；可利用原型，判断箭头函数，因其是不存在原型的；</u>**

```js
const handleFunc = (func) => {
  // 箭头函数直接返回自身
  if(!func.prototype) return func;
  const bodyReg = /(?<={)(.|\n)+(?=})/m;
  const paramReg = /(?<=\().+(?=\)\s+{)/;
  const funcString = func.toString();
  // 分别匹配 函数参数 和 函数体
  const param = paramReg.exec(funcString);
  const body = bodyReg.exec(funcString);
  if(!body) return null;
  if (param) {
    const paramArr = param[0].split(',');
    return new Function(...paramArr, body[0]);
  } else {
    return new Function(body[0]);
  }
}
```

注意：修复bug：

```js
const target = new Boolean(false);
const Ctor = target.constructor;
new Ctor(target); // 结果为 Boolean {true} 而应该是 false；
// 解决：调用valueOf：new target.constructor(target.valueOf())。
// 但实际上，这种写法是不推荐的。因为在ES6后不推荐使用 [new 基本类型()] 这样的语法，所以 es6 中的新类型 Symbol 是不能直接 new 的，只能通过 new Object(SymbelType)
```



### 2-2-2-5、完成版

```js
// 基本版1
function deepCopy(obj, cache = new WeakMap()) {
  if (!obj instanceof Object) return obj
  // 防止循环引用
  if (cache.get(obj)) return cache.get(obj)
  // 支持函数
  if (obj instanceof Function) {
    return function () {
      obj.apply(this, arguments)
    }
  }
  // 支持日期
  if (obj instanceof Date) return new Date(obj)
  // 支持正则对象
  if (obj instanceof RegExp) return new RegExp(obj.source, obj.flags)
  // 还可以增加其他对象，比如：Map, Set等，根据情况判断增加即可，面试点到为止就可以了

  // 数组是 key 为数字素银的特殊对象
  const res = Array.isArray(obj) ? [] : {}
  // 缓存 copy 的对象，用于处理循环引用的情况
  cache.set(obj, res)

  Object.keys(obj).forEach((key) => {
    if (obj[key] instanceof Object) {
      res[key] = deepCopy(obj[key], cache)
    } else {
      res[key] = obj[key]
    }
  });
  return res
}

// 测试
const source = {
  name: 'Jack',
  meta: {
    age: 12,
    birth: new Date('1997-10-10'),
    ary: [1, 2, { a: 1 }],
    say() {
      console.log('Hello');
    }
  }
}
source.source = source
const newObj = deepCopy(source)
console.log(newObj.meta.ary[2] === source.meta.ary[2]); // false
console.log(newObj.meta.birth === source.meta.birth); // false





// 基本版2
const cloneDeep1 = (target, hash = new WeakMap()) => {
  // 对于传入参数处理
  if (typeof target !== 'object' || target === null) {
    return target;
  }
  // 哈希表中存在直接返回
  if (hash.has(target)) return hash.get(target);

  const cloneTarget = Array.isArray(target) ? [] : {};
  hash.set(target, cloneTarget);

  // 针对Symbol属性
  const symKeys = Object.getOwnPropertySymbols(target);
  if (symKeys.length) {
    symKeys.forEach(symKey => {
      if (typeof target[symKey] === 'object' && target[symKey] !== null) {
        cloneTarget[symKey] = cloneDeep1(target[symKey]);
      } else {
        cloneTarget[symKey] = target[symKey];
      }
    })
  }

  for (const i in target) {
    if (Object.prototype.hasOwnProperty.call(target, i)) {
      cloneTarget[i] =
        typeof target[i] === 'object' && target[i] !== null
        ? cloneDeep1(target[i], hash)
        : target[i];
    }
  }
  return cloneTarget;
}







// 变态版
const getType = obj => Object.prototype.toString.call(obj);
const isObject = (target) => (typeof target === 'object' || typeof target === 'function') && target !== null;

const canTraverse = {
  '[object Map]'：true,
  '[object Set]'：true,
  '[object Array]'：true,
  '[object Object]'：true,
  '[object Arguments]'：true,
};
const mapTag = '[object Map]';
const setTag = '[object Set]';
const boolTag = '[object Boolean]';
const numberTag = '[object Number]';
const stringTag = '[object String]';
const symbolTag = '[object Symbol]';
const dateTag = '[object Date]';
const errorTag = '[object Error]';
const regexpTag = '[object RegExp]';
const funcTag = '[object Function]';

const handleRegExp = (target) => {
  const { source, flags } = target;
  return new target.constructor(source, flags);
}

const handleFunc = (func) => {
  // 箭头函数直接返回自身
  if(!func.prototype) return func;
  const bodyReg = /(?<={)(.|\n)+(?=})/m;
  const paramReg = /(?<=\().+(?=\)\s+{)/;
  const funcString = func.toString();
  // 分别匹配 函数参数 和 函数体
  const param = paramReg.exec(funcString);
  const body = bodyReg.exec(funcString);
  if(!body) return null;
  if (param) {
    const paramArr = param[0].split(',');
    return new Function(...paramArr, body[0]);
  } else {
    return new Function(body[0]);
  }
}

const handleNotTraverse = (target, tag) => {
  // 关键：保证对象的原型不丢失！
  const Ctor = target.constructor;
  switch(tag) {
    case boolTag:
      return new Object(Boolean.prototype.valueOf.call(target));
    case numberTag:
      return new Object(Number.prototype.valueOf.call(target));
    case stringTag:
      return new Object(String.prototype.valueOf.call(target));
    case symbolTag:
      return new Object(Symbol.prototype.valueOf.call(target));
    case errorTag：
    case dateTag:
      return new Ctor(target);
    case regexpTag:
      return handleRegExp(target);
    case funcTag:
      return handleFunc(target);
    default:
      return new Ctor(target);
  }
}

const deepClone = (target, map = new WeakMap()) => {
  if(!isObject(target)) 
    return target;
  let type = getType(target);
  let cloneTarget;
  if(!canTraverse[type]) {
    // 处理不能遍历的对象
    return handleNotTraverse(target, type);
  } else {
    // 关键：保证对象的原型不丢失！
    let ctor = target.constructor;
    cloneTarget = new ctor();
  }

  if(map.get(target)) 
    return target;
  map.set(target, true);

  // 处理Map
  if(type === mapTag) {
    target.forEach((item, key) => {
      cloneTarget.set(deepClone(key, map), deepClone(item, map));
    })
  }
  
  // 处理Set
  if(type === setTag) {
    target.forEach(item => {
      cloneTarget.add(deepClone(item, map));
    })
  }

  // 处理数组和对象
  for (let prop in target) {
    if (target.hasOwnProperty(prop)) {
        cloneTarget[prop] = deepClone(target[prop], map);
    }
  }
  return cloneTarget;
}
```







## 2-3、双向绑定

### 2-3-1、defineProperty 实现

```js
<div id="myapp">
  <input v-model="message" /><br>
  <span v-bind="message"></span>
</div>
<script type="text/javascript">
  var model = {
    message: ""
  };
  var models = myapp.querySelectorAll(" [v-mode l=message]");
  for (var i = 0; i < models.length; i++) {
    models[ i ].onkeyup = function () {
      model[ this.getAttribute("v-model") ] = this.value;
    }
  }
  Object.defineProperty(model, "message", {
    set: function (newValue) {
      var binds = myapp.querySelectorAll(" [v-bind=message]");
      for (var i = 0; i < binds.length; i++) {
        binds[ i ].innerHTML = newValue;
      };
      var models = myapp.querySelectorAll(" [v-mode l=message]");
      for (var i = 0; i < models.length; i++) {
        models[ i ].value = newValue;
      };
      this.value = newValue;
    },
    get: function () {
      return this.value;
    }
  }
</script>
```

```js
// 数据
const data = {
  text: 'default'
};
const input = document.getElementById('input');
const span = document.getElementById('span');
// 数据劫持
Object.defineProperty(data, 'text', {
  // 数据变化 --> 修改视图
  set(newVal) {
    input.value = newVal;
    span.innerHTML = newVal;
  }
});
// 视图更改 --> 数据变化
input.addEventListener('keyup', function(e) {
  data.text = e.target.value;
});
```

```js
// Dep module
class Dep {
  static stack = []
  static target = null
  deps = null
  
  constructor() {
    this.deps = new Set()
  }

  depend() {
    if (Dep.target) {
      this.deps.add(Dep.target)
    }
  }

  notify() {
    this.deps.forEach(w => w.update())
  }

  static pushTarget(t) {
    if (this.target) {
      this.stack.push(this.target)
    }
    this.target = t
  }

  static popTarget() {
    this.target = this.stack.pop()
  }
}

// reactive
function reactive(o) {
  if (o && typeof o === 'object') {
    Object.keys(o).forEach(k => {
      defineReactive(o, k, o[k])
    })
  }
  return o
}

function defineReactive(obj, k, val) {
  let dep = new Dep()
  Object.defineProperty(obj, k, {
    get() {
      dep.depend()
      return val
    },
    set(newVal) {
      val = newVal
      dep.notify()
    }
  })
  if (val && typeof val === 'object') {
    reactive(val)
  }
}

// watcher
class Watcher {
  constructor(effect) {
    this.effect = effect
    this.update()
  }

  update() {
    Dep.pushTarget(this)
    this.value = this.effect()
    Dep.popTarget()
    return this.value
  }
}

// 测试代码
const data = reactive({
  msg: 'aaa'
})

new Watcher(() => {
  console.log('===> effect', data.msg);
})

setTimeout(() => {
  data.msg = 'hello'
}, 1000)
```





### 2-3-2、proxy 实现

```js
// 数据
const data = {
  text: 'default'
};
const input = document.getElementById('input');
const span = document.getElementById('span');
// 数据劫持
const handler = {
  set(target, key, value) {
    target[key] = value;
    // 数据变化 --> 修改视图
    input.value = value;
    span.innerHTML = value;
    return value;
  }
};
const proxy = new Proxy(data, handler);

// 视图更改 --> 数据变化
input.addEventListener('keyup', function(e) {
  proxy.text = e.target.value;
});
```







