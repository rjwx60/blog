## 一、前端核心

### 1-1、一段话讲

#### 1-1-1、代码执行(语法层)

后台的每个执行环境都有一个表示变量的对象——变量对象。 全局环境的变量对象始终存在，而像 compare()函数这样的局部环境的变量对象，则只在函数执行的过程中存在；

- 在创建 compare()函数时，会创建一个预先包含全局变量对象的作用城链 这个作用域链被保存在内部的 [[scope]] 属在中；
- 当调用 compare() 函数时，会为函数创建一个执行环境，然后通过复制函数的 [[scope]] 属性中的对象，构建起执行环境的作用域链；
- 此后，又有一个活动对象(在此作为变量对象使用)被创建并被推入执行环境作用域链的前端；

- 对于这个例子中compare ()函数的执行环境而言，其作用城链中包含两个变量对象：本地活动对象和全局变量对象；显然，作用域链本质上是一个指向变量对象的指针列表， 它只引用但不实际包含变量对象。无论什么时候在函数中访问一个变量时，就会从作用域链中搜索具有相应名字的变量。一般来讲，函数执行完毕后，局部活动对象就会被销毁，内存中仅保存全局作用域(全局执行环境的变量对象)。但是，闭包的情况又有所不同。

**<u>*所以：总结过程如下：*</u>**

- 首先，在创建 main 函数时，会
  - 创建一个预先包含父级变量对象的**<u>作用城链</u>**，但 main 已是最顶级，所以此时的作用域链内容为空，并被保存在函数的 [[scope]] 属性中；
- 然后，在执行 main 函数时，会：
  - 为函数创建一个**<u>执行环境 Execution context</u>**，然后通过复制函数的 [[scope]] 属性中的所有对象，构建起执行环境的作用域链；
  - 然后，创建**<u>活动对象</u>**(即全局变量对象VO，因激活态为 AO—常驻对象)，并推入执行环境作用域链的前端；[全局变量对象]；
  - 至此，完成了完全体的**<u>作用域链</u>**的构建，最后创建 **<u>this 对象</u>**；
- 然后，在执行过程中，遇到某函数A的调用，首先，创建该函数 A：
  - 创建一个预先包含父级变量对象的**<u>作用城链</u>**，并被保存在函数 A 的 [[scope]] 属性中；

- 然后，执行函数 A，
  - 为函数 A 创建一个**<u>执行环境 Execution context</u>**，然后通过复制函数 A 的 [[scope]] 属性中的所有对象，构建起执行环境的作用域链；
  - 然后，创建**<u>活动对象</u>**(即全局变量对象VO，因激活态为 AO—常驻对象)，并推入执行环境作用域链的前端；[函数A 的 AO，父级变量对象]；
  - 至此，完成了完全体的**<u>作用域链</u>**的构建，最后创建 **<u>this 对象</u>**；
- 上述过程循环往复；

所以：作用域链本质上是一个：存放系列变量对象的指针列表， 但其只存放引用不包含实际变量对象；当在函数中访问一个变量时，就会从作用域链中搜索具有相应名字的变量。一般来讲，函数执行完毕后，局部活动对象就会被销毁，内存中仅保存全局作用域(全局执行环境的变量对象)

**<u>*最终版本!!!!!!!!!!!!!!!!(下面与红宝石书描述不太一致，主要在书中倾向于执行时才创建 Exceution context，个人倾向于下方内容)：*</u>**

**<u>*首先*</u>**：在调用函数，在执行函数代码前：

- 进入创建阶段(内存分配)——Creation Phase——(执行上下文的创建，即 JS 执行一段代码时的运行环境的创建)：
  - 1、初始化作用域链——Scope Chain (保存在函数的 [[scope]] 属性中，即此属性是一个指向这个链表头结点的指针，预先包含所有外层已完成的 AO)
  - 2、创建 变量对象 Variable object (注意只是创建，其中属性值未被赋值；此对象形成的所有可访问变量，可以说是作用域的实体；开启变量生命周期)
    - 创建实参对象 (arguments object)，检查 context 形参 (parameters)，初始化参数名称和参数值，并且创建一份引用拷贝；
    - 扫描context中的函数声明：

      - 为每一函数在 Varible object 上创建属性，属性名即函数名，含有一个指向内存中函数的引用指针；
      - 若函数名已存在，则此引用指针值将会被重写；

    - 扫描 context 中变量声明：
      - 为每一变量在 Variable object 上创建属性， 属性名即变量名，并将变量值初始化为 undefined； 
      - 若变量名已存在，则什么均不会发生，并继续扫描；
  - 3、确定 this 值；
    - 所以 this 在创建阶段确定，即**<u>在函数被调用时才发生绑定，this指向最近的调用方(匿名函数除外)</u>**
  - 补充：执行上下文的创建，实际上并不单单创建者三个对象，还会包含其他信息：函数在哪被调用(调用栈)，函数的调用方法等；

**<u>*最后*</u>**：代码执行阶段——Code Execution Phase：

- 运行/解释 context 中函数代码，并且根据代码一行一行的执行；
- 变量对象转为激活对象，即完成 VO—>AO 的转换，并被推入当下执行环境的 ScopeChain 的前端，而因为创建阶段已经塞入所有 AO 的引用，所以此时的 作用域链 ScopeChain 由当前执行环境的变量对象和所有外层已经完成的激活对象组成，即包含：全局AO，...，爷级AO，父级VO，与当前本地 VO(AO)；至此，作用域链被确定下来了；这道工序保证了变量和函数的有序访问，即如果当前作用域中未找到变量，则继续向上查找直到全局作用域；
  - 注意：即函数创建时初始化作用域链，并用 [[scope]] 指针指向，初始值为系列外层 AO；执行时塞入当前 AO；再遇调用，则再创建-初始-填充；
  - 注意：VO 即作用域的实体，在当前 VO 找不到时，就通过作用域链——一个本质上是存放系列变量对象的指针列表来逐个向上寻找；
- 为变量赋值、新一轮的函数创建-压栈执行-执行完毕则退栈；或退栈时返回了个函数，函数包含 [[scope]] 指向，成为了闭包；

**<u>*示例*</u>**：

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123716.png" style="zoom:50%;" align="left" />

当调用foo(22)时，创建阶段时，context 如下：

即在创建阶段时，只负责对属性名称(变量名)定义，但并无赋值 (例外：formal arguments / parameters(实参 / 形参) )

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123717.png" style="zoom:50%;" align="left" />

创建阶段完成后，执行流进入函数内部，激活执行阶段(execution stage)，然后代码完成执行，context 如下：

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123718.png" style="zoom:50%;" align="left" />

**<u>*关于变量提升——Hoisting：*</u>**

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123719.png" style="zoom:50%;" align="left" />

Why foo can be visited before declare？

- 跟踪 creation stage，则知代码执行阶段之前，变量已被创建，故在函数流开始执行之前，foo 已经在 activation object中被定义；


Foo has been declared twice, why last foo show function instead of undefined or string？

- 创建阶段，函数创建在变量前，并且若属性名在 activation object 中已存在的话，会跳过此声明；故对 function foo() 的引用在 activation object 上先被创建了，当解释器到达 var foo 时，属性名 foo 已存在，代码跳过继续向下执行；


Why bar undefined？

- bar 实际上是一个变量，并且被赋值了一个函数的引用，变量是在创建阶段被创建，并被初始化为 undefined，故 bar 是 undefined；



#### 1-1-2、执行上下文

**<u>关于执行上下文</u>**：

个人认为其是字节码执行时创建的隐式的对象，包含众多辅助代码执行的对象，比如变量对象、this、作用域链，为方便分析还分为下述几类：

- 全局执行上下文：默认上下文，任何不在函数内部的代码均在全局上下文中(一程序中只有一全局上下文)；它会执行两件事：
  - 创建一个全局 window 对象 (浏览器)；
  - 设置 this 的值等于这个全局对象；
- 函数执行上下文：每当一函数被调用时，都会为该函数创建一新的上下文；每个函数都有它自己的执行上下文，不过是在函数被调用时创建；函数上下文可有任意多个，每当一个新的执行上下文被创建，它会按定义的顺序执行一系列步骤；
- Eval 函数执行上下文：执行在 eval 函数内部的代码也会有它属于自己的执行上下文；



#### 1-1-3、执行栈、作用域查找

**<u>关于执行栈</u>**：

执行上下文创建后，进入执行阶段，此时进入执行栈，将执行上下文压栈执行，底层更感觉是 ESP 指针移动，进入此对象的引用地址的区域执行代码；亦可理解为一个存储函数调用的 栈结构；

正常来讲，在函数执行完毕并出栈时，函数内局部变量在下一个垃圾回收节点会被回收，该函数对应的执行上下文将会被销毁，这也正是我们在外界无法访问函数内定义的变量的原因。也就是说，只有在函数执行时，相关函数可以访问该变量，该变量在预编译阶段进行创建，在执行阶段进行激活，在函数执行完毕后，相关上下文被销毁；

**<u>*关于作用域及其查找*</u>**：

作用域其实就是变量对象的实体，作用域查找其实就是变量对象上的检索；但若当前 AO(VO) 找不到，就从 [[scope]] 指向的作用域链上的 AO 列表逐个查找，行为表现类似依据作用域链查找，而实际上是 VO 链表的查询；为便于分析，衍生为全局、函数作用域等概念；至于块级作用域，个人觉得与创建变量对象时，变量生命周期有关，引擎限定了 let/const 在初始化-定义前不得使用，故存在 TDZ，存在块级作用域；



#### 1-1-4、闭包、变量提升

**<u>关于闭包</u>**：

闭包一种特殊的作用域，称为 <u>静态作用域</u>；可理解为：<u>父函数被销毁</u> 的情况下(ESP指针下移，执行上下文出栈、切换)，而返回出的子函数的`[[scope]]`(指向作用域链) 中仍保留系列父级变量对象，因此可继续访问到父级的变量对象，如此的函数称为闭包，而因为保留着引用，所以父函数无法被即使回收，作为活动对象长期存在，新生代—老生代；闭包用于实现 OOP 的封装性、模块化、命名空间、函数工厂、延期执行等，实际上利用的是当前执行上下文的作用域链对象没有包含父级VO，变量查找不到==私有变量；

注意：在定时器、事件监听、Ajax请求、跨窗口通信、Web Workers 或任何异步中，只要使用回调函数，实际上就是在使用闭包；

**<u>关于变量提升</u>**：

变量对象的创建，即开始进入了变量的生命周期：声明(Declaration phase)、初始化(Initialization phase)与赋值(Assignment phase)；其中：

- Var：在内存分配阶段，进行变量的创建-声明与初始化-定义，最后在代码执行阶段进行赋值操作；

- Function：在内存分配阶段就已经完成三个变量周期；同名情况下，比 Var 优先级高；

- Let：在内存分配阶段仅完成变量的创建-声明，并未初始化-定义，只有在执行阶段的 let x = xxx 时才进行首次初始化-定义，若后续还有操作才是赋值行为；

  - 所以，在 let x = xx 前就使用就会报错：x is not define(定义)，即所谓的暂时性死区—TDZ—未初始化-定义前不准使用变量；

  - ```js
    // Ex1
    let xx = yyy
    // Uncaught ReferenceError: yyy is not defined
    
    // Ex2
    // 注意: 除了块级作用域以外，函数参数默认值也会受到 TDZ 影响；
    function foo(arg1 = arg2, arg2) { ... }
    // Uncaught ReferenceError: arg2 is not defined
    foo(undefined, 'arg2')  
    // 将函数参数默认值区域也想象成为一个 TDZ 范围会比较容易理解
    // 即 arg2 虽然已经声明但为初始化-定义，在执行阶段 arg1 的初始化时，寻找 arg2 就会报错
    // 至于为何下面传入 null 没有报错是因为前者传 undefined 相当于不传值，使用 arg2，后者则替代了 arg2 避免了出错
    function foo(arg1 = arg2, arg2) { ... }
    foo(null, 'arg2') // null arg2
    ```

- Const：在代码执行阶段进行创建-声明与初始化-定义，没有二次赋值行为；

注意：变量提升只对 var 命令声明的变量有效，若一变量不是用 var 命令声明的，就不会发生变量提升：

注意：函数表达式也会提升，但作为普通变量提升，而非函数提升；而同名函数和变量同存时，函数优先，变量延后提升，相当于变量会覆盖函数声明；



#### 1-1-5、代码执行(源码层)

**<u>关于执行代码</u>**：

个人感觉此处的执行代码与前面的执行上下文的创建于执行不同，不同在此处偏向于机器码的实现，而后者偏向于在字节码执行的过程，字节码执行过程控制着内存的分配与执行时的操作等；所以此两个阶段并不冲突；

- 1、**预解析 parser**：<u>检查语法错误</u>；
- 2、**生成 AST**：<u>经过词法分析—分词、Token/语法分析—转换 AST</u>，生成  **<u>AST 抽象语法树</u>**——Babel类似原理；
- 3、**生成字节码**：**<u>基线编译器 (Ignition)</u>** 将 AST 转换成 **<u>字节码</u>**——吸取过去教训的中间产物—个人理解其包含内存分配阶段，即包含变量对象等内容的生成；
- 4、**生成机器码**：**<u>优化编译器 (Turbofan)</u>** 将字节码转换成优化过的 **<u>机器码</u>**，此外在逐行执行字节码的过程中，若某段代码经常被执行， V8 会将这段代码直接转换成机器码保存起来，下一次执行就不必经过字节码转换阶段，优化执行速度；
- - 注意：**<u>在逐行执行字节码的过程中</u>(个人认为此处即"代码执行阶段——包含作用域链的完善、赋值操作等，最后才会被机器码真正执行")**，若 Turbofan 发现某段代码经常被执行， 则 V8 会将这段代码标记为 <u>热点代码(HotSpot)</u>，并将这段代码直接转换成机器码保存起来，下一次执行就不必经过字节码转换阶段，以优化执行速度；如此执行时间越久，执行效率越高；
  - 注意：**<u>JS 并非纯粹的解释器语言，因为字节码不仅配合解释器，还有编译器的参与</u>**，而<u>两者根本区别</u>在于：前者会编译生成二进制文件，但后者不会；此外，这种字节码跟编译器、解释器结合的技术，称为 **<u>即时编译(JIT)</u>**；
- 5、**执行代码**；



#### 1-1-6、this指向


**<u>关于 this 指向：</u>**

指向上下文创建时的 this 确定值，即外层调用，而 call、apply、bind 形式的调用是重新进行了一次执行上下文创建过程，修改调用主体，修改 this 确定；

- 普通 this 指向：默认指向全局对象，严格模式指向 undefined；注意赋值操作，因赋值后的调用又创建了一次上下文，又进行了一次 this 确定；
  - 注意严格模式下，在全局环境打印 this 还是可以输出无报错——但函数体内使用诸如 this.a 就报错…
  - 注意 var 会默认绑定到 window，但 let/const 不会；
  
- 隐式绑定：即对象点方法的形式调用；注意赋值操作，因赋值后的调用又创建了一次上下文，又进行了一次 this 确定；且赋值操作并不限定于 =，还可以是 :

- 显式绑定：即 call/apply 绑定，意为：在 obj 中使用 function；在对象上强制调用函数，直接指定 this 绑定对象；

- 显式硬绑：显式绑定的变种 (本质是：在显式绑定的基础上用一层函数包裹)
  - 无法再次修改 this 指向，除非 new 操作
  - bind 会判断硬绑定函数，是否是被 new 调用，若是则使用 new 操作中新创建的 this 替换硬绑定的 this；
  - 显式硬绑定是 ES5中 bind 的雏形
  
- new 绑定：构造函数中的 this 指向实例对象；个人理解为内部做了一层无法改变的 this 绑定；

  - 1、创建一个新的对象；2、将构造函数的 `this` 指向这个新对象；3、为这个对象添加属性、方法等；4、最终返回新对象；

  - 注意：若在构造函数中出现了显式 `return` 的情况

    - 若构造函数中显式返回一个值，且返回的是对象，则 `this` 就指向这个返回的对象；

    - 若构造函数中显式返回一个值，且返回的非对象，则 `this` 仍然指向实例；

    - ```js
      // 返回对象
      function Foo(){
          this.user = "TLP"
          const o = {}
          return o
      }
      const instance = new Foo()
      console.log(instance.user) // undefined
      
      // 返回非对象
      function Foo(){
          this.user = "TLP"
          return 1
      }
      const instance = new Foo()
      console.log(instance.user)
      ```

- 特殊：DOM 事件绑定：onclick 和  addEventerListener中 this 默认指向绑定事件的元素；

- 特殊：箭头函数，根据外层上下文绑定的 `this` 决定 `this` 指向；

- 特殊：匿名函数：默认指向全局对象，严格模式指向 undefined；比如 setTimeout、匿名函数的赋值调用而非对象点方法调用；

- 注意：赋值操作(=/:/传参/)+匿名函数-> 全局环境下调用匿名函数(个人认为是因为赋值的是一个地址引用，最后调用时，凭空创建上下文，this 默认绑定全局)

各绑定优先级：默认绑定 < 隐式绑定 < 显式绑定 < 显式硬绑定 < new 绑定；以及判断 this 绑定位置：

1. 函数是否在 new 中调用(new 绑定)？如果是的话 this 绑定的是，新创建的对象；var bar = new foo()
2. 函数是否通过 call、apply(显式绑定)或者 bind (显示硬绑定)调用？如果是的话this 绑定的是，指定的对象；var bar = foo.call(obj2)
3. 函数是否在某个上下文对象中调用(隐式绑定)？如果是的话this 绑定的是，那个上下文对象；var bar = obj1.foo()
4. 若都不是的话，使用默认绑定。严格模式下，就绑定到 undefined，否则绑定到，全局对象；var bar = foo()

注意：箭头函数不使用 this 的四种标准规则，其 this 的指向 根据外层(函数或者全局)作用域来决定，且这种绑定无法被修改，常用于回调中；

注意：箭头函数使用了词法作用域取代传统的 this 机制，同 self = this 机制一致；

注意：箭头函数：

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200913134636.png" alt="截屏2020-09-13 下午1.46.33" style="zoom:50%;" />

#### 1-1-7、EvntLoop

关于 EventLoop：

前面讲到，执行 JS 代码时其实就是往执行栈中放入函数，而当遇到异步的代码时，会被 **挂起** 并在需要执行时加入到 Task(有多种 Task) 队列中；一旦执行栈为空，Event Loop(事件循环机制) 就会从 Task 队列 中拿出需要执行的代码并放入执行栈中执行；

浏览器(多进程)包含了**Browser进程**(浏览器的主进程)、**第三方插件进程**、**GPU进程**(浏览器渲染进程)等，其中**GPU进程**(多线程)与前端密切相关，包含以下线程：

- **GUI渲染线程**
- **JS引擎线程**(注意：GUI渲染线程、JS引擎线程互斥，为防止DOM渲染不一致性，其中一线程执行时另一线程会被挂起)
- **事件触发线程**(和EventLoop密切相关)
- **定时触发器线程**
- **异步HTTP请求线程**

浏览器页面初次渲染完毕后，**JS引擎线程**结合**事件触发线程**的工作流程如下：

- 同步任务在 **JS引擎线程**(主线程)上执行，形成**执行栈**(Execution Context Stack)；
- 主线程之外，**事件触发线程** 管理着一个**任务队列**(Task Queue)只要异步任务有了运行结果，就在**任务队列**之中放置一个事件；
- **执行栈** 中的同步任务执行完毕，系统就会读取**任务队列**，如果有异步任务需要执行，将其加到主线程的**执行栈**并执行相应的异步任务；

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123822.png" style="zoom:50%;" />

**<u>*事件循环机制*</u>**：**事件触发线程**管理的任务是从**JS引擎线程**本身产生：主线程在运行时会产生**执行栈**，栈中的代码调用某些异步API时会在**任务队列**中添加事件，栈中的代码执行完毕后，就会读取**任务队列**中的事件，去执行事件对应的回调函数，如此循环往复，形成事件循环机制

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123823.png" style="zoom:50%;" />

JS中有两种任务类型：**微任务**(microtask)和**宏任务**(macrotask)，在ES6中，microtask称为 jobs，macrotask称为 task。

- **宏任务**： script (主代码块)、`setTimeout` 、`setInterval` 、`setImmediate` 、I/O 、UI rendering、WebWorker；
- **微任务**：process.nextTick、Promises.then/reject-catch-finally、Object.observe、MutationObserver、以 Promise 为基础开发的其他技术(比如fetch API)、V8 的垃圾回收过程等；
  - 注意：**宏任务**并非全是异步任务，主代码块就是属于**宏任务**的一种 (Promises/A+规范)；
  - 注意：宏微任务由来：<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200913140611.png" alt="截屏2020-09-13 下午2.06.08" style="zoom:50%;" />

两种任务间的区别如下：

- **宏任务**是每次**执行栈**执行的代码(包括每次从事件队列中获取一个事件回调并放到执行栈中执行)
- 浏览器为能够使得**JS引擎线程**与**GUI渲染线程**有序切换，会在当前**宏任务**结束后，下一**宏任务**执行开始前，对页面进行重新渲染(**宏任务** > 渲染  > **宏任务** > ...)
- **微任务**是在当前**宏任务**执行结束之后立即执行的任务(在当前 **宏任务**执行之后，UI渲染之前执行的任务)。**微任务**的响应速度相比`setTimeout`(下一个**宏任务**)会更快，因为无需等待UI渲染；
- 当前**宏任务**执行后，会将在它执行期间产生的所有**微任务**都执行一遍。

总结：

- **宏任务**中的事件是由**事件触发线程**来维护；
- **微任务**中的所有任务是由**JS引擎线程**维护的(这只是自我猜测，因为**宏任务**执行完毕后会立即执行**微任务**，为了提升性能，这种无缝连接的操作放在**事件触发线程**来维护明显是不合理的)。

根据事件循环机制，重新梳理一下流程：

- 首先，将整段脚本作为首个 **宏任务** 执行；
- 然后，执行过程中同步代码直接执行，**宏任务** 进入宏任务队列，**微任务**进入微任务队列；
- 然后，当前宏任务执行完全，执行栈为空，检查微任务队列，若有则依次执行，直到微任务队列为空；
- 然后，JS引擎线程挂起，执行浏览器 UI 线程的渲染工作；
- 然后，UI 线程挂起，检查是否有 Web worker 任务，有则执行；
- 最后，执行队首新的宏任务，回到第二步，依此循环，直到宏任务和微任务队列都为空；

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123824.png" style="zoom:40%;" align="left" />

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123825.png" style="zoom:40%;" align="left" />

- await 处理、return new Promise 处理、嵌套 promise 处理，看示例代码



#### 1-1-8、NodeEventLoop

EventLoop 与 Node 区别：最主要的区别在于：浏览器中的微任务是在 **<u>每个相应的宏任务</u>** 间执行的，而 Node  中的微任务是在 **<u>不同阶段间</u>** 执行的；

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200913150721.png" alt="截屏2020-09-13 下午3.07.18" style="zoom:50%;" />





### 1-2、深刻示例

##### 1-2-1、作用域查找

万变不离其宗——VO 对象的值的查找—>[父级VO集合]上的值的查找

```js
for(var i = 1; i <= 5; i ++){
  setTimeout(function timer(){
    console.log(i)
  }, 0)
}
// setTimeout 为宏任务, 而由于 JS 单线程 EvLoop 机制，在主线程同步任务执行完后才去执行宏任务，此时循环已结束，i 也已变成了 6；
// loop 结束后, setTimeout 依次执行回调，但输出时在当前变量对象无 i，遂通过作用域链向上寻找 i, 因此会全部输出6；


// 解决1、利用 IIFE，使得每次 for 均创建不一样的 VO(每 VO 含有不一样的 j——虽然同名)，但注意到均包含父级 VO，均能找到 a
// 输出 5 个 6，1-5
for(var i = 1;i <= 5;i++){
  var a = 1
  (function(j){
    setTimeout(function timer(){
      console.log(j)
      console.log(a)
    }, 0)
  })(i)
}

// 解决2、给定时器传入第三个参数, 与 IIFE 原理类似，创建单独的 VO，但注意到均包含父级 VO，均能找到 i
// 输出 5 个 6，1-5
for(var i=1;i<=5;i++){
  setTimeout(function timer(j){
    console.log(j)
  }, 0, i)
}
for(var i=1;i<=5;i++){
  setTimeout(function timer(j){
    console.log(i); console.log(j)
  }, 0, i)
}


// 解决3、使用块级作用域 let 使 JS 发生革命性的变化，让 JS 有函数作用域变为块级作用域
// 原理其实还是一样，利用 VO 的查找层级
for(let i = 1; i <= 5; i++){
  setTimeout(function timer(){
    console.log(i)
  },0)
}
// babel 转译后结果
"use strict";
var _loop = function _loop(i) {
  setTimeout(function timer() {
    console.log(i);
  }, 0);
};
for (var i = 1; i <= 5; i++) {
  _loop(i);
}
// 加个 const 怎么样
for(let i = 1; i <= 5; i++){
  const a = 1;
  setTimeout(function timer(){
    console.log(i)
  },0)
}
// babel 转译后结果
"use strict";
var _loop = function _loop(i) {
  // 啊哈
  var a = 1;
  setTimeout(function timer() {
    console.log(i);
  }, 0);
};
for (var i = 1; i <= 5; i++) {
  _loop(i);
}
```

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123746.png" style="zoom:50%;" align="left" />

```
前面考虑的是多个子函数的 ScopeChain 包含的 父级 VO 是一样的，所以输出为：undefined 0 0 0 
中间考虑的是嵌套子函数的 VO 查找，单纯考你思维性，输出为：undefined 0 1 2
后面就是上面的多个利用，无他，输出为：undefined 0 1 1
```

##### 1-2-2、this 指向

万变不离其宗：调用，创建上下文，this 指向 确定——即调用即确定；注意匿名、注意赋值操作(=或:)(实际上还是通过调用即指向)；

```js
// Ex1
// 匿名函数实际上还是走那个形式，只不过它因为是宏任务，先交给浏览器 WebAPI, 完成计时后放入队列，等真正执行时是 window 执行
var a = {
  name: 'tlp',
  fun1: function(){ this.name },
  fun2: function(){
    setTimeout(function(){
      this.fun1() // TypeError: fun1 is not a function "undefined"
    },0)
  }
}

// Ex2
function foo () { console.log(this.a) };
var obj = { a: 1, foo };
var a = 2;
var foo2 = obj.foo;
var obj2 = { a: 3, foo2: obj.foo }

obj.foo(); 		// 1 调用者为 obj 没毛病
foo2(); 			// 2 赋值后，调用时，上下文，this 为 window	 
obj2.foo2(); 	// 3 foo2: obj.foo 乃赋值的另一种形式，所以最后调用者为 obj2 

// Ex3
function foo () { console.log(this.a)}
function doFoo (fn) {
  console.log(this) // window
  fn()
}
var obj = { a: 1, foo }
var a = 2
doFoo(obj.foo) // 2	参数传参也是赋值操作，随后 doFoo 创建上下文时，this 为 window

// Ex4
function foo () { console.log(this.a) }
function doFoo (fn) {
  console.log(this) // obj2
  console.log(this.a) // 3
  fn()
}
var obj = { a: 1, foo }
var a = 2
var obj2 = { a: 3, doFoo }
obj2.doFoo(obj.foo) // 2 迷惑题，但本质还是一样，虽然 obj2.doFoo 形式，让 doFoo this 指向 obj2, 但 fn 调用时，采取的是变量对象寻值的方式!!

// Ex5
var obj1 = {
  a: 1
}
var obj2 = {
  a: 2,
  foo1: function () {
    console.log(this.a)
  },
  foo2: function () {
    setTimeout(function () {
      console.log(this)
      console.log(this.a)
    }.call(obj1), 0)
    // 注意：不能是 obj2.foo2.call(obj1) 写法，否则改变 this 为 foo2 环境，但内部计时器存在仍会指向 window
  }
}
var a = 3
obj2.foo1() // 2
obj2.foo2() // obj1 1 改变的不是匿名函数，而是匿名的回调

// Ex6
var obj = {
  a: 1,
  foo: function (b) {
    b = b || this.a
    return function (c) {
      console.log(this.a + b + c)
    }
  }
}
var a = 2
var obj2 = { a: 3 }

obj.foo(a).call(obj2, 1)
// 3 + 2 + 1 == 6 极好综合题
obj.foo.call(obj2)(1) 
// 2 + 3 + 1 == 6 极好综合题

// Ex7
var name = 'window'
function Person (name) {
  this.name = name
  this.foo = function () {
    console.log(this.name)
    return function () {
      console.log(this.name)
    }
  }
}
var person1 = new Person('person1')
var person2 = new Person('person2')
person1.foo.call(person2)() // person2 window 最后返回匿名函数并在 window 下调用，除非改变匿名绑定
person1.foo().call(person2) // person1 person2 

// Ex8
function Foo() {
    Foo.a = function() {
        console.log(1)
    }
    this.a = function() {
        console.log(2)
    }
}
Foo.prototype.a = function() {
    console.log(3)
}
Foo.a = function() {
    console.log(4)
}
Foo.a(); // 4
let obj = new Foo();
obj.a(); // 2
Foo.a(); // 1

// Ex9
// 综合示例
const o1 = {
    text: 'o1',
    fn: function() {
        return this.text
    }
}
const o2 = {
    text: 'o2',
    fn: function() {
        return o1.fn()
    }
}
const o3 = {
    text: 'o3',
    fn: function() {
        var fn = o1.fn
        return fn()
    }
}
console.log(o1.fn()) // o1
console.log(o2.fn()) // o1
console.log(o3.fn()) // undefined

// this 永远指向最后调用它的那个对象
// 匿名函数的 this 永远指向 window
// 使用.call()或者.apply()的函数是会直接执行的
// bind()是创建一个新的函数，需要手动调用才会执行
// 若 call、apply、bind 接收到的第一个参数是空或者 null、undefined 的话，则会忽略这个参数
// forEach、map、filter函数的第二个参数也是能显式绑定this的

// Ex10
var obj = {
  name: 'obj',
  foo1: () => {
    console.log(this.name)
  },
  foo2: function () {
    console.log(this.name)
    return () => {
      console.log(this.name)
    }
  }
}
var name = 'window'
obj.foo1() // window 注意: window.obj.foo1 故应为 window
obj.foo2()() // obj obj

// Ex11
// 箭头函数的 this 无法通过 bind、call、apply 来直接修改，但可通过改变作用域中 this 的指向来间接修改
var name = 'window'
var obj1 = {
  name: 'obj1',
  foo1: function () {
    console.log(this.name)
    return () => {
      console.log(this.name)
    }
  },
  foo2: () => {
    console.log(this.name)
    return function () {
      console.log(this.name)
    }
  }
}
var obj2 = {
  name: 'obj2'
}
obj1.foo1.call(obj2)() // obj2 obj2
obj1.foo1().call(obj2) // obj1 obj1
obj1.foo2.call(obj2)() // window window
obj1.foo2().call(obj2) // window obj2
// 箭头函数里面的 this 是由外层作用域来决定的，且指向函数定义时的 this 而非执行时
// 字面量创建的对象，作用域是 window，若里面有箭头函数属性的话，this 指向的是 window
// 构造函数创建的对象，作用域可理解为是这个构造函数，且这个构造函数的 this 是指向新建的对象的，因此 this 指向这个对象。
// 箭头函数的 this 无法通过 bind、call、apply 来直接修改，但可通过改变作用域中 this 的指向来间接修改。

// 综合1：字面量对象中的各种场景
var name = 'window'
var person1 = {
  name: 'person1',
  foo1: function () {
    console.log(this.name)
  },
  foo2: () => console.log(this.name),
  foo3: function () {
    return function () {
      console.log(this.name)
    }
  },
  foo4: function () {
    return () => {
      console.log(this.name)
    }
  }
}
var person2 = { name: 'person2' }

person1.foo1() // person1
person1.foo1.call(person2) // person2

person1.foo2() // window
person1.foo2.call(person2) // window

person1.foo3()() // window
person1.foo3.call(person2)() // window
person1.foo3().call(person2) // person2

person1.foo4()() // person1
person1.foo4.call(person2)() // person2
person1.foo4().call(person2) // person1


// 综合2：构造函数中的各种场景 - 坑
var name = 'window'
function Person (name) {
  this.name = name
  this.foo1 = function () {
    console.log(this.name)
  },
  this.foo2 = () => console.log(this.name),
  this.foo3 = function () {
    return function () {
      console.log(this.name)
    }
  },
  this.foo4 = function () {
    return () => {
      console.log(this.name)
    }
  }
}
var person1 = new Person('person1')
var person2 = new Person('person2')

person1.foo1() // person1
person1.foo1.call(person2) // person2

person1.foo2() // person1
person1.foo2.call(person2) // person1

person1.foo3()() // window
person1.foo3.call(person2)() // window
person1.foo3().call(person2) // person2

person1.foo4()() // person1
person1.foo4.call(person2)() // person2
person1.foo4().call(person2) // person1


// 综合3:
var name = 'window'
function Person (name) {
  this.name = name
  this.obj = {
    name: 'obj',
    foo1: function () {
      return function () {
        console.log(this.name)
      }
    },
    foo2: function () {
      return () => {
        console.log(this.name)
      }
    }
  }
}
var person1 = new Person('person1')
var person2 = new Person('person2')

person1.obj.foo1()() // window
person1.obj.foo1.call(person2)() // window
person1.obj.foo1().call(person2) // person2

person1.obj.foo2()() // obj
person1.obj.foo2.call(person2)() // person2
person1.obj.foo2().call(person2) // obj


// 综合4
function foo() {
  console.log( this.a );
}
var a = 2;
(function(){
  "use strict";
  console.log(this) // undefined
  foo(); // 2
})();
```





## 二、前端异步

### 2-1、一段话讲

每个异步解决方案不是无中生有，都是为了解决问题的集合性方案：

**<u>阶段一：回调函数</u>**

- 问题1：缺乏顺序性：其导致调试困难，并与大脑线性思维方式不符；

- 问题2：缺乏可信任性： 控制反转导致系列信任问题；
- 其实最直观的是回调地狱问题，多层嵌套、调试复杂，维护困难；此外还有控制反转的问题，就是异步事件完全由三方控制，不由主程控制，无法控制异步行为，或多次调用、或不调用、或报错，主程对此完全无法预知；

**<u>阶段二：Promise 基于 PromiseA+ 规范的实现</u>**

- 解决：上述问题2——缺乏可信任性问题，重掌代码执行主动权；主要通过约定异步行为来实现；(一定程度上还解决了顺序问题：链式调用)，但是！并没有摆脱回调，它只是将三角形递增式的回调写法变成直线式；
- 约定的方式或规则，即 Promise 规范；**<u>*我觉得最重要的是下面2点!!!!*</u>**
  - **<u>不变性：某个 Promise 必处于3态之一且不变</u>**(一旦决议，状态不再改变)：pending(激发态)、fulfilled(稳定态)、rejected(稳定态)—状态机；
  - **<u>可信任性：then 总能返回一个Promise</u>**；内部通过 Promise 抽象过程实现，将某些非标准的：类Promise接口、对象、函数或值规范为标准 Promise；
  - 核心1：Promise 本质是状态机，状态单方向改变；
  - 核心2：then 接收 2 个可选参数，分别对应状态改变时触发的回调，then 返回 promise，then 可被同一个 promise 调用多次

**<u>阶段三：Generator(生成器函数) 用同步方式来书写代码</u>**

- 解决：上述问题1——缺乏顺序性，执行可控；(利用协程完成 Generator 函数，用 co 库让代码依次执行完，同时以同步方式书写，也让异步操作按顺序执行)，将回调成功返回的数据送回 JS 主流程中；但需手动调用 next 方法；
- 基本：Generator 实际上是利用了 ES6 的两个新增协议：可迭代协议、迭代器协议；**<u>其实感觉只是利用了迭代器协议…… Generator 利用了迭代器协议，实现 next 方法(无参函数)，方法返回一含有2个属性：done & value 的对象，并利用了协程思想进行代码执行对象的切换和挂起；</u>**
  - 可迭代协议，允许 Js 对象去定义或定制它们的迭代行为；比如：定义在一个 for...of 结构中，什么值可被循环得到；注意：**<u>为变成可迭代对象，1个对象必须实现@@iterator方法；即此对象须有一名为 [Symbol.iterator] 的属性，其值为返回一个对象(须符合迭代器协议)的无参函数 (或对象原型链 prototype chain上的某个对象含有)；而当一个对象需要被迭代的时候 (比如开始用于一个for...of循环中) ，其 @@iterator 方法被调用，且无参数，最后返回一个用于在迭代中获得值的迭代器</u>**；比如 Array、Map、Set、String、NodeList
  - 迭代器协议：协议定义一种标准方式，来产生一个有限或无限序列的值；比如：当1个对象被认为是1个迭代器时，其实现了1个next 方法(无参函数)，方法是返回一对象，对象拥有2个属性；done & value；
  - <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200908092803.png" style="zoom:50%;" align="left" />

**<u>阶段四：Async/Await (结合 Promise & Generator)，在 await 后面跟 Promise，自动等待 Promise 决议值</u>**

- Async/Await 利用 `协程` 和 `Promise ` 实现同步方式编写异步代码的效果，其中 `Generator` 是对 `协程` 的一种实现，虽然语法简单，但引擎在背后做了大量的工作，用 `async/await` 写出的代码也更加优雅、美观，相比于之前的 `Promise` 不断调用then的方式，语义化更加明显；相比于`co + Generator`性能更高，上手成本也更低；

- 解决：Generator 需要手动控制 next(...) 执行的问题、真正实现了用同步的方式书写异步代码；是一个通过异步执行并隐式 **<u>返回 Promise 作为结果</u>** 的函数；<u>是 协程 和 Promise 的组合体</u>，完全解决了基于传统回调的异步流程存在的两个问题(见上方)，能够像 co + Generator 一样用同步的方式来书写异步代码，又得到底层的语法支持，无需借助任何第三方库；
- Await：暂停异步函数的执行；注意 await 只能与 Promise 共用，无法与传统回调共用，await 等待 Promise 完成并返回其结果；

  - 优点：解决了 Generator 需要手动控制 next 执行的问题；
  - 优点：真正实现用同步的方式书写异步代码，逻辑和数据依赖清晰；
  - 优点：无需写 .then、无需写匿名函数处理 Promise 的 resolve 值、无需定义多余变量、避免代码嵌套、提高可读性；
  - 缺点：错误处理过于安静，往往需要用 try-catch 来捕获；

#### 2-1-1、Promise 伟业

**<u>*Promise 本质上并没有完全摆脱回调；但就是这样比单纯使用回调更值得信任，因为它使用了 Promise.resolve，它总能返回一个 Promise!!*</u>**，then 的内部实现就是调用了 Promise.resolve!!，所以可信任性就这么来的!!!，没有了控制反转，可控!!

若向 Promise.resolve 传递1个真 Promise，则得到传递过去的同1个 Promise：

- <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200908092755.png" style="zoom:50%;" align="left" />

若向 Promise.resolve 传递1个非 Promise、非 thenable 的立即值，则得到1个用这个值填充的 Promise：

- <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200908092756.png" style="zoom:50%;" align="left" />

若向 Promise.resolve 传递1个非 Promise、真 thenable 的立即值，Promise.resolve 则会试图展开此值 ，且展开过程中会持续到提取出一个具体的非类 Promise 的规范后的最终值：

- <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200908092757.png" style="zoom:50%;" align="left" />

**<u>*所以!Promise 解决了：*</u>**

<u>回调调用过早问题</u>：Promise 调用 then 时，即使 Promise 已决议，也总会在当前 Js 事件处理完后再调用提供给 then 的回调；**<u>也就是说调用的刚刚好</u>**

<u>回调调用过晚问题</u>：Promise 对象调用 resolve 或 reject 时，通过 then 注册的回调会在下一个异步时间点上被触发；而若多个通过 then 注册的回调，都会在下一个异步时间点上被依次调用，这些注册回调中的异步回调均无法影响或延误对其他 then 上回调的调用；**<u>内部原因是微任务实现；</u>**

- <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200908092753.png" style="zoom:50%;" align="left" />

<u>回调调用次数太多或太少问题</u>：

- Promise 的定义方式使得它 **<u>只能被决议一次</u>**，且会默默忽略任何后续调用，因此任何通过 then 注册的回调就只会被调用一次；

<u>回调无法成功接收所传参数的问题</u>：

- resolve 或 reject，默认传值 undefined
- resolve 或 reject，中的值不管是什么，都会被传给所有注册在 then 中的回调函数
- resolve 或 reject，中传递多个参数时，第一个参数后的所有参数都会被忽略；故<u>多参数传递需通过对象传递；</u>

<u>吞掉可能出现的错误或异常问题</u>：**<u>通过 then 接收 2 个可选参数，分别对应状态改变时触发的回调</u>**

- <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200908092754.png" style="zoom:50%;" align="left" />

**<u>上面提到的作为微任务引入</u>**：Promise 中的执行函数是同步进行，但其中可能存在着异步操作，在异步操作结束后，会调用 resolve 方法或中途遇到错误调用 reject 方法，而两者均作为微任务进入到 EventLoop 中；其实就是如何处理回调的问题，总结起来有三种方式:

- 使用同步回调，直到异步任务进行完，再进行后面的任务；
  - 同步问题明显，阻塞整个脚本；
- 使用异步回调，将回调函数放在进行 **<u>宏任务队列的队尾</u>**；
  - 若宏任务队列非常长，那么回调迟迟得不到执行，造成应用卡顿；
- 使用异步回调，将回调函数放到  **<u>当前宏任务中的最后面</u>**；
  - 为解决上述方案问题，Promise 采取第三种方式， 即作为微任务引入：把 resolve(reject) 回调的执行放在当前宏任务的末尾；
  - 采用**异步回调**替代同步回调解决了浪费 CPU 性能的问题；
  - 放到**当前宏任务最后**执行，解决了回调执行的实时性问题；





#### 2-1-2、Promise 手写

**<u>简单版本：</u>**

猜测实现：new Promise((resolve, reject) => { ... }) 立马执行，且只有调用 resolve 或 reject 才会执行 then 的参数函数方法，then 接收2个参数函数；

实现思路：resolve reject 起调用 then 参数函数方法的作用；在 new Promise 就要将其传入首个函数；then 控制将参数函数塞入(用队列实现吧)；

实现如下：new Promise 时传入 resolve reject 方便传入函数使用，then 则添加方法，等下一次 resolve 时执行队列方法； 

- 1、构建成功&失败回调队列；
- 2、resolve&reject 方法作用是只要队列不为空，则取出并执行(只要调用就执行)
- 3、then 方法是接收 resolveFn&rejectFn并推入队列；
- 4、excutor 即传入的第一个方法，立即调用，传入 resolve&reject

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200913184724.png" alt="截屏2020-09-13 下午6.47.19" style="zoom:50%;" align="left"/>

**<u>高级版本</u>**：

- 核心1：Promise 本质是状态机，且状态只能为以下三种：Pending-等待态、Fulfilled-执行态、Rejected-拒绝态，状态变更单向；
- 核心2：then 接收 2 个可选参数，分别对应状态改变时触发的回调，then 返回 promise，then 可被同一个 promise 调用多次；

基本实现1——状态机

猜测实现：只有 resolve 或 reject 才改变状态，所以应该有最初状态，且改变状态的逻辑在 resolve 或 reject

实现如下：设置常量，与Promise 初始状态，只有通过 resolve reject 才可改变

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200913194556.png" alt="截屏2020-09-13 下午7.45.47" style="zoom:50%;" align="left"/>

基本实现2——链式调用

猜测实现：then 总是返回 Promise 实例，或者说将 then 返回的内容包装成 Promise、而系列 then 的回调要等上一个 resolve 或 reject 才会执行；

实现思路：过去是不管三七二十一就将 resolveFn 推入队列中，现在先将它用 Promise 包裹，才塞入队列中；内部执行时，判断其执行返回值

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200913200616.png" alt="截屏2020-09-13 下午8.06.10" style="zoom:50%;" align="left"/>

**<u>*then 收集方法到队列，在 new Promise 执行 resolve 或 reject 时，才执行队列方法；上面只将方法直接填充队列，这里先将方法用新的 Promise 包裹并返回，从而实现了链式调用，但注意此时返回的 Promise 已经不同于首个 Promise!!!，而是新的 Promise；随后在新 Promise 内部，将包裹了的 resolveFn 塞入旧 Promise 队列，当旧 Promise 内部调用 resolve，就会调用队列中的所有方法，调用 fulfilledFn，然后计算 resolveFn 返回值，判断是否为 Promise，是则等待变更，否则直接调用新 Promise 的 resolve，传值并触发下一个 then，循环往复；*</u>**

基本实现3——值穿透&状态变更

猜测实现：

- 值穿透：即若 then 接收的参数类型不是 function 则应当忽略，让链式调用继续往下执行；

- 处理状态为 resolve/reject 的情况：一般情况下 then 对应状态 pending，但特殊情况比如 Promise.resolve()/reject().then() 则此时状态为 resolve/reject，此时若还按照 pending 态时的做法：将 then 中回调 push 进 resolve/reject 队列中的话，回调将不会正确执行，故需对上述特殊情况进行处理，即对 fulfilled 状态和 rejected 情况进行处理：直接执行回调；

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200908092800.png" style="zoom:50%;" align="left" />

基本实现4——实现同步任务的兼容

目前 Promise 执行顺序是 new Promise -> then()收集回调 -> resolve/reject执行回调，但前提是异步任务；

若为同步则会变为：new Promise -> resolve/reject执行回调 -> then() 收集回调，解决方式是为同步任务包裹 setTimeout 强行变为异步任务

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200913204402.png" alt="截屏2020-09-13 下午8.43.58" style="zoom:50%;" align="left"/>

基本实现5——在前面基础上，实现静态方法

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200913204740.png" alt="截屏2020-09-13 下午8.47.36" style="zoom:50%;" />

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200913204809.png" alt="截屏2020-09-13 下午8.48.02" style="zoom:50%;" />



#### 2-1-3、Promise 实现思路

**<u>resolve 负责接收传入的 value、状态改变、执行 then 存入的系列回调—callback(value)；</u>**

- 首先，在异步事件调用 resolve(value) 时接收值；
- 随后进行状态检查，每个 Promise 只能进行一次的状态变更；
- 随后，执行由 then 存入的回调—callback(value)；
- 注意：目前 Promise 执行顺序是 new Promise -> then()收集回调 -> resolve/reject执行回调，但前提是异步任务；若为同步则会变为：new Promise -> resolve/reject执行回调 -> then() 收集回调，解决方式是为同步任务包裹 setTimeout 强行变为异步任务；
- <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200908092801.png" style="zoom:40%;" align="left" />

**<u>then 负责接收异步后的回调操作cb，存放到执行 then 的上一级 Promise 的队列中，但为了实现链式调用，需要进行包裹；</u>**

- 所以，then 必定返回一个新的 Promise 实例，以实现链式调用；
- 并且，包装异步后的回调操作cb，目的是让 resolve 触发执行队列cb时，先对cb返回值进行判断；
- 你品，你细品，如果执行完后，返回值为普通值，则调用 resolve，执行当前新的 Promise 的 then 存放的回调；
- **<u>就是，执行一开始，就将所有 then 中回调加入，只是所加入的 Promise 不同，一个 Promise 只负责一个 then 的回调，而 then 会返回下一个新的 Promise，新的 Promise 负责下一个 then 的回调存储和执行；当首个 Promise resolve 则执行 then 回调，执行完后(先有判断)通过变量搜索获取新的 Promise 的 resolve 并调用，调用新 Promise 的 then 存放的回调，如此实现链式调用；其中提到的判断是指若 then 异步回调返回 new Promise，会在此处检测到并进入此链式流程中，相当于从中插入了一条新 Promise 处理线路；</u>**
- <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200914091606.png" alt="截屏2020-09-14 上午9.16.02" style="zoom:50%;" align="left"/>
- <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200908092753.png" style="zoom:50%;" align="left" />
- 注意 then 接收的必须是 function，否则发生值穿透，其实就是直接返回，让新的 Promise resolve，执行下一个 then
- <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200908092800.png" style="zoom:50%;" align="left" />
- 其他方法的实现：
- <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200913204740.png" alt="" style="zoom:50%;" align="left"/>
- <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200913204809.png" alt="" style="zoom:50%;" align="left"/>



#### 2-1-4、Promise 使用注意

then 及 catch 方法：

- Promise 状态一经改变就不能再改变：
  - 因 resolve、reject；
- .then 和 .catch 都会返回一个新的 Promise；
  - catch 即 this.then(undefined, rejectFun)
- .catch 不管被连接到哪里，都**<u>能捕获上层未捕捉过的错误</u>**；
- Promise 中，返回任意一个非 promise 的值都会被包裹成 promise 对象，比如 return 2 会被包装为 return Promise.resolve(2)；
- Promise 的 .then 或  .catch 可以被调用多次，但若 Promise 内部的状态一经改变，并且有了一个值，则后续每次调用.then或 .catch 时都会直接拿到该值；
- .then 或 .catch 中 return 一个 error 对象并不会抛出错误，所以不会被后续的 .catch 捕获；
- .then 或 .catch 返回的值不能是 promise 本身，否则会造成死循环；
- .then 或 .catch 的参数期望是函数，传入非函数则会发生值透传；
- .then 方法是能接收两个参数的，第一个是处理成功的函数，第二个是处理失败的函数，某些时候可认为 catch 是 .then 第二个参数的简便写法；



finally 方法：

- .finally 方法不管 Promise 对象最后的状态如何都会执行
- .finally 方法的回调函数不接受任何参数，即在此函数中无法知道 Promise 最终状态是 resolved 还是 rejected
- .finally 最终返回的默认会是一个<u>**上一次的Promise对象值**</u>，不过若抛出的是一个异常则返回异常的Promise对象；
- .finally 方法也是返回一个 Promise，在 Promise 结束时，无论结果为 resolved 还是 rejected，都会执行里面的回调函数；



all 及 race 方法：

- Promise.all：作用是接收一组异步任务，然后<u>**并行执行异步任务**</u>，且在所有异步操作执行完后才执行回调；
- .race：作用同接收异步，然后**<u>并行执行异步任务</u>**，只保留取第一个执行完成的异步操作结果，其他方法仍在执行，但结果会被抛弃；
- Promise.all.then() 结果中数组的顺序和 Promise.all 接收到的数组顺序一致；
- all 和 race 传入的数组中若有会抛出异常的异步任务，则只有最先抛出的错误会被捕获，并且是被 then 的第二个参数或者后面的catch捕获；但并不会影响数组中其它的异步任务的执行；



#### 2-1-5、Generator

Generator 利用了迭代器协议，实现 next 方法(无参函数)，方法返回一含有2个属性：done & value 的对象，并利用了协程思想进行代码执行对象的切换和挂起；

**<u>Generator—生成器</u>** 是一个带 <u>星号</u> 的 "函数"(注意：但并非真正函数)，可通过  `yield` 关键字  <u>暂停执行</u> 和 <u>恢复执行</u>；其执行有这样几个关键点:

- 调用 gen() 后，程序会阻塞住，不会执行任何语句；调用 g.next() 后，程序继续执行，直到遇到 yield 程序暂停；
- next 方法 <u>返回有两个属性的对象</u>：`value` 和 `done`；
  - 前者为`当前 yield 后面的结果`；
  - 后者表示`是否执行完`，遇到`return` 后，`done` 会由`false`变为`true`；

```js
function* gen() {
  console.log("gen enter");
  let a = yield 1;
  let b = yield (function () {return 2})();
  return 3;
}
// 生成迭代器实例
// 阻塞住，不会执行任何语句
var g = gen() 

console.log(typeof g)  
// object 注意不是 "function"
// gen enter
console.log(g.next())  
// { value: 1, done: false }
console.log(g.next())  
// { value: 2, done: false }
console.log(g.next())  
// { value: 3, done: true }
console.log(g.next()) 
// { value: undefined, done: true }
```

**<u>协程</u>**：是一种比线程更加轻量级的存在，协程处在线程的环境中，<u>一个线程可存在多个协程</u>，可将协程理解为线程中的一个个任务；不像进程和线程，<u>协程并不受操作系统的管理，而是被具体的应用程序代码所控制</u>；

- 注意：JS 是单线程执行，**<u>多协程无法同时执行，一个线程一次只能执行一个协程</u>**；
- 比如：当前执行 A 协程，另外尚有 B 协程，若想执行 B 任务，则须在 A 协程中，<u>将 JS 线程控制权转交给 B协程</u>，而在 B 执行时，A 就会处于暂停状态；

```js
function* A() {
  console.log("我是A");
  yield B(); // A停住，在这里转交线程执行权给B
  console.log("结束了");
}
function B() {
  console.log("我是B");
  return 100;// 返回，并且将线程执行权还给A
}
let gen = A();
gen.next();
gen.next();

// 我是A
// 我是B
// 结束了

// A 将执行权交给 B，也就是 A 启动 B，我们也称 A 是 B 的父协程。因此 B 当中最后return 100其实是将 100 传给了父协程。
// 注意：对于协程来说，其并不受操作系统控制，完全由用户自定义切换，因此并没有进程/线程上下文切换的开销，此乃高性能的重要原因

// 示例
// 生成器调用另生成器
function* gen1() {
    yield 1;
    yield 4;
}
function* gen2() {
    yield 2;
    yield 3;
}

// 输出 1 2 3 4
function* gen1() {
    yield 1;
    yield* gen2();
    yield 4;
}
```



#### 2-1-6、Async

Async/Await 利用 `协程` 和 `Promise ` 实现同步方式编写异步代码的效果，其中 `Generator` 是对 `协程` 的一种实现，虽然语法简单，但引擎在背后做了大量的工作，用 `async/await` 写出的代码也更加优雅、美观；

- 相比于之前的 `Promise` 不断调用then的方式，语义化更加明显；

- 相比于 `co + Generator` 性能更高，上手成本也更低；

```js
async function func() {
  return 100;
}
console.log(func());
// Promise {<resolved>: 100}
```

```js
async function test() {
  console.log(100)
  let x = await 200
  // let promise = new Promise((resolve,reject) => {
  //	resolve(200);
  //  // 调用 resolve, 进入微任务队列
  //	// JS 引擎将暂停当前协程的运行，把线程的执行权交给父协程
  // })
  // 回到父协程中，父协程的第一件事情就是对 await 返回的 Promise 调用 then, 来监听这个 Promise 的状态改变
  // promise.then(value => {
  //  // 相关逻辑，在resolve 执行之后来调用
  //  // 1. 将线程的执行权交给test协程
  //  // 2. 把 value 值传递给 test 协程
	// })
  console.log(x)
  console.log(200)
}
// 首先, 代码同步执行，打印出 0，然后将 test 压入执行栈, 打印 100
console.log(0)
// 然后，遇到 await，被 JS 引擎转换成一个 Promise
test()
// 然后往下执行，打印出300。
// 根据 EvLoop 机制，当前主线程的宏任务完成，现在检查微任务队列, 发现还有一个Promise的 resolve，执行，现在父协程在then中传入的回调执
console.log(300)

// 0 100 300 200 200
```

Promise 一旦新建即立即执行则无法停止，错误需通过回调函数来捕获，而 async/await 可进行更细粒度的操作；

而 async/await 实际上是对 Generator(生成器) 的封装，是一个语法糖，为何前者盛行是因为后者刚出现不久就被前者取代；

```js
// Promise 立即执行则无法停止
Promise.resolve(a).then(b => {}).then(c => {})
// Async/await
async function test() { 
	const a = await Promise.resolve(a);
  // do something else ..
  const b = await Promise.resolve(b);
  // do something else ..
  const c = await Promise.resolve(c);
  // do something else ..
}

// testGenerator1
function* testG1() {
  yield 'hello'
  yield 'guys'
  return '!'
}

const gen1 = testG1();
console.log(gen1.next()); // {value: "hello", done: false}
console.log(gen1.next()); // {value: "guys", done: false}
console.log(gen1.next()); // {value: "!", done: true}

// testGenerator2
function* testG2() {
  console.log(yield 'hello');
  console.log(yield 'guys');
  return '!'
}

const gen2 = testG2();
gen2.next();
// value: "hello", done: false}
gen2.next('anybody');
// anybody
// {value: "guys", done: false}
gen2.next('here');
// here
// {value: "!", done: true}
gen2.next('!!!');
// {value: undefined, done: true}
```



#### 2-1-7、Async 实现

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200914113810.png" alt="截屏2020-09-14 上午11.38.05" style="zoom:50%;" align="left"/>

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200914113830.png" alt="截屏2020-09-14 上午11.38.20" style="zoom:50%;" align="left"/>



#### 2-1-8、Ajax

**<u>*Ajax—Asynchronous JS And XML*</u>** (异步的 JS 和 XML)

Ajax 是一种用于创建快速动态网页的技术；通过在后台与服务器进行少量数据交换，Ajax 可使网页实现异步更新；其最大特点也即实现局部刷新；

- 核心：**<u>*XMLHttpRequest*</u>** 对象 (老版本是ActiveXObject)，其并非单一技术实现，而是有机利用一系列交互式网页应用相关的技术所形成的结合体；

- 前身：过去使用 JS 向服务器发出 [HTTP](https://link.juejin.im/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen%2FHTTP) 请求，故需要负责此功能的类实例，此亦 <u>**XMLHttpRequest**</u> 的由来，此类最初是在 IE 中作为一个名为 **<u>XMLHTTP</u>** 的**<u>ActiveX</u>** 对象引入；然后，Mozilla、Safari、其他浏览器，实现一个 **<u>XMLHttpRequest</u>** 类，支持 Microsoft 的原始 <u>**ActiveX**</u> 对象的方法和属性，同时微软也实现了 **<u>XMLHttpRequest</u>**；浏览器实现对象：XMLHttpRequest、IE7-ActiveXObject；
- 注意：虽名称包含 XML，但实际上数据格式可由 [JSON](https://link.juejin.im/?target=https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2FJSON) 代替，以进一步减少数据量，形成所谓的 Ajaj；

Ajax 优点：

- 无刷新更新数据，用户体验好；
- 异步通信，更加快的响应能力；
- 基于标准化的并被广泛支持的技术，无需下载插件或小程序；
- 减少冗余请求，减少了带宽占用，减轻了服务器负担、场地租用成本；
- 数据与呈现分离，有利于分工合作、减少非技术人员对页面的修改造成的 WEB 应用程序错误、提高效率；

Ajax 缺点：

- 不支持浏览器回退功能和加入收藏书签功能，即破坏了浏览器后退机制；
  - 现象：在动态更新页面情况下，用户无法回到上一页面状态；
  - 解决：
    - [HTML5](https://link.juejin.im/?target=https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2FHTML5)  前可使用 [URL](https://link.juejin.im/?target=https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2FURL) 片断标识符 ([锚点](https://link.juejin.im/?target=https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2F%E9%94%9A%E7%82%B9)，即URL中#后面的部分)来保持追踪，允许用户回到指定的某个应用程序状态；
    - [HTML5](https://link.juejin.im/?target=https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2FHTML5)  后可直接操作浏览历史，并以字符串形式存储网页状态，将网页加入网页收藏夹或书签时状态会被隐形地保留；
- 存在一定的安全问题，因其暴露了与服务器交互的细节；容易受攻击：跨站点脚步攻击、SQL注入攻击和基于Credentials的安全漏洞等；
- 对搜索引擎的支持比较弱；
- 无法用URL直接访问，不易调试；



#### 2-1-9、Fetch

可理解为 Ajax 的 Promise 化，在 Ajax 基础上增加更多扩展，比如 CORS、HTTP、流程化等；

问题：因 fetch 为底层 API，故没有太多封装

- 需要自己判断返回值类型，并执行响应获取返回值的方法；

- 获取返回值方法只能调用一次，不能多次调用；

- 老版浏览器不会默认携带 cookie；

- 不能直接传递 JS 对象作为参数；

- 无法正常的捕获异常；

- 不支持超时控制；

- 不支持 jsonp；



#### 2-1-10、Axios

基本：Axios 也是对原生 XHR 的封装，是基于 promise 的 HTTP 库，它有以下几大特性，[文档](https://www.kancloud.cn/yunye/axios/234845)：

- 提供了并发请求的接口；
- 可在 Node 与浏览器中使用；
- 支持 Promise API，客户端支持防御 XSRF；
- 可拦截请求和响应、转换请求数据&响应数据、取消请求、自动转换 JSON 数据；

```js
// 1、简单使用1
axios({
    method: 'GET',
    url: url,
})
.then(res => {console.log(res)})
.catch(err => {console.log(err)})


// 2、简单使用2
axios.post('/user', {
    name: 'zxm',
    age: 18,
  })
  .then(function (response) {
    console.log(response);
  })


// 3、并发请求
function getUserAccount() {
  return axios.get('/user/12345');
}
function getUserPermissions() {
  return axios.get('/user/12345/permissions');
}
axios.all([getUserAccount(), getUserPermissions()])
  .then(axios.spread(function (acct, perms) {
  // Both requests are now complete
}));
```







### 2-2、深刻示例

#### 2-2-1、Promise

##### 2-2-1-1、基本

```js
const promise1 = new Promise((resolve, reject) => {
  console.log('promise1')
})
console.log('1', promise1);
// 'promise1'
// '1' Promise{<pending>}
// 1、new Promise 执行、执行同步代码 1，此时 promise1 没有被 resolve 或者 reject，因此状态还是 pending


// Ex2
const promise = new Promise((resolve, reject) => {
  console.log(1);
  resolve('success')
  console.log(2);
});
promise.then(() => {
  console.log(3);
});
console.log(4);
// 1 2 4 3
// 1、new Promise 执行
// 2、resolve('success')， 更改 promise 状态为 resolved 并将值保存
// 3、执行同步代码2
// 4、跳出 promise，往下执行，碰到 promise.then 微任务，将其加入微任务队列
// 5、执行同步代码 4
// 6、本轮宏任务全部执行完毕，检查微任务队列，发现 promise.then 这个微任务且状态为 resolved，执行它。



// Ex3
const promise = new Promise((resolve, reject) => {
  console.log(1);
  console.log(2);
});
promise.then(() => {
  console.log(3);
});
console.log(4);
// 1 2 4
// 1、在 promise 中并没有 resolve 或 reject 因此 promise.then 并不会执行，它只有在被改变了状态之后才会执行



// Ex4
const promise1 = new Promise((resolve, reject) => {
  console.log('promise1')
  resolve('resolve1')
})
const promise2 = promise1.then(res => {
  console.log(res)
})
console.log('1', promise1);
console.log('2', promise2);
// 'promise1'
// '1' Promise{<resolved>: 'resolve1'}
// '2' Promise{<pending>}
// 'resolve1'

// 1、new Promise，执行
// 2、resolve 状态改变为 resolved, 并将结果保存下来
// 3、promise1.then 微任务，将它放入微任务队列
// 4、promise2 是一个新的状态为 pending 的Promise
// 5、执行同步代码1，同时打印出 promise1 状态 resolved
// 6、执行同步代码2，同时打印出 promise2 状态 pending
// 7、宏任务执行完毕，查找微任务队列，发现 promise1.then 且状态为 resolved，执行它


// Ex5
const fn = () => (new Promise((resolve, reject) => {
  console.log(1);
  resolve('success')
}))
fn().then(res => {
  console.log(res)
})
console.log('start')
// 1
// 'start'
// 'success'


// Ex6
const fn = () =>
  new Promise((resolve, reject) => {
    console.log(1);
    resolve("success");
  });
console.log("start");
fn().then(res => {
  console.log(res);
});
// 'start'
// 1
// 'success'
```



##### 2-2-1-2、基本 + setTimeout

```js
console.log('start')
setTimeout(() => {
  console.log('time')
})
Promise.resolve().then(() => {
  console.log('resolve')
})
console.log('end')
// 'start'
// 'end'
// 'resolve'
// 'time'

// 1、同步代码直接压入执行栈进行执行
// 2、setTimout 作为一个宏任务被放入下一个宏任务队列
// 3、Promise.then 作为一个微任务被放入微任务队列
// 4、本次宏任务执行完，检查微任务，发现 Promise.then，执行
// 5、进入下一个宏任务，发现 setTimeout，执行


// Ex2
const promise = new Promise((resolve, reject) => {
  console.log(1);
  setTimeout(() => {
    console.log("timerStart");
    resolve("success");
    console.log("timerEnd");
  }, 0);
  console.log(2);
});
promise.then((res) => {
  console.log(res);
});
console.log(4);
// 1 2 4 timeStart timerEnd success

// 1、new Promise，执行
// 2、定时器，存入下一个宏任务的延迟队列中等待执行
// 3、执行同步代码2
// 4、跳出 promise 函数，遇到 promise.then，但其状态还是为 pending，理解为先不执行
// 5、执行同步代码4
// 6、一轮循环过后，进入二次宏任务，发现延迟队列中有 setTimeout 定时器，执行它
// 7、resolve，将 promise 状态改为 resolved 且保存结果，并将之前的 promise.then 推入微任务队列(???这里才加入么???)
// 8、继续执行同步代码 timerEnd
// 9、宏任务全部执行完毕，查找微任务队列，发现 promise.then 微任务，执行它

// Ex3-1
setTimeout(() => {
  console.log('timer1');
  setTimeout(() => {
    console.log('timer3')
  }, 0)
}, 0)
setTimeout(() => {
  console.log('timer2')
}, 0)
console.log('start')
// start timer1 timer2 timer3

// Ex3-2
setTimeout(() => {
  console.log('timer1');
  Promise.resolve().then(() => {
    console.log('promise')
  })
}, 0)
setTimeout(() => {
  console.log('timer2')
}, 0)
console.log('start')
// start timer1 timer2 promise

// Ex3-3
Promise.resolve().then(() => {
  console.log('promise1');
  const timer2 = setTimeout(() => {
    console.log('timer2')
  }, 0)
});
const timer1 = setTimeout(() => {
  console.log('timer1')
  Promise.resolve().then(() => {
    console.log('promise2')
  })
}, 0)
console.log('start');
// start promise1 timer1 promise2 timer2



// Ex4
const promise1 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('success')
  }, 1000)
})
const promise2 = promise1.then(() => {
  throw new Error('error!!!')
})
console.log('promise1', promise1)
console.log('promise2', promise2)
setTimeout(() => {
  console.log('promise1', promise1)
  console.log('promise2', promise2)
}, 2000)
// 'promise1' Promise{<pending>}
// 'promise2' Promise{<pending>}
// test5.html:102 Uncaught (in promise) Error: error!!! at test.html:102
// 'promise1' Promise{<resolved>: "success"}
// 'promise2' Promise{<rejected>: Error: error!!!}



// Ex5 - 注意 resolve/reject 后才会执行 then
const promise1 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve("success");
    console.log("timer1");
  }, 1000);
  console.log("promise1 ok");
});
const promise2 = promise1.then(() => {
  throw new Error("error!!!");
});
console.log("promise1", promise1);
console.log("promise2", promise2);
setTimeout(() => {
  console.log("timer2");
  console.log("promise1", promise1);
  console.log("promise2", promise2);
}, 2000);
// promise1 ok
// 'promise1' Promise{<pending>}
// 'promise2' Promise{<pending>}
// timer1
// test5.html:102 Uncaught (in promise) Error: error!!! at test.html:102
// timer2
// 'promise1' Promise{<resolved>: "success"}
// 'promise2' Promise{<rejected>: Error: error!!!}
```

##### 2-2-1-3、基本 + then/catch/finally

1. `Promise` 状态一经改变就不能再改变；
   1. `Promise` 的 `.then` 或 `.catch` 可被调用多次, 当若 `Promise `内部状态一经改变，且有一个值，则后续每次调用 `.then` 或 `.catch` 时都会直接拿到该值；
2. `.then` 和 `.catch` 都会返回一新 `Promise`
   1. `Promise`  中，返回任意一个非 `promise`  值都会被包裹成 `promise` 对象，比如 `return 2`  会被包装为 `return Promise.resolve(2)`；
   2. `.then` 或 `.catch` 中 `return` 一个 `error` 对象并不会抛出错误，故不会被后续的 `.catch` 捕获；
   3. `.then` 或 `.catch` 返回值不能是 promise 本身，否则会造成死循环；
   4. `.then` 或 `.catch` 参数期望是函数，传入非函数则会发生值透传；
3. `catch ` 不管被连接到哪里，都能捕获上层的错误；
4. `.then` 能接收两个参数，第一个是处理成功的函数，第二个是处理失败的函数，某些时候可认为 `catch` 是 `.then` 第二个参数的简便写法；
5. `.finally` 返回一个 `Promise`，在  `Promise` 结束时，无论结果为  `resolved` 还是  `rejected`(无论状态如何均为执行)，都会执行里面的回调函数；也正因如此，finally 回调函数不接受任何的参数，即在 `.finally()` 函数中无法知道 `Promise` 最终状态；其最终返回的默认会是一个<u>上一次的 Promise 对象值</u>，不过如果抛出的是一个异常则返回异常的`Promise`对象；
6. `.finally` 报错方式有二且各自归属不同方法，`return new Error` 归属 then，throw new Error 归属 catch，两者同时存在时，后者覆盖前者;
7. `.finally` 行为与 `.then` 一致，只是执行行为存在不同 (本质上是 then 方法的特例)；

```js
Promise.prototype.finally = function (callback) {
  let P = this.constructor
  return this.then(
    value  => P.resolve(callback()).then(() => value),
    reason => P.resolve(callback()).then(() => { throw reason })
  )
}
```

```js
const promise = new Promise((resolve, reject) => {
  resolve("success1");
  reject("error");
  resolve("success2");
});
promise
.then(res => {
	console.log("then: ", res);
}).catch(err => {
	console.log("catch: ", err);
})
// "then: success1"


// Ex2 - catch() 也会返回一个 Promise，且由于这个 Promise 没有返回值，所以打印出来的是 undefined
const promise = new Promise((resolve, reject) => {
  reject("error");
  resolve("success2");
});
promise.then(res => {
  console.log("then1: ", res);
}).then(res => {
  console.log("then2: ", res);
}).catch(err => {
  console.log("catch: ", err);
}).then(res => {
  console.log("then3: ", res);
})
// "catch: " "error"
// "then3: " undefined



// Ex3 - return 2 会被包装成 resolve(2)
Promise.resolve(1).then(res => {
  console.log(res);
  return 2;
})
  .catch(err => {
  return 3;
})
  .then(res => {
  console.log(res);
});
// 1 2

// Ex3-1
Promise.reject(1)
  .then(res => {
  console.log(res);
  return 2;
})
  .catch(err => {
  console.log(err);
  return 3
})
  .then(res => {
  console.log(res);
});
// 1 3



// Ex4 - .then 或者 .catch 可以被调用多次，但 Promise 构造函数只执行一次
const promise = new Promise((resolve, reject) => {
  setTimeout(() => {
    console.log('timer')
    resolve('success')
  }, 1000)
})
const start = Date.now();
promise.then(res => {
  console.log(res, Date.now() - start)
})
promise.then(res => {
  console.log(res, Date.now() - start)
})
// 'timer'
// success 1001
// success 100x/1001 - 前提 - 足够快




// Ex5 - 非 promise 的值都会被包裹成 promise 对象
// 因此 return new Error('error!!!') 也被包裹成了 return Promise.resolve(new Error('error!!!'))
Promise.resolve().then(() => {
  return new Error('error!!!')
}).then(res => {
  console.log("then: ", res)
}).catch(err => {
  console.log("catch: ", err)
})
// "then: " "Error: error!!!"
// 注意：若想抛出错误请:
// return Promise.reject(new Error('error!!!'));
// or
// throw new Error('error!!!')



// Ex7 - .then 或 .catch 返回的值不能是 promise 本身，否则会造成死循环
const promise = Promise.resolve().then(() => {
  return promise;
})
promise.catch(console.err)
// Uncaught (in promise) TypeError: Chaining cycle detected for promise #<Promise>



// Ex8 - .then 或者 .catch 的参数期望是函数，传入非函数则会发生值透传
// 一个是数字类型，一个是对象类型，因此发生了透传，将resolve(1) 的值直接传到最后一个then里
Promise.resolve(1)
  .then(2)
  .then(Promise.resolve(3))
  .then(console.log)
// 1



// Ex9
Promise.reject('err!!!')
  .then((res) => {
    console.log('success', res)
  }, (err) => {
    console.log('error', err)
  }).catch(err => {
    console.log('catch', err)
  })
// 'error' 'error!!!' 
// 如果去掉第二函数，则进入 catch: 'catch' 'error!!!'

// Ex9-1
Promise.resolve()
  .then(function success (res) {
    throw new Error('error!!!')
  }, function fail1 (err) {
    console.log('fail1', err)
  }).catch(function fail2 (err) {
    console.log('fail2', err)
  })
// fail2 Error: error!!!    at success (<anonymous>:3:11)




// Ex10
Promise.resolve('1')
  .then(res => {
    console.log(res)
  })
  .finally(() => {
    console.log('finally')
  })
Promise.resolve('2')
  .finally(() => {
    console.log('finally2')
  	return '我是finally2返回的值'
  })
  .then(res => {
    console.log('finally2后面的then函数', res)
  })



// Ex11 - return 的报错方式会被 then 捕获
Promise.resolve('1')
  .finally(() => {
    console.log('finally2')
    return new Error('finally return error')
  })
  .then(res => {
    console.log('then catch: ', res)
  })
  .catch(err => {
    console.log('catch catch: ', err)
  })
// finally2
// then catch 1

// Ex11 - 1 - throw 报错方式会被 catch 捕获
Promise.resolve('1')
  .finally(() => {
    console.log('finally1')
    throw new Error('finally throw error')
  })
  .then(res => {
    console.log('then catch: ', res)
  })
  .catch(err => {
    console.log('catch catch: ', err)
  })
// finally1
// catch catch Error finally throw error


// Ex11 - 2 - 两种报错方式同在则还是会被 catch 捕获
Promise.resolve('1')
  .finally(() => {
    console.log('finally1')
    throw new Error('finally throw error')
  })
  .finally(() => {
    console.log('finally2')
    return new Error('finally return error')
  })
  .then(res => {
    console.log('then catch: ', res)
  })
  .catch(err => {
    console.log('catch catch: ', err)
  })
// finally1
// finally2
// catch catch Error finally throw error

// Ex11 - 2 - 两种报错方式同在则还是会被 catch 捕获，不管顺序
Promise.resolve('1')
  .finally(() => {
    console.log('finally2')
    return new Error('finally return error')
  })
  .finally(() => {
    console.log('finally1')
    throw new Error('finally throw error')
  })
  .then(res => {
    console.log('then catch: ', res)
  })
  .catch(err => {
    console.log('catch catch: ', err)
  })
// finally2
// finally1
// catch catch Error finally throw error



// Ex12
// 1、最终返回的默认会是一个上一次的 Promise 对象值，不过如果抛出的是一个异常则返回异常的 Promise 对象
// 2、.finally() 方法不管 Promise 对象最后的状态如何都会执行
// 3、.finally() 方法的回调函数不接受任何的参数，也即在 .finally() 函数中无法得知 Promise 最终状态
// 4、关于 finally2 为何先执行，看 Ex13 系列, 实际上是关于微任务的添加顺序，
Promise.resolve('1')
  .then(res => {
    console.log(res)
  })
  .finally(() => {
    console.log('finally')
  })
Promise.resolve('2')
  .finally(() => {
    console.log('finally2')
  	return 'finally2 return'
  })
  .then(res => {
    console.log('finally2 then', res)
  }
// '1'
// 'finally2'
// 'finally'
// 'finally2 then' '2'
        
        
// Ex13 - 1
function promise1 () {
  return new Promise((resolve) => {
    resolve('p1')
  })
}
function promise2 () {
  return new Promise((resolve, reject) => {
   	resolve('p2')
  })
}
promise1()
  .then(res => console.log(res + ' p1t1'))
  .then(res => console.log(res + ' p1t2'))
  .catch(err => console.log(err + ' p1e1'))
  .finally(() => console.log('finally1'))
  .then(res => console.log(res + ' p1t3'))
promise2()
  .then(res => console.log(res + ' p2t1'))
  .then(res => console.log(res + ' p2t2'))
  .catch(err => console.log(err + ' p2e1'))
  .finally(() => console.log('finally2'))
  .then(res => console.log(res + ' p2t3'))
// p1 p1t1
// p2 p2t1
// undefined p1t2
// undefined p2t2
// finally1
// finally2
// undefined p1t3
// undefined p2t3
```



##### 2-2-1-4、基本 + all/race

- `Promise.all()`的作用是接收一组异步任务，然后并行执行异步任务，并且在所有异步操作执行完后才执行回调；
- `.race()` 作用也是接收一组异步任务，然后并行执行异步任务，只保留取第一个执行完成的异步操作的结果，其他的方法仍在执行，不过执行结果会被抛弃；
- `Promise.all().then()` 结果中数组的顺序和 `Promise.all()` 接收到的数组顺序一致；

```js
// all
// 立即执行
const p1 = new Promise(r => console.log('立即打印'))

// 函数包裹控制执行
var runP1 = () => new Promise(r => console.log('立即打印')
runP1()

// all 并发执行，全部执行完毕才返回
var runAsync = (x) => new Promise(r => setTimeout(() => r(x, console.log(x)), 1000 * x));
Promise.all([runAsync(1), runAsync(2), runAsync(3)]).then(res => console.log(res))

// all .catch 会捕获最先的那个异常 - 懵逼 - all/race 用法
var runReject = (x) => new Promise((res, rej) => setTimeout(() => rej(`Error: ${x}`, console.log(x)), 1000 * x));
Promise.all([runAsync(1), runReject(4), runAsync(3), runReject(2)])
  .then(res => console.log(res))
  .catch(err => console.log(err))
// 1 3 2s后输出: 2Error: 2  4s后输出: 4





// race
Promise.race([runAsync(1), runAsync(2), runAsync(3)])
  .then(res => console.log('result: ', res))
  .catch(err => console.log(err))
// 1 
// 'result: ' 
// 1 
// 2 
// 3
Promise.race([runReject(0), runAsync(1), runAsync(2), runAsync(3)])
  .then(res => console.log("result: ", res))
  .catch(err => console.log(err));
// 0 'Error: 0'
// 1
// 2
// 3
```



#### 2-2-2、Async/Await 相关

```js
// Ex1 - 可理解为 await 后面的内容就相当于放到了 Promise.then 中
async function async1() {
  console.log("async1 start");
  await async2();
  console.log("async1 end");
}
async function async2() {
  console.log("async2");
}
async1();
console.log('start')
// 'async1 start'
// 'async2'
// 'start'
// 'async1 end'


// Ex2
async function async1() {
  console.log("async1 start");
  new Promise(resolve => {
    console.log('promise')
  })
  console.log("async1 end");
}
async1();
console.log("start")
// 'async start'
// 'promise'
// 'async1 end'
// 'start'


// Ex3
async function async1() {
  console.log("async1 start");
  await async2();
  console.log("async1 end");
}
async function async2() {
  setTimeout(() => {
    console.log('timer')
  }, 0)
  console.log("async2");
}
async1();
console.log("start")
// 'async1 start'
// 'async2'
// 'start'
// 'async1 end'
// 'timer'




// Ex4
async function async1() {
  console.log("async1 start");
  await async2();
  console.log("async1 end");
  setTimeout(() => {
    console.log('timer1')
  }, 0)
}
async function async2() {
  setTimeout(() => {
    console.log('timer2')
  }, 0)
  console.log("async2");
}
async1();
setTimeout(() => {
  console.log('timer3')
}, 0)
console.log("start")
// 'async1 start'
// 'async2'
// 'start'
// 'async1 end'
// 'timer2'
// 'timer3'
// 'timer1'



// Ex5 - async 中的 await 命令是一个 Promise 对象，返回该对象的结果,
// 但若非 Promise 对象，就会直接返回对应的值，相当于 Promise.resolve()
async function fn () {
  // return await 1234
  // 等同于
  return 123
}
fn().then(res => console.log(res))



// Ex6 - async1 中 await 后面的 Promise 是没有返回值的，也就是它的状态始终是 pending 状态，因此相当于一直在 await
async function async1 () {
  console.log('async1 start');
  await new Promise(resolve => {
    console.log('promise1')
  })
  console.log('async1 success');
  return 'async1 end'
}
console.log('srcipt start')
async1().then(res => console.log(res))
console.log('srcipt end')
// 'script start'
// 'async1 start'
// 'promise1'
// 'script end'

// Ex6-1 - 有了返回值，await 后面的内容将会被执行
async function async1 () {
  console.log('async1 start');
  await new Promise(resolve => {
    console.log('promise1')
    resolve('promise1 resolve')
  }).then(res => console.log(res))
  console.log('async1 success');
  return 'async1 end'
}
console.log('srcipt start')
async1().then(res => console.log(res))
console.log('srcipt end')
// 'script start'
// 'async1 start'
// 'promise1'
// 'script end'
// 'promise1 resolve'
// 'async1 success'
// 'async1 end'



// Ex7
async function async1 () {
  console.log('async1 start');
  await new Promise(resolve => {
    console.log('promise1')
    resolve('promise resolve')
  })
  console.log('async1 success');
  return 'async1 end'
}
console.log('srcipt start')
async1().then(res => {
  console.log(res)
})
new Promise(resolve => {
  console.log('promise2')
  setTimeout(() => {
    console.log('timer')
  })
})
// 'script start'
// 'async1 start'
// 'promise1'
// 'promise2'
// 'async1 success'
// 'sync1 end'
// 'timer'



// EX8
async function async1() {
  console.log("async1 start");
  await async2();
  console.log("async1 end");
}
async function async2() {
  console.log("async2");
}
console.log("script start");
setTimeout(function() {
  console.log("setTimeout");
}, 0);
async1();
new Promise(function(resolve) {
  console.log("promise1");
  resolve();
}).then(function() {
  console.log("promise2");
});
console.log('script end')
// ss async1-start async2 promise1 se async-end promise2 se




// Ex9
async function testSometing() {
  console.log("执行testSometing");
  return "testSometing";
}

async function testAsync() {
  console.log("执行testAsync");
  return Promise.resolve("hello async");
}

async function test() {
  console.log("test start...");
  const v1 = await testSometing();
  console.log(v1);
  const v2 = await testAsync();
  console.log(v2);
  console.log(v1, v2);
}

test();

var promise = new Promise(resolve => {
  console.log("promise start...");
  resolve("promise");
});
promise.then(val => console.log(val));

console.log("test end...");
// 'test start...'
// '执行testSometing'
// 'promise start...'
// 'test end...'
// 'testSometing'
// '执行testAsync'
// 'promise'
// 'hello async'
// 'testSometing' 'hello async'





// Ex10 - 若在 async 函数中抛出了错误，则终止错误结果，不会继续向下执行
async function async1 () {
  await async2();
  console.log('async1');
  return 'async1 success'
}
async function async2 () {
  return new Promise((resolve, reject) => {
    console.log('async2')
    reject('error')
  })
}
async1().then(res => console.log(res))
// 'async2'
// Uncaught (in promise) error


// Ex10 - 1 - 改为 throw new Error 也是一样
async function async1 () {
  console.log('async1');
  throw new Error('error!!!')
  return 'async1 success'
}
async1().then(res => console.log(res))
// 'async1'
// Uncaught (in promise) Error: error!!!



// Ex11 - 针对上述问题，可用 try-catch 不影响后续执行
async function async1 () {
  try {
    await Promise.reject('error!!!')
  } catch(e) {
    console.log(e)
  }
  console.log('async1');
  return Promise.resolve('async1 success')
}
async1().then(res => console.log(res))
console.log('script start')
// 'script start'
// 'error!!!'
// 'async1'
// 'async1 success'

// 或直接在 Promise.reject 后面跟着一个 catch() 方法
async function async1 () {
  // try {
  //   await Promise.reject('error!!!')
  // } catch(e) {
  //   console.log(e)
  // }
  await Promise.reject('error!!!')
    .catch(e => console.log(e))
  console.log('async1');
  return Promise.resolve('async1 success')
}
async1().then(res => console.log(res))
console.log('script start')
// 'script start'
// 'error!!!'
// 'async1'
// 'async1 success'
```



#### 2-2-X、综合题

```js
// Ex1
const first = () => (new Promise((resolve, reject) => {
    console.log(3);
    let p = new Promise((resolve, reject) => {
        console.log(7);
        setTimeout(() => {
            console.log(5);
            resolve(6);
            console.log(p)
        }, 0)
        resolve(1);
    });
    resolve(2);
    p.then((arg) => {
        console.log(arg);
    });
}));
first().then((arg) => {
    console.log(arg);
});
console.log(4);
// 3 7 4 1 2 5 Promise{<resolved>: 1}



// Ex2
// async 函数中 await 的 new Promise 要是没有返回值的话则不执行后面的内容
// .then 函数中的参数期待的是函数，如果不是函数的话会发生透传
// 注意定时器的延迟时间
const async1 = async () => {
  console.log('async1');
  setTimeout(() => {
    console.log('timer1')
  }, 2000)
  await new Promise(resolve => {
    console.log('promise1')
  })
  console.log('async1 end')
  return 'async1 success'
} 
console.log('script start');
async1().then(res => console.log(res));
console.log('script end');
Promise.resolve(1)
  .then(2)
  .then(Promise.resolve(3))
  .catch(4)
  .then(res => console.log(res))
setTimeout(() => {
  console.log('timer2')
}, 1000)
// 'script start'
// 'async1'
// 'promise1'
// 'script end'
// 1
// 'timer2'
// 'timer1'




// Ex3
// Promise 状态一旦改变就无法改变
// finally 不管 Promise的状态是 resolved 还是 rejected 都会执行，且它的回调函数是接收不到 Promise 结果，所以 finally() 中的 res 是一个迷惑项
// 最后一个定时器打印出的 p1 其实是 .finally 返回值，.finally 返回值如果在没有抛出错误的情况下默认会是上一个 Promise 返回值, 而这道题中 .finally 上一个 Promise 是 .then()，但这个 .then() 并无返回值，故 p1 打印出来的 Promise 值是 undefined，若在定时器的下面加上一个 return 1，则值就会变成1
const p1 = new Promise((resolve) => {
  setTimeout(() => {
    resolve('resolve3');
    console.log('timer1')
  }, 0)
  resolve('resovle1');
  resolve('resolve2');
}).then(res => {
  console.log(res)
  setTimeout(() => {
    console.log(p1)
  }, 1000)
}).finally(res => {
  console.log('finally', res)
})
// 'resolve1'
// 'finally' undefined
// 'timer1'
// Promise{<resolved>: undefined}
```





#### 2-2-Y、面试相关题

##### 2-2-Y-1、红绿灯闪烁

红灯3秒亮一次，黄灯2秒亮一次，绿灯1秒亮一次；如何让三个灯不断交替重复亮灯

```js
function red() {
  console.log("red");
}
function green() {
  console.log("green");
}
function yellow() {
  console.log("yellow");
}
const light = function (timer, cb) {
  return new Promise(resolve => {
    setTimeout(() => {
      cb()
      resolve()
    }, timer)
  })
}
const step = function () {
  Promise.resolve().then(() => {
    return light(3000, red)
  }).then(() => {
    return light(2000, green)
  }).then(() => {
    return light(1000, yellow)
  }).then(() => {
    return step()
  })
}

step();
```



##### 2-2-Y-2、实现 mergePromise

实现 mergePromise 函数，把传进去的数组按顺序先后执行，并且把返回的数据先后放到数组 data 中

```js
// 将零碎合整，化为链式调用
const time = (timer) => {
  return new Promise(resolve => {
    setTimeout(() => {
      resolve()
    }, timer)
  })
}
const ajax1 = () => time(2000).then(() => {
  console.log(1);
  return 1
})
const ajax2 = () => time(1000).then(() => {
  console.log(2);
  return 2
})
const ajax3 = () => time(1000).then(() => {
  console.log(3);
  return 3
})

function mergePromise (ajaxArray) {
  // 存放每个ajax的结果
  const data = [];
  let promise = Promise.resolve();
  ajaxArray.forEach(ajax => {
  	// 第一次的then为了用来调用ajax
  	// 第二次的then是为了获取ajax的结果
    promise = promise.then(ajax).then(res => {
      data.push(res);
      return data; // 把每次的结果返回
    })
  })
  // 最后得到的promise它的值就是data
  return promise;
}

mergePromise([ajax1, ajax2, ajax3]).then(data => {
  console.log("done");
  console.log(data); // data 为 [1, 2, 3]
});

// 要求分别输出
// 1
// 2
// 3
// done
// [1, 2, 3]
```





