# 二、编程分类

面向对象编程——OOP：

- 定义：把构成问题事务分解成单或多个对象，但分拆成对象并非为了完成某一步骤，而是为了描述某个事物在整个解决问题的步骤中的行为；
- 示例：Eat(Dog，Apple)；
- 示例：Refrigerator.open() —> Refrigerator.load(thing) —> Refrigerator.close()；
- 优点：具有良好的可移植性和可扩展性；
- 缺点：掌握难，容易偏向为面向过程；
- 特性：多态、封装、继承

面向过程编程——POP：

- 定义：分析出解决问题所需步骤，然后用方法将各个步骤逐一实现，使用时依次调用；
- 示例：Dog.eat(apple)；
- 示例：Open(Refrigerator) —> Load(Refrigerator，thing) —> Close(Refrigerator)；
- 优点：同步思维开发；
- 缺点：牵一发而动全身，移植性和可扩展性差；

面向组件编程——COP：(暂略)；

面向方面编程——AOP：(暂略)；

面向服务编程——SOP：(暂略)；



# 二-1、多态

基本：根据传入参数的个数不同，调用相应的方法

JS 是弱类型，不存在编译时要确定类型，天然支持多态。



# 二-2、封装

含义：将客观事物封装成抽象的类，隐藏属性和方法的实现细节，仅对外公开接口(可见性控制)；此点 JS 可通过闭包实现；

ES6 class 为语法糖，在此之前没有类概念(实际上 JS 没有类，只是模拟行为)，均借助于：原型对象、构造函数来实现；

- 私有属性/方法：只能在构造函数内访问不能被外部所访问：在构造函数内使用 var 等声明的属性/方法；
- 公有属性/方法(或实例方法)：对象外可访问到对象内的属性和方法：在构造函数内使用 this 设置，或设置在构造函数原型 prototype 对象上；
- 静态属性/方法：定义在构造函数上的方法，无需实例即可调用；

使用 `for...in...` 能获取到实例对象自身的属性和原型链上的属性(可枚举属性)；

使用 `Object.keys()` 和 `Object.getOwnPropertyNames() `只能获取实例对象自身属性(可枚举属性)；

使用 `Object.hasOwnProperty()` 方法传入属性名来判断某属性是不是实例自身属性(可枚举属性)；

- 注意：类不会提升(不像普通变量和函数)，注意报错

  - ```js
    var a = new A()
    function A () {}
    console.log(a)
    // A{}
    
    var b = new B()
    class B {}
    console.log(b)
    // Uncaught ReferenceError: Cannot access 'B' before initialization
    ```

- 注意：constructor 的 var 等声明变量为私有变量不可获取

  - ```js
    class TLP {
      constructor () {
        var type = 'fykms'
        this.name = 'tlp'
      }
      type = 'old man'
      getType = function () {
        console.log(this.type)
        console.log(type)
      }
    }
    var type = 'window'
    var tlp = new TLP()
    tlp.getType()
    // old man
    // window
    ```

- 注意：类中箭头函数转为 ES5 时，仍作为一个函数处理，只是处理后仍为箭头函数，保留箭头函数特性；

- 注意：若同名变量则以 constructor 为优先(优先是因为Babel转译顺序导致)，原因看Babel 转译结果

- <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909091213.png" style="zoom:50%;" />

  







# 二-3、继承

将属性和方法组装成一个类的过程(私有化变量和方法 (通过 this 创建的属性视作为共有变量，而通过 <u>闭包</u> 还可实现对私有变量的访问))；

- 问题1：JS 中没有类概念；
- 解决2：可通过作用域的变量访问限制，以模拟类实现，比如：构造函数、`Object.create()`、点语法；
  - 方法1：<u>通过构造函数添加类</u>：在函数中创建 this 相关属性和方法，再通过 new 生成实例和绑定 this，例略；
    - 好处：实例间相互独立，不受影响；
    - 坏处：好处即坏处，通过 this 定义的属性或方法，每次实例化都复制一份，内存消耗大、复杂、可读性；
  - 方法2：<u>通过原型添加类</u>：基于 `实例.__proto__` 指向 函数原型，从而使用原型上的方法；
    - 好处：原型链上的属性和方法只需建立一次;
    - 坏处：原型链上的属性和方法为全体实例共用，若链上的属性是引用类型则会被改变(而链上的方法铁定会改变)，不能实现私有属性和私有方法；
  - 方法3：<u>通过点语法</u>：在构造函数身上通过点语法增加属性或方法；
    - 好处：仅创建一次；
    - 坏处：显而易见，实例无法访问，仅能用过自身访问；
- 问题2：JS没有 `private public protected` 关键字；
- 解决2：可通过作用域的变量访问限制，来模拟此类关键字：图1
  - Public：对所有用户开放，均可直接调用；
  - Private：自身属性或方法，仅自身能直接访问；
  - Protected：自身实例可访问，外部类不可访问；

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909091214.png" style="zoom:50%;" align="" />

- 总结：JS 很容易模拟一个类，并且可以一定程度上做到面向对象中的三大特性：封装、继承、多态；
- 所以，从最初去模拟一个类，到 ES5 提供更便捷的原型操控API，到 ES6 中提供更多类相关的关键字，都是在帮助开发者减小 JS 中面向对象的使用成本；
- 虽然，JS 中的继承并非真正"继承"，类也不是真正的"类"，相比 Java 肯定还有很多实现不了的地方；
  - 比如，abstract class、Interface 等，只能通过一些 tricky 的办法去模拟；
- 因此 JS 中所谓的继承，是为方便程序员用面向对象的方式来组织代码；





<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909091215.png" style="zoom:50%;" align="" />



## 2-2、构造函数的继承

### 2-2-1、原型链继承

基本：构造函数、原型、实例间关系：每个 <u>构造函数</u> 都有一 <u>原型</u> 对象，<u>原型</u> 对象都包含一指向 <u>构造函数</u> 的指针，而 <u>实例</u> 都包含一 <u>原型对象</u> 的指针；

关键：`子类.prototype = new 父类();  子类.prototype.constructor = 子类;`

原理：直接让子类原型对象指向父类实例，当子类实例找不到相应属性和方法时，就会往其原型对象，也即父类实例上找，从而实现对父类属性和方法的继承；

注意：但凡对 prototype 作赋值操作，均需重新将 prototype.constructor 修正为子类；因 子类.constructor 属性默认调用 prototype 对象 constructor 属性；

```js
// 父类
function Parent() {
    this.name = '特朗普'
}
// 父类原型方法
Parent.prototype.getName = function() {
    return this.name
}
// 子类
function Child() {}

// 让子类的原型对象指向父类实例, 这样一来在 Child 实例中找不到的属性和方法就会到原型对象(父类实例)上寻找
Child.prototype = new Parent()
// 根据原型链的规则, 顺便绑定一下 constructor, 这一步不影响继承, 只是在用到 constructor 时会需要
// 帮助修复 子类实例的构造函数错误指向
Child.prototype.constructor = Child 

// 然后 Child 实例就能访问到父类及其原型上的 name 属性和 getName() 方法
const child = new Child()
child.name          // '特朗普'
child.getName()     // '特朗普'
```

优点：可使用父类方法；

缺点：

- 因直接 `子类.prototype = new 父类`，故会覆盖 `子类.prototype` 原有属性 (不解释)；

- 父类的引用属性会被所有子类实例共享，多个实例对引用类型的操作会相互影响；

  - 解释：由于所有子类实例原型都指向同一个父类实例，故对某个子类实例的父类引用类型变量修改会影响所有子类实例 (因为是多对一关系)

- 子类构建实例时不能向父类传递参数，即没有实现 `super()` 的功能 (你™怎么传参，子类与父类的关系纽带就靠 prototype 维系，无关构造)

  - ```js
    // Ex1:
    function Parent() {
        this.name = ['特朗普'] 
    }
    Parent.prototype.getName = function() {
        return this.name
    }
    function Child() {}
    Child.prototype = new Parent()
    Child.prototype.constructor = Child 
    
    // 测试
    const child1 = new Child()
    const child2 = new Child()
    child1.name[0] = 'foo'
    console.log(child1.name)  // ['foo']
    console.log(child2.name)  // ['foo'] (预期是['特朗普'], 对 child1.name 的修改引起了所有 child 实例的变化)
    ```

    



### 2-2-2、构造函数继承

基本：使用父类的构造函数来增强子类实例，等同于复制父类的实例给子类(不使用原型)

关键： 在子类函数中执行：`父类函数.apply/call(this, arguments/…arguments);`

原理：即在子类的构造函数中执行父类的构造函数，并为其绑定子类的 `this`，让父类的构造函数将成员属性和方法，都挂到 `子类的this`上去，避免原型继承中，实例间共享同一原型实例问题，此外还能向父类构造方法传参；

```js
function Parent(name) {
    this.name = [name]
}
Parent.prototype.getName = function() {
    return this.name
}
function Child(...args) {
  	console.log(this);
  	this.name = ['child']			// 执行 call 后被覆盖
    Parent.call(this, args)   // 执行父类构造方法并绑定子类的 this, 使得父类中的属性能够赋到子类的 this 上
  	console.log(this);
}

// 传参测试
const child1 = new Child('test1')
const child2 = new Child('test2')
// 共享测试
child1.name[0] = 'foo'
console.log(child1.name)          // ['foo'] 
console.log(child2.name)          // ['test2']
// 原型链继承测试
child2.getName()                  // Error, 找不到 getName(), 无法继承父类原型上的属性和方法，因为只是单纯的在子类执行，获取父类构造中的方法和属性
```

优点：与原型链继承相反

- 父类的引用属性不会被共享；
- 子类构建实例时可向父类传递参数；

缺点：

- 只能继承父类的实例属性和方法，不能继承原型属性/方法 (因为只是单纯的在子类执行，获取父类构造中的方法和属性)；
- 无法实现复用，每个子类都有父类实例函数的副本，影响性能 (无法复用是因为父类原型链上属性方法子类完全无法用到)；



### 2-2-3、组合式继承

基本：即组合上述两种方法，借用原型链实现对**原型**属性和方法的继承，借用构造函数技术来实现**实例**属性的继承；

原理：原型链继承和构造函数继承各有互补的优缺点，合体为组合式继承；

注意：但凡对 prototype 作赋值操作，均需重新将 prototype.constructor 修正为子类；因 子类.constructor 属性默认调用 prototype 对象 constructor 属性；

```js
function Parent(name) {
    this.name = [name];
  	this.play = [1, 2, 3];
}
Parent.prototype.getName = function() {
    return this.name
}
function Child(name, age) {
    // 1、构造函数的继承 复制父类构造属性方法给子类实例 - 第二次调用 Parent
    Parent.call(this, name);
  	this.age = age;
}
// 2、原型链的继承 - 第一次调用 Parent
Child.prototype = new Parent()
// 因上一句的关系，故须将指向修正为原本态: 指向自身构造函数, 否则指向的是 Parent
Child.prototype.constructor = Child
Child.prototype.getAge = function() {
    return this.age
}

// 传参测试
const child1 = new Child('TPP', 20)
const child2 = new Child('TLP', 70)
// 原型链继承测试
console.log('child1', child1);		
console.log(child1.getName(), child1.getAge()) // ['TPP'] 20
console.log(child1 instanceof Child, child1 instanceof Parent) // true true

child1.name[0] = 'foo'
child1.play.push(4);
// 共享测试
console.log(child1.play, child2.play); // [1,2,3,4] [1,2,3]
console.log(child1.name)          // ['foo']
console.log(child2.name)          // ['TLP']
child2.getName()                  // ['TLP']
```

优点：

- 父类的方法可以被复用；
- 父类的引用属性不会被共享；
- 子类构建实例时可以向父类传递参数；

缺点：每次创建子类实例都执行了两次构造函数，虽不影响对父类的继承，但子类创建实例时，原型中会存在两份相同的属性和方法，这并不优雅；

- 第一次调用 `Parent()`：给 `Child.prototype` 写入两个属性 name，play (可通过 `child1.__proto__.play` 访问得到)
- 第二次调用 `Parent()`：给 `Child` 写入两个属性 name、play；
- 再解释：实例对象 `child1` 上的两个属性就屏蔽了其原型对象 Child.prototype 的两个同名属性；所以，组合模式的缺点就是在使用子类创建实例对象时，其原型中会存在两份相同的父类实例的属性/方法；这种被覆盖的情况造成了性能上的浪费



## 2-3、非构造函数的继承

### 2-3-1、原型式继承

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909091216.png" style="zoom:50%;" align="" />

```js
const Chinese = {
  nation: '中国'
}

const Doctor = {
  career: '医生'
}

// How to make 'ChineseDoctor' ?
```

可利用 object() 方法：即将子对象的 prototype 属性，指向父对象，从而使得子对象与父对象连在一起；

其本质上是对传入其中的对象执行了一次 **<u>*浅拷贝*</u>**，将构造函数 `F` 的原型直接指向传入的对象；

```js
// ES5 中存在 Object.create() 方法，能覆盖下面这个方法
function object(obj) {
  function F() { }
  F.prototype = obj
  return new F()
}

let person = {
  name: "Nicholas",
  friends: ["Shelby", "Court", "Van"]
};

let anotherPerson = object(person);
anotherPerson.name = "Greg";
anotherPerson.friends.push("Rob");

let yetAnotherPerson = object(person);
yetAnotherPerson.name = "Linda";
yetAnotherPerson.friends.push("Barbie");

console.log(person.friends);   // "Shelby,Court,Van,Rob,Barbie"
```

ECMAScript 5 通过新增 [Object.create()](https://link.zhihu.com/?target=https%3A//developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create) 方法规范化了原型式继承；此方法接收两个参数：在传入一个参数情况下， Object.create 与 object() 方法行为相同；

- 一 个用作新对象原型的对象和(可选的)
- 一个为新对象定义额外属性的对象；

```js
let yetAnotherPerson = object(person)
//  => 
let yetAnotherPerson = Object.create(person)
```

**优点**：父类方法可以复用

**缺点**：

- 原型链继承多个实例的引用类型属性指向相同，存在篡改的可能
- 子类构建实例时不能向父类传递参数



### 2-3-2、寄生式继承

使用原型式继承获得一份目标对象的 `浅拷贝`，然后增强了此浅拷贝的能力；

优缺点：其实和原型式继承一样，寄生式继承说白了就是：能在拷贝来的对象上加点方法，也就是所谓增强能力；

```js
function object(obj) {
  function F() { }
  F.prototype = obj
  return new F()
}

function createAnother(original) {
  // 通过调用函数创建一个新对象
  let clone = object(original)
  // 以某种方式来增强这个对象
  clone.getName = function () {
    console.log('我有了getName方法: ' + this.name)
  }
  return clone
}

let person = {
  name: 'Asuna',
  friends: ['Kirito', 'Yuuki', 'Sinon']
}

let inst1 = createAnother(person)
let inst2 = createAnother(person)
```

**优点**：父类方法可以复用

**缺点**：

- 原型链继承多个实例的引用类型属性指向相同，存在篡改的可能
- 子类构建实例时不能向父类传递参数



## 2-4、寄生组合式继承

组合继承会有两次调用父类的构造函数而造成浪费的缺点，寄生组合继承就可解决此问题：

核心在于<u>让子类的 prototype 指向父类原型的拷贝</u>，如此就不会调用父类的构造函数，进而引发内存的浪费问题；

- 即构造函数被执行两次的问题，将 `指向父类实例` 改为 `指向父类原型`，减去一次构造函数的执行；

```js
function Parent(name) {
    this.name = [name];
  	this.play = [1, 2, 3];
}
Parent.prototype.getName = function() {
    return this.name
}
function Child(name, age) {
    // 1、构造函数的继承 复制父类构造属性方法给子类实例
    Parent.call(this, name);
  	this.age = age;
}
// 2、原型链的继承
// Child.prototype = new Parent()
// 3、优化组合继承 2 
Child.prototype = Parent.prototype  // 寄生组合式继承中，将组合式继承的: 指向父类实例 改为:指向父类原型
// 因上一句的关系，故须将指向修正为原本态: 指向自身构造函数, 否则指向的是 Parent
Child.prototype.constructor = Child
Child.prototype.getAge = function() {
    return this.age
}

// 传参测试
const child1 = new Child('TPP', 20)
const child2 = new Child('TLP', 70)
// 原型链继承测试
console.log('child1', child1);		
console.log(child1.getName(), child1.getAge()) // ['TPP'] 20
console.log(child1 instanceof Child, child1 instanceof Parent) // true true

child1.name[0] = 'foo'
child1.play.push(4);
// 共享测试
console.log(child1.play, child2.play); // [1,2,3,4] [1,2,3]
console.log(child1.name)          // ['foo']
console.log(child2.name)          // ['TLP']
child2.getName()                  // ['TLP']
```

问题：而由于子类原型和父类原型指向同一个对象：`Child.prototype = Parent.prototype`，故对子类原型的操作会影响到父类原型；

- 比如：给 `Child.prototype` 增加一个getName() 方法，会导致 `Parent.prototype` 也增加或被覆盖一个 getName() 方法；

解决：可对 `Parent.prototype` 做浅拷贝，利用 <u>空对象</u> 作为中介，此几乎不占内存，且修改 子类 的 prototype 对象，也不会影响到 父类 的 prototype 对象；

- 注意：后续演进中的 super() 作用也大致如此；
- 注意：继承后才在子类 prototype 上添加方法和属性；
- <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909091217.png" style="zoom:50%;" align="" />

```js
function Parent(name) {
    this.name = [name];
  	this.play = [1, 2, 3];
}
Parent.prototype.getName = function() {
    return this.name
}
function Child(name, age) {
    // 1、构造函数的继承 复制父类构造属性方法给子类实例
    Parent.call(this, name);
  	this.age = age;
}
// 2、原型链的继承
// Child.prototype = new Parent()
// 3、优化组合继承 2 
// Child.prototype = Parent.prototype  // 寄生组合式继承中，将组合式继承的: 指向父类实例 改为:指向父类原型
// 将 指向父类实例 改为 指向父类原型，并使用浅拷贝避免父子原型间的影响
Child.prototype = Object.create(Parent.prototype)  
// 因上一句的关系，故须将指向修正为原本态: 指向自身构造函数, 否则指向的是 Parent
Child.prototype.constructor = Child
Child.prototype.getAge = function() {
    return this.age
}

// 传参测试
const child1 = new Child('TPP', 20)
const child2 = new Child('TLP', 70)
// 原型链继承测试
console.log('child1', child1);		
console.log(child1.getName(), child1.getAge()) // ['TPP'] 20
console.log(child1 instanceof Child, child1 instanceof Parent) // true true

child1.name[0] = 'foo'
child1.play.push(4);
// 共享测试
console.log(child1.play, child2.play); // [1,2,3,4] [1,2,3]
console.log(child1.name)          // ['foo']
console.log(child2.name)          // ['TLP']
child2.getName()                  // ['TLP']
```





### 2-4-1、最优解

```js
var inherit = (function(c,p){
	var F = function(){};
	return function(c,p){
    // 中间对象
		F.prototype = p.prototype;
    // 子类 prototype 通过中间对象寻找 父类 prototype, 避免子类原型操作影响父类
		c.prototype = new F();
    // 备用: 为子对象设置 uber 属性，其指向父对象的 prototype 属性，仅用欧冠与实现继承完备性，纯属备用性质
		c.uber = p.prototype;
		// 修复子类实例的构造函数错误指向
		c.prototype.constructor = c;
	}
})();



// 其他: ES6 语法糖 class / extends
// 拓展: Extend 编译源码
function _possibleConstructorReturn(self, call) {
    // ...
    return call && (typeof call === 'object' || typeof call === 'function') ? call : self;
}

// 核心
function _inherits(subClass, superClass) {
    // ...
 		// 子类的原型的__proto__指向父类的原型
    subClass.prototype = Object.create(superClass && superClass.prototype, {
      	// 给子类添加 constructor 属性 subclass.prototype.constructor === subclass
        constructor: {
            value: subClass,
            enumerable: false,
            writable: true,
            configurable: true
        }
    });
  	// 用来继承父类的静态方法, 寄生组合遗漏地方
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}


var Parent = function Parent() {
    // 验证是否是 Parent 构造出来的 this
    _classCallCheck(this, Parent);
};

var Child = (function (_Parent) {
  	// 采用寄生组合继承方式
    _inherits(Child, _Parent);
  	
    function Child() {
        _classCallCheck(this, Child);
        return _possibleConstructorReturn(this, (Child.__proto__ || Object.getPrototypeOf(Child)).apply(this, arguments));
    }
    return Child;
}(Parent));

// _possibleConstructorReturn 实现了 super
function _possibleConstructorReturn(self, call) {
  if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); 
  // 显示绑定 Child 的内置 [[prototype]] 到 this，即在 Child 中执行 Child 原型链上关联的属性
  return call && (typeof call === "object" || typeof call === "function") ? call : self; 
}
// 核心: _inherits 函数，采用的依然也是第五种方式————寄生组合继承方式，同时证明了这种方式的成功; 
// 注意: 此处增加 Object.setPrototypeOf(subClass, superClass)，用来继承父类的静态方法, 此乃寄生组合遗漏地方
```





## 2-5、ES6 继承

虽 ES6 引入了关键字 class，但底层仍然是基于原型的实现，Class 只是语法糖，让对象原型的写法更加清晰、更像面向对象编程的语法而已；

### 2-5-1、ES6 的 ES5 对应(结构)

- **constructor**

  - ```js
    // ES6
    class Person {
        constructor(name) {
            this.name = name;
        }
        sayHello() {
            return 'hello, I am ' + this.name;
        }
    }
    var kevin = new Person('Kevin');
    kevin.sayHello(); 														// hello, I am Kevin
    Object.keys(Person.prototype); 								// []
    Object.getOwnPropertyNames(Person.prototype); // ["constructor", "sayHello"]
    
    
    // ES5
    function Person(name) {
        this.name = name;
    }
    Person.prototype.sayHello = function () {
        return 'hello, I am ' + this.name;
    };
    var kevin = new Person('Kevin');
    kevin.sayHello(); 														// hello, I am Kevin
    Object.keys(Person.prototype); 								// ['sayHello']
    Object.getOwnPropertyNames(Person.prototype); // ["constructor", "sayHello"]
    
    // 1、ES5 的构造函数 Person，对应 ES6 的 Person 类的 constructor 方法
    // 2、类的内部所有定义的方法，都是不可枚举的（non-enumerable）
    ```

  - ```js
    class Point {
      	// constructor 构造函数，默认方法，通过 new 命令创建对象实例时，自动调用该方法；
      	// 一个类必须有 constructor 方法，若无显式定义，则会被默认添加
        constructor(x) {
            this.x = 1;
            this.p = 2;
        }
        print() {
          return this.x;
        }
    }
    Point.prototype.z = '4'
    class ColorPoint extends Point {
        constructor(x) {
            this.color = color; // ReferenceError
          	// 留意 super
            super(x, y);
            this.x = x; // 正确
        }
        m() {
         super.print();
       }
    }
    
    // 上述 Point 等同于
    function Points(x) {
      this.x = x;
      this.p = 2;
    }
    Points.prototype.print = function() {
      return '(' + this.x +')';
    }
    // 也即 constructor 代表在父类上加属性，而在 class 对象加方法属性等于在原型上的加
    // 而这些属性方法 只有通过 new 出的实例 或  extends 继承出来的实例才可获取到
    new Points().__proto__.print() 	// 可调用到 Points 的 print 方法
    new Points().x = 1 							// 可调用到 constructor 的 this.x = 1
    ```

    

- **实例属性**

  - ```js
    // ES6
    class Person {
        state = {
            count: 0
        };
    }
    
    
    // ES5
    function Person() {
        this.state = {
            count: 0
        };
    }
    ```

- **静态方法**

  - ```js
    // ES6
    class Person {
        static sayHello() {
            return 'hello';
        }
    }
    Person.sayHello() 				// 'hello'
    var kevin = new Person();
    kevin.sayHello(); 				// TypeError: kevin.sayHello is not a function
    
    
    // ES5
    function Person() {}
    Person.sayHello = function() {
        return 'hello';
    };
    Person.sayHello(); 				// 'hello'
    var kevin = new Person();
    kevin.sayHello(); 				// TypeError: kevin.sayHello is not a function
    ```

- **静态属性**

  - ```js
    // ES6
    class Person {}
    Person.name = 'kevin';
    或
    class Person {
      static name = 'kevin';
    }
    
    
    // ES5
    function Person() {};
    Person.name = 'kevin';
    ```

- **new 调用**

  - ```js
    class Person {}
    Person(); // TypeError: Class constructor Foo cannot be invoked without 'new'
    
    // 类必须使用 new 调用，否则会报错；这是它跟普通构造函数的一个主要区别，后者不用 new 也可以执行；
    ```

- **Getter&Setter**

  - ```js
    // ES6
    class Person {
        get name() {
            return 'kevin';
        }
        set name(newName) {
            console.log('new name 为：' + newName)
        }
    }
    let person = new Person();
    person.name = 'daisy';				// new name 为：daisy
    console.log(person.name);			// kevin
    
    
    // ES5
    function Person(name) {}
    Person.prototype = {
        get name() {
            return 'kevin';
        },
        set name(newName) {
            console.log('new name 为：' + newName)
        }
    }
    let person = new Person();
    person.name = 'daisy';				// new name 为：daisy
    console.log(person.name);			// kevin
    ```

- **综合**

  - ```js
    // ZH - 1
    class TLP {
      // 0、相当于 ES5 的静态属性/方法
      static test = 'anything'
      constructor() {
        // 1、constructor 中 var 变量，只存在于 constructor 这个构造函数中 - 私有属性/方法
        var name = "TLP";
    		// 2、this 属性方法则定义到实例上 - 公有属性/方法
        this.name = "TSL";
        this.say = function () {};
      }
      // 3、等号定义会定义到实例上 - 公有属性/方法(另类)
      age = 80;
      showName = function () {
        console.log("showName");
      };
    	// 4、直接定义方法则定义到原型上 - 相当于 ES5 的 prototype 方法 - 公有属性/方法
      showAge() {
        console.log("showAge");
      }
    }
    var tlp = new TLP();
    console.log(Cat.test)  // anything
    console.log(tlp); // {age: 80, name: "TSL", showName: ƒ, say: ƒ}
    console.log(Object.keys(tlp)); // ["age", "showName", "name", "say"]
    console.log(tlp.__proto__) // { ... showAge... }
    tlp.showName();
    tlp.showAge();
    
    
    
    // ZH - 2
    class TLP {
      // 静态属性/方法
      static test = "static-test";
      static test2 = "static-test2";
      
      constructor() {
        // 私有属性/方法
        var type = "con-oldman";
        // 公有属性/方法(实例-优先级高)
        this.name = "con-this-tlp";
        this.type = "con-this-oldman"
        this.getType = () => {
          console.log(this.type);
          console.log(type);
        };
      }
      // 公有属性/方法(实例-优先级低)
      name = "tlp"
      type = "oldman";
      getType = () => {
        console.log(this.type);
        console.log(type);
      };
      // 公有属性/方法(原型链)
      showName() {
      	console.log(this.type)
      };
    }
    var type = "window";
    var tlp = new TLP();
    tlp.getType();
    // con-this-oldman
    // con-oldman
    console.log(tlp);
    // TLP {name: "con-this-tlp", type: "con-this-oldman", getType: ƒ}
    ```

  - <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909091213.png" style="zoom:50%;" />



### 2-5-2、ES6 的 ES5 对应(源码)

利用 Babel 进行转译观察结果，[ Try it out ](https://babeljs.io/repl/#?babili=false&evaluate=true&lineWrap=false&presets=es2015%2Creact%2Cstage-2&targets=&browsers=&builtIns=false&debug=false&code_lz=Q)：

### 2-5-2-1、Class

- ```js
  // ES6
  class Person {
  }
  
  
  // Babel 转译结果
  "use strict";
  
  function _instanceof(left, right) {
    if (
      right != null &&
      typeof Symbol !== "undefined" &&
      right[Symbol.hasInstance]
    ) {
      return !!right[Symbol.hasInstance](left);
    } else {
      return left instanceof right;
    }
  }
  
  function _classCallCheck(instance, Constructor) {
    if (!_instanceof(instance, Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  
  var Person = function Person() {
    _classCallCheck(this, Person);
  };
  ```

### 2-5-2-2、Constructor

- 注意：一个类必须有 constructor 方法，若无显式定义，则会被默认添加；所以上一代码虽无 constructor 但被默认添加；

- 注意：**<u>constructor 对应的就是 ES5 中的构造函数；</u>**

- 注意：**<u>因类必须通过 new 方式调用，否则报错，此乃类特性之一，通过 _classCallCheck 实现；其作用是检查 Person 是否是通过 new 的方式调用；</u>**

  - 比如：当一类 Person 以此种方式调用：`var person = Person()`，则 this 指向 window， `instance instanceof Constructor`  为 false，报错；

- ```js
  // ES6
  class Person {
      constructor(name) {
          this.name = name;
      }
  }
  
  
  // Babel 转译结果
  "use strict";
  
  function _instanceof(left, right) {
    if (
      right != null &&
      typeof Symbol !== "undefined" &&
      right[Symbol.hasInstance]
    ) {
      // ES6 环境则使用更为不可外部更改的 Symbol 去检查
      return !!right[Symbol.hasInstance](left);
    } else {
      // ES5 环境下则退化为 instanceof
      return left instanceof right;
    }
  }
  
  function _classCallCheck(instance, Constructor) {
    // 检查 Person 是否是通过 new 的方式调用, 实现类须通过 new 调用的特性
    if (!_instanceof(instance, Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  
  var Person = function Person(name) {
    _classCallCheck(this, Person);
  	// 与上一相比只增加此行
    this.name = name;
  };
  ```

### 2-5-2-3、实例&静态属性

- 注意：**<u>ES6 Class 实例属性对应 ES5 构造函数中的 this 对象上的属性；</u>**

- 注意：**<u>ES6 Class 静态属性对应 ES5 构造函数的自身属性；</u>**

- 注意：上述对应关系通过 _defineProperty 实现，其为 Object.defineProperty 的实现封装；

- ```js
  // ES6
  class Person {
      // 实例属性
      foo = 'foo';
      // 静态属性
      static bar = 'bar';
      constructor(name) {
          this.name = name;
      }
  }
  
  
  // Babel 转译结果
  "use strict";
  
  function _instanceof(left, right) {
    if (
      right != null &&
      typeof Symbol !== "undefined" &&
      right[Symbol.hasInstance]
    ) {
      return !!right[Symbol.hasInstance](left);
    } else {
      return left instanceof right;
    }
  }
  
  function _classCallCheck(instance, Constructor) {
    if (!_instanceof(instance, Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  
  // 与上一相比增加此函数
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true,
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  
  var Person = function Person(name) {
      _classCallCheck(this, Person);
  		// 与上一相比增加此行1
      _defineProperty(this, "foo", "foo");
  
      this.name = name;
    };
  
  // 与上一相比增加此行2
  _defineProperty(Person, "bar", "bar");
  ```

### 2-5-2-4、实例&静态方法

- 注意：**<u>ES6 Class 实例方法对应 ES5 构造函数中的原型对象上的方法；</u>**

- 注意：**<u>ES6 Class 静态方法对应 ES5 构造函数的自身方法；</u>**

- 注意：**<u>上述对应关系通过 _createClass 实现，作用是根据方法类型(protoProps/staticProps)安插相应位置，使用 _defineProperties 实现方法遍历；</u>**

- 注意：**<u>前一代码返回一个 Person 构造函数，而此处，为自动执行 _createClass 方法而实现方法的绑定，返回一 IIFE，IIFE 则返回绑定后的构造函数；</u>**

- ```js
  // ES6
  class Person {
      foo = 'foo';
      static bar = 'bar';
      constructor(name) {
          this.name = name;
      }
  		// 实例方法
      sayHello() {
          return 'hello, I am ' + this.name;
      }
  		// 静态方法
      static onlySayHello() {
          return 'hello'
      }
  }
  
  
  // Babel 转译结果
  "use strict";
  
  function _instanceof(left, right) {
    if (
      right != null &&
      typeof Symbol !== "undefined" &&
      right[Symbol.hasInstance]
    ) {
      return !!right[Symbol.hasInstance](left);
    } else {
      return left instanceof right;
    }
  }
  
  function _classCallCheck(instance, Constructor) {
    if (!_instanceof(instance, Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true,
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  
  // 与上一相比增加此函数1
  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      // 默认 enumerable 为 false，configurable 为 true，是为防止 Object.keys() 之类的方法遍历
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      // 通过判断 value 是否存在，来判断是否是 getter 和 setter
      // 若存在 value，就为 descriptor 添加 value 和 writable 属性，若不存在，就直接使用 get 和 set 属性
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  // 与上一相比增加此函数2
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }
  
  // 与上一相比增加此行1(IIFE)
  var Person = /*#__PURE__*/ (function () {
    function Person(name) {
      _classCallCheck(this, Person);
  
      _defineProperty(this, "foo", "foo");
  
      this.name = name;
    } 
  
    // 与上一相比增加此行2
    _createClass(
      Person,
      [
        {
          key: "sayHello",
          value: function sayHello() {
            return "hello, I am " + this.name;
          }, // 静态方法
        },
      ],
      [
        {
          key: "onlySayHello",
          value: function onlySayHello() {
            return "hello";
          },
        },
      ]
    );
  
    return Person;
  })();
  
  _defineProperty(Person, "bar", "bar");
  ```

### 2-5-2-5、Getter&Setter

- 注意：**<u>ES6 Class  Getter&Setter 方法对应 ES5 构造函数中的原型对象上的方法；</u>**

- 注意：**<u>还通过 _createClass —>  _defineProperties 的 Object.defineProperty(target, descriptor.key, descriptor); 为 set get 对象绑定相关方法</u>**

  -     // 通过判断 value 是否存在，来判断是否是 getter 和 setter
        // 若存在 value，就为 descriptor 添加 value 和 writable 属性，若不存在，就直接使用 get 和 set 属性

  -     比如：`Object.defineProperty(target, 'name',  set: function set(newName) { console.log('new name 为：' + newName);});`

- ```js
  // ES6
  class Person {
      foo = 'foo';
      static bar = 'bar';
      constructor(name) {
          this.name = name;
      }
      sayHello() {
          return 'hello, I am ' + this.name;
      }
      static onlySayHello() {
          return 'hello'
      }
      // Getter
      get name() {
          return 'kevin';
      }
      // Setter
      set name(newName) {
          console.log('new name 为：' + newName)
      }
  }
  
  
  // Babel 转译结果
  "use strict";
  
  // ...
  
  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }
  
  // ...
  
  var Person = /*#__PURE__*/function () {
    function Person(name) {
      _classCallCheck(this, Person);
  
      _defineProperty(this, "foo", 'foo');
  
      this.name = name;
    }
  
    _createClass(Person, [{
      key: "sayHello",
      value: function sayHello() {
        return 'hello, I am ' + this.name;
      }
    }, {
      key: "name",
      get: function get() {
        return 'kevin';
      },
      set: function set(newName) {
        console.log('new name 为：' + newName);
      }
    }], [{
      key: "onlySayHello",
      value: function onlySayHello() {
        return 'hello';
      }
    }]);
  
    return Person;
  }();
  
  // ...
  ```









### 2-5-2-6、Extend

首先，几个 Extend 特殊特性：

- **<u>super 关键字表示父类的构造函数，相当于 ES5 的 Parent.call(this)</u>**

- 子类必须在 constructor 方法中调用 super 方法，<u>**否则新建实例时会报错 (已优化了，可新建实例)**</u>；

  - 因为子类没有自己的 this 对象，而是继承父类的 this 对象，然后对其进行加工；**<u>若不调用 super 方法，子类就得不到 this 对象</u>**；
  - 同时也因为此原因，在子类的构造函数中，**<u>只有调用 super 之后，才可使用 this 关键字，否则会报错</u>**

- **<u>父类的静态方法，可被子类继承</u>**；

  - ```js
    class Foo {
      // 最终变为 ES5 构造函数自身方法
      static classMethod() {
        return 'hello';
      }
    }
    // extends 内部实现了静态方法的继承: Bar.__proto__ = Foo
    class Bar extends Foo {
    }
    
    Bar.classMethod(); // 'hello'
    ```

  - 因为 Class 作为构造函数的语法糖，同时有 prototype 属性和 `__proto__` 属性，因此同时存在两条继承链：

    - 子类的 `__proto__` 属性，表示构造函数的继承，总是指向父类；

    - 子类 prototype 属性的 `__proto__` 属性，表示方法的继承，总是指向父类的 prototype 属性；

    - ```js
      class Parent {
      }
      class Child extends Parent {
      }
      console.log(Child.__proto__ === Parent); // true
      console.log(Child.prototype.__proto__ === Parent.prototype); // true
      ```

    - <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909091218.png" style="zoom:50%;" align="" />

    - 相比寄生组合式继承，ES6 的 class 多了一个 `Object.setPrototypeOf(Child, Parent)` 的步骤，此步就是用来继承父类的静态方法；

- **<u>extends 关键字后面可以跟多种类型的值：Function & null；</u>**

  - 只要是一个有 prototype 属性的函数，就能被继承；而由于函数都有 prototype 属性(除了 Function.prototype 函数)，因此 A 可是任意函数

  - ```js
    class B extends A {
    }
    class A extends null {
    }
    console.log(A.__proto__ === Function.prototype); 	// true
    console.log(A.prototype.__proto__ === undefined); // true
    ```

然后，Babel 编译与 ES6 继承区别探究：

```js
// ES6
class Parent {
    constructor(name) {
        this.name = name;
    }
}
class Child extends Parent {
}


// Babel 转译结果
("use strict");

function _inherits(subClass, superClass) {
  // 实现特性: 继承父类必须为 Function 或 null
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  // 类似于 ES5 的寄生组合式继承，使用 Object.create，设置子类 prototype 属性的 __proto__ 属性指向父类的 prototype 属性
  // 并给 subClass.prototype 添加一个可配置可写不可枚举的 constructor 属性，该属性值为 subClass (修正指向)
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: { value: subClass, writable: true, configurable: true },
  });
  // 设置子类的 __proto__ 属性指向父类
  // 实现特性: 静态方法继承, ES5 与 ES6 继承区别之一: subClass.__proto__ = superClass
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf =
    Object.setPrototypeOf ||
    function _setPrototypeOf(o, p) {
    	// subClass.__proto__ = superClass
      o.__proto__ = p;
      return o;
    };
  return _setPrototypeOf(o, p);
}

// 函数测试是否存在 NativeReflectConstruct
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  // 检查 Proxy 是因为 Reflect 是一个内置的对象，它提供拦截 JavaScript 操作的方法。这些方法与proxy handlers的方法相同
  if (typeof Proxy === "function") return true;
  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

// 获取 o.__proto__ 
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf
    ? Object.getPrototypeOf
    : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
      };
  return _getPrototypeOf(o);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError(
      "this hasn't been initialised - super() hasn't been called"
    );
  }
  return self;
}

// 帮助确定调用父类构造函数的返回值
function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized(self);
}


// _createSuper(Child) 作用是检查 Reflect 若有则利用 Reflect 创建对象否则 Super.apply(this, arguments);
// Reflect.construct() 与 Object.create() 均可创建对象，两种方式结果相同，但在创建对象过程中仍一点不同: new.target 的值上
// 当使用 Object.create() 和 Function.prototype.apply() 时，若不使用 new 操作符调用构造函数，构造函数内部的 new.target 值会指向 undefined。
// 当调用 Reflect.construct() 来创建对象，new.target 值会自动指定到 target（或者 newTarget，前提是 newTarget 指定了)
// new.target 属性允许你检测函数或构造方法是否是通过 new 运算符被调用的
// 通过 new 运算符被初始化的函数或构造方法时，new.target 返回一个指向构造方法或函数的引用；在普通的函数调用中，new.target 值是 undefined
function _createSuper(Derived) {
  // 首先检查是否有定义 Reflect
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    // 获取父类: return o.__proto__ || Object.getPrototypeOf(o) 因为先前 SubClass.__proto__ = SuperClass
    var Super = _getPrototypeOf(Derived),
      result;
    // 若有定义 Reflect
    if (hasNativeReflectConstruct) {
      // 获取实例的 constructor 即 SubClass: (return o.__proto__ || Object.getPrototypeOf(o)).constructor
      var NewTarget = _getPrototypeOf(this).constructor;
      // result 将会是 NewTarget 即 SubClass 类型
      // Reflect.construct() 方法的行为有点像 new 操作符构造函数, 相当于运行 new target(...args).
      // Reflect.construct (target, argumentsList[, newTarget]) 
      // Reflect.construct (被运行的目标构造函数, 类数组-目标构造函数调用时的参数, 作为新创建对象的原型对象的 constructor 属性)
      // 返回: 以 target(若 newTarget 存在，则为 newTarget）函数为构造函数，argumentList 为其初始化参数的对象实例
      // new Foo(...args) === Reflect.construct(Foo, args)
      // 所以: Reflect.construct(Super, arguments, NewTarget); === new NewTarget(arguments)
      // result 将会是 NewTarget 即 SubClass 类型
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      // 不使用 Reflect 此时的 new.target 值为 undefined
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}

// 严格 typeof 实现
function _typeof(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj &&
        typeof Symbol === "function" &&
        obj.constructor === Symbol &&
        obj !== Symbol.prototype
        ? "symbol"
        : typeof obj;
    };
  }
  return _typeof(obj);
}
// 严格 instanceof 实现
function _instanceof(left, right) {
  if (
    right != null &&
    typeof Symbol !== "undefined" &&
    right[Symbol.hasInstance]
  ) {
    return !!right[Symbol.hasInstance](left);
  } else {
    return left instanceof right;
  }
}
// Class 须为 new 调用
function _classCallCheck(instance, Constructor) {
  if (!_instanceof(instance, Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

var Parent = function Parent(name) {
  _classCallCheck(this, Parent);
  this.name = name;
};

var Child = /*#__PURE__*/ (function (_Parent) {
  // 继承实现
  _inherits(Child, _Parent);
  // 返回闭包延迟执行
  var _super = _createSuper(Child);

  function Child() {
    _classCallCheck(this, Child);
    return _super.apply(this, arguments);
  }
  return Child;
})(Parent);
```

- 注意：**<u>Babel 创建 _inherits 函数帮助实现继承，又创建了 _possibleConstructorReturn 函数帮助确定调用父类构造函数的返回值</u>**；

- 注意：**<u>过去缺少调用 super 时新建实例会报错，但现已通过新增 var _super = _createSuper(Child); 优化，故可新建实例，但仍无法拿到 this；</u>**

  - `var _super = _createSuper(Child);` 作用是：

    - 若有 `Reflect`，则利用 `Reflect.construct` 创建对象；
    - 若无，则利用 `Super.apply(this, arguments);` (`Object.create()`) 创建，**<u>*相当于在子类执行父类构造，所以 result = 其构造函数返回值*</u>**

  - 注意：**<u>*为何如此大费周章*</u>**，是因为后者 new.target 值为 undefined，无法完美实现 ES6 继承特征，但也不一定需要，所以支持 apply 形式，而 apply 就是 ES5 寄生组合式继承的方式：`function Child() { Parent.call(this, name, ...) ...};` 

  - 注意：`Super = _getPrototypeOf(Child), 而 _getPrototypeOf == return o.__proto__ || Object.getPrototypeOf(o);`，Super 为父类；

  - 注意：`Reflect.construct()` 方法的行为有点像 new 操作符构造函数, 相当于运行 `new target(...args).`

    - `Reflect.construct (target, argumentsList[, newTarget])` 
    - `Reflect.construct (被运行的目标构造函数, 类数组-目标构造函数调用时的参数, 作为新创建对象的原型对象的 constructor 属性)`
    - 返回: `以 target (若 newTarget 存在，则为 newTarget) 函数为构造函数，argumentList 为其初始化参数的对象实例`
    - `new Foo(...args) === Reflect.construct(Foo, args)`
    - 所以: `Reflect.construct(Super, arguments, NewTarget); === new NewTarget(arguments)`
    - `NewTarget = _getPrototypeOf(this).constructor，即获取实例的 constructor 即 SubClass`
    - **<u>*所以 Reflect.construct() 方式下，result = SubClass 的实例；*</u>**

  - 注意：`Reflect.construct()` 与 `Object.create()` 均可创建对象，两种方式结果相同，但在创建对象过程中仍一点不同：体现在 `new.target` 的值上

    - 当使用 `Object.create` 和 `Function.prototype.apply` 时，若不用 new 操作符调用构造函数，则其内部的 `new.target` 值会指向 `undefined`；
    - 当调用 `Reflect.construct` 来创建对象，`new.target` 值会自动指定到 target (或 newTarget，前提是 newTarget 指定了)
    - `new.target` 属性允许检测函数或构造方法是否是通过 new 运算符被调用的:
      - 通过 new 运算符被初始化的函数或构造方法时，`new.target` 返回一个指向构造方法或函数的引用；
      - 而通过普通函数调用，则其值是 undefined；

  - 创建出来的对象 result 再经过 `_possibleConstructorReturn(this, result);` 处理，其帮助确定调用父类构造函数的返回值；

    - ```js
      // 此为旧版实现方式，新版实现的作用与之相同，只是做了功能分拆和细化，但旧版更容易理解
      function _possibleConstructorReturn(self, call) {
          if (!self) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }
          return call && (typeof call === "object" || typeof call === "function") ? call : self;
      }
      ```

    - 前面提到，result 有两种情况，一个是 Reflect.construct 的处理结果，为子类实例，一个是 Super.apply(this, arguments) 的处理结果；对于 result 值，如果是 object 类型或是 function 类型，则返回 result，如果是 null 或 基本类型的值 或 undefined，则返回 self 也即子类的 this；

    - ```js
      // Ex1 return null
      class Parent {
          constructor(name) {
            	this.name = name;
            	return null
          }
      }
      class Child extends Parent {
        	// Child 未增加 constructor & super 版
        	// ...
      
        	// Child 增加 constructor & super 版
          constructor(name, age) {
              super(name); 
              this.age = age;
          }
      }
      // Ex1 - Babel
      // ...
      function _createSuper(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct();
        return function _createSuperInternal() {
          // Super 为 Parent 构造函数
          var Super = _getPrototypeOf(Derived), result;	
          
          // 注意!!! 此段目的就是调用 Parent.call/apply(this, arguments)
          // 只是前者能使 new.target 有其值，后者 new.target 为 undefined
      		if (hasNativeReflectConstruct) {
            // NewTarget = Child 构造函数
            var NewTarget = _getPrototypeOf(this).constructor;
            // result = Child 实例
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            // result = null
            result = Super.apply(this, arguments);
          }
          
          // 注意!!! 此段目的就是根据 result 值
          // 方式1 result 为 Child 实例，返回 result
          // 方式2:
          //			若 result 为 null、undefined、基本值 则返回 Child 实例
        	// 			否则返回 result
          return _possibleConstructorReturn(this, result);
        };
      }
      function _possibleConstructorReturn(self, call) {
        if (call && (_typeof(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized(self);
      }
      
      function _assertThisInitialized(self) {
        if (self === void 0) {
          throw new ReferenceError(
            "this hasn't been initialised - super() hasn't been called"
          );
        }
        return self;
      }
      // ...
      var Parent = function Parent(name) {
        _classCallCheck(this, Parent);
        this.name = name;
        return null;
      };
      var Child = /*#__PURE__*/ (function (_Parent) {
        _inherits(Child, _Parent);
        var _super = _createSuper(Child);
      
        // Child 未增加 constructor & super 版
        function Child() {
          _classCallCheck(this, Child);
          return _super.apply(this, arguments);
        }
        // Child 增加 constructor & super 版
        function Child(name, age) {
          var _this; 												// undefined
          _classCallCheck(this, Child);
          _this = _super.call(this, name);  // Child 实例
          _this.age = age;
          return _this;
        }
        return Child;
      })(Parent);
      var child = new Child("TLP", 70)
      ```



### 2-5-2-7、Extend 总结

```js
// ...
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    // Super 为 Parent 构造函数
    var Super = _getPrototypeOf(Derived), result;	
    
    // 注意!!! 此段目的就是调用 Parent.call/apply(this, arguments)
    // 只是前者能使 new.target 有其值，后者 new.target 为 undefined
		if (hasNativeReflectConstruct) {
      // NewTarget = Child 构造函数
      var NewTarget = _getPrototypeOf(this).constructor;
      // result = Child 实例
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      // result = null
      result = Super.apply(this, arguments);
    }
    
    // 注意!!! 此段目的就是根据 result 值
    // 方式1 result 为 Child 实例，返回 result
    // 方式2:
    //			若 result 为 null、undefined、基本值 则返回 Child 实例
  	// 			否则返回 result
    return _possibleConstructorReturn(this, result);
  };
}
function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; }
  return _assertThisInitialized(self);
}

function _assertThisInitialized(self) {
  if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}
  return self;
}
// ...
// 主体部分
var Parent = function Parent(name) {
  _classCallCheck(this, Parent);
  this.name = name;
  return null;
};
var Child = /*#__PURE__*/ (function (_Parent) {
  _inherits(Child, _Parent);
  var _super = _createSuper(Child);

  // Child 未增加 constructor & super 版
  function Child() {
    _classCallCheck(this, Child);
    return _super.apply(this, arguments);
  }
  
  // Child 增加 constructor & super 版
  function Child(name, age) {
    var _this; 												// undefined
    _classCallCheck(this, Child);
    _this = _super.call(this, name);  // Child 实例作为 this
    _this.age = age;
    return _this;
  }
  return Child;
})(Parent);
// ...
```

- 首先，执行 `_inherits(Child, Parent)`，建立 Child 和 Parent 的原型链关系，即：

  - ```js
    //  Object.setPrototypeOf(Child.prototype, Parent.prototype) 和 Object.setPrototypeOf(Child, Parent)
    function _inherits(subClass, superClass) {
      // 实现特性: 继承父类必须为 Function 或 null
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      // 类似于 ES5 的寄生组合式继承，使用 Object.create，设置子类 prototype 属性的 __proto__ 属性指向父类的 prototype 属性
      // 并给 subClass.prototype 添加一个可配置可写不可枚举的 constructor 属性，该属性值为 subClass (修正指向)
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: { value: subClass, writable: true, configurable: true },
      });
      // 设置子类的 __proto__ 属性指向父类
      // 实现特性: 静态方法继承, ES5 与 ES6 继承区别之一: subClass.__proto__ = superClass
      if (superClass) _setPrototypeOf(subClass, superClass);
    }
    ```

- 然后，调用 `_super.call(this, name)`，内部核心为   `Parent.call(this, name)`；

  - 若无调用 super()，则返回子类实例，_this 不可用；
  - 若调用 super，则将返回值(根据 Parent 构造函数的返回值类型，确定子类构造函数 this 的初始值)赋给 _this，_this 可用；

- 最终，根据子类构造函数，修改 _this 的值，然后返回该值；

- **<u>*问题：为何 super 调用前不能用 this；*</u>**

  - 因为 super 负责继承中的：构造函数的继承，复制父类构造属性方法给子类实例，倘若不加限制，在 super 前使用 this 为子类构造函数添加属性，则 super 调用后，父类构造函数属性就会覆盖掉先前设置的同名属性，所以 super 调用前不能使用 this；

  - ```js
    // 先看转换结果
    class Parent {
        constructor(name) {
          	this.name = name;
          	return null
        }
    }
    class Child extends Parent {
        constructor(name, age) {
          	console.log(this);
            super(name); 
            this.age = age;
        }
    }
    
    
    // ...
    function _assertThisInitialized(self) { 
    	if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } 
    	return self; 
    }
    
    // ...
    var Parent = function Parent(name) {
      _classCallCheck(this, Parent);
      this.name = name;
      return null;
    };
    
    var Child = /*#__PURE__*/function (_Parent) {
      _inherits(Child, _Parent);
      var _super = _createSuper(Child);
      function Child(name, age) {
        var _this;
        _classCallCheck(this, Child);
        console.log(_assertThisInitialized(_this)); // error
        _this = _super.call(this, name);
        _this.age = age;
        return _this;
      }
    
      return Child;
    }(Parent);
    // ...
    ```

- **<u>*区别：ES5 的寄生组合继承实现与 ES6 继承有细微差别：*</u>**

  - ES6 Class 中含有 Object.setPrototypeOf(subClass, superClass)，用以继承父类静态方法，但寄生组合没有；
  - super 机制，确保构造函数属性添加顺序进行；




## 2-6、总结

- 首先，最容易想到的是 **<u>原型链继承</u>**，通过把子类实例的原型指向父类实例来继承父类的属性和方法，但原型链继承的缺陷在于<u>对子类实例继承的引用类型的修改会影响到所有的实例对象，以及无法向父类的构造方法传参</u>；
- 因此，引入了 **<u>构造函数继承</u>**, 通过在子类构造函数中调用父类构造函数并传入子类 this 来获取父类的属性和方法，但构造函数继承也存在缺陷，<u>构造函数继承不能继承到父类原型链上的属性和方法</u>；
- 所以，综合两种继承的优点，提出了 **<u>组合式继承</u>**，但组合式继承也引入了新的问题：<u>它每次创建子类实例都执行了两次父类构造方法</u>；最后，通过将子类原型指向父类实例，改为子类原型指向父类原型的浅拷贝来解决这一问题，也即最终实现：**<u>寄生组合式继承</u>**



## 2-7、多继承

### 2-7-1、基本

基本：没有几个语言能真正实现多继承，比如 C++ 和 python 提供了多继承的语法；

而 Java 只允许继承一个父类，但可同时 implements 多个接口类，也算一种变相的多继承；

```js
function MyClass() {
     SuperClass.call(this);
     OtherSuperClass.call(this);
}

// 继承一个类（就是寄生组合继承的套路）
MyClass.prototype = Object.create(SuperClass.prototype);

// 混合其它类，关键是 assign() 方法: 
// assign 会将 OtherSuperClass 原型上的函数拷贝到 MyClass 原型上，使 MyClass 的所有实例都可用 OtherSuperClass 的方法
Object.assign(MyClass.prototype, OtherSuperClass.prototype);

// 重新指定 constructor
MyClass.prototype.constructor = MyClass;

// 在之类上附加方法
MyClass.prototype.myMethod = function() {
  // do a thing
};
```

[Object.assign](https://link.zhihu.com/?target=https%3A//developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign) [ polyfilled](https://link.zhihu.com/?target=https%3A//developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign%23Polyfill)，支持旧浏览器可用使用 [jQuery.extend()](https://link.zhihu.com/?target=https%3A//api.jquery.com/jQuery.extend/) 或 [_.assign()](https://link.zhihu.com/?target=https%3A//lodash.com/docs/%23assign)、[MDN\] Object.create()](https://link.zhihu.com/?target=https%3A//developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create)



### 2-7-2、多继承问题

- 问题：instanceof 指向

  - JS 只有 prototype 链，且约束了每一对象只能有一条 Prototype，则在多继承情况下， instanceof 须另外实现；

  - ```js
    class A {}
    class B {}
    // 假定有继承
    class C extend A, B {}
    // 此时 C 的实例，则应同时指向 A & B
    const c = new C();
    c instanceof A // true
    c instanceof B // true
    c instanceof C // true
    ```

- 问题：Diamond Problem 

  - 假如 ABC 三类均定义一同名函数，则 D 的实例应取谁为准
  - <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909091218.png" style="zoom:50%;" align="" />



### 2-7-3、多继承解决

- 解决：instanceof

- 思路：借鉴 Java 思路，实际只继承一个类，而其他类则通过其他方式将其功能融入；

- Java 中可用 Interface 约束类该有的行为，当然 JS 也可参考使用 interface，但如此的话，除校验外别无他用，故 JS 改用 mixin 方式更为实在

- ```js
  // 构造一个中间类，让中间类直接继承 A，并且 mixin 了 B 的原型成员，然后再让 C 去继承这个中间类
  const mixinClass = (base, ...mixins) => {
    // tool
    const mixinProps = (target, source) => {
      Object.getOwnPropertyNames(source).forEach(prop => {
        if (/^constructor$/.test(prop)) { return; }
        Object.defineProperty(target, prop, Object.getOwnPropertyDescriptor(source, prop));
      })
    };
  
    let Ctor;
    
    // 由于 B 是通过 mixin 方式浅拷贝了一份，B.prototype 并不在 C 的原型链上（C.__proto__.__proto__），所以 c instanceof B 为 false
    if (base && typeof base === 'function') {
      Ctor = class extends base {
        constructor(...props) {
          super(...props);
        }
      };
      mixins.forEach(source => {
        mixinProps(Ctor.prototype, source.prototype);
      });
    } else {
      // 
      Ctor = class {};
    }
    return Ctor;
  };
  
  class A {
    methodA() {}
  }
  class B {
    methodB() {}
  }
  class C extends mixinClass(A, B) {
    methodA() { console.log('methodA in C'); }
    methodC() {}
  }
  
  let c = new C();
  c instanceof C  // true
  c instanceof A  // true
  c instanceof B  // false
  ```

- 解决 Diamond Problem 

- 思路：Method Resolution Order (MRO) 指的是在继承结构中确定类的线性顺序，例如 `C => B => A` 表示 C 继承 B，B 继承 A，那么 C 的 MRO 就是 `C B A`，也即当调用 C 实例中的一个函数时，会按照 `C B A` 的优先级顺序去“寻找”该函数。在单继承的结构中自然没有问题，而在多继承中 MRO 发挥着其作用；常用的 [C3算法](https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/C3_linearization) 就是用来计算 MRO

- 详见：[JS多继承](https://zhuanlan.zhihu.com/p/34693209)



