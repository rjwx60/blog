# 三、模块机制

Node 借鉴 CommonJS 的 Modules 规范实现自身模块系统；



## 3-1、模块分类

### 3-1-1、核心模块

描述：由 Node 自身提供，其在源码编译时即被编译进二进制执行文件，当进程启动时便被直接加载进内存；

注意：因上述原因，此类模块的引入/文件定位/编译执行步骤均可忽略，而在路径分析中，其优先级更高，加载速度也更快；

### 3-1-2、文件模块

用户提供的，运行时加载的，速度比核心慢，需经过3阶段：路径分析、文件定位、编译执行；

### 3-1-3、两者异同

相同：引入的模块均会进行缓存 (缓存内容：编译 & 执行后的对象)，以减少二次引入时的开销；不同如下：

- 缓存检查优先度中，核心模块依然优先于文件模块；
- 文件模块无须将源代码编译进 Node，而是通过 `dlopen` 方法动态加载；
- 文件模块在编写时无须将源代码写入 Node 命名空间，也无需提供头文件；



## 3-2、模块路径分析

模块标识符分析(require() 中的标识符参数分析)，基于此标识符进行模块查找；等同npm包路径分析；

核心模块：http、fs、path 等；

- 首先，路径优先级最高，其次是缓存；
- 其次，无需定位、无需编译，直接使用；

文件模块：以点开始的相对路径文件模块 & 以斜杠开始的绝对路径文件模块；

- 首先，`require` 会将其转为真实路径，并以此作为索引；
- 然后，根据模块路径查找策略定位文件，并进行编译；
- 随后，将编译后的执行结果存放在缓存，以便二次加载更快；

自定模块：非路径形式的文件模块，形式为文件/包，比如自定义 connect 模块；

- 首先，根据模块路径查找策略定位文件；
- 注意：自定义模块均在文件最外层，故加载速度最慢 (除非写在当前文件的 `node_modules` 中..)；



### 3-2-1、模块路径形式

模块路径具体表现为由路径组成的数组；

- 生成方式：创建任意 JS 文件，内容为 `console.log(module.paths)`，然后 `node 目标文件.js` 即可输出；



### 3-2-2、模块查找策略

加载过程中，Node 会逐个尝试模块路径中的路径，直到找到目标文件为止，路径越深，模块查找耗时越多；

- <u>搜寻当前文件目录</u>下的 node_modules 目录；
- <u>搜寻父级文件目录</u>下的 node_modules 目录；
- <u>搜寻爷级文件目录</u>下的 node_modules 目录；
- 沿路径向上逐级递归，直至根目录下的 node_modules 目录；



## 3-3、文件定位

**<u>*文件扩展分析：*</u>**

若不包含扩展名，则调用 fs 模块同步阻塞式判断文件是否存在，并按 `.js > .json > .node` 顺序补足扩展名；

- 注意：因缓存优化策略，二次引入时无需路径分析、文件定位、编译执行等过程；
- 优化：对 node、json 文件，可在使用 require 时，顺带添加扩展名，以稍微提高速度；

**<u>*目录与包分析：*</u>**

若通过文件扩展名分析后，仍无法找到对应文件(或得到一目录<常见于自定义模块，逐个模块路径查找时>)，此时 Node 会将目录当作包来处理；

- 首先，在所在目录查找 `package.json`：
  - 若有，则通过 `JSON.parse` 解析出包描述对象，并取出 main 属性指定的文件名进行定位；
    - 若缺少文件名扩展名，则进入文件扩展名分析流程；
    - 若文件名错误，则将 index 作为默认文件名，依次查找 index.js、index.json、index.node；
  - 若无，则将 index 作为默认文件名，依次查找 index.js、index.json、index.node；
- 最后，若还是没有成功定位任何文件，则继续查找下一个模块路径，直至路径数组遍历完毕，若依然没有找到，则向上抛出查找失败错误；

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200918140137.png" style="zoom:50%;" align="" />



## 3-4、模块编译与导出

编译后进行加载并导出，此节亦是 CommonJS 模块规范的 Node 实现 

首先，编译过程中，Node 对获取到的 JS 文件，进行头尾包装，以实现每个模块文件的作用域隔离 (**<u>*作用域隔离原理*</u>**)：

- 头部增加：`(function(*exports*, *require*, *module*, *__filename*, *__dirname*){ \n；` 
- 尾部增加：`\n })`

然后，通过执行 vm 原生模块的 `runInThisContext` ，返回一个具体的 function 对象，并将当前模块的 exports、require、module(模块自身)、查找到的文件路径、文件目录作为参数传递此 function 执行；(require/exports/module 变量没有在模块中定义，却可在每个模块中存在的原因)；

最后，对象执行后，将模块 `exports` 属性返回给调用方，此后属性上的方法 & 属性，均可被外部调用，但其余变量则不可直接调用；

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200918140138.png" style="zoom:50%;" align="" />



### 3-4-1、文件模块编译

**<u>*普通文件模块*</u>**

- 首先，定位到具体文件后，新建模块对象；
- 然后，按照路径 & 文件扩展名载入并进行相应编译 (具体编译实现看核心模块的JS模块编译)：

  - `.js`：用 fs 模块同步读取，随后编译执行；
  - `.json` ：用 fs 模块同步读取并用 `JSON.parse` 解析，将结果赋给模块对象的 `exports` 供外部调用；
  - `.node` ：使用 dlopen 方法加载最后编译生成的文件；
  - `.else`  ：处理同 `.js` 文件；
- 最后，编译成功的模块，将其文件路径作为索引，在 `Module._cache` 对象上缓存以提高二次导入性能；

**<u>*特殊文件模块：C/C++ 模块*</u>**：即上述提到的 node 文件，用于提升性能与执行效率；

- 注意：使用 `dlopen` 方法动态加载最后编译生成的文件；`dlopen` 的实现因平台而不同，但均通过 libux 兼容层封装统一；
- 注意：实际上，node 文件是用 C/C++ 编写的扩展文件，经编译后生产，故无需编译，只需加载 & 执行；
- 注意：执行时，模块的 exports 与 .node 模块相关联，然后返回给调用者；

**<u>*特殊文件模块：C/C++扩展模块*</u>**

- 编写：与核心模块相比，无需编写如 node 命名空间，即 `namespace node { ..`
- 加载：仅通过 `process.dlopeen` 动态加载；



### 3-4-2、核心模块编译

核心模块实际可分成 C/C++ 编写部分和 JS 编写两部分：

**<u>*核心模块 JS 编写部分：*</u>**

- 存储：在 lib 目录；
- 转换：使用 V8 的 `js2c.py` 工具，将 JS 代码 (`src/node.js & lib/*.js`) 转换成 C++ 数组，生成 `node_natives.h` 文件，并存储在 `NativeModule._source` 中；

  - 首先，通过 `process.binding(‘natives’)` 取出上述通过 `js2c.py` 转换的字符串数组，并将其重新转为普通字符串；
  - 然后，进行头尾包装以导出 `export` 对象；
  - 最后，编译成功的模块，将其文件路径作为索引，缓存在 `NativeModule._cache` 对象上；
  - 注意：转换 JS 码时，JS 代码以字符串形式，存储在 node 命名空间中，不可直接执行；
  - 注意：核心模块需编译，而文件模块还需进行路径分析、文件定位；
  - 注意：文件模块缓存中在 `Module._cache` 对象中；
  - 注意：当 Node 进程启动时，JS 代码将直接加载进内存JS 核心模块经标识符分析后直接定位到内存；

**<u>*核心模块 C/C++ 编写部分：*</u>**

- 存储：在 src 目录；
- 转换：因原本即用 C/C++ 编写，随后又被编译成二进制文件，故无需再转换；

  - 注意：当 Node 进程启动时，便被直接加载进内存，无需定位、分析、编译等步骤，直接可执行；
- 协助加载：在 Node 启动过程中，还会生成全局变量 `process`，其提供 `Binding` 方法协助加载；
- 真正加载：此时，会先构建 `exports` 对象，调用 `get_builtin_module` 方法取出模块，执行 `register_func` 填充 `exports` 对象，最后 `exports` 对象按模块名缓存，并返回给调用方完成导出；





