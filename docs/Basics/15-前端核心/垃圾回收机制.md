

# 三、V8 垃圾回收机制

**新生代内存**：用于存活较短的对象；

- 可再分成两个空间：from 空间 与 to 空间；
- Scavenge GC 算法：当 from 空间被占满时启动 GC；
  - 存活的对象从 from space 按一定顺序转移到 to space；
  - 清空 from space；
  - from space 与 to space 互换，完成 GC；
  - 以上过程不断循环；

**老生代内存**：用于存活时间较长的对象；

- 从 新生代 转移到 老生代 的条件：
  - 经历过一次以上 Scavenge GC 的对象；
  - 当 to space 体积超过 25%；
- Mark-Sweep GC 算法：标记存活的对象，未被标记的则被释放；
- Mark-Compact 整理算法：将内存中清除后导致的碎片化对象往内存堆的一端移动；

**增量标记**：小模块标记，在代码执行间隙执行，缓解因 GC 的阻塞现象；

**并发标记**(最新技术)：不阻塞 JS 执行；



## 3-1、V8内存限制与回收策略

V8 只能使用系统的一部分内存，比如在 64 位系统最多只能分配 1.4G，32 位系统最多只能分配 0.7G；而之所以这样限制，是因为：

- JS 是单线程的执行机制：一旦进入到垃圾回收，其它的各种运行逻辑都要暂停；
- JS垃圾回收机制的限制：垃圾回收过程非常耗时间；

<u>与其代码执行会一直没有响应，造成应用卡顿，所以还不如直接限制内存</u>；但注意某些场景还是可以提高内存限制的：

```js
// 调整老生代这部分的内存，单位是 MB
node --max-old-space-size=2048
```

```js
// 调整新生代这部分的内存，单位是 KB
node --max-new-space-size=2048
```



### 3-1-1、突破限制实际案例

Angular：打包项目的时候就遇到过频繁报内存溢出：

`FATAL ERROR: CALL_AND_RETRY_LAST Allocation failed - process out of memory`

解决：修改项目根目录  `node_modeles` 文件夹、`.bin` 目录、`ng`的文件首行：

`#!/usr/bin/env node --max_old_space_size=4096`

VueReact：[详看](https://blog.csdn.net/qq_35624642/article/details/81084331)



### 3-1-2、回收策略

通常情况下，垃圾数据回收分为 <u>手动回收</u> 和 <u>自动回收</u> 两种策略：

- **手动回收策略**：何时分配内存、何时销毁内存都是由代码控制的；
- **自动回收策略**：产生的垃圾数据是由垃圾回收器来释放的，并不需要手动通过代码来释放；



### 3-1-3、引用计数与标记清除

- **引用计数**：给一个变量赋值引用类型，则该对象的引用次数 +1，若此变量变成了其他值，则该对象的引用次数-1，垃圾回收器会回收引用次数为 0 的对象；但当对象循环引用时，会导致引用次数永远无法归零，导致内存无法释放；
- **标记清除**：垃圾收集器先给内存中所有对象加上标记，然后从根节点开始遍历，去掉被引用的对象和运行环境中对象的标记，剩下的被标记的对象即无法访问的、等待回收的对象；



### 3-1-4、内存生命周期

- 分配内存空间
- 读写内存
- 释放内存空间
  - 注意：对于分配内存和读写内存的行为所有语言都较为一致，但释放内存空间在不同语言之间有差异；

```js
var foo = 'bar' // 在堆内存中给变量分配空间
alert(foo)  // 使用内存
foo = null // 释放内存空间
```



### 3-1-5、内存空间分类

- 栈空间：由操作系统自动分配释放，存放函数的参数值，局部变量的值等，其操作方式类似于数据结构中的栈。
- 堆空间：一般由开发者分配释放，这部分空间就要考虑垃圾回收的问题。



基本数据类型用 **<u>栈</u>** 存储，引用数据类型用 **<u>堆</u>**  存储

- boolean、null、undefined、number、string、symbol、bigint

- 注意：对于赋值操作，原始类型的数据直接完整地赋值变量值，对象数据类型的数据则是复制引用地址；
- **<u>*注意：栈的功能除了保存变量外，还有创建并切换函数执行上下文的功能；当栈指针 ESP 下移，即上下文切换后，栈顶的空间会自动被回收；*</u>**

```js
function f(a) {
  console.log(a);
}
function func(a) {
  f(a);
}
func(1);

// 首先，调用 func, 将 func 函数的上下文压栈，ESP 指向栈顶；
// 然后，执行 func，又调用 f 函数，将 f 函数的上下文压栈，ESP 指针上移；
// 然后，执行完 f 函数，将 ESP 下移，f 函数对应的栈顶空间被回收；
// 然后，执行完 func，ESP 下移，func 对应的空间被回收；
```

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123700.png" style="zoom:40%;" align=""/>

此外，可观察到，若采用栈来存储相对基本类型更加复杂的对象数据，则切换上下文的开销将变得巨大；

```js
function test(person) {
  person.age = 26
  person = {
    name: 'hzj',
    age: 18
  }
  return person
}
const p1 = {
  name: 'fyq',
  age: 19
}
const p2 = test(p1)
console.log(p1) // p1：{name: “fyq”, age: 26}
console.log(p2) // p2：{name: “hzj”, age: 18}
// 原因:
// 在函数传参时, 传递的是对象在堆中的内存地址值，test  函数中的实参 person 是 p1 对象的内存地址，通过调用 person.age = 26 确实改变了 p1 的值，但随后person 变成了另一块内存空间的地址，并且在最后将这另外一份内存空间的地址返回，赋给了 p2;
```






## 3-2、栈内存数据回收管理

引擎会通过向下移动 ESP (记录当前执行状态的指针) 来销毁该函数保存在栈中的执行上下文；

栈的功能除了保存变量外，还有创建并切换函数执行上下文的功能；当栈指针 ESP 下移，即上下文切换后，栈顶的空间会自动被回收；

```js
function f(a) {
  console.log(a);
}
function func(a) {
  f(a);
}
func(1);

// 首先，调用 func, 将 func 函数的上下文压栈，ESP 指向栈顶；
// 然后，执行 func，又调用 f 函数，将 f 函数的上下文压栈，ESP 指针上移；
// 然后，执行完 f 函数，将 ESP 下移，f 函数对应的栈顶空间被回收；
// 然后，执行完 func，ESP 下移，func 对应的空间被回收；
```

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123700.png" style="zoom:30%;" align=""/>



## 3-3、堆内存数据回收管理

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123902.png" style="zoom:30%;" align=""/>

V8 的垃圾回收策略主要基于分代式垃圾回收机制，V8 引擎对堆内存中的 JS 对象进行了分代管理：**新生代**、 **老生代**，并根据不同种类的堆内存，采用不同的回收策略，来根据不同的场景做针对性的优化：

- 新生代内存：临时分配的内存，存活时间短的对象；如字符串、临时变量；
- 老生代内存：常驻内存，存活时间长的对象或常驻内存对象；如主控制器、服务器对象；
- 注意：V8 堆的整体大小=新生代所用内存空间+老生代的内存空间，且只能在启动时指定，即运行时无法自动扩充，若超过了极限值，就会引起进程出错；
- 注意：新生区通常只支持 1～8M 的容量，远小于老生区支持容量；对于两个区域，V8 分别使用两个不同的垃圾回收器，以便更高效地实施垃圾回收：
  - 副垃圾回收器，主要负责新生代的垃圾回收；
  - 主垃圾回收器，主要负责老生代的垃圾回收；
- 注意：不论什么类型的垃圾回收器，都有一套共同的执行流程：
  - 首先，标记空间中活动对象和非活动对象；前者即尚在使用的对象，后者即可进行垃圾回收的对象；
  - 然后，回收非活动对象所占据的内存；其实就是在所有的标记完成之后，统一清理内存中所有被标记为可回收的对象；
  - 最后，做内存整理：一般来说，频繁回收对象后，内存中就会存在大量不连续空间(内存碎片)，当内存中出现了大量的内存碎片之后，若需要分配较大连续内存的时候，就有可能出现内存不足的情况；所以最后一步需要整理这些内存碎片；(实际可选，因为有的垃圾回收器不会产生内存碎片)；



## 3-4、新生代内存回收

### 3-4-1、Scavenge 算法回收流程

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123903.png" style="zoom:50%;" align=""/>

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123904.png" style="zoom:30%;" align=""/>

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123905.png" style="zoom:30%;" align=""/>

首先，在 Scavenge 具体实现中，主要采用了一种复制的方式的方法—— Cheney 算法，此算法将新生代内存空间一分为二：处于使用状态的 From 部分，为 <u>对象区域</u>，表示正在使用的内存，处于闲置状态的 To 部分 为 <u>空闲区域</u>，是目前闲置的内存；

- 注意：分配对象时，先是在 From 空间中进行分配；

- 注意：新加入的对象都会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作；
- 注意：在垃圾回收过程中，首先要对对象区域中的垃圾做标记，标记完成之后，才进入垃圾清理阶段；

然后，当进行垃圾回收时，V8 将 From 部分的对象检查一遍，

- 若是存活对象，副垃圾回收器会把这些存活的对象复制到空闲区域 To，同时将这些对象有序地排列(即同时完成了内存整理操作)

- 若是非存活对象则直接回收；

然后，当所有 From 中的存活对象按照顺序进入 To 内存后，From 和 To 两者的角色<u>翻转</u>，即 From 现在被闲置，To 被使用，完成回收操作，如此循环；

- 注意：这种角色翻转操作，还能让新生代中的这两块区域无限重复使用下去；

不足：内存只能使用新生代内存的一半，但只存放生命周期短的对象，这种对象 `一般很少`，因此`时间`性能非常优秀；

优化：为提升执行效率，一般新生区空间会被设置得较小，故也容易被存活对象装满整个区域，为了解决此问题，JS 引擎采用了`对象晋升策略`：

- 已历过一次 Scavenge 回收：当一对象经过多次复制后依然存活，其将会被认为是生命周期较长的对象，随后会被移动到老生代中，采用新的算法进行管理；
- To (闲置) 空间的内存占用超过25%：若复制一个对象到 To 空间时，To 空间占用超过了 25%，则这个对象会被直接晋升到老生代空间中；



### 3-4-2、内存碎片处理策略

为解决存活对象的空间不连续对后续的空间分配造成障碍，To 内存按照一定顺序放置，以解决内存碎片问题：

- 比如：深色方块代表存活对象，白色部分表示待分配内存，因堆内存是连续分配，但零散的空间(内存碎片)会导致稍大对象无法进行空间分配；

- 注意：堆包含一个链表来维护已用和空闲的内存块。在堆上新分配(用 new 或者 malloc)内存是从空闲的内存块中找到一些满足要求的合适块，就须要一整块连续的内存空间才能申请成功；



<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123906.png" style="zoom:50%;" align=""/>

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123907.png" style="zoom:50%;" align=""/>



## 3-5、旧生代内存回收

对于老生代中的对象，主要采用标记-清除和标记-整理算法；

标记-清除 和前文提到的标记一样，与 Scavenge 算法相比，标记清除不会将内存空间划为两半，标记清除在标记阶段会标记活着的对象，而在内存回收阶段，它会清除没有被标记的对象；而标记整理是为了解决标记清除后留下的内存碎片问题；

### 3-5-1、Mark-Sweep 算法回收流程

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123908.png" style="zoom:30%;" align=""/>

首先，`标记阶段` 会遍历堆中所有对象，并做上标记；然后取消代码环境中 `使用的变量` 以及被 `强引用` 的变量的标记；

- 注意：标记阶段从一组根元素开始，递归遍历这组根元素(遍历调用栈)，在遍历过程中，能到达的元素称为 <u>活动对象</u>，否则可判断为 <u>垃圾数据</u>；

然后，`清除阶段` 对标记变量进行空间回收；

然后，整理内存碎片，将存活的对象全部往一端靠拢(最耗时)；

- 注意：清除算法后，会产生大量不连续的内存碎片，而碎片过多会导致大对象无法分配到足够的连续内存，于是又产生了 <u>标记—整理(Mark-Compact) 算法</u>，其标记过程仍然与 Mark-Sweep 一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存，从而让存活对象占用连续的内存块；

不足：内存碎片最耗时；



### 3-5-2、内存碎片处理策略

为解决存活对象的空间不连续对后续的空间分配造成障碍，将存活的对象全部往一端靠拢，以解决内存碎片问题；

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123909.png" style="zoom:50%;" align=""/>



### 3-5-3、算法比较

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123910.png" style="zoom:50%;" align=""/>



## 3-6、增量标记

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123911.png" style="zoom:50%;" align=""/>

前面的三种算法，均需将正在执行的 JS 应用逻辑暂停下来，待垃圾回收完毕后再恢复，这种行为叫作"全停顿"(stop-the-world)；

在 V8 新生代的分代回收中，只收集新生代，而新生代通常配置较小，且存活对象较少，所以全停顿的影响不大，而老生代则相反；

为降低全部老生代全堆垃圾回收带来的停顿时间，V8 将标记过程分为一个个的子标记过程，同时让垃圾回收标记和JS应用逻辑交替进行，直到标记阶段完成；

补充：

V8 在进行垃圾回收时，由于 JS 单线程机制，不可避免地会阻塞业务逻辑执行(<u>全停顿</u>)；在 V8 新生代的垃圾回收中，因其空间较小，且存活对象较少，故全停顿影响不大，但老生代则不同，为了降低老生代的垃圾回收而造成的卡顿，V8 采取 **<u>增量标记(Incremental Marking)算法</u>** ：

将标记过程分为一个个的子标记过程，同时让垃圾回收标记和 JS 应用逻辑交替进行，直到标记阶段完成，才进入内存碎片的整理；

- 使用增量标记算法，可将一完整的垃圾回收任务拆分为很多小的任务，而小任务执行时间较短，可穿插在其他的 JS 任务中间执行，如此当执行某些动画效果时，就不会让用户因为垃圾回收任务而感受到页面的卡顿；使得垃圾回收过程对 JS 应用的阻塞时间减少为原来的 1 / 6；





## 3-7、内存泄露

不再用到的内存，没有及时释放，就叫做内存泄漏(Memory Leak)；

或称程序中己动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果；



### 3-7-1、内存泄露原因

- 意外的**全局变量**: 无法被回收
- **定时器**: 未被正确关闭，导致所引用的外部变量无法被释放
- **闭包**: 会导致父级中的变量无法被释放；
- **事件监听**: 没有正确销毁 (低版本浏览器可能出现)
- **dom 引用**: dom 元素被删除时，内存中的引用未被正确清空

- 缓存：缓存须有存储容量上限，否则高内存消耗将会导致缓存突破上限，而缓存内容无法被回收；

- 队列消费不及时：当浏览器队列消费不及时时，会导致一些作用域变量得不到及时的释放，因而导致内存泄漏；

- 全局变量：意外导致的全局变量，如：

```js
function foo(arg) {
	// 由于 this 使用不当导致的全局变量
	this.bar = "this is a hidden global variable"
	// 没有使用 var/let/const 定义变量导致全局变量
  bar = "this is a hidden global variable";
}
```

- 计时器中引用没有清除

```
var someData = getData();
setInterval(function() {
    var node = document.getElementById('Node');
    if(node) node.innerHTML = JSON.stringify(someData));
}, 1000);
// Node 节点被删除后，会导致计时器中的回调函数无法被回收，同时，someData 数据也是无法被回收的；
```

- 闭包

```js
var theThing = null;
var replaceThing = function () {
  var originalThing = theThing;
  // 变量 unused 是一个引用 originalThing(theThing) 的闭包，闭包的作用域一旦创建，便有同样的父级作用域，作用域是共享的
  var unused = function () {
    if (originalThing)
      console.log("hi");
  };
  theThing = {
    longStr: new Array(1000000).join('*'),
    // someMethod 可通过 theThing 使用，someMethod 与 unused 分享闭包作用域
    // 尽管 unused 从未使用，它引用的 originalThing 迫使它保留在内存中
    someMethod: function () {
      console.log(someMessage);
    }
  };
};
setInterval(replaceThing, 1000);
// 每次调用 replaceThing ，theThing 会创建一个大数组和一个新闭包(someMethod)的新对象
// 闭包的链表已创建，每一个闭包作用域携带一个指向大数组的间接的引用，造成严重的内存泄漏
```

- 事件监听：

  - 比如：Node.js 中 Agent 的 keepAlive 为 true 时，可能造成的内存泄漏；
  - 因为：当 Agent keepAlive 为 true 时，将会复用之前使用过的 socket，若在 socket 上添加事件监听而忘记清除的话，因为 socket 的复用，将导致事件重复监听从而产生内存泄漏；

- Dom 引用

  - <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123912.png" style="zoom:50%;" align=""/>

  - 应当增加：element = null

  - ```js
    // 例子2
    var element = document.getElementById('element')
    element.innerHTML = '<button id="button">点击</button>'
    
    var button = document.getElementById('button')
    button.addEventListener('click', function() {
        // ...
    })
    
    element.innerHTML = ''
    // 代码执行后，因 element.innerHTML = ''，button 元素已从 DOM 中移除了，但由于其事件处理句柄还在，所以依然无法被垃圾回收；还需增加 removeEventListener
    ```

    



### 3-7-2、[内存泄露识别](https://juejin.im/post/5db2beb8e51d455b450a64b4#heading-8)

用 chrome 中的 timeline 进行内存标记，可视化查看内存的变化情况，找出异常点；



### 3-7-3、内存泄露避免

- 避免使用全局变量，避免意外产生全局变量；
- 使用闭包要及时注意，有 DOM 元素的引用要及时清理;
- 计时器里的回调没用时要记得销毁；
- 为避免疏忽导致的遗忘，可使用 `WeakSet` 和 `WeakMap` 结构，它们对于值的引用都是不计入垃圾回收机制的，表示这是弱引用：

```js
// 基本上，如果你要往对象上添加数据，又不想干扰垃圾回收机制，就可以使用 WeakMap
const wm = new WeakMap();
const element = document.getElementById('example');

// 一旦消除对该节点的引用，它占用的内存就会被垃圾回收机制释放, Weakmap 保存的这个键值对，也会自动消失
wm.set(element, 'some information');
wm.get(element) // "some information"
```



## 3-X、V8 优化

JS 问题：

- **动态类型**：导致每次存取属性/寻求方法时，都需要先检查类型；此外动态类型也很难在编译阶段进行优化；
- **属性存取**：C++/Java等语言中方法、属性是存储在数组中的，仅需数组位移就可以获取，而 JS 存储在对象中，每次获取都要进行哈希查询；

V8 优化：

- **优化 JIT (即时编译)**：相较于C++/Java这类编译型语言，JS 边解释边执行，效率低；
  - V8 对此过程进行了优化：若一段代码被执行多次，则将此段代码转化为机器码缓存下来，下次运行时直接使用机器码；
- **隐藏类**：C++ 这类语言仅需几个指令就能通过偏移量获取变量信息，而 JS 需要进行字符串匹配，效率低下；
  - V8 借用类和偏移位置的思想，将对象划分成不同的组，即隐藏类；
- **内嵌缓存**：即缓存对象查询的结果；常规查询过程是：获取隐藏类地址 -> 根据属性名查找偏移值 -> 计算该属性地址，内嵌缓存就是对这一过程结果的缓存；
- **垃圾回收**：前文已介绍；