

# 二、Event Loop

前面讲到，执行 JS 代码时其实就是往执行栈中放入函数，而当遇到异步的代码时，会被 **挂起** 并在需要执行时加入到 Task(有多种 Task) 队列中；一旦执行栈为空，Event Loop(事件循环机制) 就会从 Task 队列 中拿出需要执行的代码并放入执行栈中执行；

**<u>*补充内容*</u>**：

浏览器(多进程)包含了**Browser进程**(浏览器的主进程)、**第三方插件进程**、**GPU进程**(浏览器渲染进程)等，其中**GPU进程**(多线程)与前端密切相关，包含以下线程：

- **GUI渲染线程**
- **JS引擎线程**(注意：GUI渲染线程、JS引擎线程互斥，为防止DOM渲染不一致性，其中一线程执行时另一线程会被挂起)
- **事件触发线程**(和EventLoop密切相关)
- **定时触发器线程**
- **异步HTTP请求线程**

浏览器页面初次渲染完毕后，**JS引擎线程**结合**事件触发线程**的工作流程如下：

- 同步任务在 **JS引擎线程**(主线程)上执行，形成**执行栈**(Execution Context Stack)；
- 主线程之外，**事件触发线程** 管理着一个**任务队列**(Task Queue)只要异步任务有了运行结果，就在**任务队列**之中放置一个事件；
- **执行栈** 中的同步任务执行完毕，系统就会读取**任务队列**，如果有异步任务需要执行，将其加到主线程的**执行栈**并执行相应的异步任务；

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123822.png" style="zoom:50%;" />

**<u>*事件循环机制*</u>**：**事件触发线程**管理的任务是从**JS引擎线程**本身产生，主线程在运行时会产生**执行栈**，栈中的代码调用某些异步API时会在**任务队列**中添加事件，栈中的代码执行完毕后，就会读取**任务队列**中的事件，去执行事件对应的回调函数，如此循环往复，形成事件循环机制

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123823.png" style="zoom:50%;" />

JS中有两种任务类型：**微任务**(microtask)和**宏任务**(macrotask)，在ES6中，microtask称为 jobs，macrotask称为 task。

**宏任务**： script (主代码块)、`setTimeout` 、`setInterval` 、`setImmediate` 、I/O 、UI rendering；

**微任务**：`process.nextTick`(Nodejs) 、`promise` 、`Object.observe` 、`MutationObserver`；

注意：**宏任务**并非全是异步任务，主代码块就是属于**宏任务**的一种 (Promises/A+规范**)；

它们之间区别如下：

- **宏任务**是每次**执行栈**执行的代码(包括每次从事件队列中获取一个事件回调并放到执行栈中执行)
- 浏览器为了能够使得**JS引擎线程**与**GUI渲染线程**有序切换，会在当前**宏任务**结束之后，下一个**宏任务**执行开始之前，对页面进行重新渲染(**宏任务** > 渲染  > **宏任务** > ...)
- **微任务**是在当前**宏任务**执行结束之后立即执行的任务(在当前 **宏任务**执行之后，UI渲染之前执行的任务)。**微任务**的响应速度相比`setTimeout`(下一个**宏任务**)会更快，因为无需等待UI渲染。
- 当前**宏任务**执行后，会将在它执行期间产生的所有**微任务**都执行一遍。

总结：

- **宏任务**中的事件是由**事件触发线程**来维护；
- **微任务**中的所有任务是由**JS引擎线程**维护的(这只是自我猜测，因为**宏任务**执行完毕后会立即执行**微任务**，为了提升性能，这种无缝连接的操作放在**事件触发线程**来维护明显是不合理的)。

根据事件循环机制，重新梳理一下流程：

- 执行一个**宏任务**(首次执行的主代码块或者**任务队列**中的回调函数)
- 执行过程中如果遇到**微任务**，就将它添加到**微任务**的任务队列中
- **宏任务**执行完毕后，立即执行当前**微任务**队列中的所有任务(依次执行)
- **JS引擎线程**挂起，**GUI线程**执行渲染
- **GUI线程**渲染完毕后挂起，**JS引擎线程**执行**任务队列**中的下一个**宏任务**





### 2-1、宏微任务

JS 中的大部分任务都是在主线程上执行，常见的任务有：渲染事件、用户交互事件、JS 脚本执行、网络请求、文件读写完成事件等；而为让事件有条不紊地进行，JS 引擎需对执行顺序做一定处理，并采用 <u>队列</u> 的方式存储这些任务；比如 执行 for 循环时，将队列中的任务逐一取出并执行；但注意队列包含两种任务队列：

- <u>**普通任务队列**</u>：
- <u>**延迟任务队列**</u>：专门处理诸如 setTimeout/setInterval 等定时器回调任务；

```js
bool keep_running = true;
void MainTherad(){
  for(;;){
    // 执行队列中的任务
    Task task = task_queue.takeTask();
    ProcessTask(task);
    // 执行延迟队列中的任务
    ProcessDelayTask()
    if(!keep_running) // 若设置了退出标志，则直接退出线程循环
        break; 
  }
}
```

对于每个宏任务而言，其内部都有一个微任务队列，而**<u>引入微任务的初衷是为了解决异步回调的问题</u>**，对于异步回调的处理方式如下：

- 将异步回调进行宏任务队列的入队操作；
- 将异步回调放到当前宏任务的末尾；

若采用第一种方式，则执行回调的时机应在 <u>前面所有的宏任务完成之后</u>；若任务队列非常长，则回调迟迟得不到执行，造成 <u>应用卡顿</u>；

为规避这样的问题，V8 采用第二种方式，也即 微任务的解决形式：在每一个宏任务中定义一个 <u>**微任务队列**</u>，当该宏任务执行完成，会检查其中的微任务队列，若为空则直接执行下一个宏任务，否则依次执行微任务，执行完成才去执行下一个宏任务；



### 2-1-1、宏微任务分类

- 宏任务—MacroTask：整体代码、setTimeout、setInterval、setImmediate、I/O、UI rendering、WebWorker等；
- 微任务—MicroTask：process.nextTick、Promises.then/reject-catch-finally、Object.observe、MutationObserver、以 Promise 为基础开发的其他技术(比如fetch API)、V8 的垃圾回收过程等；



### 2-2、浏览器 EvLoop

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123824.png" style="zoom:50%;" />

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123825.png" style="zoom:50%;" />

- 首先，将整段脚本作为首个 **宏任务** 执行；
- 然后，执行过程中同步代码直接执行，**宏任务** 进入宏任务队列，**微任务**进入微任务队列；
- 然后，当前宏任务执行完全，执行栈为空，检查微任务队列，若有则依次执行，直到微任务队列为空；
- 然后，执行浏览器 UI 线程的渲染工作；
- 然后，检查是否有 Web worker 任务，有则执行；
- 最后，执行队首新的宏任务，回到第二步，依此循环，直到宏任务和微任务队列都为空；

```js
Promise.resolve().then(()=>{
  console.log('Promise1')  
  setTimeout(()=>{
    console.log('setTimeout2')
  },0)
});
setTimeout(()=>{
  console.log('setTimeout1')
  Promise.resolve().then(()=>{
    console.log('Promise2')    
  })
},0);
console.log('start');

// start
// Promise1
// setTimeout1
// Promise2
// setTimeout2
```



### 2-3、Node EvLoop

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123826.png" style="zoom:50%;" align=""/>

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123827.png" style="zoom:50%;" />



### 2-3-1、关键执行阶段

Node 有三个非常重要的执行阶段：

- **<u>执行定时器回调阶段</u>**：亦称 **<u>timer 阶段</u>**：检查定时器诸如 setTimeout、setInterval，若到时间，就执行回调；

- **<u>轮询阶段</u>**：亦称 **<u>poll 阶段</u>**：Node 代码的异步操作，比如 文件I/O、网络I/O等执行完成后，就会通过 `data`、 `connect` 等事件，使得事件循环到达  `poll` 阶段，以通知 JS 主线程，到达了这个阶段后：
  - 若当前已存在定时器，且有定时器到达时间，便拿出执行，EventLoop 将回到  **<u>timer 阶段</u>**；
  - 若无定时器, 便会查看回调函数队列；
    - 若队列不为空，便遍历 callback 队列并同步执行，直到队列为空或者达到系统限制；
    - 若队列为空，则检查是否有 `setImmdiate` 回调；
      - 若有则前往 **<u>check 阶段</u>**；
      - 若无则继续等待，相当于阻塞了一段时间，等待 callback 被加入到队列中并立即执行，达到超时时间后则自动进入 **<u>check 阶段</u>**；

- **<u>check 阶段</u>**：相对简单的阶段，直接执行 `setImmdiate` 的回调；

上述三个阶段为一个循环过程，也是 Node 执行的最重要阶段，但不完整；



### 2-3-2、关键执行阶段完善

**<u>注意：若对过程不理解，可参考例子  2-5-4：定时器的执行顺序</u>**

- **<u>执行定时器回调阶段</u>**：亦称 **<u>timer 阶段</u>**：检查定时器诸如 setTimeout、setInterval，若到时间，就执行回调；**<u>注意，此阶段由 poll 阶段控制；</u>**
- **<u>I/O 异常回调阶段</u>**：处理上一轮循环中的 <u>少数未执行</u> 的 I/O 回调，比如 TCP 连接遇到 ECONNREFUSED，就会在此时执行回调；
- **<u>空闲、预备状态</u>**：第 2 阶段结束，poll 阶段未触发之前；

- **<u>轮询阶段</u>**：亦称 **<u>poll 阶段</u>**：此阶段会做两件事：
  - 回到 timer 阶段执行回调；
  - 执行 I/O 回调；
- 具体做法是：进入 **<u>poll 阶段</u>** 后：
  - 若当前已存在定时器，且 poll callback 函数队列为空，且有定时器到达时间，EventLoop 将回到  **<u>timer 阶段</u>**(拿出到时的定时器回调执行)；
  - 若无设定定时器, 便会查看 poll callback 函数队列；
    - 若队列不为空，便遍历 poll callback 队列并同步执行，直到队列为空或者达到系统限制；
      - **<u>关键：当 Node 代码异步操作(比如 文件I/O、网络I/O等)执行完成后，就会通过 `data`、 `connect` 等事件通知，使得 Ev Loop 到达  `poll` 阶段;</u>**
    - 若队列为空，则检查是否有 setImmdiate 回调；
      - 若有则前往 **<u>check 阶段</u>**；
      - 若无则继续等待，相当于阻塞了一段时间，等待 callback 被加入到队列中并立即执行，达到超时时间后则自动进入 **<u>check 阶段</u>**；

- **<u>check 阶段</u>**：相对简单的阶段，直接执行 setImmdiate 的回调；
- **<u>关闭事件的回调阶段</u>**：若一个 socket 或句柄 (handle) 被突然关闭，比如 socket.destroy()， `close` 事件回调就会在此阶段执行；

**<u>上述描述的是 macrotask 执行情况，对于 microtask 来说，它会在以上每个阶段完成前 清空  microtask 队列，下图中的 Tick 就代表了 microtask：</u>**

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123828.png" style="zoom:50%;" align=""/>





### 2-3-3、Node 版本差异

- node 版本 >= 11：与浏览器表现一致，定时器运行完立即运行相应的微任务；
- node 版本 < 11：若第一个定时器任务出队并执行完，发现队首任务仍是一个定时器，则将微任务暂时保存，直接去执行新的定时器任务，当新的定时器任务执行完后，再一一执行中途产生的微任务；

```js
setTimeout(()=>{
    console.log('timer1')
    Promise.resolve().then(function() {
        console.log('promise1')
    })
}, 0)
setTimeout(()=>{
    console.log('timer2')
    Promise.resolve().then(function() {
        console.log('promise2')
    })
}, 0)
// node 版本 >= 11
timer1
promise1
time2
promise2
// node 版本 < 11
timer1
timer2
promise1
promise2
```



### 2-4、两者间的差别

最主要的区别在于：浏览器中的微任务是在 **<u>每个相应的宏任务</u>** 间执行的，而 Node  中的微任务是在 **<u>不同阶段间</u>** 执行的；



### 2-5、注意事项

### 2-5-1、process.nextTick 执行

process.nextTick 是独立于 Node EvLoop 的任务队列；

当每个 NodeEvLoop 阶段完成后，若存在 nextTick 队列，就会 **<u>清空队列中的所有回调函数</u>**，且**<u>优先于其他微任务</u>** 执行；

```js
setTimeout(() => {
 console.log('timer1')

 Promise.resolve().then(function() {
   console.log('promise1')
 })
}, 0)

process.nextTick(() => {
 console.log('nextTick')
 process.nextTick(() => {
   console.log('nextTick')
   process.nextTick(() => {
     console.log('nextTick')
     process.nextTick(() => {
       console.log('nextTick')
     })
   })
 })
})
// 以上代码，无论如何，永远都是先把 nextTick 全部打印出来


// Ex2
setTimeout(function() {
  console.log('timeout')
})

process.nextTick(function(){
  console.log('nextTick 1')
})

new Promise(function(resolve){
  console.log('Promise 1')
  resolve();
  console.log('Promise 2')
}).then(function(){
  console.log('Promise Resolve')
})

process.nextTick(function(){
  console.log('nextTick 2')
})
// Node环境(10.3.0版本)中打印的顺序： Promise 1 > Promise 2 > nextTick 1 > nextTick 2 > Promise Resolve > timeout
// Node.js的v10.x版本中对于 process.nextTick 的说明如下：
The process.nextTick() method adds the callback to the "next tick queue". Once the current turn of the event loop turn runs to completion, all callbacks currently in the next tick queue will be called.
This is not a simple alias to setTimeout(fn, 0). It is much more efficient. It runs before any additional I/O events (including timers) fire in subsequent ticks of the event loop.
```

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123829.png" style="zoom:50%;" align=""/>

```js
// Node 环境下:
// 1 7(主阶段) 6(process.nextTick在阶段间、微任务前执行) 8(微任务) 2 4 9 11(poll 执行 timer 回调) 3 10(阶段间、微任务前) 5 12(微任务)

// 浏览器下: 可用 Promise.resolve().then(()=>{ 替换 process.nextTick；
//  1 7 6 8 2 4 3 5 9 11 10 12
```



<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123830.png" style="zoom:50%;" align=""/>

```js
// 1 10(宏) 8 9(nextTick) 5 7(微) 2 6(timer) 3(微) 4(nextTick)
```

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123831.png" style="zoom:50%;" align=""/>

```js
// 1 7(宏) 6(nextTick) 8(微) 2 4 9 11(timer) 3 10(nextTick) 5 12(微)
```

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123832.png" style="zoom:50%;" align=""/>

```js
// 1 7 6 8 2 4 3 5 9 11 10 12
```

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123833.png" style="zoom:50%;" align=""/>

```js
// 1 7 6 8 9 11 10 12 2 4 3 5
```



### 2-5-2、await 执行

基本：

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123834.png" style="zoom:50%;" align=""/>

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123835.png" style="zoom:50%;" align=""/>

关键：将 await 同行代码化为 new Promise 内容(同步)，将 await 后行内容化为 promise.then 内容即可

```js
console.log('script start')

async function async111() {
  await async2222()
  console.log('async1 end')
}
async function async2222() {
  console.log('async2 end')
}
async111()

setTimeout(function() {
  console.log('setTimeout')
}, 0)

new Promise(resolve => {
  console.log('Promise')
  resolve()
})
.then(function() {
  console.log('promise1')
})
  .then(function() {
  console.log('promise2')
})

console.log('script end')
// script start => async2 end => Promise => script end => async1 end => promise1 => promise2 => setTimeout
```



<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123836.png" style="zoom:50%;" align=""/>

```js
// scriptStart => async1Start => async2 => promise1 => scriptEnd => async1End => promise2 => setTimeout
```



<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123837.png" style="zoom:50%;" align=""/>

```js
// scriptStart => async1Start => promise1 => promise3 => scriptEnd => promise2 => async1End(注意顺序) => promise4 => setTimeout
```



<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123838.png" style="zoom:50%;" align=""/>

```js
// scriptStart => async1Start => promise1 => scriptEnd => promise2 => setTimeout3 => setTimeout2 => setTimeout1
```



<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123839.png" style="zoom:50%;" align=""/>

```js
// scriptStart => a1Start => a2 => promise2 => scriptEnd => promise1 => a1End => promise2Then => promise3 => setTimeout
```





### 2-5-3、EvLoop 进入成本

进入 EvLoop 也是需要成本的：`setTimeout(fn, 0) === setTimeout(fn, 1)`

- 若准备时间花费大于 1ms，则在 timer 阶段就会直接执行 `setTimeout` 回调；
- 若准备时间花费小于 1ms，则 `setImmediate` 回调先执行；

```js
setTimeout(() => {
  console.log('timer21')
}, 0)

Promise.resolve().then(function() {
  console.log('promise1')
})
// EvLoop 准备时间不可能小于 0ms 故必定经历 timers 阶段，阶段经历后，清空微任务队列，故输出：promise1 -> timer21
```



### 2-5-4、定时器的执行顺序

注意：某些情况下，定时器的执行顺序其实是 **随机** 的，这是由源码决定的：

```js
setTimeout(() => {
    console.log('setTimeout')
}, 0)
setImmediate(() => {
    console.log('setImmediate')
})
// setTimeout 可能执行在前，也可能执行在后
```

注意：而在某些情况下，定时器的执行顺序一定是 **固定** 的(有误)：

```js
const fs = require('fs')

fs.readFile(__filename, () => {
    setTimeout(() => {
        console.log('timeout');
    }, 0)
    setImmediate(() => {
        console.log('immediate')
    })
})
```

**<u>注意：若忘记 NodeEvLoop具体流程，可回看 2-3-2、NodeEvLoop 关键阶段完善</u>**

在上述代码中，`setImmediate` 永远**先执行**；分析过程：

- 首先，进入 Node EvLoop；
- 然后，当 Node 代码异步操作(比如 文件I/O、网络I/O等)执行完成后，就会通过 `data`、 `connect` 等事件通知，使得 Ev Loop 到达  **<u>poll 阶段</u>**；
- 因为，两个代码写在 IO 操作(此处是文件IO)的回调中，而 IO 回调是在 **<u>poll 阶段</u>**执行的；
- 所以，进入 **<u>poll 阶段</u>**后，首先主体代码无发现定时器，遂查看 poll callback 函数队列，且队列为空，并发现存在 `setImmediate` 回调，跳转到 check 阶段；
- 最后，**<u>check 阶段</u>** 直接执行 `setImmdiate` 的回调；



### 2-5-5、new Promise 执行

基本：new Promise 相当于同步任务，会立即执行；

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123840.png" style="zoom:50%;" align=""/>



**<u>注意：分析嵌套 Promise 关键</u>**：厘清微任务，执行顺序还是宏微宏微，若无宏任务，则连续执行微任务，**<u>但执行顺序是按加入微任务队列的先后执行的</u>**；

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123841.png" style="zoom:50%;" align=""/>

比如：上图一轮：promise1 后只有 then 微任务，遂进入 then 执行，输出 then11 和 promise2，随后发现 2 个微任务：一个是里面的 then，一个是外面的 then，然后执行…

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123842.png" style="zoom:50%;" align=""/>

```js
// promise1 => then11 => promise2 => then21 => then12 => then23
```



<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123843.png" style="zoom:50%;" align=""/>

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123844.png" style="zoom:50%;" align=""/>

```
// promise1 => promise3 => then11 => promise2 => then31 => then21 => then12 => then23
```



<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123845.png" style="zoom:50%;" align=""/>

```js
// 1 2 3 4 5 6 7 8 9
```



**<u>注意：处理——内里 return Promise 的关键</u>**：回归链式调用，由上往下执行

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123846.png" style="zoom:50%;" align=""/>

```js
// promise1 => then11 => promise2 => then21 => then23 => then12
```





### 2-6、示例集合

### 2-6-1、浏览器环境示例

```js
console.log('ss');
setTimeout(function() {
  console.log('setTimeout');
}, 0)
Promise.resolve().then(function() {
  console.log('p1t1');
}).then(function() {
  console.log('p1t2')
})
console.log('se');
// ss se p1t1 p1t2 setTimeout
// 宏任务 script -> 再微任务 promise1 2，再宏任务 setTimeout



// Ex2
console.log('ss');
setTimeout(function() {
  console.log('setTimeout');
}, 0)
Promise.resolve().then(function() {
  console.log('p1t1');
}).then(function() {
  console.log('p1t2')
})
Promise.resolve().then(function() {
  console.log('p2t1');
}).then(function() {
  console.log('p2t2')
})
console.log('se');
// ss se p1t1 p2t1 p1t2 p2t2 setTimeout
// 注意: 链式调用并非链式添加微任务，每当添加完后就离开执行外面内容，而非一直链式添加微任务队列



// Ex3
// 1
console.log('ss');
// 16
setTimeout(function() {
  console.log('setTimeout');
}, 0)
// 执行时发现微任务 3-p1t1，塞入微任务队列1
Promise.resolve().then(function() {
  // 3
  console.log('p1t1');
  // 执行时发现微任务 5-p1t2，塞入微任务队列2
}).then(function() {
  // 5
  console.log('p1t2');
  // 执行时发现微任务 7-p1t3，塞入微任务队列3
}).then(function() {
  // 7
  console.log('p1t3');
  // 执行时发现微任务 10-p1t3-t1，塞入微任务队列4
  Promise.resolve().then(function(){
    // 10
    console.log('p1t3-t1');
    // 执行时发现微任务 12-p1t3-t1-t1，塞入微任务队列5
    Promise.resolve().then(function(){
      // 12
    	console.log('p1t3-t1-t1');
  	})
    // 执行时发现微任务 13-p1t3-t2，塞入微任务队列5
  }).then(function(){
    // 13
    console.log('p1t3-t2');
  })
})
// 执行时发现微任务 4-p2t1，塞入微任务队列1
Promise.resolve().then(function() {
  // 4
  console.log('p2t1');
  // 执行时发现微任务 6-p2t2，塞入微任务队列2
}).then(function() {
  // 6
  console.log('p2t2');
  // 执行时发现微任务 8-p2t2-t1，塞入微任务队列3
  Promise.resolve().then(function(){
    // 8
    console.log('p2t2-t1');
    // 执行时发现微任务 11-p2t2-t2，塞入微任务队列4
  }).then(function(){
    // 11
    console.log('p2t2-t2');
    // 执行时发现微任务 14-p2t2-t2-t1，塞入微任务队列5
    Promise.resolve().then(function(){
      // 14
    	console.log('p2t2-t2-t1');
      // 执行时发现微任务 15-p2t2-t2-t1-t1，塞入微任务队列6
      Promise.resolve().then(function(){
        // 15
    		console.log('p2t2-t2-t1-t1');
  		})
  	})
  })
  // 执行时发现微任务 9-p2t3，塞入微任务队列3
}).then(function() {
  // 9
  console.log('p2t3')
})
// 2
console.log('se');

// ss
// se
// p1t1
// p2t1
// p1t2
// p2t2
// p1t3
// p2t2-t1
// p2t3
// p1t3-t1
// p2t2-t2
// p1t3-t1-t1
// p1t3-t2
// p2t2-t2-t1
// p2t2-t2-t1-t1
// setTimeout
```





<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123847.png" style="zoom:50%;" align=""/>

```js
// 先宏任务124 -> 再微任务then-53 -> 再宏任务6
```



<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123848.png" style="zoom:50%;" align=""/>

```js
// 1 8(宏) 3 4 5 7(微) 2(宏) 6(宏)
```



<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123849.png" style="zoom:50%;" align=""/>

```js
// click(宏) promise(微) mutate(微) click(宏) promise(微) mutate(微) timeout(宏) timeout(宏)
// 相当于两个 onClick 事件函数展开，mutationOb 是微任务
```



<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123850.png" style="zoom:50%;" align=""/>

```js
// 1 3 5(宏) 4(微) 2(宏)
```



<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123851.png" style="zoom:50%;" align=""/>

```js
// "马上..、代码..."(宏) "then"(微) "定时器"(宏)
```



<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123852.png" style="zoom:50%;" align=""/>

```js
// 2 3 5(宏) 4(微) 1(宏)
```

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123853.png" style="zoom:50%;" align=""/>

```js
// 1 10(宏) 5 8 7 9(微-注意顺序) 2(宏) 3 4(微) 6(宏) 
// 执行微任务遇到微任务，先塞入队列，注意顺序
```

更多详看：[这里](https://www.cnblogs.com/lpggo/p/8127604.html)





### 2-6-2、Node 环境示例

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123854.png" style="zoom:40%;" align=""/>

```js
// start end(宏) promise3(微) timer1 timer2(timer阶段) promise1 promise2(微)
```

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123855.png" style="zoom:60%;" align=""/>

```js
// scriptStart async1Start async2 promise1 scriptEnd(宏，其中 async 同行等同 new promise, 而行后内容可视为 promise.then) process(nextTick) async1End promise2(微) setTimeout(timer阶段) setImmediate(check阶段)
```

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123856.png" style="zoom:60%;" align=""/>

```js
// scriptStart async1Start async2 promise1 scriptEnd(宏) async1End promise2(微) setTimeout(timer 阶段)
```


