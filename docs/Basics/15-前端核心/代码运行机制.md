# 一、V8 JS 运行机制

## 1-1、Make—执行代码

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123701.png" style="zoom:40%;" align=""/>

机器读不懂 JS 代码，机器只能理解特定的机器码；而 JS 属于解释型语言，需要先用解释器会对源代码进行解释转换；

- **预解析 parser**：<u>检查语法错误</u>；
- **生成 AST**：<u>经过词法分析/语法分析</u>，生成  **<u>AST 抽象语法树</u>**；
- **生成字节码**：**<u>基线编译器 (Ignition)</u>** 将 AST 转换成 **<u>字节码</u>**；
- **生成机器码**：**<u>优化编译器 (Turbofan)</u>** 将字节码转换成优化过的 **<u>机器码</u>**，此外在逐行执行字节码的过程中，若某段代码经常被执行， V8 会将这段代码直接转换成机器码保存起来，下一次执行就不必经过字节码转换阶段，优化执行速度；
- **执行代码**；



### 1-1-1、预解析

### 1-1-2、生成 AST

**抽象语法树 (Abstract Syntax Tree)**，是将代码逐字母解析成 **树状对象** 的形式；这是语言间的转换、代码语法检查、风格检查、格式化、高亮、错误提示、自动补全等；生成 AST 分为两步：词法分析和语法分析：

- 词法分析：即分词，将一行行的代码分解成一个个 token；
- 语法分析：将生成的 token 数据，根据一定的语法规则转化为 AST；

注意：生成了 AST 后，编译器/解释器后续的工作都将依靠 AST 而非源代码；

注意：babel 工作原理即将 ES5 的代码解析生成 <u>ES5 的 AST</u>，然后将 ES5 的 AST 转换为 <u>ES6 的 AST</u>，最后才将 ES6 的 AST 转化为具体的 ES6 代码；

- babylon 将 ES6/ES7 代码解析成 AST；
- babel-traverse 对 AST 进行遍历转译，得到新的 AST；
- 新 AST 通过 babel-generator 转换成 ES5；

```js
function square(n){
	return n * n
}
// 通过解析转化成的 AST 如下图
```

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123702.png" style="zoom:30%;" align=""/>

补充：Babel 原理：大多数 JS Parser遵循 `estree` 规范，Babel 最初基于 `acorn` 项目(轻量级现代 JavaScript 解析器) Babel大概分为三大部分：

- 解析：将代码转换成 AST
  - 词法分析：将代码(字符串)分割为 token 流，即语法单元成的数组；
  - 语法分析：分析token流(上面生成的数组)并生成 AST；
- 转换：访问 AST 的节点进行变换操作生产新的 AST；
  - 比如：[Taro](https://github.com/NervJS/taro/blob/master/packages/taro-transformer-wx/src/index.ts#L15) 即利用 babel 完成的小程序语法转换；
- 生成：以新的 AST 为基础生成代码；










### 1-1-3、生成字节码

生成 AST 之后，通过 V8 **<u>基线解释器(Ignition)</u>** 生成字节码；

- 子节码：是介于 AST 和 机器码间的代码，但与特定类型的机器码无关，字节码需要通过解释器将其转换为机器码然后执行；
- **注意：V8 早期是直接转为机器码，但体积太大，会有严重内存占用问题；后来通过解释器逐行执行字节码，省去了生成二进制文件的操作，减少内存压力；**





### 1-1-4、生成机器码

生成字节码后，通过 **<u>优化编译器 (Turbofan)</u>** 将字节码编译成优化过的 **<u>机器码</u>**；

- 注意：在逐行执行字节码的过程中，若 Turbofan 发现某段代码经常被执行， 则 V8 会将这段代码标记为 <u>热点代码(HotSpot)</u>，并将这段代码直接转换成机器码保存起来，下一次执行就不必经过字节码转换阶段，以优化执行速度；如此执行时间越久，执行效率越高；

- 注意：**<u>JS 并非纯粹的解释器语言，因为字节码不仅配合解释器，还有编译器的参与</u>**，而<u>两者根本区别</u>在于：前者会编译生成二进制文件，但后者不会；此外，这种字节码跟编译器、解释器结合的技术，称为 **<u>即时编译(JIT)</u>**；


<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123703.png" style="zoom:50%;" align=""/>



### 1-1-5、执行代码









## 1-2、执行上下文

**<u>*执行上下文 Context  是 JS 执行一段代码时的运行环境，*</u>**比如调用一个函数，就会进入此函数的执行上下文，确定该函数在执行期间用到的诸如 this、变量、对象以及函数等，但亦可简单理解为一个对象：

- **<u>*Context 组成(三部分)：*</u>**
  - **<u>this 指向</u>**；
  - **<u>变量对象(VO)</u>**：可抽象为一种 **数据作用域**
    - 也可理解为就一简单对象：<u>存储着该执行上下文中的所有 **变量和函数声明(不包含函数表达式)**</u>；
    - **<u>活动对象 (AO)</u>**：当变量对象所处的上下文为 active EC 时，称为活动对象；
  - **<u>作用域链(词法作用域)</u>**：本质是一个指向变量对象的指针列表(父级和自身的变量对象)，注意只包含引用不包含实际 VO；由以下两部分组成：
    - `[[scope]]`属性：指向父级变量对象和作用域链，也即包含了父级的`[[scope]]` 和 `AO`；
    - AO：自身活动对象；

补充：**<u>作用域</u>**：可理解为该上下文中声明的 **变量和声明的作用范围**，可分为 **块级作用域** 和 **函数作用域**；

- 特性A：**声明提前**: 一个声明在函数体内都是可见的, 函数优先于变量；
- 特性B：非匿名自执行函数，函数名变量为 **只读** 状态，无法修改；

补充：**<u>闭包</u>**：一种特殊的作用域，称为 <u>静态作用域</u>；其定义可理解为：<u>父函数被销毁</u> 的情况下，而返回出的子函数的`[[scope]]`中仍保留父级的单变量对象、作用域链，因此可继续访问到父级的变量对象，如此的函数称为闭包；详看下方闭包小节；

- 问题：多个子函数的`[[scope]]` 均同时指向父级，完全共享；故当父级的变量对象被修改时，所有子函数都受到影响；
- 解决:
  - 变量可以通过 **函数参数的形式** 传入，避免使用默认的`[[scope]]`向上查找；
  - 使用`setTimeout`包裹，通过第三个参数传入；
  - 使用 **块级作用域**，让变量成为自己上下文的属性，避免共享；

补充：故能通过 <u>作用域链</u> 访问父级中声明的变量或函数；

补充：如此 `[[scope]]`包含`[[scope]]`，便自上而下形成一条 **<u>链式作用域</u>**；**<u>用人话讲就是</u>**：当访问一个变量时，解释器会首先在当前作用域查找标示符，若没有找到，就去父作用域找，直到找到该变量的标示符或者不在父作用域中，这就是作用域链；但须注意，每一子函数均会拷贝上级的作用域，形成一个作用域的链条；注意：作用域在预编译阶段确定，但是作用域链是在执行上下文的创建阶段完全生成的。因为函数在调用时，才会开始创建对应的执行上下文；



- **<u>*Context 类型：*</u>**

  - **<u>全局执行上下文</u>**：默认上下文，任何不在函数内部的代码均在全局上下文中(一程序中只有一全局上下文)；它会执行两件事：
    - 创建一个全局 window 对象 (浏览器)；
    - 设置 this 的值等于这个全局对象；
  - **<u>函数执行上下文</u>**：每当一函数被调用时，都会为该函数创建一新的上下文；每个函数都有它自己的执行上下文，不过是在函数被调用时创建；函数上下文可有任意多个，每当一个新的执行上下文被创建，它会按定义的顺序执行一系列步骤；
  - **<u>Eval 函数执行上下文</u>**：执行在 eval 函数内部的代码也会有它属于自己的执行上下文；

  创建执行上下文有两个阶段：1) 编辑(创建)阶段 和 2) 执行阶段；

- 代码执行过程(语法层面)

  - 创建 **全局上下文** (global EC)；
  - 全局执行上下文 (caller) 逐行 **自上而下** 执行；遇到函数时，即创建新 execution context，随后此**<u>函数执行上下文 (callee)</u>** 被压入 <u>**执行栈—Execution Stack(执行上下文栈—Execution Context Stack)**</u> 顶层；
  - 函数执行上下文被激活，成为 active EC, 开始执行函数中的代码，caller 被挂起；
  - 函数执行完后，caller 被`pop`移除出执行栈，控制权交还全局上下文 (caller)，继续执行；

  <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123704.png" style="zoom:45%;" />



<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123705.png" style="zoom:45%;" />





### 1-2-1、代码执行过程

执行上下文的创建时机：函数调用时都会创建出新的上下文；创建步骤：[参考](https://www.youtube.com/watch?v=Nt-qa_LlUH0)，创建后进入代码执行流程：分2步：

- **<u>内存分配 (Creation Phase)</u>** ：
  - 变量对象的创建
  - 作用域链的创建
  - 确定 this 值；
- **<u>代码执行 (Code Execution Phase)</u>** 
- 变量赋值、引用函数、解释/执行代码；



### 1-2-1-1、Creation Phase 1/3

变量对象创建 (Variable Object / Activation Object)，变量对象创建，即开始进入了变量的生命周期；

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123706.png" style="zoom:45%;" align="" />

变量的生命周期包含了声明(Declaration phase)、初始化(Initialization phase)与赋值(Assignment phase)过程这三个过程

变量对象包含：当前执行上下文中所有变量、函数及具体分支中的定义，各类型变量对象的创建时机：

- let 定义变量：Declaration；
- var 定义变量：Declaration、Initialization；
- const 定义变量：Declaration、Initialization；
- Function 定义变量：Declaration、Initialization、Assignment；

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123707.png" style="zoom:45%;" align="" />

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123708.png" style="zoom:45%;" align="" />

注意：因这一步，可在变量或者函数定义之前，访问这些变量，感觉就像是变量提升了，但这实际上是 JS 解析机制作用的结果；

注意：let 仅 Declaration，并无 Initialization，在 Initialization 前使用会报错，即TDZ；

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123709.png" style="zoom:45%;" align="" />

注意：由图知，let 对变量 Declaration，但因 Initialization 前使用引发了错误，故没能正常 Initialization，而这种 Initialization 只有1次机会，导致后续补救措施失效；

注意：const 的 Declaration 和 Initialization 须同步，否则报错；

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123710.png" style="zoom:45%;" align="" />

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123711.png" style="zoom:45%;" align="" />



### 1-2-1-2、Creation Phase 2/3

作用域链的创建；作用域链可被认为是包含了其自身 Variable Object 引用以及所有的父 Variable Object 引用的对象；

作用域链常被用于变量解析，当需解析某个具体的变量时，Js 解释器会在作用域链上递归查找，直到找到合适变量或任何其他需要的资源

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123712.png" style="zoom:45%;" align="" />

解析顺序(优先级)：

- 语言自身定义 (Language-defined)：所有的作用域默认都会包含 this 和 arguments；
- 函数形参 (Formal parameters)：函数有名字的形参会进入到函数体的作用域中；
- 函数声明 (Function decalrations)：通过 function foo() {} 的形式；
- 变量声明 (Variable declarations)：通过 var foo 的形式；

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123713.png" style="zoom:45%;" align="" />

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123714.png" style="zoom:45%;" align="" />



### 1-2-1-3、Creation Phase 3/3

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123715.png" style="zoom:45%;" align="" />



### 1-2-1-4、Execution Phase 1/1

代码执行：此步会发生普通变量生命周期的赋值，函数的直接调用(又发生一个上下文的创建过程…)





### 1-2-2、作用域

定义：代码执行过程中，变量、函数、对象的可访问区域；

也可理解为是一套规则：**用于确定在特定场景下如何查找变量**；

作用：决定变量/其他资源的可见性，保证代码的安全性，限制用户访问权限、帮助提升代码性能、追踪错误并且修复；

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123720.png" style="zoom:60%;" />

异同：与 Context 异同：

相同：两者常用来描述相同的概念：JS 规范中的执行上下文(Execution Context)其实描述的是：变量的作用域

区别：前者则与变量的可见性相关，后者更多关注于代码中 this 的使用；

RHS & LHS

- RHS 找不到-ReferenceError、RHS 找到-但尝试不当操作-TypeError
- LHS 非严格模式找不到-自动创建全局变量返回给引擎、LHS 严格模式找不到-ReferenceError



### 1-2-2-1、函数 & 全局作用域

```js
var a = 'TLP'
function bar() {
    var b = 'bar'
}
function foo() {
    console.log(b);
    console.log(a);
}
foo()
// 分属于两个彼此独立的函数作用域
// 变量作用域的查找是一个扩散过程，就像各个环节相扣的链条，逐次递进，此亦作用域链说法的由来
```

### 1-2-2-2、块级作用域

注意：除了块级作用域以外，函数参数默认值也会受到 TDZ 影响；

```js
function foo(arg1 = arg2, arg2) {
    console.log(`${arg1} ${arg2}`)
}

foo(undefined, 'arg2')
// Uncaught ReferenceError: arg2 is not defined

// 变式1
function foo(arg1 = arg2, arg2) {
    console.log(`${arg1} ${arg2}`)
}
foo(null, 'arg2') // null arg2
// 涉及 undefined 和 null 区别
// 在执行 foo(null, 'arg2') 时，不会认为“函数第一个参数缺省”，而会直接接受 null 作为第一个参数值。

// 变式2
function foo(arg1) {
    let arg1
}

foo('arg1')
// Uncaught SyntaxError: Identifier 'arg1' has already been declared
// 涉及：let 变量不得重复声明
function foo(arg1) {
    var arg1
    let arg1
}
```





### 1-2-2-3、变量提升

本质是 JS 解析机制作用的结果；现象是所有的声明 (变量和函数) 移动到各自作用域的最顶端的过程，提升无视 for if 等普通块的区域限制；示例：如下示例中，实际将看成2个声明：编译阶段进行的定义声明 var a、被留在原地等待执行阶段的赋值声明 a = 2；

```js
// example1
a = 2;
var a;
console.log(a);

// example2
console.log(a);
var a = 2;
```

```js
// 代码段1
var liList = document.querySelectorAll('li') // 共5个li
for( var i=0; i<liList.length; i++){
  liList[i].onclick = function(){
    console.log(i)
  }
}

// 代码段2
var liList = document.querySelectorAll('li') // 共5个li
for( let i=0; i<liList.length; i++){
  liList[i].onclick = function(){
    console.log(i)
  }
}
// for( let i = 0; i< 5; i++) 这句话的圆括号之间，有一个隐藏的作用域
// for( let i = 0; i< 5; i++) { 循环体 } 在每次执行循环体之前，JS 引擎会把 i 在循环体的上下文中重新声明及初始化一次

// 代码段3
var liList = document.querySelectorAll('li') // 共5个li
for( let i=0; i<liList.length; i++){
  // let i = 隐藏作用域中的i 
  // 5 次循环，就会有 5 个不同的 i，console.log 出来的 i 当然也是不同的值
  liList[i].onclick = function(){
    console.log(i)
  }
}
```

首先注意，提升不是一个技术名词，且 MDN 关于 let 是否存在提升的章节，被编辑了两次，第一次说存在提升，第二次说不存在提升，即 MDN 内部也存在争议，**<u>而要搞清楚提升的本质，需要理解 JS 变量的「创建create、初始化initialize 和赋值assign」</u>**

- Declaration Phase - 声明：在作用域中注册变量；
- Initialization Phase - 初始化：为变量分配内存并且创建作用域绑定，此时变量会被初始化为 undefined；
- Assignment Phase - 赋值：将开发者指定的值分配给该变量；

- 注意：为将变量创建概念与变量声明区别开，不使用声明这个字眼；

- 注意：有的地方把初始化叫做绑定(binding)，但不如初始化形象；

- **<u>var 声明的「创建、初始化和赋值」过程：</u>**

```js
function fn(){
  var x = 1
  var y = 2
}
fn()
```

在执行 fn 时，会有以下过程 (不完全)：

1. 进入 fn，为 fn 创建一个环境；
2. 找到 fn 中所有用 var 声明的变量，在这个环境中「创建」这些变量(即 x 和 y)；
3. 将这些变量「初始化」为 undefined；
4. 开始执行代码；
5. x = 1 将 x 变量「赋值」为 1；
6. y = 2 将 y 变量「赋值」为 2；

也就是说 var 声明会在代码执行之前就将「创建变量，并将其初始化为 undefined」；

这就解释了为什么在 var x = 1 前 console.log(x) 会得到 undefined；

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123721.png" style="zoom:50%;" align="" />

- **<u>Function 声明的「创建、初始化和赋值」过程：</u>**

```js
fn2()
function fn2(){
  console.log(2)
}
```

JS 引擎会有以下过程：

1. 找到所有用 function 声明的变量，在环境中「创建」这些变量。
2. 将这些变量「初始化」并「赋值」为 function(){ console.log(2) }。
3. 开始执行代码 fn2()

也就是说 function 声明会在代码执行之前就「创建、初始化并赋值」

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123722.png" style="zoom:50%;" align="" />

- **<u>let 声明的「创建、初始化和赋值」过程：</u>**

```js
{
  let x = 1
  x = 2
}
```

只看 {} 里面的过程：

1. 找到所有用 let 声明的变量，在环境中「创建」这些变量；
2. 开始执行代码 (注意现在还没有初始化)；
3. 执行 x = 1，将 x 「初始化」为 1(这并不是一次赋值，如果代码是 let x，就将 x 初始化为 undefined)
4. 执行 x = 2，对 x 进行「赋值」

这就解释了为什么在 let x 之前使用 x 会报错：

```js
let x = 'global'
{
  console.log(x) // Uncaught ReferenceError: x is not defined
  let x = 1
}
```

原因有两个：

- console.log(x) 中的 x 指的是下面的 x，而不是全局的 x；
- 执行 log 时 x 还没「初始化」，所以不能使用(也即暂时死区 TDZ)

所以 let 没有提升：

1. let 的「创建」过程被提升了，但是初始化没有提升；
2. var 的「创建」和「初始化」都被提升；
3. function 的「创建」「初始化」和「赋值」都被提升；

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123723.png" style="zoom:50%;" align="" />

注意：let x = x

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123724.png" style="zoom:30%;" align="" />

- x 变量就将永远处于 created 状态。
- 你无法再次对 x 进行初始化(初始化只有一次机会，而那次机会你失败了)。
- 由于 x 无法被初始化，所以 x 永远处在暂时死区；

- **<u>const 声明的「创建、初始化和赋值」过程：</u>**

其实 const 和 let 只有一个区别，那就是 const 只有「创建」和「初始化」，没有「赋值」过程；

而所谓暂时死区 TDZ，就是 **<u>不能在初始化之前，使用变量</u>**；

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123725.png" style="zoom:60%;" align=""/>

[最后，实际上并无"变量提升" 的这一说法](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/30)，其只是"遗留行为"，而新标准则禁止了这一会导致 bug 的行为，故产生了 TDZ：详看[文1](https://zhuanlan.zhihu.com/p/28140450) [文2](https://stackoverflow.com/questions/31219420/are-variables-declared-with-let-or-const-not-hoisted-in-es6/31222689#31222689)

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123726.png" style="zoom:40%;" align=""/>

In JavaScript, all binding declarations are instantiated when control flow enters the scope in which they appear. 

在 JS 中，当控制流进入它们出现的范围时，所有绑定声明都会被实例化。 

Legacy var and function declarations allow access to those bindings before the actual declaration, with a "value" of undefined. 

传统var和函数声明允许在实际声明之前访问这些绑定，其值“undefined”。 

That legacy behavior is known as "hoisting". 这种遗留行为被称为“悬挂”。 

let and const binding declarations are also instantiated when control flow enters the scope in which they appear, 

with access prevented until the actual declaration is reached; this is called the Temporal Dead Zone. 

当控制流进入它们出现的范围时，let和const绑定声明也被实例化，访问被阻止，直到达到实际声明为止; 这被称为时间死区。 

The TDZ exists to prevent the sort of bugs that legacy hoisting can create.

TDZ 的存在是为了防止传统吊装可能产生的那种错误；

建议：总是使用var关键字定义，避免使用全局变量，可用 strict mode 限制、声明命名空间、模块化

- 注意：变量提升只对 var 命令声明的变量有效，若一变量不是用 var 命令声明的，就不会发生变量提升：
  - <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123727.png" style="zoom:50%;" align="" />
  - <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123728.png" style="zoom:50%;" align="" />

- 注意：函数表达式也会提升，但作为普通变量提升，而非函数提升；而同名函数和变量同存时，函数优先，变量延后提升，相当于变量会覆盖函数声明；
  - <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123729.png" style="zoom:50%;" align="" />
  - <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123730.png" style="zoom:50%;" align="" />
  - <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123731.png" style="zoom:50%;" align="" />
- 注意：函数声明、变量声明都会被提升，但函数表达式，不会被提升；
  - <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123732.png" style="zoom:50%;" align="" />
- 注意：函数声明首先优先提升，然后是别的变量；
- 注意：同名变量(包括函数)，变量会被当作重复声明而忽略掉；
  - <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123733.png" style="zoom:50%;" align="" />
  - <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123734.png" style="zoom:50%;" align="" />

- 注意：存在多个同名函数时，后者声明覆盖前者
  - <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123735.png" style="zoom:50%;" align="" />
- 注意：关键字 var：声明同时定义了 undefined；关键字 let：只声明但未定义，所以报错；
  - <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123736.png" style="zoom:50%;" align="" />



### 1-2-2-3-1、变量提升示例

备忘录-变量提升示例

### 1-2-2-3-2、具名函数表达式

备忘录-变量提升示例中



### 1-2-3、闭包

- **<u>红宝书</u>** ：闭包是指有权访问另外一个函数作用域中的变量的函数；
- **<u>MDN</u>** ：闭包是指那些能够访问自由变量的函数；(其中自由变量，指在函数中使用的，但既不是函数参数arguments也不是函数的局部变量的变量，其实就是另外一个函数作用域中的变量)



### 1-2-3-1、闭包产生原因

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123737.png" style="zoom:50%;" align="" />

作用域链的解释在前文，**<u>但须注意，每一子函数都会拷贝上级的作用域，形成一个作用域的链条</u>**；

```js
var a = 1;
function f1() {
  var a = 2
  function f2() {
    var a = 3;
    console.log(a);//3
  }
}
// f1 的作用域指向有全局作用域 window 和它本身，而 f2 的作用域指向全局作用域 window、f1 和它本身; 且作用域是从最底层向上找，直到找到全局作用域 window 为止, 若全局也没有则报错；
```

**<u>闭包产生的本质</u>**：**<u>当前环境中存在指向父级作用域的引用</u>**：

```js
function f1() {
  var a = 2
  function f2() {
    console.log(a);//2
  }
  return f2;
}
var x = f1();
x();
// x 能拿到父级作用域中的变量，输出 2；因当前环境中，x 含有对 f2 的引用，而 f2 恰恰引用了 window、f1、f2 的作用域，所以 f2 可以访问到 f1 作用域的变量
```

**<u>注意: 并非只有返回函数才算是产生闭包，只需要让父级作用域的引用存在即可</u>**

```js
var f3;
function f1() {
  var a = 2
  f3 = function() {
    console.log(a);
  }
}
f1();
f3();
// f1 执行，给 f3 赋值后，f3 拥有了 window、f1、f3 本身这几个作用域的访问权限，于是自底向上查找，在 f1 中找到 a, 因此输出 2；
// 所以，此处是外面的变量 f3 存在着父级作用域的引用，因此产生了闭包
```



### 1-2-3-2、闭包表现形式

- 返回一个函数；
- 作为函数参数传递；

```js
var a = 1;
function foo(){
  var a = 2;
  function baz(){
    console.log(a);
  }
  bar(baz);
}
function bar(fn){
  // 这就是闭包
  fn();
}
// 输出2，而不是1
foo();
```

- 在定时器、事件监听、Ajax请求、跨窗口通信、Web Workers 或任何异步中，只要使用回调函数，实际上就是在使用闭包；

```js
// 以下的闭包保存的仅仅是 window 和 当前作用域
// 定时器
setTimeout(function timeHandler(){
  console.log('111');
}，100)

// 事件监听
$('#app').click(function(){
  console.log('DOM Listener');
})
```

- IIFE 创建闭包，保存了`全局作用域window`和`当前函数的作用域`，因此可使用全局的变量；

```js
var a = 2;
(function IIFE(){
  // 输出2
  console.log(a);
})();
```



### 1-2-3-3、闭包功能作用

1、读取函数内部的变量

- 利用1：可由此设计私有变量(ES6中没有私有变量，只能变通实现)：
  - 方式1：将闭包作为特权方法 (public method / privileged method)，将函数的参数、局部变量和函数内定义的其他函数作为私有变量：
  - <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123738.png" style="zoom:50%;" align="" />
  - 方式2：利用模块模式创建单例，赋予私有属性功能：
  - <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123739.png" style="zoom:50%;" align="" />
- 利用2：配合**匿名函数**，构建命名空间，减少全局变量的使用，模块化代码，减少全局变量的污染
  - <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123740.png" style="zoom:50%;" align="" />

2、让函数内部变量的值始终保持在内存中，阻止其被回收，但消耗大，滥用后果很严重、IE 中存在内存泄露，需注意解除引用；

3、模块化、函数工厂、批量化构建函数并延期执行

注意：模块模式具有两个必备的条件：

- 必须有外部的封闭函数，该函数必须至少被调用一次(每次调用都会创建一个新的模块实例)；
- 封闭函数必须返回至少**一个**内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态；

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123741.png" style="zoom:50%;" align="" />

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123742.png" style="zoom:50%;" align="" />

建议：若非特殊情况，不应在函数中创建函数，需考虑性能和内存消耗问题；

比如：创建新对象或类时，方法(函数)定义对象的构造器(函数)中，将导致每次构造调用时，方法均会重新赋值一次；

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123743.png" style="zoom:50%;" align="" />

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123744.png" style="zoom:50%;" align="" />

4、闭包计数器

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123745.png" style="zoom:50%;" align="" />









### 1-2-3-4、闭包使用示例

### 1-2-3-4-1、基本示例

```js
for(var i = 1; i <= 5; i ++){
  setTimeout(function timer(){
    console.log(i)
  }, 0)
}
// 原因:
// setTimeout 为宏任务, 而由于 JS 单线程 EvLoop 机制，在主线程同步任务执行完后才去执行宏任务
// loop 结束后, setTimeout 依次执行回调，但输出时在当前作用域没有发现 i，遂通过作用域链向上寻找 i, 此时循环已结束，i 也已变成了 6；因此会全部输出6；

// 解决:
// 1、利用IIFE, 当每次 for 循环时，将此时的变量 i 传递到定时器中
for(var i = 1;i <= 5;i++){
  (function(j){
    setTimeout(function timer(){
      console.log(j)
    }, 0)
  })(i)
}
// 2、给定时器传入第三个参数, 作 为timer 函数的第一个函数参数
for(var i=1;i<=5;i++){
  setTimeout(function timer(j){
    console.log(j)
  }, 0, i)
}
for(var i=1;i<=5;i++){
  setTimeout(function timer(j){
    console.log(i); console.log(j)
  }, 0, i)
}
// 输出 5 个 6，1-5

// 3、使用 ES6 中的 let——块级作用域
// let 使 JS 发生革命性的变化，让 JS 有函数作用域变为块级作用域，用 let 后作用域链不复存在。代码的作用域以块级为单位
for(let i = 1; i <= 5; i++){
  setTimeout(function timer(){
    console.log(i)
  },0)
}
// i = 1
{
  setTimeout(function timer(){
    console.log(1)
  },0)
}
// i = 2
{
  setTimeout(function timer(){
    console.log(2)
  },0)
}
// i = 3
```

### 1-2-3-4-2、综合示例

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123746.png" style="zoom:50%;" align="" />

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123747.png" style="zoom:50%;" align="" />

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123748.png" style="zoom:50%;" align="" />

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123749.png" style="zoom:50%;" align="" />



### 1-2-3-4-3、其他示例

备忘录 4-3





### 1-2-4、this 指向

**<u>*谁调用它，则它内部的 this 就指向谁(特殊情况另算)*</u>**

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123750.png" style="zoom:50%;" align="" />

- 描述：函数内部代码 this.count 中的 this 并非指向那个函数对象，而是指向 调用它的那个对象，可能是window，也可能是 global
- 解决：解决上述 this 绑定问题：
  - 使用词法作用域，全局定义一个变量，通过变量查找获得
  - 使用词法作用域，用函数自身属性，而不用this.count
  - 强制 this 指向，比如用 foo.call( foo, i );  

**<u>*this 实际上是，在函数被调用时才发生绑定，this指向什么，完全取决于函数在哪里被调用，被谁调用*</u>** 

当函数被调用时，会创建一个活动记录(执行上下文)，记录包含，函数在哪被调用(调用栈)，函数的调用方法、传入的参数等信息；

而 this，只是信息中的一个属性；会在函数执行的过程中使用得到；

- 注意：<u>this 在任何情况下 都不指向 函数的作用域</u>，因作用域"对象" 存在于 JS 引擎内部， 无法通过 JS 代码访问 

**<u>*1、普通 this 指向：*</u>**

- 永远指向最后调用它的那个对象；

- 函数运行时所在的环境对象 (并非指向函数作用域，作用域对象存在于引擎内部，无法通过一般访问) ；

- 函数被调用时才发生的绑定，故 this 的指向取决于函数在哪、被谁调用 (调用时创建执行上下文、创建时的内存分配阶段时的过程) ；

  - 示例1：

  - <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123751.png" style="zoom:50%;" align="" />

  - <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123752.png" style="zoom:50%;" align="" />

  - <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123753.png" style="zoom:50%;" align="" />

  - <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123754.png" style="zoom:50%;" align="" />

  - 示例2：

  - 前者将函数交由变量 go，go 存在于 window，最后调用 go 实际为 window.go()；

  - 后者最后调用函数的为 baz，故打印 1；

  - <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123755.png" style="zoom:50%;" align="" />

  - <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123756.png" style="zoom:50%;" align="" />

  - 示例3：理由同上

  - <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123757.png" style="zoom:50%;" align="" />

    

**<u>*2、其他 this 指向*</u>**

- 箭头函数，详见 2-2-4-8、箭头函数
- 匿名函数，详见 2-2-4-9、匿名函数

**<u>*3、函数调用方式*</u>**

- 作为函数直接调用：默认属于全局对象，严格模式则是 undefined，示例1；
- 作为对象方法间接调用：属于最后调用它的那个对象，示例 2； 
- 作为构造函数调用：属于构造返回的实例，new 过程；
- 作为函数方法调用：call、apply；
  - 示例1：
  - <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123758.png" style="zoom:50%;" align="" />
  - 示例2：
  - <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123759.png" style="zoom:50%;" align="" />



**<u>*X：各绑定优先级：默认绑定 < 隐式绑定 < 显式绑定 < 显式硬绑定 < new 绑定*</u>**

**<u>*X-1、默认绑定*</u>**：函数不带任何修饰地调用，this 指向 全局对象 / undefined (strict mode)

```js
// Ex1
"use strict";
var a = 10;
function foo () {
  console.log('this1', this) // 'this1' undefined
  console.log(window.a) // 10
  console.log(this.a) // Uncaught TypeError: Cannot read property 'a' of undefined
}
console.log(window.foo)	// f foo() {...}
console.log('this2', this) // 'this2' Window{...}
foo();
// 注意虽全局模式改变内部 this 为 undefined，但并不会改变全局中 this 的指向(仍为全局对象)

// Ex2
let a = 10
const b = 20
function foo () {
  console.log(this.a) // undefined
  console.log(this.b) // undefined
}
foo();
console.log(window.a) // undefined
// 注意 let 或者 const 变量是不会被绑定到 window

// Ex3
var a = 1
function foo () {
  var a = 2
  console.log(this) // Window{...}
  console.log(this.a) // 1
  function inner () { 
    console.log(this.a) // 1
  }
  inner()
}
foo()
```

**<u>*X-2、隐式绑定*</u>**：函数带修饰地被调用，this 指向此上下文对象，比如：obj.foo()

- 注意：对象属性引用链中，只有最后一层会影响调用位置：
  - <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123800.png" style="zoom:50%;" align="" />
- 注意：赋值操作中，被隐式绑定函数，<u>会丢失绑定对象</u>，此时会应用默认绑定：
  - <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123801.png" style="zoom:50%;" align="" />
  - <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123802.png" style="zoom:50%;" align="" />

```js
// Ex1
function foo () {
  console.log(this.a) 
}
var obj = { a: 1, foo }
var a = 2
obj.foo() // 1

// Ex2
var obj = {
  a: 1,
  foo: function () {
    console.log(this.a) 
  }
}
var a = 2
obj.foo() // 1

// Ex3 - 隐式丢失
function foo () {
  console.log(this.a) 
};
var obj = { a: 1, foo };
var a = 2;
var foo2 = obj.foo;

obj.foo(); // 1
foo2(); // 2

// Ex4 - 隐式丢失
function foo () {
  console.log(this.a)
};
var obj = { a: 1, foo };
var a = 2;
var foo2 = obj.foo;
var obj2 = { a: 3, foo2: obj.foo }

obj.foo(); // 1
foo2(); // 2
obj2.foo2(); // 3

// Ex5 - 隐式丢失
function foo () {
  console.log(this.a)
}
function doFoo (fn) {
  console.log(this) // window
  fn()
}
var obj = { a: 1, foo }
var a = 2
doFoo(obj.foo) // 2

// Ex6 - 隐式丢失
function foo () {
  console.log(this.a)
}
function doFoo (fn) {
  console.log(this) // obj2
  fn()
}
var obj = { a: 1, foo }
var a = 2
var obj2 = { a: 3, doFoo }
obj2.doFoo(obj.foo) // 2

// Ex7
"use strict"
function foo () {
  console.log(this.a)
}
function doFoo (fn) {
  console.log(this) // obj2
  fn()
}
var obj = { a: 1, foo }
var a = 2
var obj2 = { a: 3, doFoo }

obj2.doFoo(obj.foo) // Uncaught TypeError: Cannot read property 'a' of undefined
```



**<u>*X-3、显式绑定(call、apply)*</u>**：在对象上，强制调用函数，直接指定 this 绑定对象，其参数1 即 this 的绑定对象：

- 意为：在 obj 中使用 function；
- 注意：若收到的第一个参数是空或者`null、undefined`，则会忽略这个参数
- 注意：从 this 绑定角度上看，两者本质相同，区别在参数2，前者数组，后者元素；
- 注意：显式绑定也有隐式绑定丢失问题；
  - <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123803.png" style="zoom:50%;" align="" />
- 注意：参数2 传入 null 与 不写效果等同；
  - <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123804.png" style="zoom:50%;" align="" />

```js
// Ex1
function foo () {
  console.log(this.a)
}
var obj = { a: 1 }
var a = 2

foo()						// 2
foo.call(obj) 	// 1
foo.apply(obj) 	// 1
foo.bind(obj) 	// function

// Ex2
function foo () {
  console.log(this.a)
}
var a = 2
foo.call()		// 2
foo.call(null)// 2
foo.call(undefined) // 2

// Ex3
var obj1 = {
  a: 1
}
var obj2 = {
  a: 2,
  foo1: function () {
    console.log(this.a)
  },
  foo2: function () {
    setTimeout(function () {
      console.log(this)
      console.log(this.a)
    }, 0)
  }
}
var a = 3
obj2.foo1() // 2
obj2.foo2() // window 3

// Ex3
var obj1 = {
  a: 1
}
var obj2 = {
  a: 2,
  foo1: function () {
    console.log(this.a)
  },
  foo2: function () {
    setTimeout(function () {
      console.log(this)
      console.log(this.a)
    }.call(obj1), 0)
    // 注意：不能是 obj2.foo2.call(obj1) 写法，否则改变 this 为 foo2 环境，但内部计时器存在仍会指向 window
  }
}
var a = 3
obj2.foo1() // 2
obj2.foo2() // obj1 1

// Ex4
var obj1 = {
  a: 1
}
var obj2 = {
  a: 2,
  foo1: function () {
    console.log(this.a)
  },
  foo2: function () {
    function inner () {
      console.log(this)
      console.log(this.a)
    }
    inner()
  }
}
var a = 3
obj2.foo1() // 2
obj2.foo2() // window 3  若 inner.call(obj1) 则 obj1 1

// Ex5 - 坑
function foo () {
  console.log(this.a)
}
var obj = { a: 1 }
var a = 2

foo() // 2
foo.call(obj) // 1
foo().call(obj) // 2 Error Uncaught TypeError: Cannot read property 'call' of undefined

// Ex6
function foo () {
  console.log(this.a)
  return function () {
    console.log(this.a)
  }
}
var obj = { a: 1 }
var a = 2

foo() // 2
foo.call(obj) // 1
foo().call(obj) // 2 

// Ex7 - 坑
function foo () {
  console.log(this.a)
  return function () {
    console.log(this.a)
  }
}
var obj = { a: 1 }
var a = 2

foo() // 2
foo.bind(obj)
foo().bind(obj) // 2

// Ex8
function foo () {
  console.log(this.a)
  return function () {
    console.log(this.a)
  }
}
var obj = { a: 1 }
var a = 2

foo.call(obj)() // 1 2

// Ex9 - 综合
var obj = {
  a: 'obj',
  foo: function () {
    console.log('foo:', this.a)
    return function () {
      console.log('inner:', this.a)
    }
  }
}
var a = 'window'
var obj2 = { a: 'obj2' }

obj.foo()() // 'foo: obj' 'inner: window'
obj.foo.call(obj2)() // 'foo: obj2' 'inner: window'
obj.foo().call(obj2) // 'foo: obj' 'inner: obj2'

// Ex10 - 综合 - 坑
var obj = {
  a: 1,
  foo: function (b) {
    b = b || this.a
    return function (c) {
      console.log(this.a + b + c)
    }
  }
}
var a = 2
var obj2 = { a: 3 }

obj.foo(a).call(obj2, 1)
// 3 + 2 + 1 == 6
obj.foo.call(obj2)(1) 
// 2 + 3 + 1 == 6

// Ex11
function foo1 () {
  console.log(this.a)
}
var a = 1
var obj = {
  a: 2
}
var foo2 = function () {
  foo1.call(obj)
}
foo2() // 2
foo2.call(window) // 2




// Ex12
function foo1 (b) {
  console.log(`${this.a} + ${b}`)
  return this.a + b
}
var a = 1
var obj = {
  a: 2
}
var foo2 = function () {
  // return foo1.call(obj, 3)
  return foo1.call(obj, ...arguments)
}
var num = foo2(3) // '2 + 3'
console.log(num) // 5


// Ex13
function foo (item) {
  console.log(item, this.a)
}
var obj = {
  a: 'obj'
}
var a = 'window'
var arr = [1, 2, 3]
// arr.forEach(foo, obj)
// arr.map(foo, obj)
arr.filter(function (i) {
  // 1 'obj'
  // 2 'obj'
 	// 3 'obj'
  console.log(i, this.a)
  return i > 2
}, obj) 

// 总结
// this 永远指向最后调用它的那个对象
// 匿名函数的 this 永远指向 window
// 使用.call()或者.apply()的函数是会直接执行的
// bind()是创建一个新的函数，需要手动调用才会执行
// 若 call、apply、bind 接收到的第一个参数是空或者 null、undefined 的话，则会忽略这个参数
// forEach、map、filter函数的第二个参数也是能显式绑定this的
```

**<u>*X-4、显式硬绑定*</u>**：显式绑定的变种 (本质是：在显式绑定的基础上用一层函数包裹)

- 注意：无法再次修改 this 指向，除非 new 操作，图1；

- - bind 会判断硬绑定函数，是否是被 new 调用，若是则使用 new 操作中新创建的 this 替换硬绑定的 this；
  - 即 new 优先级 > 硬绑定；

- 注意：显式硬绑定是 ES5中 bind 的雏形：图2；

- 注意：bind 返回硬编码的新函数，但并无调用，bind会将参数，设置为 this 的上下文并调用原始函数；

- 注意：许多 API 都提供了一个可选的，上下文参数，作用同 bind，确保回调函数使用指定的 this；

- 注意：还有软绑定，后续能修改 this，但又不会指向全局对象或 undefined，自行查阅

  - 示例1：
  - <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123805.png" style="zoom:50%;" align="" />
  - <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123805.png" style="zoom:50%;" align="" />

- bind 实现

  - 返回一个函数，绑定this，传递预置参数

  - bind 返回的函数可以作为构造函数使用。故作为构造函数时应使得this失效，但是传入的参数依然有效

  - ```js
    Function.prototype.bind2 = function(context) {
        var _this = this;
        var argsParent = Array.prototype.slice.call(arguments, 1);
        return function() {
            var args = argsParent.concat(Array.prototype.slice.call(arguments)); //转化成数组
            _this.apply(context, args);
        };
    }
    // 2
    Function.prototype.bind1 = function(context) {
      var that = this
      return function() {
        that.apply(context, arguments)
      }
    }
    // 最简版
    Function.prototype.myBind = function(content, ...args) {
      return () => this.apply(content, args);
    };
    // ES6
    Function.prototype.bind2 = function() {
        var fn = this;
        var argsParent = [...arguments];
        return function() {
            fn.call(...argsParent, ...arguments);
        };
    }
    // MDN
    //  Yes, it does work with `new (funcA.bind(thisArg, args))`
    if (!Function.prototype.bind) (function(){
      var ArrayPrototypeSlice = Array.prototype.slice;
      Function.prototype.bind = function(otherThis) {
        if (typeof this !== 'function') {
          // closest thing possible to the ECMAScript 5
          // internal IsCallable function
          throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');
        }
    
        var baseArgs= ArrayPrototypeSlice.call(arguments, 1),
            baseArgsLength = baseArgs.length,
            fToBind = this,
            fNOP    = function() {},
            fBound  = function() {
              baseArgs.length = baseArgsLength; // reset to default base arguments
              baseArgs.push.apply(baseArgs, arguments);
              return fToBind.apply(
                     fNOP.prototype.isPrototypeOf(this) ? this : otherThis, baseArgs
              );
            };
    
        if (this.prototype) {
          // Function.prototype doesn't have a prototype property
          fNOP.prototype = this.prototype; 
        }
        fBound.prototype = new fNOP();
    
        return fBound;
      };
    })();
    ```

**<u>*X-5、new 绑定*</u>**：用 new 来调用函数，构造一个新对象 (实例)，并将 this 指向实例对象本身；而若为普通调用，则指向全局对象：

- 注意：使用 new 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作：
  - 创建一全新的对象 (中间对象)；
  - 新对象会被执行 [[ 原型 ]] 连接 (将中间对象的原型指向函数原型，此后便可使用函数原型上的方法和属性)；
  - 新对象会绑定到函数调用的 this (即将函数内部 this 指向中间对象)；
  - 若函数返回基本类型，则返回中间对象；若返回对象，则代替中间对象，返回函数返回的对象；
  - <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123806.png" style="zoom:60%;" align="" />

```js
// Ex1
function Person (name) {
  this.name = name
}
var name = 'window'
var persion1 = new Person('TLP')
console.log(person1.name) // TLP

// Ex2
function Person (name) {
  this.name = name
  this.foo1 = function () {
    console.log(this.name)
  }
  this.foo2 = function () {
    return function () {
      console.log(this.name)
    }
  }
}
var person1 = new Person('person1')
person1.foo1() // person1
person1.foo2()() // '' 
// 注意: window.不存在值 输出 ''

// Ex3
var name = 'window'
function Person (name) {
  this.name = name
  this.foo = function () {
    console.log(this.name)
    return function () {
      console.log(this.name)
    }
  }
}
var person2 = {
  name: 'person2',
  foo: function() {
    console.log(this.name)
    return function () {
      console.log(this.name)
    }
  }
}
var person1 = new Person('person1')
person1.foo()() // persono1 window
person2.foo()() // person2 window

// Ex4
var name = 'window'
function Person (name) {
  this.name = name
  this.foo = function () {
    console.log(this.name)
    return function () {
      console.log(this.name)
    }
  }
}
var person1 = new Person('person1')
var person2 = new Person('person2')
person1.foo.call(person2)() // person2 window
person1.foo().call(person2) // person1 person2
```

**<u>*X-6、判断 this 的应用规则，先查找函数直接调用的位置*</u>**：

1. 函数是否在 new 中调用(new 绑定)？如果是的话 this 绑定的是，新创建的对象；var bar = new foo()
2. 函数是否通过 call、apply(显式绑定)或者 bind (显示硬绑定)调用？如果是的话this 绑定的是，指定的对象；var bar = foo.call(obj2)
3. 函数是否在某个上下文对象中调用(隐式绑定)？如果是的话this 绑定的是，那个上下文对象；var bar = obj1.foo()
4. 若都不是的话，使用默认绑定。严格模式下，就绑定到 undefined，否则绑定到，全局对象；var bar = foo()

注意：箭头函数不使用 this 的四种标准规则，其 this 的指向 根据外层(函数或者全局)作用域来决定，且这种绑定无法被修改，常用于回调中；

注意：箭头函数使用了词法作用域取代传统的 this 机制，同 self = this 机制一致；

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123807.png" style="zoom:50%;" align="" />

- 示例1：前者隐式绑定，有 callback = function(){ this.output() }过程；后者通过 bind ，将 this 硬绑定；

  - <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123808.png" style="zoom:50%;" align="" />

- 示例2：箭头函数无视 bind 等绑定，可谓是优先级最高了

  - <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123809.png" style="zoom:50%;" align="" />
  - 

- 示例4：但凡有赋值操作均会隐式丢失，但某些赋值操作不明显，比如函数传参、逗号操作符

  - <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123810.png" style="zoom:50%;" align="" />

- 示例5

  - ```js
    function Foo() {
        Foo.a = function() {
            console.log(1)
        }
        this.a = function() {
            console.log(2)
        }
    }
    Foo.prototype.a = function() {
        console.log(3)
    }
    Foo.a = function() {
        console.log(4)
    }
    Foo.a();
    let obj = new Foo();
    obj.a();
    Foo.a();
    
    
    // 解析
    function Foo() {
        Foo.a = function() {
            console.log(1)
        }
        this.a = function() {
            console.log(2)
        }
    }
    // 以上只是 Foo 的构建方法，没有产生实例，此刻也没有执行
    
    Foo.prototype.a = function() {
        console.log(3)
    }
    // 现在在 Foo 上挂载了原型方法 a ，方法输出值为 3
    
    Foo.a = function() {
        console.log(4)
    }
    // 现在在 Foo 上挂载了直接方法 a ，输出值为 4
    
    Foo.a();
    // 立刻执行了 Foo 上的 a 方法，也就是刚刚定义的，所以
    // # 输出 4
    
    let obj = new Foo();
    /* 这里调用了 Foo 的构建方法。Foo 的构建方法主要做了两件事：
    1. 将全局的 Foo 上的直接方法 a 替换为一个输出 1 的方法。
    2. 在新对象上挂载直接方法 a ，输出值为 2。
    */
    
    obj.a();
    // 因为有直接方法 a ，不需要去访问原型链，所以使用的是构建方法里所定义的 this.a，
    // # 输出 2
    
    Foo.a();
    // 构建方法里已经替换了全局 Foo 上的 a 方法，所以
    // # 输出 1
    ```

- 示例6：

  - ```js
    var x = 3;
    var foo = {
      x: 2,
      baz: {
        x: 1,
        bar: function() {
          return this.x;
        }
      }
    }
    var go = foo.baz.bar;
    
    console.log(go());  // 3
    console.log(foo.baz.bar()); // 1
    
    // this 由调用者提供，由调用函数的方式来决定。如果是一个对象调用的函数，则 this 指向该对象，比如 foo.baz.bar()。如果函数独立调用比如 go()，那么该函数内部的 this，则指向 undefined。但是在非严格模式中，它会被自动指向全局对象 window。
    ```

    



### 1-2-4-1、基本

`this` 的指向，是在调用函数时根据执行上下文所动态确定的；

**<u>优先级：new  > call/apply/bind  > 对象.方法 > 直接调用</u>**，但此处主讲隐式绑定：

- 全局上下文
- 直接调用函数：在函数体中，简单调用该函数时(非显式/隐式绑定下)；
  - 严格模式， `this` 绑定到 `undefined`；
  - 非严格模式，绑定到全局对象 `window`／`global`；
- 对象.方法的形式调用：由上下文对象调用，绑定在该对象上；
- DOM 事件绑定(特殊)
- call/apply/bind 显式绑定：由 `call`/`apply`/`bind` 方法显式调用，绑定到指定参数的对象上
- new 构造函数绑定构造函数 `new` 调用，绑定到新创建的对象上
- 箭头函数：根据外层上下文绑定的 `this` 决定 `this` 指向；





### 1-2-4-2、全局上下文

全局上下文默认 this 指向 window，严格模式下指向 undefined；

```js
function f1 () {
    console.log(this)
}
function f2 () {
    'use strict'
    console.log(this)
}
f1() // window
f2() // undefined

// 变式
const foo = {
    bar: 10,
    fn: function() {
       console.log(this)
       console.log(this.bar)
    }
}
var fn1 = foo.fn
fn1()
// 在赋值给 fn1 之后，fn1 的执行仍然是在 window 的全局环境中, 相当于下式
console.log(window)
console.log(window.bar)
```



### 1-2-4-3、直接调用函数

直接调用 this 相当于全局上下文的情况；

```js
let obj = {
  a: function() {
    console.log(this);
  }
}
let func = obj.a;
func();
```



### 1-2-4-4、对象.方法的形式调用

`对象.方法` 的形式，this 指向此对象；

注意：在这种嵌套的关系中，`this` 指向 **<u>最后</u>** 调用它的对象

```js
// 示例1
let obj = {
  a: function() {
    console.log(this);
  }
}
obj.a();

// 示例2
const student = {
    name: 'TLP',
    fn: function() {
        return this
    }
}
console.log(student.fn() === student) // true

// 示例2
const person = {
    name: 'TLP',
    brother: {
        name: 'BDeng',
        fn: function() {
            return this.name
        }
    }
}
console.log(person.brother.fn()) // BDeng

// 综合示例
const o1 = {
    text: 'o1',
    fn: function() {
        return this.text
    }
}
const o2 = {
    text: 'o2',
    fn: function() {
        return o1.fn()
    }
}
const o3 = {
    text: 'o3',
    fn: function() {
        var fn = o1.fn
        return fn()
    }
}
// 注意第三个
console.log(o1.fn()) // o1
console.log(o2.fn()) // o1
console.log(o3.fn()) // undefined - 懵逼

// 追问: 让 console.log(o2.fn()) 输出 o2
// 1、修改 o2
const o2 = {
    text: 'o2',
    fn: o1.fn
}
// 2、修改 o2
var o2 = {
    text: 'o2',
    fn: function() {
        return o1.fn.call(this)
      	return o1.fn.apply(this)
    }
}
// 3、修改 o2
var o2 = {
    text: 'o2',
    fn: function() {
        return o1.fn.bind(o2)
      	// o2.fn()()
    }
}
```

### 1-2-4-5、DOM 事件绑定

onclick 和  addEventerListener中 this 默认指向绑定事件的元素；

注意：IE 比较奇异，使用 attachEvent，其 this 默认指向 window；

### 1-2-4-6、bind/call/apply 绑定

均用以改变相关函数 `this` 指向的，但是 `call/apply` 是直接进行相关函数调用；`bind` 不会执行相关函数，而是返回一个新的函数；

```js
const target = {}
fn.call(target, 'arg1', 'arg2')

const target = {}
fn.apply(target, ['arg1', 'arg2'])

const target = {}
fn.bind(target, 'arg1', 'arg2')()
```

```js
const foo = {
    name: 'TLP',
    logName: function() {
        console.log(this.name)
    }
}
const bar = {
    name: 'BDeng'
}
console.log(foo.logName.call(bar)) // BDeng
```

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123811.png" style="zoom:50%;" align="" />







### 1-2-4-7、new + 构造函数

构造函数中的 this 指向实例对象；因为：

- 创建一个新的对象；
- 将构造函数的 `this` 指向这个新对象；
- 为这个对象添加属性、方法等；
- 最终返回新对象；

```js
// 示例
function Foo() {
    this.bar = "TLP"
}
const instance = new Foo()
console.log(instance.bar)
```

注意：若在构造函数中出现了显式 `return` 的情况

- 若构造函数中显式返回一个值，且返回的是一个对象，则 `this` 就指向这个返回的对象；
- 若构造函数中显式返回一个值，且返回的不是一个对象，则 `this` 仍然指向实例；

```js
// 返回对象
function Foo(){
    this.user = "TLP"
    const o = {}
    return o
}
const instance = new Foo()
console.log(instance.user) // undefined

// 返回非对象
function Foo(){
    this.user = "TLP"
    return 1
}
const instance = new Foo()
console.log(instance.user)
```



### 1-2-4-8、箭头函数

箭头函数没有 this，无法绑定，不适用以上标准规则，而是根据外层(函数或者全局) 上下文来决定；

- 其他 this 指向，始终指向函数定义时的 this，而非后者的执行时；
- 其他 this 通过，查找作用域链来绑定，若箭头函数被非箭头函数包含，则 this 绑定的是最近一层非箭头函数的 this；否则 window/undefined

引入箭头函数有 2 方面的<u>作用</u>：更简短的函数，且不绑定 this；箭头函数 <u>与普通函数不同之处有</u>：

- 函数体内的 this 对象，就是应该是定义时所在的作用域中的 this 值

- 没有 this，它会从自己的作用域链的上一层继承 this (因此无法使用 apply / call / bind 进行绑定 this 值)；

- 不可以使用 arguments 对象，该对象在函数体内不存在；若要用，可以用 rest 参数代替，强行使用会向作用域链搜寻；

- 不可使用 yield 命令，因此箭头函数不能用作 Generator 函数；

- 不绑定 super 和 new.target；

- <u>无法使用 new 实例化对象</u>

  - <u>浅层原因：</u>没有自己的 this，无法调用 call，apply。

  - 浅层原因：没有 prototype 属性 ，而 new 命令在执行时需要将构造函数的 prototype 赋值给新的对象的 `__proto__`

  - <u>深层原因</u>：

  - JS 函数两个内部方法：[[Call]] 和 [[Construct]]

    - 直接调用时执行：`[[Call]]` 方法，直接执行函数体

    - `new` 调用时执行：`[[Construct]]` 方法，创建一个实例对象

    - ```js
      function New(Ctor, ...rest) {
        const o = Object.create(Ctor.prototype)
        const ret = Ctor.apply(o, rest)
        return ret || o
      }
      ```

    - **<u>而箭头函数并没有 `[[Construct]]` 方法，所以不能被用作构造函数</u>**

    - 另外，可参考 `Proxy` 中的 `handler.construct` 方法，其用于拦截 `new` 操作符，为使 `new` 操作符在生成的 `Proxy` 对象上生效，用于初始化代理的目标对象自身必须具有 `[[Construct]]` 内部方法 (即 `new target` 必须是有效的)；

```js
// 找到最近的非箭头函数 a，a 现在绑定着 obj, 因此箭头函数中的 this 是 obj
let obj = {
  a: function() {
    let do = () => {
      console.log(this);
    }
    do();
  }
}
obj.a(); 

// Ex2 - 坑
var obj = {
  name: 'obj',
  foo1: () => {
    console.log(this.name)
  },
  foo2: function () {
    console.log(this.name)
    return () => {
      console.log(this.name)
    }
  }
}
var name = 'window'
obj.foo1() // window 注意: window.obj.foo1 故应为 window
obj.foo2()() // obj obj

// Ex3
var name = 'window'
var obj1 = {
	name: 'obj1',
	foo: function () {
		console.log(this.name)
	}
}
var obj2 = {
	name: 'obj2',
	foo: () => {
		console.log(this.name)
	}
}
obj1.foo() // obj1
obj2.foo() // window

// Ex4
var name = 'window'
var obj1 = {
  name: 'obj1',
  foo: function () {
    console.log(this.name)
    return function () {
      console.log(this.name)
    }
  }
}
var obj2 = {
  name: 'obj2',
  foo: function () {
    console.log(this.name)
    return () => {
      console.log(this.name)
    }
  }
}
var obj3 = {
  name: 'obj3',
  foo: () => {
    console.log(this.name)
    return function () {
      console.log(this.name)
    }
  }
}
var obj4 = {
  name: 'obj4',
  foo: () => {
    console.log(this.name)
    return () => {
      console.log(this.name)
    }
  }
}
obj1.foo()() // obj1 window
obj2.foo()() // obj2 obj2
obj3.foo()() // window window
obj4.foo()() // window window

// Ex5
var name = 'window'
function Person (name) {
  this.name = name
  this.foo1 = function () {
    console.log(this.name)
  }
  this.foo2 = () => {
    console.log(this.name)
  }
}
var person2 = {
  name: 'person2',
  foo2: () => {
    console.log(this.name)
  }
}
var person1 = new Person('person1')
person1.foo1() // person1
person1.foo2() // person1
person2.foo2() // window

// Ex6
var name = 'window'
function Person (name) {
  this.name = name
  this.foo1 = function () {
    console.log(this.name)
    return function () {
      console.log(this.name)
    }
  }
  this.foo2 = function () {
    console.log(this.name)
    return () => {
      console.log(this.name)
    }
  }
  this.foo3 = () => {
    console.log(this.name)
    return function () {
      console.log(this.name)
    }
  }
  this.foo4 = () => {
    console.log(this.name)
    return () => {
      console.log(this.name)
    }
  }
}
var person1 = new Person('person1')
person1.foo1()() // person1 window
person1.foo2()() // person1 person1
person1.foo3()() // person1 window
person1.foo4()() // person1 person1

// Ex7 - 坑
// 箭头函数的 this 无法通过 bind、call、apply 来直接修改，但可通过改变作用域中 this 的指向来间接修改
var name = 'window'
var obj1 = {
  name: 'obj1',
  foo1: function () {
    console.log(this.name)
    return () => {
      console.log(this.name)
    }
  },
  foo2: () => {
    console.log(this.name)
    return function () {
      console.log(this.name)
    }
  }
}
var obj2 = {
  name: 'obj2'
}
obj1.foo1.call(obj2)() // obj2 obj2
obj1.foo1().call(obj2) // obj1 obj1
obj1.foo2.call(obj2)() // window window
obj1.foo2().call(obj2) // window obj2

// 总结
// 箭头函数里面的 this 是由外层作用域来决定的，且指向函数定义时的 this 而非执行时
// 字面量创建的对象，作用域是 window，若里面有箭头函数属性的话，this 指向的是 window
// 构造函数创建的对象，作用域可理解为是这个构造函数，且这个构造函数的 this 是指向新建的对象的，因此 this 指向这个对象。
// 箭头函数的 this 无法通过 bind、call、apply 来直接修改，但可通过改变作用域中 this 的指向来间接修改。
```

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123812.png" style="zoom:50%;" align="" />

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123813.png" style="zoom:50%;" align="" />





### 1-2-4-9、匿名函数

**<u>*匿名函数的 this 永远指向 window*</u>**

- 示例1：
  - 某解释：this 永远指向最后调用它的那个对象，但匿名函数因无名，故无法找到调用它的对象，故默认指向全局对象….
  - <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123814.png" style="zoom:50%;" align="" />
  - <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123815.png" style="zoom:50%;" align="" />
- 示例2：
  - window 调用了 fn7，故内部 this 指向 window，而箭头函数 this 绑定外层非箭头函数 this
  - <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123816.png" style="zoom:50%;" align="" />
- 示例3：
  - <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123817.png" style="zoom:50%;" align="" />
  - <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123818.png" style="zoom:50%;" align="" />





### 1-2-4-10、优先级分析

- call/apply 比一般高

  - ```js
    function foo (a) {
        console.log(this.a)
    }
    
    const obj1 = {
        a: 1,
        foo: foo
    }
    
    const obj2 = {
        a: 2,
        foo: foo
    }
    
    obj1.foo.call(obj2)
    obj2.foo.call(obj1)
    ```

- new 比 bind 高

  - ```js
    function foo (a) {
        this.a = a
    }
    
    const obj1 = {}
    
    var bar = foo.bind(obj1)
    bar(2)
    console.log(obj1.a) // 2
    
    var baz = new bar(3)
    console.log(baz.a) // 3
    ```

- 箭头函数 this 无法修改

  - ```js
    function foo() {
        return a => {
            console.log(this.a)
        };
    }
    
    const obj1 = {
        a: 2
    }
    
    const obj2 = {
        a: 3
    }
    
    const bar = foo.call(obj1)
    console.log(bar.call(obj2)) // 2
    
    // 示例2
    var a = 123
    const foo = () => a => {
        console.log(this.a)
    }
    
    const obj1 = {
        a: 2
    }
    
    const obj2 = {
        a: 3
    }
    
    var bar = foo.call(obj1)
    console.log(bar.call(obj2)) // 123
    
    // 示例3
    // 将上述 var a 修改为 const a
    console.log(bar.call(obj2)) // undefined
    // 因为 const 声明的变量不会挂载到 window 全局对象
    ```

    

### 1-2-4-11、典型事例

```js
Function.prototype.bind = Function.prototype.bind || function (context) {
    var me = this;
    var args = Array.prototype.slice.call(arguments, 1);
    return function bound () {
        var innerArgs = Array.prototype.slice.call(arguments);
        var finalArgs = args.concat(innerArgs);
        return me.apply(context, finalArgs);
    }
}
// 注意 bind 返回的函数如果作为构造函数，搭配 new 关键字出现的话，我们的绑定 this 就需要“被忽略”
// 为了实现这样的规则，开发者就应该需要考虑如何区分这两种调用方式。具体来讲 bound 函数中就要进行 this instanceof 的判断
// 另外注意 函数具有 length 属性，表示形参的个数。上述实现方式形参的个数显然会失真。我们的实现就需要对 length 属性进行还原。可是难点在于：函数的 length 属性值是不可重写的
// ....
```



```js
// 综合1：字面量对象中的各种场景
var name = 'window'
var person1 = {
  name: 'person1',
  foo1: function () {
    console.log(this.name)
  },
  foo2: () => console.log(this.name),
  foo3: function () {
    return function () {
      console.log(this.name)
    }
  },
  foo4: function () {
    return () => {
      console.log(this.name)
    }
  }
}
var person2 = { name: 'person2' }

person1.foo1() // person1
person1.foo1.call(person2) // person2

person1.foo2() // window
person1.foo2.call(person2) // window

person1.foo3()() // window
person1.foo3.call(person2)() // window
person1.foo3().call(person2) // person2

person1.foo4()() // person1
person1.foo4.call(person2)() // person2
person1.foo4().call(person2) // person1


// 综合2：构造函数中的各种场景 - 坑
var name = 'window'
function Person (name) {
  this.name = name
  this.foo1 = function () {
    console.log(this.name)
  },
  this.foo2 = () => console.log(this.name),
  this.foo3 = function () {
    return function () {
      console.log(this.name)
    }
  },
  this.foo4 = function () {
    return () => {
      console.log(this.name)
    }
  }
}
var person1 = new Person('person1')
var person2 = new Person('person2')

person1.foo1() // person1
person1.foo1.call(person2) // person2

person1.foo2() // person1
person1.foo2.call(person2) // person1

person1.foo3()() // window
person1.foo3.call(person2)() // window
person1.foo3().call(person2) // person2

person1.foo4()() // person1
person1.foo4.call(person2)() // person2
person1.foo4().call(person2) // person1


// 综合3:
var name = 'window'
function Person (name) {
  this.name = name
  this.obj = {
    name: 'obj',
    foo1: function () {
      return function () {
        console.log(this.name)
      }
    },
    foo2: function () {
      return () => {
        console.log(this.name)
      }
    }
  }
}
var person1 = new Person('person1')
var person2 = new Person('person2')

person1.obj.foo1()() // window
person1.obj.foo1.call(person2)() // window
person1.obj.foo1().call(person2) // person2

person1.obj.foo2()() // obj
person1.obj.foo2.call(person2)() // person2
person1.obj.foo2().call(person2) // obj


// 综合4
function foo() {
  console.log( this.a );
}
var a = 2;
(function(){
  "use strict";
  console.log(this) // undefined
  foo(); // 2
})();
```









## 1-3、执行栈

可以将执行栈理解为一个存储函数调用的 **栈结构**，遵循先进后出的原则；执行一个函数时，如果这个函数又调用了另外一个函数，而这个“另外一个函数”也调用了“另外一个函数”，便形成了一系列的调用栈

当开始执行 JS 代码时，首先会执行一个 `main` 函数，然后执行我们的代码。根据先进后出的原则，后执行的函数会先弹出栈；

注意：栈可存放的函数是有**限制**的，一旦存放了过多的函数且没有得到释放，就会发生 **栈溢出**；

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123819.png" style="zoom:50%;" />

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123820.png" style="zoom:50%;" />

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200909123821.png" style="zoom:50%;" />

正常来讲，在函数执行完毕并出栈时，函数内局部变量在下一个垃圾回收节点会被回收，该函数对应的执行上下文将会被销毁，这也正是我们在外界无法访问函数内定义的变量的原因。也就是说，只有在函数执行时，相关函数可以访问该变量，该变量在预编译阶段进行创建，在执行阶段进行激活，在函数执行完毕后，相关上下文被销毁




