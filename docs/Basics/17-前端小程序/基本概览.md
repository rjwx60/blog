

小程序基本流程、注意事项(目的、了解、技术栈、优化、效率开发、上线等)-大致了解；



playlist-组件swiper/image 使用、机型调整、样式调整、block标签、云函数的上传及使用/上传依赖问题解决、serverless概念、组件概念、组件思想、组件构建、组件引入、组件数据传递、样式中的背景图片，只能使用本地或base64转码后的、组件化开发的数据监听器 observers、wx:for 语法糖、云函数使用、依赖下载、调试方法等；云函数虽然便利，但开发太恶心了；要等待；node 中最重要的是异步操作；云函数获取云数据库限制，100，小程序中则20条限制；定时触发云函数-触发器--定时获取最新内容-json配置-triggers、tcb-router根据所在page请求，来触发相应方法，可看作API层级的路由



wx 04-09

setStorageAsync 与 setStorage 方法、获取全局唯一的背景音频管理器：const backgroundAudioManager = wx.getBackgroundAudioManager()；const app = getApp()—微信暴露方法，获取全局函数，data 可理解为可观察数据，与页面无关的变量应定义在最外层；否则才放里面；模糊使用 filter:blur(xxrpx)，遮罩层z-index:-2、Iconfont在WX上的引入与使用，微信后台模块使用声明：requiredBackgroundModes-audio、三元运算符；animation-play-state: paused；<x-progress-bar bind:musicEnd="onNext" 组件事件冒泡，小程序内置组件：movable-area & progress 使用；组件中使用 this 调用 this.createSelectorQuery；页面中使用 wx.createSelectorQuery、组件生命周期 lifetimes: { ready.... }，setData 对象中赋值 this.setData({ ['showTime.totalTime']: ... })、// this.data 设值方式只是静态，setData 才会动态关联显示、backgroundAudioManager.seek(duration * this.data.progress / 100)、子组件通知父级组件：this.triggerEvent('musicEnd’)、<x-progress-bar bind:musicEnd="onNext”、wx:if (DOM)与 hidden(样式变化) 区别、跨组件通讯：子组件传递到父级，父级再 this.selectComponent('.lyric').update(event.detail.currentTime) 调用组件方法，类似 CRX.getBackgroundPage.方法、小程序，750rpx 固定，然后根据不同设备去转换；wx.getSystemInfo({ 获取设备信息，然后可进行 rpx px 转换、externalClasses—父级给子级传递的使用样式类名(乱)……styleIsolation 又一个样式把控方式，这二种方式都很不好…(组件内部引入外部样式—。—，很不好，反了，顺序，奇怪操作)、插槽即自定义组件内部内容传入到自定义组件中的 slot 所占用位置，承载组件使用方的传入内容，当然若使用多个插槽，须提前在组件中的 options 声明：multipleSlots: true、微信原生组件(脱离 webview、层级最高、不能在容器使用(swiper、progress-bar)、)

