# 二、模块构建工具

模块化规范：规范如何组织代码，提高代码可读性，用以针对开发者；

包管理工具：用以管理包的安装、卸载、更新、查看、搜索、发布等；

模块化构建工具：用以组织前端模块逻辑的构建工具、现已不局限于模块化，还有很多便利的工具，如压缩、代码检查等；

| **包管理工具** |      **模块化构建工具**      |     **模块化规范**      |
| :------------: | :--------------------------: | :---------------------: |
|      npm       |           webpack            |        es6Module        |
|     bower      | requireJs、seaJs、browserify | AMD、CMD、UMD、CommonJS |



## 2-1、模块构建工具演变

<img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200918181214.png" style="zoom:50%;" align=""/>

- 黑暗时代、构建、通过在线工具压缩和混淆(避免代码逻辑暴露)、08年出现 YUI(可本地进行JSCSS压缩)
- 模块化推进、并催生各种规范；
- Grunt：Task Runner，将构建过程分为多个独立任务、任务处理完成后将结果存放到本地磁盘中，导致打包速度慢(涉及磁盘IO操作)
- Gulp、FIS3：改进前者；引入文件流概念，将处理结果存放内存中，下一任务可直接利用前一步处理结果，加速打包速度；
  - 注意 FIS3 已不再维护；
- Webpack：社区活跃、官方更迭速度快、配置灵活插件化扩展；
  - Rollup：主要引入了 tree-shaking 概念；

<img src="https://i.loli.net/2020/09/07/qRzjDmH9w5Vl2bK.png" style="zoom:50%;" align=""/>



## 2-2、模块工具简介

### 2-2-1、Browserify

Commonjs In Browser - 2011 - 2014 - 模块打包器

原理：其找出入口文件，解析 require-调用为 AST，以遍历项目的整个依赖关系，并将其所有依赖项都包含在出口文件中；

使用：`browserify main.js -o bundle.js`

- 注意：browserify 是 模块打包器，browserify 是在浏览器中利用 CommonJS 的思想实现；



### 2-2-2、Webpack

Module Bundler - 2014 - 模块打包器

基本：Webpack 始于 2012 年，由 Tobias Koppers 发起，⽤于解决当时前端开发的⼀个难题：构建复杂的单⻚ 应⽤程序(SPA)；Webpack 将⼀切都作为模块，然后通过不同加载器 loader 来加载这些模块；若想按需加载，则其还提供了代码拆分 (Code Splitting)

介绍：可处理 CommonJS 、 AMD 和 ES6 模块，并具有多种功能：

- loader：加载器，可加载任何文件到源文件中；用 require() 语法，可加载 Js、CSS、CoffeeScript、Sass、Less、HTML模板、图像等；
- plugin：可在打包写入到打包文件之前对其进行操作；比如，给打包代码添加注释，添加 Source map，将打包文件分离成块等等；
- tree-shaking：webpack2 引入： [webpack 2 中的 Tree Shaking](https://www.html.cn/archives/6946)，更多 tree-shaking 内容请看 rollup 小节
- dev-server：热更新开发；
- code-splitting：代码拆分；

### 2-2-2-1、Version diff

不管哪个版本，**<u>*均能节省前端程序员时间*</u>**：

Webpack 1 发布：

- 模块加载、代码拆分；

Webpack 2 发布：

- 增加 tree-shaking (借鉴 Rollup)；

Webpack 3 发布：

- 增加 Scope Hoisting (借鉴 Rollup)；

Webpack 4 发布：

- 免配置；
  - ⽐如默认 entry 为 ./src，默认 output  为 ./dist，即项目初始时不用配置 webpack.config (借鉴 Parcel)
  - <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200918181215.png" style="zoom:25%;" align=""/>
- [支持 JSON 的 tree-shaking](https://zhuanlan.zhihu.com/p/32691352)；
- 支持 .mjs (EcmaScript module)；
- 支持 WebAssembly，默认会寻找 .wasm , .mjs , .js 和 .json 扩展名的⽂件进⾏加载和打包；
- 优化提升，删除了 CommonsChunkPlugin，增加了 optimization.splitChunks 和 optimization.runtimeChunk；
  - CommonsChunkPlugin 存在 hash 问题，使用复杂，虽改造后仍复杂；
- 代码层面的最大变化：整个 Plugin 的事件注册与触发机制被重写，所有三方插件都要修改才能使用：

```js
// Webpack3 注册 与 触发
compiler.plugin(‘done’,callback)
compilitation.applyPlugins(‘done’,params)

// Webpack4 注册 与 触发
compiler.hooks.done.tap(‘mypluinname’,callback)
compiler.hooks.done.call()
```



### 2-2-3、SystemJS

通用模块加载器，能在浏览器 / Node 上动态加载模块、支持 CommonJS、AMD、全局模块对象和 ES6 模块；通过插件，可加载 Js、CoffeeScript、TypeScript；

优点：建立在 ES6 模块加载器之上，其语法 & API 在将来很可能是语言的一部分；



### 2-2-X、Rollup

普及 JS 圈内一重要特性：Tree shaking，即消除 JS 上下文中无用代码，只保留有用的代码；

原理：依赖于 ES6 模块 import / export 模块系统的静态结构(static structure) 来检测哪一模块没有被使用；



### 2-2-X-1、Tree-shaking

<u>注意：讨论的此版本为 2018年1月的 webpack 版本的 TreeShaking，webpack4 已无下述问题；</u>

背景：**<u>*Tree-shaking*</u>** 最早由 Rich Harris 的 rollup 实现，后来支持此功能的还有 webpack2、**<u>*Closure compiler*</u>**

定义：通过工具去除 JS  文件中没有使用到的代码或模块，以删除无用代码，实现性能优化；

意义：Tree-shaking 对 web 意义重大，是一极致优化的理想世界，是前端进化的又一个终极理想；



### 2-2-X-2、DCE

**<u>*DCE—dead code elimination*</u>**，消除无用代码；无用代码消除广泛存在于传统的编程语言编译器中，编译器可判断出哪些代码根本不影响输出，从而消除此部分代码，此称为 DCE，而 Tree-shaking 是 DCE 的新实现；

- JS 绝大多数情况都需通过网络加载，然后执行，加载文件越小，整体执行时间越短，故消除无用代码减少体积对 JS 非常有意义；
- JS DCE—Tree-shaking 与 传统 DCE 不一样，后者消除不可能执行的代码，前者关注于去除没有用到的代码；



### 2-2-X-2-1、Tree-Shaking 

<u>DeadCode</u> 几个特征：

- 代码不会被执行，不可到达；
- 代码执行结果不会被用到；
- 代码只影响死变量(只写不读)；
- <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200918181216.png" style="zoom:60%;" align=""/>

传统编译型的语言中，均由编译器将 <u>Dead Code</u> 从 AST 中删除；

而 JS 中 DCE 是由代码压缩优化工具 uglify 完成；

- 示例：均未增加 uglify 处理、未进行 DCE 的 rollup 和 webpack：
  - 现象：rollup 将无用代码 foo 和 unused 函数消除，但仍保留了不会执行到的代码，而 webpack 完整保留所有代码；
  - <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200918181217.png" style="zoom:60%;" align=""/>
- 示例：增加 uglify 处理、进行了 DCE 的 rollup 和 webpack：
  - 现象：中间是两者增加 uglify 的配置文件，右侧是两者输出结果：
  - <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200918181218.png" style="zoom:60%;" align=""/>





### 2-2-X-2-2、Tree-Shaking 原理

<u>***Tree-shaking 的消除原理依赖于 ES6 的模块特性，即要使用 ES6 module syntax 才可 Tree-shaking***</u>；其特点：

- 仅能作为模块顶层的语句出现；
- import 的模块名只能是字符串变量；
- import binding 是 immutable 的；

ES6 模块依赖关系是确定的、与运行时的状态无关，可进行可靠的静态分析，此亦乃 Tree-shaking 实现基础：

- 静态分析：即不执行代码，从字面量对代码进行分析；

- 比如：反例：ES6 前的模块化方案：动态 require 某模块时，只有执行后才知道引用了什么模块；

- 函数的 tree-shaking 验证：去除无用函数

  - 现象：rollup 与 webpack 操作的结果均无无用函数 get，很好；
  - <img src="https://leibnize-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200918181219.png" style="zoom:60%;" align=""/>

- 类的 tree-shaking 验证：去除无用类

  - 现象：rollup 与 webpack 操作的结果均包含了无用类的整体代码...；
  - <img src="https://i.loli.net/2020/09/07/8LHAQ4okgbREGsY.png" style="zoom:60%;" align=""/>

- 原因：

  - rollup 只能处理函数和顶层的 import/export 变量，无法将无用到的类方法去除；

  - js 动态语言的特性使得静态分析艰难；

  - SideEffect(副作用) 广泛存在(无法判断真正有用无用代码，删除有效代码)

    - ```js
      // SideEffect
      // Ex1
      function Menu() {
      }
      Menu.prototype.show = function() {
      }
      // Array 扩展
      Array.prototype.unique = function() {
        // 将 array 中的重复元素去除
      }
      export default Menu;
      // 若删除 menu.js，则对 Array 扩展也会被删除，就会影响功能
      
      
      // Ex2
      function Menu() {
      }
      Menu.prototype.show = function() {
      }
      var a = 'Arr' + 'ay'
      var b
      if(a == 'Array') {
          b = Array
      } else {
          b = Menu
      }
      b.prototype.unique = function() {
          // 将 array 中的重复元素去除
      }
      export default Menu;
      ```

      

- 总结：Tree-shaking 对顶层纯函数的效果好，其余处理效果不佳；

  - 函数的 SideEffect 相对较少、顶层函数相对更容易分析、而 babel 默认严格模式，减少顶层函数的动态访问方式也更容易分析；



### 2-2-X-2-3、Closure compiler

<img src="https://i.loli.net/2020/09/07/3APxNB96Gn14sit.png" style="zoom:60%;" align=""/>

现象：完美实现 Tree Shaking；

注意：完美结果是需要条件的，那就是 cc 的侵入式约束规范；必须在代码里添加这样的代码；

<img src="https://i.loli.net/2020/09/07/3APxNB96Gn14sit.png" style="zoom:60%;" align=""/>

总结：Google 定义一整套注解规范 <u>*Annotating JavaScript for the Closure Compiler*</u>，侵入式让人不爽，且 Google Closure Compiler 是 java 写的，而与基于 node 的各种构建库不太兼容(目前已有 nodejs 版 Closure Compiler)，Closure Compiler 使用较麻烦，迁移成本较大；



### 2-2-Y、构建工具的选择

<img src="https://i.loli.net/2020/09/07/SKbEdZ5nOl4uGBs.png" style="zoom:40%;" align=""/>

Webpack 和 Rollup 在不同场景下，都能发挥自身优势作用；

- webpack 作为打包工具，但是在定义模块输出的时候，webpack确不支持ESM，webpack插件系统庞大，确实有支持模块级的 Tree-Shacking 的插件，如webpack-deep-scope-analysis-plugin；
- rollup 支持程序流分析，能更加正确的判断项目本身的代码是否有副作用，其实就是 rollup 的 tree-shaking 更干净；
- 结论：rollup 比较适合打包 js 的 sdk 或者封装的框架等，例如，vue 源码就是 rollup 打包的；而 webpack 较适合打包一些应用，例如 SPA 或同构项目等；

