---
typora-root-url: ../Source
---



## 一、基本排序

**<u>*基本排序的基本思想非常类似：重排列时用的技术基本都是一组嵌套的for循环: 外循环遍历数组的每一项，内循环则用于比较元素*</u>**



### 1-1、冒泡排序

最笨最基本最经典点的方法，无需多言：

![](/Image/Algorithm/Sort/1.gif )

```js
function bubleSort(arr) {
    var len = arr.length;
    for (let outer = len ; outer >= 2; outer--) {
        for(let inner = 0; inner <=outer - 1; inner++) {
            if(arr[inner] > arr[inner + 1]) {
              	// 数值交换 — 最经典的交换策略
                let temp = arr[inner];
                arr[inner] = arr[inner + 1];
                arr[inner + 1] = temp;
              	// 或可利用 ES6 的解构赋值
              	[arr[inner],arr[inner+1]] = [arr[inner+1],arr[inner]]
            }
        }
    }
    return arr;
}
```

注意两点：

- 外层循环，从最大值开始递减，因为内层是两两比较，因此最外层当`>=2`时即可停止；
- 内层是两两比较，从0开始，比较 `inner` 与 `inner+1`，因此，临界条件是 `inner<outer -1`；



### 1-2、选择排序

选择排序是从数组的开头开始，将第一个元素与其他元素比较，检查完所有的元素后，最小的放在第一个位置，接下来再开始从第二个元素开始，重复直到最后；

![](/Image/Algorithm/Sort/2.gif )

```js
// 外层循环从0开始到 length-1， 然后内层比较，最小的放开头
function selectSort(arr) {
    var len = arr.length;
    for(let i = 0 ;i < len - 1; i++) {
        for(let j = i ; j<len; j++) {
            if(arr[j] < arr[i]) {
                [arr[i],arr[j]] = [arr[j],arr[i]];
            }
        }
    }
    return arr
}
```

注意：

- 外层循环的`i`表示第几轮，`arr[i]`就表示当前轮次最靠前(小)的位置；
- 内层从`i`开始，依次往后数，找到比开头小的，互换位置即可



### 1-3、插入排序

插入排序核心：扑克牌思想： 打扑克牌，接起来一张，放哪里无所谓，再接起来一张，比第一张小，放左边，继续接，可能是中间数，就插在中间....

![](/Image/Algorithm/Sort/3.gif )

其实每种算法，主要是理解其原理，至于写代码，都是在原理之上顺理成章的事情：

- 首先将待排序的第一个记录作为一个有序段
- 从第二个开始，到最后一个，依次和前面的有序段进行比较，确定插入位置

```js
function insertSort(arr) {
    for(let i = 1; i < arr.length; i++) {  // 外循环从1开始，默认 arr[0] 是有序段
        for(let j = i; j > 0; j--) {  //j = i,将arr[j]依次插入有序段中
            if(arr[j] < arr[j-1]) {
                [arr[j],arr[j-1]] = [arr[j-1],arr[j]];
            } else {
                break;
            }
        }
    }
    return arr;
}
```

注意这里两次循环中，`i`和`j`的含义：

1. `i`是外循环，依次把后面的数插入前面的有序序列中，默认`arr[0]`为有序的，`i`就从1开始
2. `j`进来后，依次与前面队列的数进行比较，因为前面的序列是有序的，因此只需要循环比较、交换即可
3. 注意这里的`break`，因为前面是都是有序的序列，所以如果当前要插入的值`arr[j]`大于或等于`arr[j-1]`，则无需继续比较，直接下一次循环即可；



### 1-X、时间复杂度对比

| 排序算法     | 平均时间复杂度 | 最坏时间复杂度 | 空间复杂度 | 是否稳定 |
| ------------ | :------------: | :------------: | :--------: | :------: |
| 冒泡排序     |     O(n²)      |     O(n²)      |    O(1)    |    是    |
| 选择排序     |     O(n²)      |     O(n²)      |    O(1)    |   不是   |
| 直接插入排序 |     O(n²)      |     O(n²)      |    O(1)    |    是    |

- 注意：插入排序时，若序列逆序，则每次插入都要一次次交换，此时速度和冒泡排序是一样，时间复杂度O(n²)；
- 注意：基本排序算法 ：基本思想就是两层循环嵌套，第一遍找元素O(n),第二遍找位置O(n)，所以这几种方法，时间复杂度就可以这么简便记忆啦!



## 二、高级排序

如果所有排序都像上面的基本方法一样，那么对于大量数据的处理，将是灾难性的



### 2-1、快速排序

快排是处理大数据最快的排序算法之一；

对前端来说，是最最最最重要的排序算法，没有之一(面试官大概率问)

快排是一种分而治之的算法，通过递归方式，将数据依次分解为包含较小元素和较大元素的不同子序列；该算法不断重复这个步骤直至所有数据都是有序；

比如，找一个数作为参考数 A，比这它大的数放在 A 左边，比它小的放在 A 右边； 然后分别再对左边和右变的序列做相同的操作:

1. 选择一个基准元素，将列表分割成两个子序列；
2. 对列表重新排序，将所有小于基准值的元素放在基准值前面，所有大于基准值的元素放在基准值的后面；
3. 分别对较小元素的子序列和较大元素的子序列重复步骤1和2

![](/Image/Algorithm/Sort/4.gif )

```js
function quickSort(arr) {
    if(arr.length <= 1) {
        return arr;  // 递归出口
    }
    var left = [],
        right = [],
        current = arr.splice(0,1); // 注意 splice 后，数组长度少了一个
    for(let i = 0; i < arr.length; i++) {
        if(arr[i] < current) {
            left.push(arr[i])  // 放在左边
        } else {
            right.push(arr[i]) // 放在右边
        }
    }
    return quickSort(left).concat(current,quickSort(right)); // 递归
}
```



### 2-2、希尔排序

希尔排序是插入排序的改良算法，但是核心理念与插入算法又不同，它会先比较距离较远的元素，而非相邻的元素；

![](/Image/Algorithm/Sort/5.gif )

```js
// 插入排序
function insertSort(arr) {
    for(let i = 1; i < arr.length - 1; i++) {  //外循环从1开始，默认arr[0]是有序段
        for(let j = i; j > 0; j--) {  //j = i,将arr[j]依次插入有序段中
            if(arr[j] < arr[j-1]) {
                [arr[j],arr[j-1]] = [arr[j-1],arr[j]];
            } else {
                continue;
            }
        }
    }
    return arr;
}

// 希尔排序
// 不同之处: 让步长按照 3、2、1 来进行比较，相当于是三层循环和嵌套
insertSort(arr,[3,2,1]);
function shellSort(arr,gap) {
  	// 观察过程
    console.log(arr) 
  	// 最外层循环，一次取不同的步长，步长需要预先给出
    for(let i = 0; i<gap.length; i++) {  
      	//步长为 n
        let n = gap[i]; 
      	// 接下类和插入排序一样，j 循环依次取后面的数 - 插入排序部分，但区别是 1 变为了 n
      	// 也即三层循环的内两层完全就是一个插入排序，但略有不同
        for(let j = i + n; j < arr.length; j++) { 
          	// k 循环进行比较，和直接插入的唯一区别是 1 变为了 n
            for(let k = j; k > 0; k-=n) { 
                if(arr[k] < arr[k-n]) {
                    [arr[k],arr[k-n]] = [arr[k-n],arr[k]];
                  	// 观察过程
                    console.log(`当前序列为[${arr}] \n 交换了${arr[k]}和${arr[k-n]}`)
                } else {
                    continue;
                }
            }
        }
    }
    return arr;
}

// 运行
var arr = [3, 2, 45, 6, 55, 23, 5, 4, 8, 9, 19, 0];
var gap = [3,2,1];
console.log(shellSort(arr,gap))
// (12) [3, 2, 45, 6, 55, 23, 5, 4, 8, 9, 19, 0] // 初始值
// 当前序列为[3,2,23,6,55,45,5,4,8,9,19,0] 
//  交换了45和23
// 当前序列为[3,2,23,5,55,45,6,4,8,9,19,0] 
//  交换了6和5
// 当前序列为[3,2,23,5,4,45,6,55,8,9,19,0] 
//  交换了55和4
// 当前序列为[3,2,23,5,4,8,6,55,45,9,19,0] 
//  交换了45和8
// 当前序列为[3,2,8,5,4,23,6,55,45,9,19,0] 
//  交换了23和8
// 当前序列为[3,2,8,5,4,23,6,19,45,9,55,0] 
//  交换了55和19
// 当前序列为[3,2,8,5,4,23,6,19,0,9,55,45] 
//  交换了45和0
// 当前序列为[3,2,8,5,4,0,6,19,23,9,55,45] 
//  交换了23和0
// 当前序列为[3,2,0,5,4,8,6,19,23,9,55,45] 
//  交换了8和0
// 当前序列为[0,2,3,5,4,8,6,19,23,9,55,45] 
//  交换了3和0
// 当前序列为[0,2,3,5,4,8,6,9,23,19,55,45] 
//  交换了19和9
// 当前序列为[0,2,3,4,5,8,6,9,23,19,55,45] 
//  交换了5和4
// 当前序列为[0,2,3,4,5,6,8,9,23,19,55,45] 
//  交换了8和6
// 当前序列为[0,2,3,4,5,6,8,9,19,23,55,45] 
//  交换了23和19
// 当前序列为[0,2,3,4,5,6,8,9,19,23,45,55] 
//  交换了55和45
```



### 2-X、时间复杂度对比

| 排序算法     | 平均时间复杂度 | 最坏时间复杂度 | 空间复杂度 | 是否稳定 |
| ------------ | :------------: | :------------: | :--------: | :------: |
| 冒泡排序     |     O(n²)      |     O(n²)      |    O(1)    |    是    |
| 选择排序     |     O(n²)      |     O(n²)      |    O(1)    |   不是   |
| 直接插入排序 |     O(n²)      |     O(n²)      |    O(1)    |    是    |
| 快速排序     |    O(nlogn)    |     O(n²)      |  O(logn)   |   不是   |
| 希尔排序     |    O(nlogn)    |     O(n^s)     |    O(1)    |   不是   |

- 注意：时间复杂度记忆
  - 冒泡、选择、直接 排序需要两个for循环，每次只关注一个元素，平均时间复杂度为O(n²)(一遍找元素O(n)，一遍找位置O(n)）
  - 快速、归并、希尔、堆基于二分思想，log以2为底，平均时间复杂度为O(nlogn)(一遍找元素O(n)，一遍找位置O(logn))



### 2-Y、注意事项

#### 2-Y-1、稳定性

若不考虑稳定性，快排似乎是近乎完美的方法之一，但它不稳定的：稳定性：通俗的讲：有两个相同的数 A 和 B，在排序前 A 在 B 前面，而经过排序后，B 变成在 A 的前面；此种情况就称：**<u>*排序的不稳定性*</u>**，而快排在对存在相同数进行排序时就有可能发生这种情况；

- 比如：对 (5，3A，6，3B ) 进行排序，排序前相同的数 3A 与 3B，A 在 B 前面，经过排序后会变成 (3B，3A，5，6)
- 危害：在前端领域，不稳定排序或操作将会使本身不需要变化的东西变化，比如 ul 的列表项快排，虽然相同但交换位置，导致重新渲染，带来性能损耗；





作者：Vincent Ko
链接：https://juejin.im/post/6844903656865677326