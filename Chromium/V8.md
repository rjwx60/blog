---
typora-root-url: ../Source
---



### 一、V8 JS 数据存储

基本数据类型用 **<u>栈</u>** 存储，引用数据类型用 **<u>堆</u>**  存储

- boolean、null、undefined、number、string、symbol、bigint

- 注意：对于赋值操作，原始类型的数据直接完整地赋值变量值，对象数据类型的数据则是复制引用地址；
- 注意：栈的功能除了保存变量外，还有创建并切换函数执行上下文的功能；当栈指针 ESP 下移，即上下文切换后，栈顶的空间会自动被回收；

```js
function f(a) {
  console.log(a);
}
function func(a) {
  f(a);
}
func(1);

// 首先，调用 func, 将 func 函数的上下文压栈，ESP 指向栈顶；
// 然后，执行 func，又调用 f 函数，将 f 函数的上下文压栈，ESP 指针上移；
// 然后，执行完 f 函数，将 ESP 下移，f 函数对应的栈顶空间被回收；
// 然后，执行完 func，ESP 下移，func 对应的空间被回收；
```

<img src="/Image/Chromium/500.png" style="zoom:40%;" align="left"/>

此外，可观察到，若采用栈来存储相对基本类型更加复杂的对象数据，则切换上下文的开销将变得巨大；



### 二、V8 JS 运行机制

#### 2-1、Make—执行代码

<img src="/Image/Chromium/600.png" style="zoom:40%;" align="left"/>

机器读不懂 JS 代码，机器只能理解特定的机器码；而 JS 属于解释型语言，需要先用解释器会对源代码进行解释转换；

- **预解析**：检查语法错误；
- **生成 AST**：经过词法分析/语法分析，生成  **<u>AST 抽象语法树</u>**；
- **生成字节码**：**<u>基线编译器 (Ignition)</u>** 将 AST 转换成 **<u>字节码</u>**；
- **生成机器码**：**<u>优化编译器 (Turbofan)</u>** 将字节码转换成优化过的 **<u>机器码</u>**，此外在逐行执行字节码的过程中，若某段代码经常被执行， V8 会将这段代码直接转换成机器码保存起来，下一次执行就不必经过字节码转换阶段，优化执行速度；
- **执行代码**；



##### 2-1-1、预解析

##### 2-1-2、生成 AST

生成 AST 分为两步：词法分析和语法分析：

- 词法分析：即分词，将一行行的代码分解成一个个 token；
- 语法分析：将生成的 token 数据，根据一定的语法规则转化为 AST；

注意：生成了 AST 后，编译器/解释器后续的工作都将依靠 AST 而非源代码；

注意：babel 工作原理即将 ES5 的代码解析生成 <u>ES5 的 AST</u>，然后将 ES5 的 AST 转换为 <u>ES6 的 AST</u>，最后才将 ES6 的 AST 转化为具体的 ES6 代码；





##### 2-1-3、生成字节码

生成 AST 之后，通过 V8 **<u>基线解释器(Ignition)</u>** 生成字节码；

- 子节码：是介于 AST 和 机器码间的代码，但与特定类型的机器码无关，字节码需要通过解释器将其转换为机器码然后执行；
- 注意：V8 早期是直接转为机器码，但体积太大，会有严重内存占用问题；后来通过解释器逐行执行字节码，省去了生成二进制文件的操作，减少内存压力；





##### 2-1-4、生成机器码

生成字节码后，通过 **<u>优化编译器 (Turbofan)</u>** 将字节码编译成优化过的 **<u>机器码</u>**；

注意：在逐行执行字节码的过程中，若 Turbofan 发现某段代码经常被执行， 则 V8 会将这段代码标记为 <u>热点代码(HotSpot)</u>，并将这段代码直接转换成机器码保存起来，下一次执行就不必经过字节码转换阶段，以优化执行速度；如此执行时间越久，执行效率越高；

注意：JS 并非纯粹的解释器语言，因为字节码不仅配合解释器，还有编译器的参与，而<u>两者根本区别</u>在于：前者会编译生成二进制文件，但后者不会；此外，这种字节码跟编译器、解释器结合的技术，称为 **<u>即时编译(JIT)</u>**；

<img src="/Image/Chromium/601.png" style="zoom:50%;" align="left"/>



##### 2-1-5、执行代码









#### 2-2、Context—执行上下文



#### 2-3、Call Stack —执行栈

可以将执行栈理解为一个存储函数调用的 **栈结构**，遵循先进后出的原则；当开始执行 JS 代码时，首先会执行一个 `main` 函数，然后执行我们的代码。根据先进后出的原则，后执行的函数会先弹出栈；注意：栈可存放的函数是有**限制**的，一旦存放了过多的函数且没有得到释放，就会发生 **栈溢出**；

<img src="/Image/Chromium/25.png" style="zoom:50%;" />

<img src="/Image/Chromium/26.png" style="zoom:50%;" />

<img src="/Image/Chromium/27.png" style="zoom:50%;" />



#### 2-4、Event Loop

前面讲到，执行 JS 代码时其实就是往执行栈中放入函数，而当遇到异步的代码时，会被 **挂起** 并在需要执行时加入到 Task(有多种 Task) 队列中；一旦执行栈为空，Event Loop(事件循环机制) 就会从 Task 队列 中拿出需要执行的代码并放入执行栈中执行；

<img src="/Image/Chromium/28.png" style="zoom:50%;" />

##### 2-4-1、宏微任务

JS 中的大部分任务都是在主线程上执行，常见的任务有：渲染事件、用户交互事件、JS 脚本执行、网络请求、文件读写完成事件等；而为让事件有条不紊地进行，JS 引擎需对执行顺序做一定处理，并采用  <u>队列</u> 的方式存储这些任务；比如 执行 for 循环时，将队列中的任务逐一取出并执行；但注意队列包含两种任务队列：

- <u>**普通任务队列**</u>：
- <u>**延迟任务队列**</u>：专门处理诸如 setTimeout/setInterval 等定时器回调任务；

```js
bool keep_running = true;
void MainTherad(){
  for(;;){
    // 执行队列中的任务
    Task task = task_queue.takeTask();
    ProcessTask(task);
    // 执行延迟队列中的任务
    ProcessDelayTask()
    if(!keep_running) // 若设置了退出标志，则直接退出线程循环
        break; 
  }
}
```

对于每个宏任务而言，其内部都有一个微任务队列，而引入微任务的初衷是为了解决异步回调的问题，对于异步回调的处理方式如下：

- 将异步回调进行宏任务队列的入队操作；
- 将异步回调放到当前宏任务的末尾；

若采用第一种方式，则执行回调的时机应在 <u>前面所有的宏任务完成之后</u>；若任务队列非常长，则回调迟迟得不到执行，造成 <u>应用卡顿</u>；

为规避这样的问题，V8 采用第二种方式，也即 微任务的解决形式：在每一个宏任务中定义一个 <u>**微任务队列**</u>，当该宏任务执行完成，会检查其中的微任务队列，若为空则直接执行下一个宏任务，否则依次执行微任务，执行完成才去执行下一个宏任务；



##### 2-4-1-1、宏微任务分类

- 宏任务—MacroTask：整体代码、setTimeout、setInterval、setImmediate、I/O、UI rendering、WebWorker等；
- 微任务—MicroTask：process.nextTick、Promises.then/reject-catch-finally、Object.observe、MutationObserver、以 Promise 为基础开发的其他技术(比如fetch API)、V8 的垃圾回收过程等；



##### 2-4-2、浏览器 EvLoop

- 首先，将整段脚本作为首个 **宏任务** 执行；
- 然后，执行过程中同步代码直接执行，**宏任务** 进入宏任务队列，**微任务**进入微任务队列；
- 然后，当前宏任务执行完全，执行栈为空，检查微任务队列，若有则依次执行，直到微任务队列为空；
- 然后，执行浏览器 UI 线程的渲染工作；
- 然后，检查是否有 Web worker 任务，有则执行；
- 最后，执行队首新的宏任务，回到第二步，依此循环，直到宏任务和微任务队列都为空；

```js
Promise.resolve().then(()=>{
  console.log('Promise1')  
  setTimeout(()=>{
    console.log('setTimeout2')
  },0)
});
setTimeout(()=>{
  console.log('setTimeout1')
  Promise.resolve().then(()=>{
    console.log('Promise2')    
  })
},0);
console.log('start');

// start
// Promise1
// setTimeout1
// Promise2
// setTimeout2
```



##### 2-4-3、Node EventLoop

<img src="/Image/Chromium/24.png" style="zoom:50%;" align="left"/>



##### 2-4-3-1、NodeEvLoop 关键执行阶段

Node 有三个非常重要的执行阶段：

- **<u>执行定时器回调阶段</u>**：亦称 **<u>timer 阶段</u>**：检查定时器诸如 setTimeout、setInterval，若到时间，就执行回调；

- **<u>轮询阶段</u>**：亦称 **<u>poll 阶段</u>**：Node 代码的异步操作，比如 文件I/O、网络I/O等执行完成后，就会通过 `data`、 `connect` 等事件，使得事件循环到达  `poll` 阶段，以通知 JS 主线程，到达了这个阶段后：
  - 若当前已存在定时器，且有定时器到达时间，便拿出执行，EventLoop 将回到  **<u>timer 阶段</u>**；
  - 若无定时器, 便会查看回调函数队列；
    - 若队列不为空，便遍历 callback 队列并同步执行，直到队列为空或者达到系统限制；
    - 若队列为空，则检查是否有 `setImmdiate` 回调；
      - 若有则前往 **<u>check 阶段</u>**；
      - 若无则继续等待，相当于阻塞了一段时间，等待 callback 被加入到队列中并立即执行，达到超时时间后则自动进入 **<u>check 阶段</u>**；

- **<u>check 阶段</u>**：相对简单的阶段，直接执行 `setImmdiate` 的回调；

上述三个阶段为一个循环过程，也是 Node 执行的最重要阶段，但不完整；



##### 2-4-3-2、NodeEvLoop 关键执行阶段完善

**<u>注意：若对过程不理解，可参考例子  2-4-5-4：定时器的执行顺序</u>**

- **<u>执行定时器回调阶段</u>**：亦称 **<u>timer 阶段</u>**：检查定时器诸如 setTimeout、setInterval，若到时间，就执行回调，注意，此阶段由 poll 阶段控制；
- **<u>I/O 异常回调阶段</u>**：处理一些上一轮循环中的 <u>少数未执行</u> 的 I/O 回调，比如 TCP 连接遇到 ECONNREFUSED，就会在此时执行回调；
- **<u>空闲、预备状态</u>**：第 2 阶段结束，poll 阶段未触发之前；

- **<u>轮询阶段</u>**：亦称 **<u>poll 阶段</u>**：此阶段会做两件事：
  - 回到 timer 阶段执行回调；
  - 执行 I/O 回调；
- 具体做法是：进入 **<u>poll 阶段</u>** 后：
  - 若当前已存在定时器，且 poll callback 函数队列为空，且有定时器到达时间，EventLoop 将回到  **<u>timer 阶段</u>**(拿出到时的定时器回调执行)；
  - 若无设定定时器, 便会查看 poll callback 函数队列；
    - 若队列不为空，便遍历 poll callback 队列并同步执行，直到队列为空或者达到系统限制；
      - **<u>关键：当 Node 代码异步操作(比如 文件I/O、网络I/O等)执行完成后，就会通过 `data`、 `connect` 等事件通知，使得 Ev Loop 到达  `poll` 阶段;</u>**
    - 若队列为空，则检查是否有 setImmdiate 回调；
      - 若有则前往 **<u>check 阶段</u>**；
      - 若无则继续等待，相当于阻塞了一段时间，等待 callback 被加入到队列中并立即执行，达到超时时间后则自动进入 **<u>check 阶段</u>**；

- **<u>check 阶段</u>**：相对简单的阶段，直接执行 setImmdiate 的回调；
- **<u>关闭事件的回调阶段</u>**：若一个 socket 或句柄 (handle) 被突然关闭，比如 socket.destroy()， `close` 事件回调就会在此阶段执行；

上述描述的是 macrotask 执行情况，对于 microtask 来说，它会在以上每个阶段完成前 **清空**  microtask 队列，下图中的 Tick 就代表了 microtask：

<img src="/Image/Chromium/29.png" style="zoom:50%;" align="left"/>





##### 2-4-3-3、Node 版本差异

- node 版本 >= 11：与浏览器表现一致，定时器运行完立即运行相应的微任务；
- node 版本 < 11：若第一个定时器任务出队并执行完，发现队首任务仍是一个定时器，则将微任务暂时保存，直接去执行新的定时器任务，当新的定时器任务执行完后，再一一执行中途产生的微任务；

```js
setTimeout(()=>{
    console.log('timer1')
    Promise.resolve().then(function() {
        console.log('promise1')
    })
}, 0)
setTimeout(()=>{
    console.log('timer2')
    Promise.resolve().then(function() {
        console.log('promise2')
    })
}, 0)
// node 版本 >= 11
timer1
promise1
time2
promise2
// node 版本 < 11
timer1
timer2
promise1
promise2
```



##### 2-4-4、浏览器与Node Ev Loop 差别

最主要的区别在于：浏览器中的微任务是在 **<u>每个相应的宏任务</u>** 间执行的，而 Node  中的微任务是在 **<u>不同阶段间</u>** 执行的；



##### 2-4-5、注意事项

##### 2-4-5-1、process.nextTick 执行

process.nextTick 是独立于 EvLoop 的任务队列；

当每个 NodeEvLoop 阶段完成后，若存在 nextTick 队列，就会 **<u>清空队列中的所有回调函数</u>**，且**<u>优先于其他微任务</u>** 执行；

```js
setTimeout(() => {
 console.log('timer1')

 Promise.resolve().then(function() {
   console.log('promise1')
 })
}, 0)

process.nextTick(() => {
 console.log('nextTick')
 process.nextTick(() => {
   console.log('nextTick')
   process.nextTick(() => {
     console.log('nextTick')
     process.nextTick(() => {
       console.log('nextTick')
     })
   })
 })
})
// 以上代码，无论如何，永远都是先把 nextTick 全部打印出来
```



##### 2-4-5-2、await 执行

```js
console.log('script start')

async function async111() {
  await async2222()
  console.log('async1 end')
}
async function async2222() {
  console.log('async2 end')
}
async111()

setTimeout(function() {
  console.log('setTimeout')
}, 0)

new Promise(resolve => {
  console.log('Promise')
  resolve()
})
.then(function() {
  console.log('promise1')
})
  .then(function() {
  console.log('promise2')
})

console.log('script end')
// script start => async2 end => Promise => script end => async1 end => promise1 => promise2 => setTimeout
```



##### 2-4-5-3、EvLoop 进入成本

进入 EvLoop 也是需要成本的：`setTimeout(fn, 0) === setTimeout(fn, 1)`

- 若准备时间花费大于 1ms，则在 timer 阶段就会直接执行 `setTimeout` 回调；
- 若准备时间花费小于 1ms，则 `setImmediate` 回调先执行；

```js
setTimeout(() => {
  console.log('timer21')
}, 0)

Promise.resolve().then(function() {
  console.log('promise1')
})
// EvLoop 准备时间不可能小于 0ms 故必定经历 timers 阶段，阶段经历后，清空微任务队列，故输出：promise1 -> timer21
```



##### 2-4-5-4、定时器的执行顺序

注意：某些情况下，定时器的执行顺序其实是 **随机** 的，这是由源码决定的：

```js
setTimeout(() => {
    console.log('setTimeout')
}, 0)
setImmediate(() => {
    console.log('setImmediate')
})
// setTimeout 可能执行在前，也可能执行在后
```

注意：而在某些情况下，定时器的执行顺序一定是 **固定** 的：

```js
const fs = require('fs')

fs.readFile(__filename, () => {
    setTimeout(() => {
        console.log('timeout');
    }, 0)
    setImmediate(() => {
        console.log('immediate')
    })
})
```

**<u>注意：若忘记 NodeEvLoop具体流程，可回看 2-4-3-2、NodeEvLoop 关键阶段完善</u>**

在上述代码中，`setImmediate` 永远**先执行**；分析过程：

- 首先，进入 Node EvLoop；
- 然后，当 Node 代码异步操作(比如 文件I/O、网络I/O等)执行完成后，就会通过 `data`、 `connect` 等事件通知，使得 Ev Loop 到达  **<u>poll 阶段</u>**；
- 因为，两个代码写在 IO 操作(此处是文件IO)的回调中，而 IO 回调是在 **<u>poll 阶段</u>**执行的；
- 所以，进入 **<u>poll 阶段</u>**后，首先主体代码无发现定时器，遂查看 poll callback 函数队列，且队列为空，并发现存在 `setImmediate` 回调，跳转到 check 阶段；
- 最后，**<u>check 阶段</u>** 直接执行 `setImmdiate` 的回调；



##### 2-4-6、示例集合















### 三、V8 垃圾回收机制

**新生代内存**：用于存活较短的对象；

- 可再分成两个空间：from 空间 与 to 空间；
- Scavenge GC 算法：当 from 空间被占满时启动 GC；
  - 存活的对象从 from space 按一定顺序转移到 to space；
  - 清空 from space；
  - from space 与 to space 互换，完成 GC；
  - 以上过程不断循环；

**老生代内存**：用于存活时间较长的对象；

- 从 新生代 转移到 老生代 的条件：
  - 经历过一次以上 Scavenge GC 的对象；
  - 当 to space 体积超过 25%；
- Mark-Sweep GC 算法：标记存活的对象，未被标记的则被释放；
- Mark-Compact 整理算法：将内存中清除后导致的碎片化对象往内存堆的一端移动；

**增量标记**：小模块标记，在代码执行间隙执行，缓解因 GC 的阻塞现象；

**并发标记**(最新技术)：不阻塞 JS 执行；



#### 3-1、V8内存限制与回收策略

V8 只能使用系统的一部分内存，比如在 64 位系统最多只能分配 1.4G，32 位系统最多只能分配 0.7G；而之所以这样限制，是因为：

- JS 是单线程的执行机制：一旦进入到垃圾回收，其它的各种运行逻辑都要暂停；
- JS垃圾回收机制的限制：垃圾回收过程非常耗时间；

<u>与其代码执行会一直没有响应，造成应用卡顿，所以还不如直接限制内存</u>；但注意某些场景还是可以提高内存限制的：

```js
// 调整老生代这部分的内存，单位是 MB
node --max-old-space-size=2048
```

```js
// 调整新生代这部分的内存，单位是 KB
node --max-new-space-size=2048
```



##### 3-1-1、突破限制实际案例

Angular：打包项目的时候就遇到过频繁报内存溢出：`FATAL ERROR: CALL_AND_RETRY_LAST Allocation failed - process out of memory`

解决：修改项目根目录  `node_modeles` 文件夹、`.bin` 目录、`ng`的文件首行：`#!/usr/bin/env node --max_old_space_size=4096`

VueReact：[详看](https://blog.csdn.net/qq_35624642/article/details/81084331)



##### 3-1-2、回收策略

通常情况下，垃圾数据回收分为 <u>手动回收</u> 和 <u>自动回收</u> 两种策略：

- **手动回收策略**：何时分配内存、何时销毁内存都是由代码控制的；
- **自动回收策略**：产生的垃圾数据是由垃圾回收器来释放的，并不需要手动通过代码来释放；



##### 3-1-3、引用计数与标记清除

- **引用计数**：给一个变量赋值引用类型，则该对象的引用次数 +1，若此变量变成了其他值，则该对象的引用次数-1，垃圾回收器会回收引用次数为 0 的对象；但当对象循环引用时，会导致引用次数永远无法归零，导致内存无法释放；
- **标记清除**：垃圾收集器先给内存中所有对象加上标记，然后从根节点开始遍历，去掉被引用的对象和运行环境中对象的标记，剩下的被标记的对象即无法访问的、等待回收的对象；




#### 3-2、栈内存数据回收管理

引擎会通过向下移动 ESP (记录当前执行状态的指针) 来销毁该函数保存在栈中的执行上下文；

栈的功能除了保存变量外，还有创建并切换函数执行上下文的功能；当栈指针 ESP 下移，即上下文切换后，栈顶的空间会自动被回收；

```js
function f(a) {
  console.log(a);
}
function func(a) {
  f(a);
}
func(1);

// 首先，调用 func, 将 func 函数的上下文压栈，ESP 指向栈顶；
// 然后，执行 func，又调用 f 函数，将 f 函数的上下文压栈，ESP 指针上移；
// 然后，执行完 f 函数，将 ESP 下移，f 函数对应的栈顶空间被回收；
// 然后，执行完 func，ESP 下移，func 对应的空间被回收；
```

<img src="/Image/Chromium/500.png" style="zoom:30%;" align="left"/>



#### 3-3、堆内存数据回收管理

V8 引擎对堆内存中的 JS 对象进行了分代管理：**新生代**、 **老生代**，并根据不同种类的堆内存，采用不同的回收策略，来根据不同的场景做针对性的优化：

- 新生代内存：临时分配的内存，存活时间短；如字符串、临时变量；
- 老生代内存：常驻内存，存活时间长；如主控制器、服务器对象；
- 注意：新生区通常只支持 1～8M 的容量，远小于老生区支持容量；对于两个区域，V8 分别使用两个不同的垃圾回收器，以便更高效地实施垃圾回收：
  - 副垃圾回收器，主要负责新生代的垃圾回收；
  - 主垃圾回收器，主要负责老生代的垃圾回收；
- 注意：不论什么类型的垃圾回收器，都有一套共同的执行流程：
  - 首先，标记空间中活动对象和非活动对象；前者即尚在使用的对象，后者即可进行垃圾回收的对象；
  - 然后，回收非活动对象所占据的内存；其实就是在所有的标记完成之后，统一清理内存中所有被标记为可回收的对象；
  - 最后，做内存整理：一般来说，频繁回收对象后，内存中就会存在大量不连续空间(内存碎片)，当内存中出现了大量的内存碎片之后，若需要分配较大连续内存的时候，就有可能出现内存不足的情况；所以最后一步需要整理这些内存碎片；(实际可选，因为有的垃圾回收器不会产生内存碎片)；



#### 3-4、新生代内存回收算法—Scavenge 算法

##### 3-4-1、Scavenge 算法回收流程

<img src="/Image/Chromium/501.png" style="zoom:50%;" align="left"/>

<img src="/Image/Chromium/505.png" style="zoom:30%;" align="left"/>

首先，将新生代内存空间一分为二：From 部分，为 <u>对象区域</u>，表示正在使用的内存，To  为 <u>空闲区域</u>，是目前闲置的内存；

- 注意：新加入的对象都会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作；
- 注意：在垃圾回收过程中，首先要对对象区域中的垃圾做标记，标记完成之后，才进入垃圾清理阶段；

然后，当进行垃圾回收时，V8 将 From 部分的对象检查一遍，

- 若是存活对象，副垃圾回收器会把这些存活的对象复制到空闲区域 To，同时将这些对象有序地排列(即同时完成了内存整理操作)

- 若是非存活对象则直接回收；

然后，当所有 From 中的存活对象按照顺序进入 To 内存后，From 和 To 两者的角色<u>翻转</u>，即 From 现在被闲置，To 被使用，完成回收操作，如此循环；

- 注意：这种角色翻转操作，还能让新生代中的这两块区域无限重复使用下去；

不足：内存只能使用新生代内存的一半，但只存放生命周期短的对象，这种对象 `一般很少`，因此`时间`性能非常优秀；

优化：为提升执行效率，一般新生区空间会被设置得较小，故也容易被存活对象装满整个区域，为了解决此问题，JS 引擎采用了`对象晋升策略`：

- 已经历过一次 Scavenge 回收；
- To (闲置) 空间的内存占用超过25%；



##### 3-4-2、内存碎片处理策略

为解决存活对象的空间不连续对后续的空间分配造成障碍，To 内存按照一定顺序放置，以解决内存碎片问题：

- 比如：深色方块代表存活对象，白色部分表示待分配内存，因堆内存是连续分配，但零散的空间(内存碎片)会导致稍大对象无法进行空间分配；

- 注意：堆包含一个链表来维护已用和空闲的内存块。在堆上新分配（用 new 或者 malloc）内存是从空闲的内存块中找到一些满足要求的合适块，就须要一整块连续的内存空间才能申请成功；



<img src="/Image/Chromium/502.png" style="zoom:50%;" align="left"/>

<img src="/Image/Chromium/503.png" style="zoom:50%;" align="left"/>



#### 3-5、旧生代内存回收—Mark-Sweep 算法

##### 3-5-1、Mark-Sweep 算法回收流程

<img src="/Image/Chromium/506.png" style="zoom:30%;" align="left"/>

首先，`标记阶段` 会遍历堆中所有对象，并做上标记；然后取消代码环境中 `使用的变量` 以及被 `强引用` 的变量的标记；

- 注意：标记阶段从一组根元素开始，递归遍历这组根元素(遍历调用栈)，在遍历过程中，能到达的元素称为 <u>活动对象</u>，否则可判断为 <u>垃圾数据</u>；

然后，`清除阶段` 对标记变量进行空间回收；

然后，整理内存碎片，将存活的对象全部往一端靠拢(最耗时)；

- 注意：清除算法后，会产生大量不连续的内存碎片，而碎片过多会导致大对象无法分配到足够的连续内存，于是又产生了 <u>标记—整理(Mark-Compact) 算法</u>，其标记过程仍然与 Mark-Sweep 一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存，从而让存活对象占用连续的内存块；

不足：内存碎片最耗时；



##### 3-5-2、内存碎片处理策略

为解决存活对象的空间不连续对后续的空间分配造成障碍，将存活的对象全部往一端靠拢，以解决内存碎片问题；

<img src="/Image/Chromium/504.png" style="zoom:50%;" align="left"/>



##### 3-5-3、算法比较

<img src="/Image/Chromium/507.png" style="zoom:50%;" align="left"/>



#### 3-6、增量标记—Incremental Marking 算法

V8 在进行垃圾回收时，由于 JS 单线程机制，不可避免地会阻塞业务逻辑执行(<u>全停顿</u>)；在 V8 新生代的垃圾回收中，因其空间较小，且存活对象较少，故全停顿影响不大，但老生代则不同，为了降低老生代的垃圾回收而造成的卡顿，V8 采取 **<u>增量标记(Incremental Marking)算法</u>** ：

将标记过程分为一个个的子标记过程，同时让垃圾回收标记和 JS 应用逻辑交替进行，直到标记阶段完成，才进入内存碎片的整理；

使用增量标记算法，可将一完整的垃圾回收任务拆分为很多小的任务，而小任务执行时间较短，可穿插在其他的 JS 任务中间执行，如此当执行某些动画效果时，就不会让用户因为垃圾回收任务而感受到页面的卡顿；使得垃圾回收过程对 JS 应用的阻塞时间减少为原来的 1 / 6；




#### 3-7、内存泄露—Memory Leak

不再用到的内存，没有及时释放，就叫做内存泄漏；

##### 3-7-1、内存泄露原因

- 意外的**全局变量**: 无法被回收
- **定时器**: 未被正确关闭，导致所引用的外部变量无法被释放
- **事件监听**: 没有正确销毁 (低版本浏览器可能出现)
- **闭包**: 会导致父级中的变量无法被释放
- **dom 引用**: dom 元素被删除时，内存中的引用未被正确清空



- 缓存：缓存须有存储容量上限，否则高内存消耗将会导致缓存突破上限，而缓存内容无法被回收；

- 队列消费不及时：当浏览器队列消费不及时时，会导致一些作用域变量得不到及时的释放，因而导致内存泄漏；

- 全局变量：意外导致的全局变量，如：

```js
function foo(arg) {
	// 由于 this 使用不当导致的全局变量
	this.bar = "this is a hidden global variable"
	// 没有使用 var/let/const 定义变量导致全局变量
  bar = "this is a hidden global variable";
}
```

- 计时器中引用没有清除

```
var someData = getData();
setInterval(function() {
    var node = document.getElementById('Node');
    if(node) node.innerHTML = JSON.stringify(someData));
}, 1000);
// Node 节点被删除后，会导致计时器中的回调函数无法被回收，同时，someData 数据也是无法被回收的；
```

- 闭包

```js
var theThing = null;
var replaceThing = function () {
  var originalThing = theThing;
  // 变量 unused 是一个引用 originalThing(theThing) 的闭包，闭包的作用域一旦创建，便有同样的父级作用域，作用域是共享的
  var unused = function () {
    if (originalThing)
      console.log("hi");
  };
  theThing = {
    longStr: new Array(1000000).join('*'),
    // someMethod 可通过 theThing 使用，someMethod 与 unused 分享闭包作用域
    // 尽管 unused 从未使用，它引用的 originalThing 迫使它保留在内存中
    someMethod: function () {
      console.log(someMessage);
    }
  };
};
setInterval(replaceThing, 1000);
// 每次调用 replaceThing ，theThing 会创建一个大数组和一个新闭包（someMethod）的新对象
// 闭包的链表已创建，每一个闭包作用域携带一个指向大数组的间接的引用，造成严重的内存泄漏
```

- 事件监听：
  - 比如：Node.js 中 Agent 的 keepAlive 为 true 时，可能造成的内存泄漏；
  - 因为：当 Agent keepAlive 为 true 时，将会复用之前使用过的 socket，若在 socket 上添加事件监听而忘记清除的话，因为 socket 的复用，将导致事件重复监听从而产生内存泄漏；



##### 3-7-2、[内存泄露识别](https://juejin.im/post/5db2beb8e51d455b450a64b4#heading-8)

用 chrome 中的 timeline 进行内存标记，可视化查看内存的变化情况，找出异常点；



##### 3-7-3、内存泄露避免

- 避免使用全局变量，避免意外产生全局变量；
- 使用闭包要及时注意，有 DOM 元素的引用要及时清理;
- 计时器里的回调没用时要记得销毁；
- 为避免疏忽导致的遗忘，可使用 `WeakSet` 和 `WeakMap` 结构，它们对于值的引用都是不计入垃圾回收机制的，表示这是弱引用：

```js
// 基本上，如果你要往对象上添加数据，又不想干扰垃圾回收机制，就可以使用 WeakMap
const wm = new WeakMap();
const element = document.getElementById('example');

// 一旦消除对该节点的引用，它占用的内存就会被垃圾回收机制释放, Weakmap 保存的这个键值对，也会自动消失
wm.set(element, 'some information');
wm.get(element) // "some information"
```



#### 3-X、V8 优化

JS 问题：

- **动态类型**：导致每次存取属性/寻求方法时，都需要先检查类型；此外动态类型也很难在编译阶段进行优化；
- **属性存取**：C++/Java等语言中方法、属性是存储在数组中的，仅需数组位移就可以获取，而 JS 存储在对象中，每次获取都要进行哈希查询；

V8 优化：

- **优化 JIT (即时编译)**：相较于C++/Java这类编译型语言，JS 边解释边执行，效率低；
  - V8 对此过程进行了优化：若一段代码被执行多次，则将此段代码转化为机器码缓存下来，下次运行时直接使用机器码；
- **隐藏类**：C++ 这类语言仅需几个指令就能通过偏移量获取变量信息，而 JS 需要进行字符串匹配，效率低下；
  - V8 借用类和偏移位置的思想，将对象划分成不同的组，即隐藏类；
- **内嵌缓存**：即缓存对象查询的结果；常规查询过程是：获取隐藏类地址 -> 根据属性名查找偏移值 -> 计算该属性地址，内嵌缓存就是对这一过程结果的缓存；
- **垃圾回收**：前文已介绍；