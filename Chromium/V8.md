---
typora-root-url: ../../BlogImgsBed/Source
---



### 一、V8 JS 数据存储

基本数据类型用 **<u>栈</u>** 存储，引用数据类型用 **<u>堆</u>**  存储

- boolean、null、undefined、number、string、symbol、bigint

- 注意：对于赋值操作，原始类型的数据直接完整地赋值变量值，对象数据类型的数据则是复制引用地址；
- 注意：栈的功能除了保存变量外，还有创建并切换函数执行上下文的功能；当栈指针 ESP 下移，即上下文切换后，栈顶的空间会自动被回收；

```js
function f(a) {
  console.log(a);
}
function func(a) {
  f(a);
}
func(1);

// 首先，调用 func, 将 func 函数的上下文压栈，ESP 指向栈顶；
// 然后，执行 func，又调用 f 函数，将 f 函数的上下文压栈，ESP 指针上移；
// 然后，执行完 f 函数，将 ESP 下移，f 函数对应的栈顶空间被回收；
// 然后，执行完 func，ESP 下移，func 对应的空间被回收；
```

<img src="/Image/Chromium/500.png" style="zoom:40%;" align="left"/>

此外，可观察到，若采用栈来存储相对基本类型更加复杂的对象数据，则切换上下文的开销将变得巨大；

#### 1-1、函数传参

```js
function test(person) {
  person.age = 26
  person = {
    name: 'hzj',
    age: 18
  }
  return person
}
const p1 = {
  name: 'fyq',
  age: 19
}
const p2 = test(p1)
console.log(p1) // p1：{name: “fyq”, age: 26}
console.log(p2) // p2：{name: “hzj”, age: 18}
// 原因:
// 在函数传参时, 传递的是对象在堆中的内存地址值，test  函数中的实参 person 是 p1 对象的内存地址，通过调用 person.age = 26 确实改变了 p1 的值，但随后person 变成了另一块内存空间的地址，并且在最后将这另外一份内存空间的地址返回，赋给了 p2;
```







### 二、V8 JS 运行机制

#### 2-1、Make—执行代码

<img src="/Image/Chromium/600.png" style="zoom:40%;" align="left"/>

机器读不懂 JS 代码，机器只能理解特定的机器码；而 JS 属于解释型语言，需要先用解释器会对源代码进行解释转换；

- **预解析**：检查语法错误；
- **生成 AST**：经过词法分析/语法分析，生成  **<u>AST 抽象语法树</u>**；
- **生成字节码**：**<u>基线编译器 (Ignition)</u>** 将 AST 转换成 **<u>字节码</u>**；
- **生成机器码**：**<u>优化编译器 (Turbofan)</u>** 将字节码转换成优化过的 **<u>机器码</u>**，此外在逐行执行字节码的过程中，若某段代码经常被执行， V8 会将这段代码直接转换成机器码保存起来，下一次执行就不必经过字节码转换阶段，优化执行速度；
- **执行代码**；



##### 2-1-1、预解析

##### 2-1-2、生成 AST

**抽象语法树 (Abstract Syntax Tree)**，是将代码逐字母解析成 **树状对象** 的形式；这是语言间的转换、代码语法检查，代码风格检查，代码格式化，代码高亮，代码错误提示，代码自动补全等等的基础；生成 AST 分为两步：词法分析和语法分析：

- 词法分析：即分词，将一行行的代码分解成一个个 token；
- 语法分析：将生成的 token 数据，根据一定的语法规则转化为 AST；

注意：生成了 AST 后，编译器/解释器后续的工作都将依靠 AST 而非源代码；

注意：babel 工作原理即将 ES5 的代码解析生成 <u>ES5 的 AST</u>，然后将 ES5 的 AST 转换为 <u>ES6 的 AST</u>，最后才将 ES6 的 AST 转化为具体的 ES6 代码；

- 比如 babylon 将 ES6/ES7 代码解析成 AST；
- babel-traverse 对 AST 进行遍历转译，得到新的 AST；
- 新 AST 通过 babel-generator 转换成 ES5；

```js
function square(n){
	return n * n
}
// 通过解析转化成的 AST 如下图
```

<img src="/Image/Chromium/51.png" style="zoom:30%;" align="left"/>

补充：Babel 原理：大多数 JS Parser遵循 `estree` 规范，Babel 最初基于 `acorn` 项目(轻量级现代 JavaScript 解析器) Babel大概分为三大部分：

- 解析：将代码转换成 AST
  - 词法分析：将代码(字符串)分割为 token 流，即语法单元成的数组；
  - 语法分析：分析token流(上面生成的数组)并生成 AST；
- 转换：访问 AST 的节点进行变换操作生产新的 AST；
  - 比如：[Taro](https://github.com/NervJS/taro/blob/master/packages/taro-transformer-wx/src/index.ts#L15) 即利用 babel 完成的小程序语法转换；
- 生成：以新的 AST 为基础生成代码；










##### 2-1-3、生成字节码

生成 AST 之后，通过 V8 **<u>基线解释器(Ignition)</u>** 生成字节码；

- 子节码：是介于 AST 和 机器码间的代码，但与特定类型的机器码无关，字节码需要通过解释器将其转换为机器码然后执行；
- 注意：V8 早期是直接转为机器码，但体积太大，会有严重内存占用问题；后来通过解释器逐行执行字节码，省去了生成二进制文件的操作，减少内存压力；





##### 2-1-4、生成机器码

生成字节码后，通过 **<u>优化编译器 (Turbofan)</u>** 将字节码编译成优化过的 **<u>机器码</u>**；

注意：在逐行执行字节码的过程中，若 Turbofan 发现某段代码经常被执行， 则 V8 会将这段代码标记为 <u>热点代码(HotSpot)</u>，并将这段代码直接转换成机器码保存起来，下一次执行就不必经过字节码转换阶段，以优化执行速度；如此执行时间越久，执行效率越高；

注意：JS 并非纯粹的解释器语言，因为字节码不仅配合解释器，还有编译器的参与，而<u>两者根本区别</u>在于：前者会编译生成二进制文件，但后者不会；此外，这种字节码跟编译器、解释器结合的技术，称为 **<u>即时编译(JIT)</u>**；

<img src="/Image/Chromium/601.png" style="zoom:50%;" align="left"/>



##### 2-1-5、执行代码









#### 2-2、执行上下文

执行上下文 Context  是 JS 执行一段代码时的运行环境，比如调用一个函数，就会进入此函数的执行上下文，确定该函数在执行期间用到的诸如 this、变量、对象以及函数等，但亦可简单理解为一个对象：

- Context 包含三个部分：

  - **<u>变量对象(VO)</u>**：可抽象为一种 **数据作用域**
    - 也可理解为就一简单对象：<u>存储着该执行上下文中的所有 **变量和函数声明(不包含函数表达式)**</u>；
    - **<u>活动对象 (AO)</u>**：当变量对象所处的上下文为 active EC 时，称为活动对象；
  - **<u>作用域链(词法作用域)</u>**：可理解为一组对象列表，包含 **父级和自身的变量对象**，故能通过 <u>作用域链</u> 访问父级中声明的变量或函数；由以下两部分组成，如此 `[[scopr]]`包含`[[scope]]`，便自上而下形成一条 **<u>链式作用域</u>**；**<u>用人话讲就是</u>**：当访问一个变量时，解释器会首先在当前作用域查找标示符，若没有找到，就去父作用域找，直到找到该变量的标示符或者不在父作用域中，这就是作用域链；但须注意，每一子函数均会拷贝上级的作用域，形成一个作用域的链条；注意：作用域在预编译阶段确定，但是作用域链是在执行上下文的创建阶段完全生成的。因为函数在调用时，才会开始创建对应的执行上下文；
    - `[[scope]]`属性：指向父级变量对象和作用域链，也即包含了父级的`[[scope]]` 和 `AO`；
    - AO：自身活动对象；
    - **<u>作用域</u>**：可理解为该上下文中声明的 **变量和声明的作用范围**，可分为 **块级作用域** 和 **函数作用域**；
      - 特性A：**声明提前**: 一个声明在函数体内都是可见的, 函数优先于变量；
      - 特性B：非匿名自执行函数，函数名变量为 **只读** 状态，无法修改；
    - **<u>闭包</u>**：一种特殊的作用域，称为 <u>静态作用域</u>；其定义可理解为：<u>父函数被销毁</u> 的情况下，而返回出的子函数的`[[scope]]`中仍保留父级的单变量对象、作用域链，因此可继续访问到父级的变量对象，如此的函数称为闭包；详看下方闭包小节；
      - 问题：多个子函数的`[[scope]]` 均同时指向父级，完全共享；故当父级的变量对象被修改时，所有子函数都受到影响；
      - 解决:
        - 变量可以通过 **函数参数的形式** 传入，避免使用默认的`[[scope]]`向上查找；
        - 使用`setTimeout`包裹，通过第三个参数传入；
        - 使用 **块级作用域**，让变量成为自己上下文的属性，避免共享；
  - **<u>this 指向</u>**；

- Context 类型：

  - **<u>全局执行上下文</u>**：默认上下文，任何不在函数内部的代码均在全局上下文中(一程序中只有一全局上下文)；它会执行两件事：
    - 创建一个全局 window 对象 (浏览器)；
    - 设置 this 的值等于这个全局对象；
  - **<u>函数执行上下文</u>**：每当一函数被调用时，都会为该函数创建一新的上下文；每个函数都有它自己的执行上下文，不过是在函数被调用时创建；函数上下文可有任意多个，每当一个新的执行上下文被创建，它会按定义的顺序执行一系列步骤；
  - **<u>Eval 函数执行上下文</u>**：执行在 eval 函数内部的代码也会有它属于自己的执行上下文；

  创建执行上下文有两个阶段：1) 编辑(创建)阶段 和 2) 执行阶段。举个例子：

- 代码执行过程(简述，详细请看 2-2-1)：

  - 创建 **全局上下文** (global EC)；
  - 全局执行上下文 (caller) 逐行 **自上而下** 执行；遇到函数时，即创建新 execution context，随后此**<u>函数执行上下文 (callee)</u>** 被压入 <u>**执行栈—CallStack(执行上下文栈—Execution Context Stack)**</u> 顶层；
  - 函数执行上下文被激活，成为 active EC, 开始执行函数中的代码，caller 被挂起；
  - 函数执行完后，caller 被`pop`移除出执行栈，控制权交还全局上下文 (caller)，继续执行；
  
  <img src="/Image/Chromium/52.png" style="zoom:45%;" />



<img src="/Image/Chromium/50.png" style="zoom:45%;" />





##### 2-2-1、代码执行过程

创建时机：函数调用时都会创建出新的上下文；创建步骤：[参考](https://www.youtube.com/watch?v=Nt-qa_LlUH0)

- **<u>内存分配 (Creation Phase)</u>** ：
  - 变量对象的创建
  - 作用域链的创建
  - 确定 this 值；
- **<u>代码执行 (Code Execution Phase)</u>** 
- 变量赋值、引用函数、解释/执行代码；

##### 2-2-1-1、Creation Phase 1/3

变量对象创建 (Variable Object / Activation Object)，变量对象创建，即开始进入了变量的生命周期；

<img src="/Image/Chromium/54.png" style="zoom:45%;" align="left" />

变量的生命周期包含了声明(Declaration phase)、初始化(Initialization phase)与赋值(Assignment phase)过程这三个过程

变量对象包含：当前执行上下文中所有变量、函数及具体分支中的定义，各类型变量对象的创建时机：

- let 定义变量：Declaration；
- var 定义变量：Declaration、Initialization；
- const 定义变量：Declaration、Initialization；
- Function 定义变量：Declaration、Initialization、Assignment；

<img src="/Image/Chromium/54-1.png" style="zoom:45%;" align="left" />

<img src="/Image/Chromium/56.png" style="zoom:45%;" align="left" />

注意：因这一步，可在变量或者函数定义之前，访问这些变量，感觉就像是变量提升了，但这实际上是 JS 解析机制作用的结果；

注意：let 仅 Declaration，并无 Initialization，在 Initialization 前使用会报错，即TDZ；

<img src="/Image/Chromium/57.png" style="zoom:45%;" align="left" />

注意：由图知，let 对变量 Declaration，但因 Initialization 前使用引发了错误，故没能正常 Initialization，而这种 Initialization 只有1次机会，导致后续补救措施失效；

注意：const 的 Declaration 和 Initialization 须同步，否则报错；

<img src="/Image/Chromium/58.png" style="zoom:45%;" align="left" />

<img src="/Image/Chromium/59.png" style="zoom:45%;" align="left" />



##### 2-2-1-2、Creation Phase 2/3

作用域链的创建；作用域链可被认为是包含了其自身 Variable Object 引用以及所有的父 Variable Object 引用的对象；

作用域链常被用于变量解析，当需解析某个具体的变量时，Js 解释器会在作用域链上递归查找，直到找到合适变量或任何其他需要的资源

<img src="/Image/Chromium/60.png" style="zoom:45%;" align="left" />

解析顺序(优先级)：

- 语言自身定义 (Language-defined)：所有的作用域默认都会包含 this 和 arguments；
- 函数形参 (Formal parameters)：函数有名字的形参会进入到函数体的作用域中；
- 函数声明 (Function decalrations)：通过 function foo() {} 的形式；
- 变量声明 (Variable declarations)：通过 var foo 的形式；

<img src="/Image/Chromium/61.png" style="zoom:45%;" align="left" />

<img src="/Image/Chromium/62.png" style="zoom:45%;" align="left" />



##### 2-2-1-3、Creation Phase 3/3

<img src="/Image/Chromium/63.png" style="zoom:45%;" align="left" />



##### 2-2-1-4、Code Execution Phase 1/1

代码执行：此步会发生普通变量生命周期的赋值，函数的直接调用(又发生一个上下文的创建过程…)



##### 2-2-1-5、综述

综述1：

代码执行的整个过程说起来就像**一条生产流水线**。第一道工序是在预编译阶段创建**变量对象**(Variable Object)，此时只是创建，而未赋值。到了下一道工序代码执行阶段，变量对象转为**激活对象**(Active Object)，即完成 VO → AO。此时，作用域链也将被确定，它由当前执行环境的变量对象和所有外层已经完成的激活对象组成。这道工序保证了变量和函数的有序访问，即如果当前作用域中未找到变量，则继续向上查找直到全局作用域



综述2：

- 调用函数代码；

- 在执行函数代码前，

- 创建阶段：

- - 初始化 作用域链 Scope Chain

  - 创建 变量对象 Variable object

  - - 创建实参对象 (arguments object)，检查 context 形参 (parameters)，初始化参数名称和参数值，并且创建一份引用拷贝；

    - 扫描context中的函数声明：

    - - 为每一函数在 Varible object 上创建属性，属性名即函数名，含有一个指向内存中函数的引用指针；
      - 若函数名已存在，则此引用指针值将会被重写；

  - 扫描 context 中变量申明：

  - - 为每一变量在 Variable object 上创建属性， 属性名即变量名，并将变量值初始化为 undefined； 
    - 若变量名已存在，则什么均不会发生，并继续扫描；

- 激活/代码执行阶段：

- - 运行/解释 context 中函数代码，并且根据代码一行一行的执行，为变量赋值；

- 示例如下：

<img src="/Image/Chromium/64.png" style="zoom:50%;" align="left" />

当调用foo(22)时，创建阶段时，context 如下：

故创建阶段时，只负责对属性名称(变量名)定义，但并无赋值 (例外：formal arguments / parameters(实参 / 形参) )

<img src="/Image/Chromium/65.png" style="zoom:50%;" align="left" />

创建阶段完成后，执行流进入函数内部，激活执行阶段(execution stage)，然后代码完成执行，context 如下：

<img src="/Image/Chromium/66.png" style="zoom:50%;" align="left" />

Why Hoisting：

<img src="/Image/Chromium/67.png" style="zoom:50%;" align="left" />

Why foo can be visited before declare？

跟踪 creation stage，则知代码执行阶段之前，变量已被创建，故在函数流开始执行之前，foo 已经在 activation object中被定义；

Foo has been declared twice, why last foo show function instead of undefined or string？

创建阶段，函数创建在变量之前，并且若属性名在 activation object 中已存在的话，会跳过此声明；

故 对 function foo() 的引用在 activation object 上先被创建了，当解释器到达 var foo 时，属性名 foo 已存在，代码跳过继续向下执行；

Why bar undefined？

bar 实际上是一个变量，并且被赋值了一个函数的引用，变量是在创建阶段被创建，并被初始化为 undefined，故 bar 是 undefined；





##### 2-2-2、作用域

定义：代码执行过程中，变量、函数、对象的可访问区域；

也可理解为是一套规则：**用于确定在特定场景下如何查找变量**；

作用：决定变量/其他资源的可见性，保证代码的安全性，限制用户访问权限、帮助提升代码性能、追踪错误并且修复；

<img src="/Image/Chromium/53.png" style="zoom:60%;" />

异同：与 Context 异同：

相同：两者常用来描述相同的概念：JS 规范中的执行上下文(Execution Context)其实描述的是：变量的作用域

区别：前者则与变量的可见性相关，后者更多关注于代码中 this 的使用；

RHS & LHS

- RHS 找不到-ReferenceError、RHS 找到-但尝试不当操作-TypeError
- LHS 非严格模式找不到-自动创建全局变量返回给引擎、LHS 严格模式找不到-ReferenceError



##### 2-2-2-1、函数 & 全局作用域

```
var a = 'TLP'
function bar() {
    var b = 'bar'
}
function foo() {
    console.log(b);
    console.log(a);
}
foo()
// 分属于两个彼此独立的函数作用域
// 变量作用域的查找是一个扩散过程，就像各个环节相扣的链条，逐次递进，此亦作用域链说法的由来
```

##### 2-2-2-2、块级作用域

注意：除了块级作用域以外，函数参数默认值也会受到 TDZ 影响；

```js
function foo(arg1 = arg2, arg2) {
    console.log(`${arg1} ${arg2}`)
}

foo(undefined, 'arg2')
// Uncaught ReferenceError: arg2 is not defined

// 变式1
function foo(arg1 = arg2, arg2) {
    console.log(`${arg1} ${arg2}`)
}
foo(null, 'arg2') // null arg2
// 涉及 undefined 和 null 区别
// 在执行 foo(null, 'arg2') 时，不会认为“函数第一个参数缺省”，而会直接接受 null 作为第一个参数值。

// 变式2
function foo(arg1) {
    let arg1
}

foo('arg1')
// Uncaught SyntaxError: Identifier 'arg1' has already been declared
// 涉及：let 变量不得重复声明
function foo(arg1) {
    var arg1
    let arg1
}
```





##### 2-2-2-3、变量提升

本质是 JS 解析机制作用的结果；现象是所有的声明 (变量和函数) 移动到各自作用域的最顶端的过程，提升无视 for if 等普通块的区域限制；示例：如下示例中，实际将看成2个声明：编译阶段进行的定义声明 var a、被留在原地等待执行阶段的赋值声明 a = 2；

```js
// example1
a = 2;
var a;
console.log(a);

// example2
console.log(a);
var a = 2;
```

```js
// 代码段1
var liList = document.querySelectorAll('li') // 共5个li
for( var i=0; i<liList.length; i++){
  liList[i].onclick = function(){
    console.log(i)
  }
}

// 代码段2
var liList = document.querySelectorAll('li') // 共5个li
for( let i=0; i<liList.length; i++){
  liList[i].onclick = function(){
    console.log(i)
  }
}
// for( let i = 0; i< 5; i++) 这句话的圆括号之间，有一个隐藏的作用域
// for( let i = 0; i< 5; i++) { 循环体 } 在每次执行循环体之前，JS 引擎会把 i 在循环体的上下文中重新声明及初始化一次

// 代码段3
var liList = document.querySelectorAll('li') // 共5个li
for( let i=0; i<liList.length; i++){
  // let i = 隐藏作用域中的i 
  // 5 次循环，就会有 5 个不同的 i，console.log 出来的 i 当然也是不同的值
  liList[i].onclick = function(){
    console.log(i)
  }
}
```

首先注意，提升不是一个技术名词，且 MDN 关于 let 是否存在提升的章节，被编辑了两次，第一次说存在提升，第二次说不存在提升，即 MDN 内部也存在争议，**<u>而要搞清楚提升的本质，需要理解 JS 变量的「创建create、初始化initialize 和赋值assign」</u>**

- Declaration Phase - 声明：在作用域中注册变量；
- Initialization Phase - 初始化：为变量分配内存并且创建作用域绑定，此时变量会被初始化为 undefined；
- Assignment Phase - 赋值：将开发者指定的值分配给该变量；

- 注意：为将变量创建概念与变量声明区别开，不使用声明这个字眼；

- 注意：有的地方把初始化叫做绑定(binding)，但不如初始化形象；

- **<u>var 声明的「创建、初始化和赋值」过程：</u>**

```js
function fn(){
  var x = 1
  var y = 2
}
fn()
```

在执行 fn 时，会有以下过程 (不完全)：

1. 进入 fn，为 fn 创建一个环境；
2. 找到 fn 中所有用 var 声明的变量，在这个环境中「创建」这些变量(即 x 和 y)；
3. 将这些变量「初始化」为 undefined；
4. 开始执行代码；
5. x = 1 将 x 变量「赋值」为 1；
6. y = 2 将 y 变量「赋值」为 2；

也就是说 var 声明会在代码执行之前就将「创建变量，并将其初始化为 undefined」；

这就解释了为什么在 var x = 1 前 console.log(x) 会得到 undefined；

<img src="/Image/Chromium/79.png" style="zoom:50%;" align="left" />

- **<u>Function 声明的「创建、初始化和赋值」过程：</u>**

```js
fn2()
function fn2(){
  console.log(2)
}
```

JS 引擎会有以下过程：

1. 找到所有用 function 声明的变量，在环境中「创建」这些变量。
2. 将这些变量「初始化」并「赋值」为 function(){ console.log(2) }。
3. 开始执行代码 fn2()

也就是说 function 声明会在代码执行之前就「创建、初始化并赋值」

<img src="/Image/Chromium/80.png" style="zoom:50%;" align="left" />

- **<u>let 声明的「创建、初始化和赋值」过程：</u>**

```js
{
  let x = 1
  x = 2
}
```

只看 {} 里面的过程：

1. 找到所有用 let 声明的变量，在环境中「创建」这些变量；
2. 开始执行代码 (注意现在还没有初始化)；
3. 执行 x = 1，将 x 「初始化」为 1(这并不是一次赋值，如果代码是 let x，就将 x 初始化为 undefined)
4. 执行 x = 2，对 x 进行「赋值」

这就解释了为什么在 let x 之前使用 x 会报错：

```js
let x = 'global'
{
  console.log(x) // Uncaught ReferenceError: x is not defined
  let x = 1
}
```

原因有两个：

- console.log(x) 中的 x 指的是下面的 x，而不是全局的 x；
- 执行 log 时 x 还没「初始化」，所以不能使用(也即暂时死区 TDZ)

所以 let 没有提升：

1. let 的「创建」过程被提升了，但是初始化没有提升；
2. var 的「创建」和「初始化」都被提升；
3. function 的「创建」「初始化」和「赋值」都被提升；

<img src="/Image/Chromium/81.png" style="zoom:50%;" align="left" />

注意：let x = x

<img src="/Image/Chromium/84-1.png" style="zoom:30%;" align="left" />

- x 变量就将永远处于 created 状态。
- 你无法再次对 x 进行初始化(初始化只有一次机会，而那次机会你失败了)。
- 由于 x 无法被初始化，所以 x 永远处在暂时死区；

- **<u>const 声明的「创建、初始化和赋值」过程：</u>**

其实 const 和 let 只有一个区别，那就是 const 只有「创建」和「初始化」，没有「赋值」过程；

而所谓暂时死区 TDZ，就是 **<u>不能在初始化之前，使用变量</u>**；

<img src="/Image/Chromium/84.png" style="zoom:60%;" align="left"/>

[最后，实际上并无"变量提升" 的这一说法](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/30)，其只是"遗留行为"，而新标准则禁止了这一会导致 bug 的行为，故产生了 TDZ：详看[文1](https://zhuanlan.zhihu.com/p/28140450) [文2](https://stackoverflow.com/questions/31219420/are-variables-declared-with-let-or-const-not-hoisted-in-es6/31222689#31222689)

<img src="/Image/Chromium/83.png" style="zoom:40%;" align="left"/>

In JavaScript, all binding declarations are instantiated when control flow enters the scope in which they appear. 

在 JS 中，当控制流进入它们出现的范围时，所有绑定声明都会被实例化。 

Legacy var and function declarations allow access to those bindings before the actual declaration, with a "value" of undefined. 

传统var和函数声明允许在实际声明之前访问这些绑定，其值“undefined”。 

That legacy behavior is known as "hoisting". 这种遗留行为被称为“悬挂”。 

let and const binding declarations are also instantiated when control flow enters the scope in which they appear, 

with access prevented until the actual declaration is reached; this is called the Temporal Dead Zone. 

当控制流进入它们出现的范围时，let和const绑定声明也被实例化，访问被阻止，直到达到实际声明为止; 这被称为时间死区。 

The TDZ exists to prevent the sort of bugs that legacy hoisting can create.

TDZ 的存在是为了防止传统吊装可能产生的那种错误；

建议：总是使用var关键字定义，避免使用全局变量，可用 strict mode 限制、声明命名空间、模块化

- 注意：变量提升只对 var 命令声明的变量有效，若一变量不是用 var 命令声明的，就不会发生变量提升：
  - <img src="/Image/Chromium/70.png" style="zoom:50%;" align="left" />
  - <img src="/Image/Chromium/71.png" style="zoom:50%;" align="left" />

- 注意：函数表达式也会提升，但作为普通变量提升，而非函数提升；而同名函数和变量同存时，函数优先，变量延后提升，相当于变量会覆盖函数声明；
  - <img src="/Image/Chromium/72.png" style="zoom:50%;" align="left" />
  - <img src="/Image/Chromium/73.png" style="zoom:50%;" align="left" />
  - <img src="/Image/Chromium/74.png" style="zoom:50%;" align="left" />
- 注意：函数声明、变量声明都会被提升，但函数表达式，不会被提升；
  - <img src="/Image/Chromium/75.png" style="zoom:50%;" align="left" />
- 注意：函数声明首先优先提升，然后是别的变量；
- 注意：同名变量(包括函数)，变量会被当作重复声明而忽略掉；
  - <img src="/Image/Chromium/76.png" style="zoom:50%;" align="left" />
  -  <img src="/Image/Chromium/77.png" style="zoom:50%;" align="left" />









- 注意：存在多个同名函数时，后者声明覆盖前者
  - <img src="/Image/Chromium/78.png" style="zoom:50%;" align="left" />
- 注意：关键字 var：声明同时定义了 undefined；关键字 let：只声明但未定义，所以报错；
  - <img src="/Image/Chromium/82.png" style="zoom:50%;" align="left" />



##### 2-2-2-3-1、变量提升示例

备忘录-变量提升示例

##### 2-2-2-3-2、具名函数表达式

备忘录-变量提升示例中



##### 2-2-3、闭包

- **<u>红宝书</u>** ：闭包是指有权访问另外一个函数作用域中的变量的函数；
- **<u>MDN</u>** ：闭包是指那些能够访问自由变量的函数；(其中自由变量，指在函数中使用的，但既不是函数参数arguments也不是函数的局部变量的变量，其实就是另外一个函数作用域中的变量)



##### 2-2-3-1、闭包产生原因

<img src="/Image/Chromium/98.png" style="zoom:50%;" align="left" />

作用域链的解释在前文，**<u>但须注意，每一子函数都会拷贝上级的作用域，形成一个作用域的链条</u>**；

```js
var a = 1;
function f1() {
  var a = 2
  function f2() {
    var a = 3;
    console.log(a);//3
  }
}
// f1 的作用域指向有全局作用域 window 和它本身，而 f2 的作用域指向全局作用域 window、f1 和它本身; 且作用域是从最底层向上找，直到找到全局作用域 window 为止, 若全局也没有则报错；
```

**<u>闭包产生的本质</u>**：**<u>当前环境中存在指向父级作用域的引用</u>**：

```js
function f1() {
  var a = 2
  function f2() {
    console.log(a);//2
  }
  return f2;
}
var x = f1();
x();
// x 能拿到父级作用域中的变量，输出 2；因当前环境中，x 含有对 f2 的引用，而 f2 恰恰引用了 window、f1、f2 的作用域，所以 f2 可以访问到 f1 作用域的变量
```

**<u>注意: 并非只有返回函数才算是产生闭包，只需要让父级作用域的引用存在即可</u>**

```js
var f3;
function f1() {
  var a = 2
  f3 = function() {
    console.log(a);
  }
}
f1();
f3();
// f1 执行，给 f3 赋值后，f3 拥有了 window、f1、f3 本身这几个作用域的访问权限，于是自底向上查找，在 f1 中找到 a, 因此输出 2；
// 所以，此处是外面的变量 f3 存在着父级作用域的引用，因此产生了闭包
```



##### 2-2-3-2、闭包表现形式

- 返回一个函数；
- 作为函数参数传递；

```js
var a = 1;
function foo(){
  var a = 2;
  function baz(){
    console.log(a);
  }
  bar(baz);
}
function bar(fn){
  // 这就是闭包
  fn();
}
// 输出2，而不是1
foo();
```

- 在定时器、事件监听、Ajax请求、跨窗口通信、Web Workers 或任何异步中，只要使用回调函数，实际上就是在使用闭包；

```js
// 以下的闭包保存的仅仅是 window 和 当前作用域
// 定时器
setTimeout(function timeHandler(){
  console.log('111');
}，100)

// 事件监听
$('#app').click(function(){
  console.log('DOM Listener');
})
```

- IIFE 创建闭包，保存了`全局作用域window`和`当前函数的作用域`，因此可使用全局的变量；

```js
var a = 2;
(function IIFE(){
  // 输出2
  console.log(a);
})();
```



##### 2-2-3-3、闭包功能作用

1、读取函数内部的变量

- 利用1：可由此设计私有变量(ES6中没有私有变量，只能变通实现)：
  - 方式1：将闭包作为特权方法 (public method / privileged method)，将函数的参数、局部变量和函数内定义的其他函数作为私有变量：
  - <img src="/Image/Chromium/86.png" style="zoom:50%;" align="left" />
  - 方式2：利用模块模式创建单例，赋予私有属性功能：
  - <img src="/Image/Chromium/87.png" style="zoom:50%;" align="left" />
- 利用2：配合**匿名函数**，构建命名空间，减少全局变量的使用，模块化代码，减少全局变量的污染
  - <img src="/Image/Chromium/88.png" style="zoom:50%;" align="left" />

2、让函数内部变量的值始终保持在内存中，阻止其被回收，但消耗大，滥用后果很严重、IE 中存在内存泄露，需注意解除引用；

3、模块化、函数工厂、批量化构建函数并延期执行

注意：模块模式具有两个必备的条件：

- 必须有外部的封闭函数，该函数必须至少被调用一次(每次调用都会创建一个新的模块实例)；
- 封闭函数必须返回至少**一个**内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态；

<img src="/Image/Chromium/89.png" style="zoom:50%;" align="left" />

<img src="/Image/Chromium/90.png" style="zoom:50%;" align="left" />

建议：若非特殊情况，不应在函数中创建函数，需考虑性能和内存消耗问题；

比如：创建新对象或类时，方法(函数)定义对象的构造器(函数)中，将导致每次构造调用时，方法均会重新赋值一次；

<img src="/Image/Chromium/91.png" style="zoom:50%;" align="left" />

<img src="/Image/Chromium/92.png" style="zoom:50%;" align="left" />

4、闭包计数器

<img src="/Image/Chromium/97.png" style="zoom:50%;" align="left" />









##### 2-2-3-4、闭包使用示例

##### 2-2-3-4-1、基本示例

```js
for(var i = 1; i <= 5; i ++){
  setTimeout(function timer(){
    console.log(i)
  }, 0)
}
// 原因:
// setTimeout 为宏任务, 而由于 JS 单线程 EvLoop 机制，在主线程同步任务执行完后才去执行宏任务
// loop 结束后, setTimeout 依次执行回调，但输出时在当前作用域没有发现 i，遂通过作用域链向上寻找 i, 此时循环已结束，i 也已变成了 6；因此会全部输出6；

// 解决:
// 1、利用IIFE, 当每次 for 循环时，将此时的变量 i 传递到定时器中
for(var i = 1;i <= 5;i++){
  (function(j){
    setTimeout(function timer(){
      console.log(j)
    }, 0)
  })(i)
}
// 2、给定时器传入第三个参数, 作 为timer 函数的第一个函数参数
for(var i=1;i<=5;i++){
  setTimeout(function timer(j){
    console.log(j)
  }, 0, i)
}
// 3、使用 ES6 中的 let——块级作用域
// let 使 JS 发生革命性的变化，让 JS 有函数作用域变为块级作用域，用 let 后作用域链不复存在。代码的作用域以块级为单位
for(let i = 1; i <= 5; i++){
  setTimeout(function timer(){
    console.log(i)
  },0)
}
// i = 1
{
  setTimeout(function timer(){
    console.log(1)
  },0)
}
// i = 2
{
  setTimeout(function timer(){
    console.log(2)
  },0)
}
// i = 3
```

##### 2-2-3-4-2、综合示例

<img src="/Image/Chromium/93.png" style="zoom:50%;" align="left" />

<img src="/Image/Chromium/94.png" style="zoom:50%;" align="left" />

<img src="/Image/Chromium/95.png" style="zoom:50%;" align="left" />

<img src="/Image/Chromium/96.png" style="zoom:50%;" align="left" />



##### 2-2-3-4-3、其他示例

备忘录 4-3





##### 2-2-4、this 指向

**<u>*谁调用它，则它内部的 this 就指向谁(特殊情况另算)*</u>**

<img src="/Image/Chromium/602.png" style="zoom:50%;" align="left" />

- 描述：函数内部代码 this.count 中的 this 并非指向那个函数对象，而是指向 调用它的那个对象，可能是window，也可能是 global
- 解决：解决上述 this 绑定问题：
  - 使用词法作用域，全局定义一个变量，通过变量查找获得
  - 使用词法作用域，用函数自身属性，而不用this.count
  - 强制 this 指向，比如用 foo.call( foo, i );  

**<u>*this 实际上是，在函数被调用时才发生绑定，this指向什么，完全取决于函数在哪里被调用，被谁调用*</u>** 

当函数被调用时，会创建一个活动记录(执行上下文)，记录包含，函数在哪被调用(调用栈)，函数的调用方法、传入的参数等信息；

而 this，只是信息中的一个属性；会在函数执行的过程中使用得到；

- 注意：<u>this 在任何情况下 都不指向 函数的作用域</u>，因作用域"对象" 存在于 JS 引擎内部， 无法通过 JS 代码访问 

**<u>*1、普通 this 指向：*</u>**

- 永远指向最后调用它的那个对象；

- 函数运行时所在的环境对象 (并非指向函数作用域，作用域对象存在于引擎内部，无法通过一般访问) ；

- 函数被调用时才发生的绑定，故 this 的指向取决于函数在哪、被谁调用 (调用时创建执行上下文、创建时的内存分配阶段时的过程) ；
  - 示例1：

  - <img src="/Image/Chromium/606.png" style="zoom:50%;" align="left" />

  - <img src="/Image/Chromium/607.png" style="zoom:50%;" align="left" />

  - <img src="/Image/Chromium/608.png" style="zoom:50%;" align="left" />

  - <img src="/Image/Chromium/609.png" style="zoom:50%;" align="left" />

  - 示例2：

  - 前者将函数交由变量 go，go 存在于 window，最后调用 go 实际为 window.go()；

  - 后者最后调用函数的为 baz，故打印 1；

  - <img src="/Image/Chromium/610.png" style="zoom:50%;" align="left" />

  - <img src="/Image/Chromium/611.png" style="zoom:50%;" align="left" />

  - 示例3：理由同上

  - <img src="/Image/Chromium/605.png" style="zoom:50%;" align="left" />

    

**<u>*2、其他 this 指向*</u>**

- 箭头函数，详见 2-2-4-8、箭头函数
- 匿名函数，详见 2-2-4-9、匿名函数

**<u>*3、函数调用方式*</u>**

- 作为函数直接调用：默认属于全局对象，严格模式则是 undefined，示例1；
- 作为对象方法间接调用：属于最后调用它的那个对象，示例 2； 
- 作为构造函数调用：属于构造返回的实例，new 过程；
- 作为函数方法调用：call、apply；
  - 示例1：
  - <img src="/Image/Chromium/619.png" style="zoom:50%;" align="left" />
  - 示例2：
  - <img src="/Image/Chromium/620.png" style="zoom:50%;" align="left" />



**<u>*X：各绑定优先级：默认绑定 < 隐式绑定 < 显式绑定 < 显式硬绑定 < new 绑定*</u>**

**<u>*X-1、默认绑定*</u>**：函数不带任何修饰地调用，this 指向 全局对象 / undefined (strict mode)

```js
// Ex1
"use strict";
var a = 10;
function foo () {
  console.log('this1', this) // 'this1' undefined
  console.log(window.a) // 10
  console.log(this.a) // Uncaught TypeError: Cannot read property 'a' of undefined
}
console.log(window.foo)	// f foo() {...}
console.log('this2', this) // 'this2' Window{...}
foo();
// 注意虽全局模式改变内部 this 为 undefined，但并不会改变全局中 this 的指向(仍为全局对象)

// Ex2
let a = 10
const b = 20
function foo () {
  console.log(this.a) // undefined
  console.log(this.b) // undefined
}
foo();
console.log(window.a) // undefined
// 注意 let 或者 const 变量是不会被绑定到 window

// Ex3
var a = 1
function foo () {
  var a = 2
  console.log(this) // Window{...}
  console.log(this.a) // 1
  function inner () { 
    console.log(this.a) // 1
  }
  inner()
}
foo()
```

**<u>*X-2、隐式绑定*</u>**：函数带修饰地被调用，this 指向此上下文对象，比如：obj.foo()

- 注意：对象属性引用链中，只有最后一层会影响调用位置：
  - <img src="/Image/Chromium/621.png" style="zoom:50%;" align="left" />
- 注意：赋值操作中，被隐式绑定函数，<u>会丢失绑定对象</u>，此时会应用默认绑定：
  - <img src="/Image/Chromium/622.png" style="zoom:50%;" align="left" />
  - <img src="/Image/Chromium/623.png" style="zoom:50%;" align="left" />

```js
// Ex1
function foo () {
  console.log(this.a) 
}
var obj = { a: 1, foo }
var a = 2
obj.foo() // 1

// Ex2
var obj = {
  a: 1,
  foo: function () {
    console.log(this.a) 
  }
}
var a = 2
obj.foo() // 1

// Ex3 - 隐式丢失
function foo () {
  console.log(this.a) 
};
var obj = { a: 1, foo };
var a = 2;
var foo2 = obj.foo;

obj.foo(); // 1
foo2(); // 2

// Ex4 - 隐式丢失
function foo () {
  console.log(this.a)
};
var obj = { a: 1, foo };
var a = 2;
var foo2 = obj.foo;
var obj2 = { a: 3, foo2: obj.foo }

obj.foo(); // 1
foo2(); // 2
obj2.foo2(); // 3

// Ex5 - 隐式丢失
function foo () {
  console.log(this.a)
}
function doFoo (fn) {
  console.log(this) // window
  fn()
}
var obj = { a: 1, foo }
var a = 2
doFoo(obj.foo) // 2

// Ex6 - 隐式丢失
function foo () {
  console.log(this.a)
}
function doFoo (fn) {
  console.log(this) // obj2
  fn()
}
var obj = { a: 1, foo }
var a = 2
var obj2 = { a: 3, doFoo }
obj2.doFoo(obj.foo) // 2

// Ex7
"use strict"
function foo () {
  console.log(this.a)
}
function doFoo (fn) {
  console.log(this) // obj2
  fn()
}
var obj = { a: 1, foo }
var a = 2
var obj2 = { a: 3, doFoo }

obj2.doFoo(obj.foo) // Uncaught TypeError: Cannot read property 'a' of undefined
```



**<u>*X-3、显式绑定(call、apply)*</u>**：在对象上，强制调用函数，直接指定 this 绑定对象，其参数1 即 this 的绑定对象：

- 意为：在 obj 中使用 function；
- 注意：若收到的第一个参数是空或者`null、undefined`，则会忽略这个参数
- 注意：从 this 绑定角度上看，两者本质相同，区别在参数2，前者数组，后者元素；
- 注意：显式绑定也有隐式绑定丢失问题；
  - <img src="/Image/Chromium/624.png" style="zoom:50%;" align="left" />
- 注意：参数2 传入 null 与 不写效果等同；
  - <img src="/Image/Chromium/625.png" style="zoom:50%;" align="left" />

```js
// Ex1
function foo () {
  console.log(this.a)
}
var obj = { a: 1 }
var a = 2

foo()
foo.call(obj) 	// 2
foo.apply(obj) 	// 1
foo.bind(obj) 	// 1

// Ex2
function foo () {
  console.log(this.a)
}
var a = 2
foo.call()		// 2
foo.call(null)// 2
foo.call(undefined) // 2

// Ex3
var obj1 = {
  a: 1
}
var obj2 = {
  a: 2,
  foo1: function () {
    console.log(this.a)
  },
  foo2: function () {
    setTimeout(function () {
      console.log(this)
      console.log(this.a)
    }, 0)
  }
}
var a = 3
obj2.foo1() // 2
obj2.foo2() // window 3

// Ex3
var obj1 = {
  a: 1
}
var obj2 = {
  a: 2,
  foo1: function () {
    console.log(this.a)
  },
  foo2: function () {
    setTimeout(function () {
      console.log(this)
      console.log(this.a)
    }.call(obj1), 0)
    // 注意：不能是 obj2.foo2.call(obj1) 写法，否则改变 this 为 foo2 环境，但内部计时器存在仍会指向 window
  }
}
var a = 3
obj2.foo1() // 2
obj2.foo2() // obj1 1

// Ex4
var obj1 = {
  a: 1
}
var obj2 = {
  a: 2,
  foo1: function () {
    console.log(this.a)
  },
  foo2: function () {
    function inner () {
      console.log(this)
      console.log(this.a)
    }
    inner()
  }
}
var a = 3
obj2.foo1() // 2
obj2.foo2() // window 3  若 inner.call(obj1) 则 obj1 1

// Ex5 - 坑
function foo () {
  console.log(this.a)
}
var obj = { a: 1 }
var a = 2

foo() // 2
foo.call(obj) // 1
foo().call(obj) // 2 Error Uncaught TypeError: Cannot read property 'call' of undefined

// Ex6
function foo () {
  console.log(this.a)
  return function () {
    console.log(this.a)
  }
}
var obj = { a: 1 }
var a = 2

foo() // 2
foo.call(obj) // 1
foo().call(obj) // 2 

// Ex7 - 坑
function foo () {
  console.log(this.a)
  return function () {
    console.log(this.a)
  }
}
var obj = { a: 1 }
var a = 2

foo() // 2
foo.bind(obj)
foo().bind(obj) // 2

// Ex8
function foo () {
  console.log(this.a)
  return function () {
    console.log(this.a)
  }
}
var obj = { a: 1 }
var a = 2

foo.call(obj)() // 1 2

// Ex9 - 综合
var obj = {
  a: 'obj',
  foo: function () {
    console.log('foo:', this.a)
    return function () {
      console.log('inner:', this.a)
    }
  }
}
var a = 'window'
var obj2 = { a: 'obj2' }

obj.foo()() // 'foo: obj' 'inner: window'
obj.foo.call(obj2)() // 'foo: obj2' 'inner: window'
obj.foo().call(obj2) // 'foo: obj' 'inner: obj2'

// Ex10 - 综合 - 坑
var obj = {
  a: 1,
  foo: function (b) {
    b = b || this.a
    return function (c) {
      console.log(this.a + b + c)
    }
  }
}
var a = 2
var obj2 = { a: 3 }

obj.foo(a).call(obj2, 1)
// 3 + 2 + 1 == 6
obj.foo.call(obj2)(1) 
// 2 + 3 + 1 == 6

// Ex11
function foo1 () {
  console.log(this.a)
}
var a = 1
var obj = {
  a: 2
}
var foo2 = function () {
  foo1.call(obj)
}
foo2() // 2
foo2.call(window) // 2

// Ex12
function foo1 (b) {
  console.log(`${this.a} + ${b}`)
  return this.a + b
}
var a = 1
var obj = {
  a: 2
}
var foo2 = function () {
  // return foo1.call(obj, 3)
  return foo1.call(obj, ...arguments)
}
var num = foo2(3) // '2 + 3'
console.log(num) // 5


// Ex13
function foo (item) {
  console.log(item, this.a)
}
var obj = {
  a: 'obj'
}
var a = 'window'
var arr = [1, 2, 3]
// arr.forEach(foo, obj)
// arr.map(foo, obj)
arr.filter(function (i) {
  // 1 'obj'
  // 2 'obj'
 	// 3 'obj'
  console.log(i, this.a)
  return i > 2
}, obj) 

// 总结
// this 永远指向最后调用它的那个对象
// 匿名函数的 this 永远指向 window
// 使用.call()或者.apply()的函数是会直接执行的
// bind()是创建一个新的函数，需要手动调用才会执行
// 若 call、apply、bind 接收到的第一个参数是空或者 null、undefined 的话，则会忽略这个参数
// forEach、map、filter函数的第二个参数也是能显式绑定this的
```

**<u>*X-4、显式硬绑定*</u>**：显式绑定的变种 (本质是：在显式绑定的基础上用一层函数包裹)

- 注意：无法再次修改 this 指向，除非 new 操作，图1；

- - bind 会判断硬绑定函数，是否是被 new 调用，若是则使用 new 操作中新创建的 this 替换硬绑定的 this；
  - 即 new 优先级 > 硬绑定；

- 注意：显式硬绑定是 ES5中 bind 的雏形：图2；

- 注意：bind 返回硬编码的新函数，但并无调用，bind会将参数，设置为 this 的上下文并调用原始函数；

- 注意：许多 API 都提供了一个可选的，上下文参数，作用同 bind，确保回调函数使用指定的 this；

- 注意：还有软绑定，后续能修改 this，但又不会指向全局对象或 undefined，自行查阅

  - 示例1：
  - <img src="/Image/Chromium/626.png" style="zoom:50%;" align="left" />
  - <img src="/Image/Chromium/626.png" style="zoom:50%;" align="left" />

- bind 实现

  - 返回一个函数，绑定this，传递预置参数

  - bind 返回的函数可以作为构造函数使用。故作为构造函数时应使得this失效，但是传入的参数依然有效

  - ```js
    Function.prototype.bind2 = function(context) {
        var _this = this;
        var argsParent = Array.prototype.slice.call(arguments, 1);
        return function() {
            var args = argsParent.concat(Array.prototype.slice.call(arguments)); //转化成数组
            _this.apply(context, args);
        };
    }
    // 2
    Function.prototype.bind1 = function(context) {
      var that = this
      return function() {
        that.apply(context, arguments)
      }
    }
    // 最简版
    Function.prototype.myBind = function(content, ...args) {
      return () => this.apply(content, args);
    };
    // ES6
    Function.prototype.bind2 = function() {
        var fn = this;
        var argsParent = [...arguments];
        return function() {
            fn.call(...argsParent, ...arguments);
        };
    }
    // MDN
    //  Yes, it does work with `new (funcA.bind(thisArg, args))`
    if (!Function.prototype.bind) (function(){
      var ArrayPrototypeSlice = Array.prototype.slice;
      Function.prototype.bind = function(otherThis) {
        if (typeof this !== 'function') {
          // closest thing possible to the ECMAScript 5
          // internal IsCallable function
          throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');
        }
    
        var baseArgs= ArrayPrototypeSlice.call(arguments, 1),
            baseArgsLength = baseArgs.length,
            fToBind = this,
            fNOP    = function() {},
            fBound  = function() {
              baseArgs.length = baseArgsLength; // reset to default base arguments
              baseArgs.push.apply(baseArgs, arguments);
              return fToBind.apply(
                     fNOP.prototype.isPrototypeOf(this) ? this : otherThis, baseArgs
              );
            };
    
        if (this.prototype) {
          // Function.prototype doesn't have a prototype property
          fNOP.prototype = this.prototype; 
        }
        fBound.prototype = new fNOP();
    
        return fBound;
      };
    })();
    ```

**<u>*X-5、new 绑定*</u>**：用 new 来调用函数，构造一个新对象 (实例)，并将 this 指向实例对象本身；而若为普通调用，则指向全局对象：

- 注意：使用 new 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作：
  - 创建一全新的对象 (中间对象)；
  - 新对象会被执行 [[ 原型 ]] 连接 (将中间对象的原型指向函数原型，此后便可使用函数原型上的方法和属性)；
  - 新对象会绑定到函数调用的 this (即将函数内部 this 指向中间对象)；
  - 若函数返回基本类型，则返回中间对象；若返回对象，则代替中间对象，返回函数返回的对象；
  - <img src="/Image/Chromium/628.png" style="zoom:60%;" align="left" />

```js
// Ex1
function Person (name) {
  this.name = name
}
var name = 'window'
var persion1 = new Person('TLP')
console.log(person1.name) // TLP

// Ex2
function Person (name) {
  this.name = name
  this.foo1 = function () {
    console.log(this.name)
  }
  this.foo2 = function () {
    return function () {
      console.log(this.name)
    }
  }
}
var person1 = new Person('person1')
person1.foo1() // person1
person1.foo2()() // '' 
// 注意: window.不存在值 输出 ''

// Ex3
var name = 'window'
function Person (name) {
  this.name = name
  this.foo = function () {
    console.log(this.name)
    return function () {
      console.log(this.name)
    }
  }
}
var person2 = {
  name: 'person2',
  foo: function() {
    console.log(this.name)
    return function () {
      console.log(this.name)
    }
  }
}
var person1 = new Person('person1')
person1.foo()() // persono1 window
person2.foo()() // person2 window

// Ex4
var name = 'window'
function Person (name) {
  this.name = name
  this.foo = function () {
    console.log(this.name)
    return function () {
      console.log(this.name)
    }
  }
}
var person1 = new Person('person1')
var person2 = new Person('person2')
person1.foo.call(person2)() // person2 window
person1.foo().call(person2) // person1 person2
```

**<u>*X-6、判断 this 的应用规则，先查找函数直接调用的位置*</u>**：

1. 函数是否在 new 中调用(new 绑定)？如果是的话 this 绑定的是，新创建的对象；var bar = new foo()
2. 函数是否通过 call、apply(显式绑定)或者 bind (显示硬绑定)调用？如果是的话this 绑定的是，指定的对象；var bar = foo.call(obj2)
3. 函数是否在某个上下文对象中调用(隐式绑定)？如果是的话this 绑定的是，那个上下文对象；var bar = obj1.foo()
4. 若都不是的话，使用默认绑定。严格模式下，就绑定到 undefined，否则绑定到，全局对象；var bar = foo()

注意：箭头函数不使用 this 的四种标准规则，其 this 的指向 根据外层(函数或者全局)作用域来决定，且这种绑定无法被修改，常用于回调中；

注意：箭头函数使用了词法作用域取代传统的 this 机制，同 self = this 机制一致；

<img src="/Image/Chromium/630.png" style="zoom:50%;" align="left" />

- 示例1：前者隐式绑定，有 callback = function(){ this.output() }过程；后者通过 bind ，将 this 硬绑定；

  - <img src="/Image/Chromium/632.png" style="zoom:50%;" align="left" />

- 示例2：箭头函数无视 bind 等绑定，可谓是优先级最高了

  - <img src="/Image/Chromium/633.png" style="zoom:50%;" align="left" />
  - 

- 示例4：但凡有赋值操作均会隐式丢失，但某些赋值操作不明显，比如函数传参、逗号操作符

  - <img src="/Image/Chromium/634.png" style="zoom:50%;" align="left" />

- 示例5

  - ```js
    function Foo() {
        Foo.a = function() {
            console.log(1)
        }
        this.a = function() {
            console.log(2)
        }
    }
    Foo.prototype.a = function() {
        console.log(3)
    }
    Foo.a = function() {
        console.log(4)
    }
    Foo.a();
    let obj = new Foo();
    obj.a();
    Foo.a();
    
    
    // 解析
    function Foo() {
        Foo.a = function() {
            console.log(1)
        }
        this.a = function() {
            console.log(2)
        }
    }
    // 以上只是 Foo 的构建方法，没有产生实例，此刻也没有执行
    
    Foo.prototype.a = function() {
        console.log(3)
    }
    // 现在在 Foo 上挂载了原型方法 a ，方法输出值为 3
    
    Foo.a = function() {
        console.log(4)
    }
    // 现在在 Foo 上挂载了直接方法 a ，输出值为 4
    
    Foo.a();
    // 立刻执行了 Foo 上的 a 方法，也就是刚刚定义的，所以
    // # 输出 4
    
    let obj = new Foo();
    /* 这里调用了 Foo 的构建方法。Foo 的构建方法主要做了两件事：
    1. 将全局的 Foo 上的直接方法 a 替换为一个输出 1 的方法。
    2. 在新对象上挂载直接方法 a ，输出值为 2。
    */
    
    obj.a();
    // 因为有直接方法 a ，不需要去访问原型链，所以使用的是构建方法里所定义的 this.a，
    // # 输出 2
    
    Foo.a();
    // 构建方法里已经替换了全局 Foo 上的 a 方法，所以
    // # 输出 1
    ```

- 示例6：

  - ```js
    var x = 3;
    var foo = {
      x: 2,
      baz: {
        x: 1,
        bar: function() {
          return this.x;
        }
      }
    }
    var go = foo.baz.bar;
    
    console.log(go());  // 3
    console.log(foo.baz.bar()); // 1
    
    // this 由调用者提供，由调用函数的方式来决定。如果是一个对象调用的函数，则 this 指向该对象，比如 foo.baz.bar()。如果函数独立调用比如 go()，那么该函数内部的 this，则指向 undefined。但是在非严格模式中，它会被自动指向全局对象 window。
    ```

    



##### 2-2-4-1、基本

`this` 的指向，是在调用函数时根据执行上下文所动态确定的；

**<u>优先级：new  > call/apply/bind  > 对象.方法 > 直接调用</u>**，但此处主讲隐式绑定：

- 全局上下文
- 直接调用函数：在函数体中，简单调用该函数时(非显式/隐式绑定下)；
  - 严格模式， `this` 绑定到 `undefined`；
  - 非严格模式，绑定到全局对象 `window`／`global`；
- 对象.方法的形式调用：由上下文对象调用，绑定在该对象上；
- DOM 事件绑定(特殊)
- call/apply/bind 显式绑定：由 `call`/`apply`/`bind` 方法显式调用，绑定到指定参数的对象上
- new 构造函数绑定构造函数 `new` 调用，绑定到新创建的对象上
- 箭头函数：根据外层上下文绑定的 `this` 决定 `this` 指向；





##### 2-2-4-2、全局上下文

全局上下文默认 this 指向 window，严格模式下指向 undefined；

```js
function f1 () {
    console.log(this)
}
function f2 () {
    'use strict'
    console.log(this)
}
f1() // window
f2() // undefined

// 变式
const foo = {
    bar: 10,
    fn: function() {
       console.log(this)
       console.log(this.bar)
    }
}
var fn1 = foo.fn
fn1()
// 在赋值给 fn1 之后，fn1 的执行仍然是在 window 的全局环境中, 相当于下式
console.log(window)
console.log(window.bar)
```



##### 2-2-4-3、直接调用函数

直接调用 this 相当于全局上下文的情况；

```js
let obj = {
  a: function() {
    console.log(this);
  }
}
let func = obj.a;
func();
```



##### 2-2-4-4、对象.方法的形式调用

`对象.方法` 的形式，this 指向此对象；

注意：在这种嵌套的关系中，`this` 指向 **<u>最后</u>** 调用它的对象

```js
// 示例1
let obj = {
  a: function() {
    console.log(this);
  }
}
obj.a();

// 示例2
const student = {
    name: 'TLP',
    fn: function() {
        return this
    }
}
console.log(student.fn() === student) // true

// 示例2
const person = {
    name: 'TLP',
    brother: {
        name: 'BDeng',
        fn: function() {
            return this.name
        }
    }
}
console.log(person.brother.fn()) // BDeng

// 综合示例
const o1 = {
    text: 'o1',
    fn: function() {
        return this.text
    }
}
const o2 = {
    text: 'o2',
    fn: function() {
        return o1.fn()
    }
}
const o3 = {
    text: 'o3',
    fn: function() {
        var fn = o1.fn
        return fn()
    }
}
// 注意第三个
console.log(o1.fn()) // o1
console.log(o2.fn()) // o1
console.log(o3.fn()) // undefined - 懵逼

// 追问: 让 console.log(o2.fn()) 输出 o2
// 1、修改 o2m - 懵逼
const o2 = {
    text: 'o2',
    fn: o1.fn
}
// 2、修改 o2
var o2 = {
    text: 'o2',
    fn: function() {
        return o11.fn.call(this)
      	return o11.fn.apply(this)
    }
}
// 3、修改 o2
var o2 = {
    text: 'o2',
    fn: function() {
        return o11.fn.bind(o22)
      	// o2.fn()()
    }
}
```

##### 2-2-4-5、DOM 事件绑定

onclick 和  addEventerListener中 this 默认指向绑定事件的元素；

注意：IE 比较奇异，使用 attachEvent，其 this 默认指向 window；

##### 2-2-4-6、bind/call/apply 绑定

均用以改变相关函数 `this` 指向的，但是 `call/apply` 是直接进行相关函数调用；`bind` 不会执行相关函数，而是返回一个新的函数；

```js
const target = {}
fn.call(target, 'arg1', 'arg2')

const target = {}
fn.apply(target, ['arg1', 'arg2'])

const target = {}
fn.bind(target, 'arg1', 'arg2')()
```

```js
const foo = {
    name: 'TLP',
    logName: function() {
        console.log(this.name)
    }
}
const bar = {
    name: 'BDeng'
}
console.log(foo.logName.call(bar)) // BDeng
```

<img src="/Image/Chromium/631.png" style="zoom:50%;" align="left" />







##### 2-2-4-7、new + 构造函数

构造函数中的 this 指向实例对象；因为：

- 创建一个新的对象；
- 将构造函数的 `this` 指向这个新对象；
- 为这个对象添加属性、方法等；
- 最终返回新对象；

```js
// 示例
function Foo() {
    this.bar = "TLP"
}
const instance = new Foo()
console.log(instance.bar)
```

注意：若在构造函数中出现了显式 `return` 的情况

- 若构造函数中显式返回一个值，且返回的是一个对象，则 `this` 就指向这个返回的对象；
- 若构造函数中显式返回一个值，且返回的不是一个对象，则 `this` 仍然指向实例；

```js
// 返回对象
function Foo(){
    this.user = "TLP"
    const o = {}
    return o
}
const instance = new Foo()
console.log(instance.user) // undefined

// 返回非对象
function Foo(){
    this.user = "TLP"
    return 1
}
const instance = new Foo()
console.log(instance.user)
```



##### 2-2-4-8、箭头函数

箭头函数没有 this，无法绑定，不适用以上标准规则，而是根据外层(函数或者全局) 上下文来决定；

- 其他 this 指向，始终指向函数定义时的 this，而非后者的执行时；
- 其他 this 通过，查找作用域链来绑定，若箭头函数被非箭头函数包含，则 this 绑定的是最近一层非箭头函数的 this；否则 window/undefined

引入箭头函数有 2 方面的<u>作用</u>：更简短的函数，且不绑定 this；箭头函数 <u>与普通函数不同之处有</u>：

- 函数体内的 this 对象，就是应该是定义时所在的作用域中的 this 值

- 没有 this，它会从自己的作用域链的上一层继承 this (因此无法使用 apply / call / bind 进行绑定 this 值)；

- 不可以使用 arguments 对象，该对象在函数体内不存在；若要用，可以用 rest 参数代替，强行使用会向作用域链搜寻；

- 不可以使用 yield 命令，因此箭头函数不能用作 Generator 函数；

- 不绑定 super 和 new.target；

- <u>无法使用 new 实例化对象</u>

  - <u>浅层原因</u>：

  - 没有自己的 this，无法调用 call，apply。

  - 没有 prototype 属性 ，而 new 命令在执行时需要将构造函数的 prototype 赋值给新的对象的 `__proto__`

  - <u>深层原因</u>：

  - JS 函数两个内部方法：[[Call]] 和 [[Construct]]

    - 直接调用时执行：`[[Call]]` 方法，直接执行函数体

    - `new` 调用时执行：`[[Construct]]` 方法，创建一个实例对象

    - ```js
      function New(Ctor, ...rest) {
        const o = Object.create(Ctor.prototype)
        const ret = Ctor.apply(o, rest)
        return ret || o
      }
      ```

    - 而箭头函数并没有 `[[Construct]]` 方法，所以不能被用作构造函数

    - 另外，可参考 `Proxy` 中的 `handler.construct` 方法，其用于拦截 `new` 操作符，为使 `new` 操作符在生成的 `Proxy` 对象上生效，用于初始化代理的目标对象自身必须具有 `[[Construct]]` 内部方法 (即 `new target` 必须是有效的)；

```js
// 找到最近的非箭头函数 a，a 现在绑定着 obj, 因此箭头函数中的 this 是 obj
let obj = {
  a: function() {
    let do = () => {
      console.log(this);
    }
    do();
  }
}
obj.a(); 

// Ex2 - 坑
var obj = {
  name: 'obj',
  foo1: () => {
    console.log(this.name)
  },
  foo2: function () {
    console.log(this.name)
    return () => {
      console.log(this.name)
    }
  }
}
var name = 'window'
obj.foo1() // window 注意: window.obj.foo1 故应为 window
obj.foo2()() // obj obj

// Ex3
var name = 'window'
var obj1 = {
	name: 'obj1',
	foo: function () {
		console.log(this.name)
	}
}
var obj2 = {
	name: 'obj2',
	foo: () => {
		console.log(this.name)
	}
}
obj1.foo() // obj1
obj2.foo() // window

// Ex4
var name = 'window'
var obj1 = {
  name: 'obj1',
  foo: function () {
    console.log(this.name)
    return function () {
      console.log(this.name)
    }
  }
}
var obj2 = {
  name: 'obj2',
  foo: function () {
    console.log(this.name)
    return () => {
      console.log(this.name)
    }
  }
}
var obj3 = {
  name: 'obj3',
  foo: () => {
    console.log(this.name)
    return function () {
      console.log(this.name)
    }
  }
}
var obj4 = {
  name: 'obj4',
  foo: () => {
    console.log(this.name)
    return () => {
      console.log(this.name)
    }
  }
}
obj1.foo()() // obj1 window
obj2.foo()() // obj2 obj2
obj3.foo()() // window window
obj4.foo()() // window window

// Ex5
var name = 'window'
function Person (name) {
  this.name = name
  this.foo1 = function () {
    console.log(this.name)
  }
  this.foo2 = () => {
    console.log(this.name)
  }
}
var person2 = {
  name: 'person2',
  foo2: () => {
    console.log(this.name)
  }
}
var person1 = new Person('person1')
person1.foo1() // person1
person1.foo2() // person1
person2.foo2() // window

// Ex6
var name = 'window'
function Person (name) {
  this.name = name
  this.foo1 = function () {
    console.log(this.name)
    return function () {
      console.log(this.name)
    }
  }
  this.foo2 = function () {
    console.log(this.name)
    return () => {
      console.log(this.name)
    }
  }
  this.foo3 = () => {
    console.log(this.name)
    return function () {
      console.log(this.name)
    }
  }
  this.foo4 = () => {
    console.log(this.name)
    return () => {
      console.log(this.name)
    }
  }
}
var person1 = new Person('person1')
person1.foo1()() // person1 window
person1.foo2()() // person1 person1
person1.foo3()() // person1 window
person1.foo4()() // person1 person1

// Ex7 - 坑
// 箭头函数的 this 无法通过 bind、call、apply 来直接修改，但可通过改变作用域中 this 的指向来间接修改
var name = 'window'
var obj1 = {
  name: 'obj1',
  foo1: function () {
    console.log(this.name)
    return () => {
      console.log(this.name)
    }
  },
  foo2: () => {
    console.log(this.name)
    return function () {
      console.log(this.name)
    }
  }
}
var obj2 = {
  name: 'obj2'
}
obj1.foo1.call(obj2)() // obj2 obj2
obj1.foo1().call(obj2) // obj1 obj1
obj1.foo2.call(obj2)() // window window
obj1.foo2().call(obj2) // window obj2

// 总结
// 箭头函数里面的 this 是由外层作用域来决定的，且指向函数定义时的 this 而非执行时
// 字面量创建的对象，作用域是 window，若里面有箭头函数属性的话，this 指向的是 window
// 构造函数创建的对象，作用域可理解为是这个构造函数，且这个构造函数的 this 是指向新建的对象的，因此 this 指向这个对象。
// 箭头函数的 this 无法通过 bind、call、apply 来直接修改，但可通过改变作用域中 this 的指向来间接修改。
```

<img src="/Image/Chromium/612.png" style="zoom:50%;" align="left" />

<img src="/Image/Chromium/613.png" style="zoom:50%;" align="left" />





##### 2-2-4-9、匿名函数

**<u>*匿名函数的 this 永远指向 window*</u>**

- 示例1：
  - 某解释：this 永远指向最后调用它的那个对象，但匿名函数因无名，故无法找到调用它的对象，故默认指向全局对象….
  - <img src="/Image/Chromium/614.png" style="zoom:50%;" align="left" />
  - <img src="/Image/Chromium/615.png" style="zoom:50%;" align="left" />
- 示例2：
  - window 调用了 fn7，故内部 this 指向 window，而箭头函数 this 绑定外层非箭头函数 this
  - <img src="/Image/Chromium/616.png" style="zoom:50%;" align="left" />
- 示例3：
  - <img src="/Image/Chromium/617.png" style="zoom:50%;" align="left" />
  - <img src="/Image/Chromium/618.png" style="zoom:50%;" align="left" />





##### 2-2-4-10、优先级分析

- call/apply 比一般高

  - ```js
    function foo (a) {
        console.log(this.a)
    }
    
    const obj1 = {
        a: 1,
        foo: foo
    }
    
    const obj2 = {
        a: 2,
        foo: foo
    }
    
    obj1.foo.call(obj2)
    obj2.foo.call(obj1)
    ```

- new 比 bind 高

  - ```js
    function foo (a) {
        this.a = a
    }
    
    const obj1 = {}
    
    var bar = foo.bind(obj1)
    bar(2)
    console.log(obj1.a) // 2
    
    var baz = new bar(3)
    console.log(baz.a) // 3
    ```

- 箭头函数 this 无法修改

  - ```js
    function foo() {
        return a => {
            console.log(this.a)
        };
    }
    
    const obj1 = {
        a: 2
    }
    
    const obj2 = {
        a: 3
    }
    
    const bar = foo.call(obj1)
    console.log(bar.call(obj2)) // 2
    
    // 示例2
    var a = 123
    const foo = () => a => {
        console.log(this.a)
    }
    
    const obj1 = {
        a: 2
    }
    
    const obj2 = {
        a: 3
    }
    
    var bar = foo.call(obj1)
    console.log(bar.call(obj2)) // 123
    
    // 示例3
    // 将上述 var a 修改为 const a
    console.log(bar.call(obj2)) // undefined
    // 因为 const 声明的变量不会挂载到 window 全局对象
    ```

    

##### 2-2-4-11、典型事例

```js
Function.prototype.bind = Function.prototype.bind || function (context) {
    var me = this;
    var args = Array.prototype.slice.call(arguments, 1);
    return function bound () {
        var innerArgs = Array.prototype.slice.call(arguments);
        var finalArgs = args.concat(innerArgs);
        return me.apply(context, finalArgs);
    }
}
// 注意 bind 返回的函数如果作为构造函数，搭配 new 关键字出现的话，我们的绑定 this 就需要“被忽略”
// 为了实现这样的规则，开发者就应该需要考虑如何区分这两种调用方式。具体来讲 bound 函数中就要进行 this instanceof 的判断
// 另外注意 函数具有 length 属性，表示形参的个数。上述实现方式形参的个数显然会失真。我们的实现就需要对 length 属性进行还原。可是难点在于：函数的 length 属性值是不可重写的
// ....
```



```js
// 综合1：字面量对象中的各种场景
var name = 'window'
var person1 = {
  name: 'person1',
  foo1: function () {
    console.log(this.name)
  },
  foo2: () => console.log(this.name),
  foo3: function () {
    return function () {
      console.log(this.name)
    }
  },
  foo4: function () {
    return () => {
      console.log(this.name)
    }
  }
}
var person2 = { name: 'person2' }

person1.foo1() // person1
person1.foo1.call(person2) // person2

person1.foo2() // window
person1.foo2.call(person2) // window

person1.foo3()() // window
person1.foo3.call(person2)() // window
person1.foo3().call(person2) // person2

person1.foo4()() // person1
person1.foo4.call(person2)() // person2
person1.foo4().call(person2) // person1


// 综合2：构造函数中的各种场景 - 坑
var name = 'window'
function Person (name) {
  this.name = name
  this.foo1 = function () {
    console.log(this.name)
  },
  this.foo2 = () => console.log(this.name),
  this.foo3 = function () {
    return function () {
      console.log(this.name)
    }
  },
  this.foo4 = function () {
    return () => {
      console.log(this.name)
    }
  }
}
var person1 = new Person('person1')
var person2 = new Person('person2')

person1.foo1() // person1
person1.foo1.call(person2) // person2

person1.foo2() // person1
person1.foo2.call(person2) // person1

person1.foo3()() // window
person1.foo3.call(person2)() // window
person1.foo3().call(person2) // person2

person1.foo4()() // person1
person1.foo4.call(person2)() // person2
person1.foo4().call(person2) // person1


// 综合3:
var name = 'window'
function Person (name) {
  this.name = name
  this.obj = {
    name: 'obj',
    foo1: function () {
      return function () {
        console.log(this.name)
      }
    },
    foo2: function () {
      return () => {
        console.log(this.name)
      }
    }
  }
}
var person1 = new Person('person1')
var person2 = new Person('person2')

person1.obj.foo1()() // window
person1.obj.foo1.call(person2)() // window
person1.obj.foo1().call(person2) // person2

person1.obj.foo2()() // obj
person1.obj.foo2.call(person2)() // person2
person1.obj.foo2().call(person2) // obj


// 综合4
function foo() {
  console.log( this.a );
}
var a = 2;
(function(){
  "use strict";
  console.log(this) // undefined
  foo(); // 2
})();
```









#### 2-3、执行栈

可以将执行栈理解为一个存储函数调用的 **栈结构**，遵循先进后出的原则；执行一个函数时，如果这个函数又调用了另外一个函数，而这个“另外一个函数”也调用了“另外一个函数”，便形成了一系列的调用栈

当开始执行 JS 代码时，首先会执行一个 `main` 函数，然后执行我们的代码。根据先进后出的原则，后执行的函数会先弹出栈；

注意：栈可存放的函数是有**限制**的，一旦存放了过多的函数且没有得到释放，就会发生 **栈溢出**；

<img src="/Image/Chromium/25.png" style="zoom:50%;" />

<img src="/Image/Chromium/26.png" style="zoom:50%;" />

<img src="/Image/Chromium/27.png" style="zoom:50%;" />

正常来讲，在函数执行完毕并出栈时，函数内局部变量在下一个垃圾回收节点会被回收，该函数对应的执行上下文将会被销毁，这也正是我们在外界无法访问函数内定义的变量的原因。也就是说，只有在函数执行时，相关函数可以访问该变量，该变量在预编译阶段进行创建，在执行阶段进行激活，在函数执行完毕后，相关上下文被销毁





#### 2-4、Event Loop

前面讲到，执行 JS 代码时其实就是往执行栈中放入函数，而当遇到异步的代码时，会被 **挂起** 并在需要执行时加入到 Task(有多种 Task) 队列中；一旦执行栈为空，Event Loop(事件循环机制) 就会从 Task 队列 中拿出需要执行的代码并放入执行栈中执行；

**<u>*补充内容*</u>**：

浏览器(多进程)包含了**Browser进程**(浏览器的主进程)、**第三方插件进程**、**GPU进程**(浏览器渲染进程)等，其中**GPU进程**(多线程)与前端密切相关，包含以下线程：

- **GUI渲染线程**
- **JS引擎线程**(注意：GUI渲染线程、JS引擎线程互斥，为防止DOM渲染不一致性，其中一线程执行时另一线程会被挂起)
- **事件触发线程**(和EventLoop密切相关)
- **定时触发器线程**
- **异步HTTP请求线程**

浏览器页面初次渲染完毕后，**JS引擎线程**结合**事件触发线程**的工作流程如下：

- 同步任务在 **JS引擎线程**(主线程)上执行，形成**执行栈**(Execution Context Stack)；
- 主线程之外，**事件触发线程** 管理着一个**任务队列**(Task Queue)只要异步任务有了运行结果，就在**任务队列**之中放置一个事件；
- **执行栈** 中的同步任务执行完毕，系统就会读取**任务队列**，如果有异步任务需要执行，将其加到主线程的**执行栈**并执行相应的异步任务；

<img src="/Image/Chromium/714.png" style="zoom:50%;" />

事件循环机制：**事件触发线程**管理的任务是从**JS引擎线程**本身产生，主线程在运行时会产生**执行栈**，栈中的代码调用某些异步API时会在**任务队列**中添加事件，栈中的代码执行完毕后，就会读取**任务队列**中的事件，去执行事件对应的回调函数，如此循环往复，形成事件循环机制

<img src="/Image/Chromium/715.png" style="zoom:50%;" />

JS中有两种任务类型：**微任务**(microtask)和**宏任务**(macrotask)，在ES6中，microtask称为 jobs，macrotask称为 task。

**宏任务**： script (主代码块)、`setTimeout` 、`setInterval` 、`setImmediate` 、I/O 、UI rendering；

**微任务**：`process.nextTick`(Nodejs) 、`promise` 、`Object.observe` 、`MutationObserver`；

注意：**宏任务**并非全是异步任务，主代码块就是属于**宏任务**的一种 (Promises/A+规范**)；

它们之间区别如下：

- **宏任务**是每次**执行栈**执行的代码(包括每次从事件队列中获取一个事件回调并放到执行栈中执行)
- 浏览器为了能够使得**JS引擎线程**与**GUI渲染线程**有序切换，会在当前**宏任务**结束之后，下一个**宏任务**执行开始之前，对页面进行重新渲染(**宏任务** > 渲染  > **宏任务** > ...)
- **微任务**是在当前**宏任务**执行结束之后立即执行的任务(在当前 **宏任务**执行之后，UI渲染之前执行的任务)。**微任务**的响应速度相比`setTimeout`(下一个**宏任务**)会更快，因为无需等待UI渲染。
- 当前**宏任务**执行后，会将在它执行期间产生的所有**微任务**都执行一遍。

总结：

- **宏任务**中的事件是由**事件触发线程**来维护；
- **微任务**中的所有任务是由**JS引擎线程**维护的(这只是自我猜测，因为**宏任务**执行完毕后会立即执行**微任务**，为了提升性能，这种无缝连接的操作放在**事件触发线程**来维护明显是不合理的)。

根据事件循环机制，重新梳理一下流程：

- 执行一个**宏任务**(首次执行的主代码块或者**任务队列**中的回调函数)
- 执行过程中如果遇到**微任务**，就将它添加到**微任务**的任务队列中
- **宏任务**执行完毕后，立即执行当前**微任务**队列中的所有任务(依次执行)
- **JS引擎线程**挂起，**GUI线程**执行渲染
- **GUI线程**渲染完毕后挂起，**JS引擎线程**执行**任务队列**中的下一个**宏任务**





##### 2-4-1、宏微任务

JS 中的大部分任务都是在主线程上执行，常见的任务有：渲染事件、用户交互事件、JS 脚本执行、网络请求、文件读写完成事件等；而为让事件有条不紊地进行，JS 引擎需对执行顺序做一定处理，并采用  <u>队列</u> 的方式存储这些任务；比如 执行 for 循环时，将队列中的任务逐一取出并执行；但注意队列包含两种任务队列：

- <u>**普通任务队列**</u>：
- <u>**延迟任务队列**</u>：专门处理诸如 setTimeout/setInterval 等定时器回调任务；

```js
bool keep_running = true;
void MainTherad(){
  for(;;){
    // 执行队列中的任务
    Task task = task_queue.takeTask();
    ProcessTask(task);
    // 执行延迟队列中的任务
    ProcessDelayTask()
    if(!keep_running) // 若设置了退出标志，则直接退出线程循环
        break; 
  }
}
```

对于每个宏任务而言，其内部都有一个微任务队列，而**<u>引入微任务的初衷是为了解决异步回调的问题</u>**，对于异步回调的处理方式如下：

- 将异步回调进行宏任务队列的入队操作；
- 将异步回调放到当前宏任务的末尾；

若采用第一种方式，则执行回调的时机应在 <u>前面所有的宏任务完成之后</u>；若任务队列非常长，则回调迟迟得不到执行，造成 <u>应用卡顿</u>；

为规避这样的问题，V8 采用第二种方式，也即 微任务的解决形式：在每一个宏任务中定义一个 <u>**微任务队列**</u>，当该宏任务执行完成，会检查其中的微任务队列，若为空则直接执行下一个宏任务，否则依次执行微任务，执行完成才去执行下一个宏任务；



##### 2-4-1-1、宏微任务分类

- 宏任务—MacroTask：整体代码、setTimeout、setInterval、setImmediate、I/O、UI rendering、WebWorker等；
- 微任务—MicroTask：process.nextTick、Promises.then/reject-catch-finally、Object.observe、MutationObserver、以 Promise 为基础开发的其他技术(比如fetch API)、V8 的垃圾回收过程等；



##### 2-4-2、浏览器 EvLoop

<img src="/Image/Chromium/700.png" style="zoom:50%;" />

<img src="/Image/Chromium/28.png" style="zoom:50%;" />

- 首先，将整段脚本作为首个 **宏任务** 执行；
- 然后，执行过程中同步代码直接执行，**宏任务** 进入宏任务队列，**微任务**进入微任务队列；
- 然后，当前宏任务执行完全，执行栈为空，检查微任务队列，若有则依次执行，直到微任务队列为空；
- 然后，执行浏览器 UI 线程的渲染工作；
- 然后，检查是否有 Web worker 任务，有则执行；
- 最后，执行队首新的宏任务，回到第二步，依此循环，直到宏任务和微任务队列都为空；

```js
Promise.resolve().then(()=>{
  console.log('Promise1')  
  setTimeout(()=>{
    console.log('setTimeout2')
  },0)
});
setTimeout(()=>{
  console.log('setTimeout1')
  Promise.resolve().then(()=>{
    console.log('Promise2')    
  })
},0);
console.log('start');

// start
// Promise1
// setTimeout1
// Promise2
// setTimeout2
```



##### 2-4-3、Node EvLoop

<img src="/Image/Chromium/24.png" style="zoom:50%;" align="left"/>

<img src="/Image/Chromium/701.png" style="zoom:50%;" />



##### 2-4-3-1、NodeEvLoop 关键执行阶段

Node 有三个非常重要的执行阶段：

- **<u>执行定时器回调阶段</u>**：亦称 **<u>timer 阶段</u>**：检查定时器诸如 setTimeout、setInterval，若到时间，就执行回调；

- **<u>轮询阶段</u>**：亦称 **<u>poll 阶段</u>**：Node 代码的异步操作，比如 文件I/O、网络I/O等执行完成后，就会通过 `data`、 `connect` 等事件，使得事件循环到达  `poll` 阶段，以通知 JS 主线程，到达了这个阶段后：
  - 若当前已存在定时器，且有定时器到达时间，便拿出执行，EventLoop 将回到  **<u>timer 阶段</u>**；
  - 若无定时器, 便会查看回调函数队列；
    - 若队列不为空，便遍历 callback 队列并同步执行，直到队列为空或者达到系统限制；
    - 若队列为空，则检查是否有 `setImmdiate` 回调；
      - 若有则前往 **<u>check 阶段</u>**；
      - 若无则继续等待，相当于阻塞了一段时间，等待 callback 被加入到队列中并立即执行，达到超时时间后则自动进入 **<u>check 阶段</u>**；

- **<u>check 阶段</u>**：相对简单的阶段，直接执行 `setImmdiate` 的回调；

上述三个阶段为一个循环过程，也是 Node 执行的最重要阶段，但不完整；



##### 2-4-3-2、NodeEvLoop 关键执行阶段完善

**<u>注意：若对过程不理解，可参考例子  2-4-5-4：定时器的执行顺序</u>**

- **<u>执行定时器回调阶段</u>**：亦称 **<u>timer 阶段</u>**：检查定时器诸如 setTimeout、setInterval，若到时间，就执行回调；**<u>注意，此阶段由 poll 阶段控制；</u>**
- **<u>I/O 异常回调阶段</u>**：处理上一轮循环中的 <u>少数未执行</u> 的 I/O 回调，比如 TCP 连接遇到 ECONNREFUSED，就会在此时执行回调；
- **<u>空闲、预备状态</u>**：第 2 阶段结束，poll 阶段未触发之前；

- **<u>轮询阶段</u>**：亦称 **<u>poll 阶段</u>**：此阶段会做两件事：
  - 回到 timer 阶段执行回调；
  - 执行 I/O 回调；
- 具体做法是：进入 **<u>poll 阶段</u>** 后：
  - 若当前已存在定时器，且 poll callback 函数队列为空，且有定时器到达时间，EventLoop 将回到  **<u>timer 阶段</u>**(拿出到时的定时器回调执行)；
  - 若无设定定时器, 便会查看 poll callback 函数队列；
    - 若队列不为空，便遍历 poll callback 队列并同步执行，直到队列为空或者达到系统限制；
      - **<u>关键：当 Node 代码异步操作(比如 文件I/O、网络I/O等)执行完成后，就会通过 `data`、 `connect` 等事件通知，使得 Ev Loop 到达  `poll` 阶段;</u>**
    - 若队列为空，则检查是否有 setImmdiate 回调；
      - 若有则前往 **<u>check 阶段</u>**；
      - 若无则继续等待，相当于阻塞了一段时间，等待 callback 被加入到队列中并立即执行，达到超时时间后则自动进入 **<u>check 阶段</u>**；

- **<u>check 阶段</u>**：相对简单的阶段，直接执行 setImmdiate 的回调；
- **<u>关闭事件的回调阶段</u>**：若一个 socket 或句柄 (handle) 被突然关闭，比如 socket.destroy()， `close` 事件回调就会在此阶段执行；

上述描述的是 macrotask 执行情况，对于 microtask 来说，它会在以上每个阶段完成前 **清空**  microtask 队列，下图中的 Tick 就代表了 microtask：

<img src="/Image/Chromium/29.png" style="zoom:50%;" align="left"/>





##### 2-4-3-3、Node 版本差异

- node 版本 >= 11：与浏览器表现一致，定时器运行完立即运行相应的微任务；
- node 版本 < 11：若第一个定时器任务出队并执行完，发现队首任务仍是一个定时器，则将微任务暂时保存，直接去执行新的定时器任务，当新的定时器任务执行完后，再一一执行中途产生的微任务；

```js
setTimeout(()=>{
    console.log('timer1')
    Promise.resolve().then(function() {
        console.log('promise1')
    })
}, 0)
setTimeout(()=>{
    console.log('timer2')
    Promise.resolve().then(function() {
        console.log('promise2')
    })
}, 0)
// node 版本 >= 11
timer1
promise1
time2
promise2
// node 版本 < 11
timer1
timer2
promise1
promise2
```



##### 2-4-4、两者间的差别

最主要的区别在于：浏览器中的微任务是在 **<u>每个相应的宏任务</u>** 间执行的，而 Node  中的微任务是在 **<u>不同阶段间</u>** 执行的；



##### 2-4-5、注意事项

##### 2-4-5-1、process.nextTick 执行

process.nextTick 是独立于 Node EvLoop 的任务队列；

当每个 NodeEvLoop 阶段完成后，若存在 nextTick 队列，就会 **<u>清空队列中的所有回调函数</u>**，且**<u>优先于其他微任务</u>** 执行；

```js
setTimeout(() => {
 console.log('timer1')

 Promise.resolve().then(function() {
   console.log('promise1')
 })
}, 0)

process.nextTick(() => {
 console.log('nextTick')
 process.nextTick(() => {
   console.log('nextTick')
   process.nextTick(() => {
     console.log('nextTick')
     process.nextTick(() => {
       console.log('nextTick')
     })
   })
 })
})
// 以上代码，无论如何，永远都是先把 nextTick 全部打印出来


// Ex2
setTimeout(function() {
  console.log('timeout')
})

process.nextTick(function(){
  console.log('nextTick 1')
})

new Promise(function(resolve){
  console.log('Promise 1')
  resolve();
  console.log('Promise 2')
}).then(function(){
  console.log('Promise Resolve')
})

process.nextTick(function(){
  console.log('nextTick 2')
})
// Node环境(10.3.0版本)中打印的顺序： Promise 1 > Promise 2 > nextTick 1 > nextTick 2 > Promise Resolve > timeout
// Node.js的v10.x版本中对于 process.nextTick 的说明如下：
The process.nextTick() method adds the callback to the "next tick queue". Once the current turn of the event loop turn runs to completion, all callbacks currently in the next tick queue will be called.
This is not a simple alias to setTimeout(fn, 0). It is much more efficient. It runs before any additional I/O events (including timers) fire in subsequent ticks of the event loop.
```

<img src="/Image/Chromium/t1.png" style="zoom:50%;" align="left"/>

```js
// Node 环境下:
// 1 7(主阶段) 6(process.nextTick在阶段间、微任务前执行) 8(微任务) 2 4 9 11(poll 执行 timer 回调) 3 10(阶段间、微任务前) 5 12(微任务)

// 浏览器下: 可用 Promise.resolve().then(()=>{ 替换 process.nextTick；
//  1 7 6 8 2 4 3 5 9 11 10 12
```



<img src="/Image/Chromium/39.png" style="zoom:50%;" align="left"/>

```js
// 1 10(宏) 8 9(nextTick) 5 7(微) 2 6(timer) 3(微) 4(nextTick)
```

<img src="/Image/Chromium/40.png" style="zoom:50%;" align="left"/>

```js
// 1 7(宏) 6(nextTick) 8(微) 2 4 9 11(timer) 3 10(nextTick) 5 12(微)
```

<img src="/Image/Chromium/41.png" style="zoom:50%;" align="left"/>

```js
// 1 7 6 8 2 4 3 5 9 11 10 12
```

<img src="/Image/Chromium/42.png" style="zoom:50%;" align="left"/>

```js
// 1 7 6 8 9 11 10 12 2 4 3 5
```



##### 2-4-5-2、await 执行

基本：

<img src="/Image/Chromium/32.png" style="zoom:50%;" align="left"/>

<img src="/Image/Chromium/34.png" style="zoom:50%;" align="left"/>

关键：将 await 同行代码化为 new Promise 内容(同步)，将 await 后行内容化为 promise.then 内容即可

```js
console.log('script start')

async function async111() {
  await async2222()
  console.log('async1 end')
}
async function async2222() {
  console.log('async2 end')
}
async111()

setTimeout(function() {
  console.log('setTimeout')
}, 0)

new Promise(resolve => {
  console.log('Promise')
  resolve()
})
.then(function() {
  console.log('promise1')
})
  .then(function() {
  console.log('promise2')
})

console.log('script end')
// script start => async2 end => Promise => script end => async1 end => promise1 => promise2 => setTimeout
```



<img src="/Image/Chromium/35.png" style="zoom:50%;" align="left"/>

```js
// scriptStart => async1Start => async2 => promise1 => scriptEnd => async1End => promise2 => setTimeout
```



<img src="/Image/Chromium/36.png" style="zoom:50%;" align="left"/>

```js
// scriptStart => async1Start => promise1 => promise3 => scriptEnd => promise2 => async1End(注意顺序) => promise4 => setTimeout
```



<img src="/Image/Chromium/37.png" style="zoom:50%;" align="left"/>

```js
// scriptStart => async1Start => promise1 => scriptEnd => promise2 => setTimeout3 => setTimeout2 => setTimeout1
```



<img src="/Image/Chromium/38.png" style="zoom:50%;" align="left"/>

```js
// scriptStart => a1Start => a2 => promise2 => scriptEnd => promise1 => a1End => promise2Then => promise3 => setTimeout
```





##### 2-4-5-3、EvLoop 进入成本

进入 EvLoop 也是需要成本的：`setTimeout(fn, 0) === setTimeout(fn, 1)`

- 若准备时间花费大于 1ms，则在 timer 阶段就会直接执行 `setTimeout` 回调；
- 若准备时间花费小于 1ms，则 `setImmediate` 回调先执行；

```js
setTimeout(() => {
  console.log('timer21')
}, 0)

Promise.resolve().then(function() {
  console.log('promise1')
})
// EvLoop 准备时间不可能小于 0ms 故必定经历 timers 阶段，阶段经历后，清空微任务队列，故输出：promise1 -> timer21
```



##### 2-4-5-4、定时器的执行顺序

注意：某些情况下，定时器的执行顺序其实是 **随机** 的，这是由源码决定的：

```js
setTimeout(() => {
    console.log('setTimeout')
}, 0)
setImmediate(() => {
    console.log('setImmediate')
})
// setTimeout 可能执行在前，也可能执行在后
```

注意：而在某些情况下，定时器的执行顺序一定是 **固定** 的：

```js
const fs = require('fs')

fs.readFile(__filename, () => {
    setTimeout(() => {
        console.log('timeout');
    }, 0)
    setImmediate(() => {
        console.log('immediate')
    })
})
```

**<u>注意：若忘记 NodeEvLoop具体流程，可回看 2-4-3-2、NodeEvLoop 关键阶段完善</u>**

在上述代码中，`setImmediate` 永远**先执行**；分析过程：

- 首先，进入 Node EvLoop；
- 然后，当 Node 代码异步操作(比如 文件I/O、网络I/O等)执行完成后，就会通过 `data`、 `connect` 等事件通知，使得 Ev Loop 到达  **<u>poll 阶段</u>**；
- 因为，两个代码写在 IO 操作(此处是文件IO)的回调中，而 IO 回调是在 **<u>poll 阶段</u>**执行的；
- 所以，进入 **<u>poll 阶段</u>**后，首先主体代码无发现定时器，遂查看 poll callback 函数队列，且队列为空，并发现存在 `setImmediate` 回调，跳转到 check 阶段；
- 最后，**<u>check 阶段</u>** 直接执行 `setImmdiate` 的回调；



##### 2-4-5-5、new Promise 执行

基本：new Promise 相当于同步任务，会立即执行；

<img src="/Image/Chromium/31.png" style="zoom:50%;" align="left"/>



**<u>注意：分析嵌套 Promise 关键</u>**：厘清微任务，执行顺序还是宏微宏微，若无宏任务，则连续执行微任务，**<u>但执行顺序是按加入微任务队列的先后执行的</u>**；

<img src="/Image/Chromium/43.png" style="zoom:50%;" align="left"/>

比如：上图一轮：promise1 后只有 then 微任务，遂进入 then 执行，输出 then11 和 promise2，随后发现 2 个微任务：一个是里面的 then，一个是外面的 then，然后执行…

<img src="/Image/Chromium/44.png" style="zoom:50%;" align="left"/>

```js
// promise1 => then11 => promise2 => then21 => then12 => then23
```



<img src="/Image/Chromium/48.png" style="zoom:50%;" align="left"/>

<img src="/Image/Chromium/49.png" style="zoom:50%;" align="left"/>

```
// promise1 => promise3 => then11 => promise2 => then31 => then21 => then12 => then23
```



<img src="/Image/Chromium/45.png" style="zoom:50%;" align="left"/>

```js
// 1 2 3 4 5 6 7 8 9
```



**<u>注意：处理内里 return Promise 的关键</u>**：回归链式调用，由上往下执行

<img src="/Image/Chromium/47.png" style="zoom:50%;" align="left"/>

```js
// promise1 => then11 => promise2 => then21 => then23 => then12
```





##### 2-4-6、示例集合

##### 2-4-6-1、浏览器环境示例

```js
console.log('ss');
setTimeout(function() {
  console.log('setTimeout');
}, 0)
Promise.resolve().then(function() {
  console.log('p1t1');
}).then(function() {
  console.log('p1t2')
})
console.log('se');
// ss se p1t1 p1t2 setTimeout
// 宏任务 script -> 再微任务 promise1 2，再宏任务 setTimeout



// Ex2
console.log('ss');
setTimeout(function() {
  console.log('setTimeout');
}, 0)
Promise.resolve().then(function() {
  console.log('p1t1');
}).then(function() {
  console.log('p1t2')
})
Promise.resolve().then(function() {
  console.log('p2t1');
}).then(function() {
  console.log('p2t2')
})
console.log('se');
// ss se p1t1 p2t1 p1t2 p2t2 setTimeout
// 注意: 链式调用并非链式添加微任务，每当添加完后就离开执行外面内容，而非一直链式添加微任务队列



// Ex3
// 1
console.log('ss');
// 16
setTimeout(function() {
  console.log('setTimeout');
}, 0)
// 执行时发现微任务 3-p1t1，塞入微任务队列1
Promise.resolve().then(function() {
  // 3
  console.log('p1t1');
  // 执行时发现微任务 5-p1t2，塞入微任务队列2
}).then(function() {
  // 5
  console.log('p1t2');
  // 执行时发现微任务 7-p1t3，塞入微任务队列3
}).then(function() {
  // 7
  console.log('p1t3');
  // 执行时发现微任务 10-p1t3-t1，塞入微任务队列4
  Promise.resolve().then(function(){
    // 10
    console.log('p1t3-t1');
    // 执行时发现微任务 12-p1t3-t1-t1，塞入微任务队列5
    Promise.resolve().then(function(){
      // 12
    	console.log('p1t3-t1-t1');
  	})
    // 执行时发现微任务 13-p1t3-t2，塞入微任务队列5
  }).then(function(){
    // 13
    console.log('p1t3-t2');
  })
})
// 执行时发现微任务 4-p2t1，塞入微任务队列1
Promise.resolve().then(function() {
  // 4
  console.log('p2t1');
  // 执行时发现微任务 6-p2t2，塞入微任务队列2
}).then(function() {
  // 6
  console.log('p2t2');
  // 执行时发现微任务 8-p2t2-t1，塞入微任务队列3
  Promise.resolve().then(function(){
    // 8
    console.log('p2t2-t1');
    // 执行时发现微任务 11-p2t2-t2，塞入微任务队列4
  }).then(function(){
    // 11
    console.log('p2t2-t2');
    // 执行时发现微任务 14-p2t2-t2-t1，塞入微任务队列5
    Promise.resolve().then(function(){
      // 14
    	console.log('p2t2-t2-t1');
      // 执行时发现微任务 15-p2t2-t2-t1-t1，塞入微任务队列6
      Promise.resolve().then(function(){
        // 15
    		console.log('p2t2-t2-t1-t1');
  		})
  	})
  })
  // 执行时发现微任务 9-p2t3，塞入微任务队列3
}).then(function() {
  // 9
  console.log('p2t3')
})
// 2
console.log('se');

// ss
// se
// p1t1
// p2t1
// p1t2
// p2t2
// p1t3
// p2t2-t1
// p2t3
// p1t3-t1
// p2t2-t2
// p1t3-t1-t1
// p1t3-t2
// p2t2-t2-t1
// p2t2-t2-t1-t1
// setTimeout
```





<img src="/Image/Chromium/t3.png" style="zoom:50%;" align="left"/>

```js
// 先宏任务124 -> 再微任务then-53 -> 再宏任务6
```



<img src="/Image/Chromium/t4.png" style="zoom:50%;" align="left"/>

```js
// 1 8(宏) 3 4 5 7(微) 2(宏) 6(宏)
```



<img src="/Image/Chromium/t5.png" style="zoom:50%;" align="left"/>

```js
// click(宏) promise(微) mutate(微) click(宏) promise(微) mutate(微) timeout(宏) timeout(宏)
// 相当于两个 onClick 事件函数展开，mutationOb 是微任务
```



<img src="/Image/Chromium/t6.png" style="zoom:50%;" align="left"/>

```js
// 1 3 5(宏) 4(微) 2(宏)
```



<img src="/Image/Chromium/t7.png" style="zoom:50%;" align="left"/>

```js
// "马上..、代码..."(宏) "then"(微) "定时器"(宏)
```



<img src="/Image/Chromium/t8.png" style="zoom:50%;" align="left"/>

```js
// 2 3 5(宏) 4(微) 1(宏)
```

<img src="/Image/Chromium/t9.png" style="zoom:50%;" align="left"/>

```js
// 1 10(宏) 5 8 7 9(微-注意顺序) 2(宏) 3 4(微) 6(宏) 
// 执行微任务遇到微任务，先塞入队列，注意顺序
```

更多详看：[这里](https://www.cnblogs.com/lpggo/p/8127604.html)





##### 2-4-6-2、Node 环境示例

<img src="/Image/Chromium/t11.png" style="zoom:40%;" align="left"/>

```js
// start end(宏) promise3(微) timer1 timer2(timer阶段) promise1 promise2(微)
```

<img src="/Image/Chromium/t12.png" style="zoom:60%;" align="left"/>

```js
// scriptStart async1Start async2 promise1 scriptEnd(宏，其中 async 同行等同 new promise, 而行后内容可视为 promise.then) process(nextTick) async1End promise2(微) setTimeout(timer阶段) setImmediate(check阶段)
```

<img src="/Image/Chromium/t14.png" style="zoom:60%;" align="left"/>

```js
// scriptStart async1Start async2 promise1 scriptEnd(宏) async1End promise2(微) setTimeout(timer 阶段)
```



##### 2-4-X、setTimeout/setInterval/Req

屏幕绘制频率：普通屏电子束每秒击打荧光粉的次数或通电持续发光、显示器高频更新屏幕图像；

视觉停留效应：图像停留在大脑的印象还没消失，紧接着图像又被移到了下一个位置，因人眼视觉停留效应，当前位置图像停留在大脑印象尚未消失；

CSS 动画原理：图像被绘制而引起变化的视觉效果，比如 60Hz，每16.7ms 绘制一次；

动画的 JS实现：受 setTimeout 执行时间和设备的屏幕绘制频率影响；

动画卡顿现象：上述因素中，setTimeout 是唯一人为可控，但其执行时间无法确定；若其执行步调和屏幕刷新步调不同，引起丢帧/动画不连贯导致肉眼可视卡顿

- 比如：setTimeout 每隔10s设置图像向左移动1px,就会出现如下绘制过程：

- ```js
  第 0 ms:    屏幕未绘制，等待中，setTimeout 也未执行，等待中；
  第 10 ms:   屏幕未绘制，等待中，setTimeout 开始执行并设置元素属性 left=1px;
  第 16.7ms:  屏幕开始绘制，屏幕上的元素向左移动了 1px, setTimeout 未执行，继续等待中；
  第 20 ms:   屏幕未绘制，等待中，setTimeout 开始执行并设置 left=2px;
  第 30 ms:   屏幕未绘制，等待中，setTimeout 开始执行并设置 left=3px;
  第 33.4 ms: 屏幕开始绘制，屏幕上的元素向左移动了 3px, setTimeout 未执行，继续等待中；
  // 上面的绘制过程中可以看出，屏幕没有更新 left=2px 的那一帧画面，元素直接从 left=1px 的位置跳到了 left=3px的的位置
  // 这就是丢帧现象，这种现象就会引起动画卡顿
  ```

- 注意：RAF 可实现 setTIme/setInterVal，但受外界影响，后者却无法实现 RAF；
- 注意：setTimeout 动画效果卡顿原因：执行步调和屏幕刷新步调不一致；

- 注意：函数 setTImeout 的二参为最少延迟时间，而非确切等待时间；
- 注意：函数 setTImeout 的二参为零，并不意味着回调会立即执行，其等待时间取决于队列里待处理的消息数量；



##### 2-4-X-1、setTime/setInterval 

`setTimeout` 运行机制：执行该语句时，是立即把当前定时器代码推入事件队列，当定时器在事件列表中满足设置的时间值时将传入的函数加入任务队列，之后的执行就交给任务队列负责；但若此时任务队列不为空，则需等待，所以执行定时器内代码的时间可能会大于设置的时间；

```js
// 使用技巧
// 1、setTimeout/setInterval(函数参数，时间，[函数参数所接受参数, ...])
setTimeout(function(...args) {
	console.log(args);
}, 1000, [1,2,3], 4, 5, 6);
// [Array(3), 4, 5, 6]

setInterval(function(...args) {
	console.log(args);
}, 1000, [1,2,3], 4, 5, 6);
// [Array(3), 4, 5, 6]

// 2、可通过强绑定形式传参
setTimeout(function(a, b) {
  // 3 4
}.bind(Object.create(null), 3, 4), 1000);

// 3、参数一有两种形式：不加括号的函数名形式，与加括号的字符串形式
setTimeout(test, 1000);
setTimeout('test()', 1000);
setTimeout(test(), 1000);
// TypeError: callback argument must be a function

// 4、无法动态改变 Interval 间隔值，需先暂停，再赋值重新启动
var time = 2000;
var set1 = setInterval(fn, time);
function fn() {
  time -= 10;
  clearInterval(set1);
  if(time > 0) {
    set1 = setInterval(fn, time);
  }
}
```



##### 2-4-X-2、setTime/setInterval 区别&实现

前者，时间指：Math.max (其他代码执行时间 与 setTime设定时间)；

后者，时间指：定期将任务加入事件队列中(但需注意，若内部执行代码时长 > setInterval 耗时则会被忽略)；

注意：定期清除，搭配 null 使用，即：timer = serInterVal 并 clearInterVal 后，timer = null；

问题：setInterval 设置的间隔时间过短时，若代码块里的代码并没有执行完也会重新开始执行(比如内部执行较大循环)；

解决：但使用 setTimeout 实现 setInterval 的效果就无此问题：必然会把代码块中的代码运行玩后，然后才会再次调用该函数；

```js
// 用 setTimeout 实现 setInterval
function timeoutBuildInterval() {
  timeoutBuildInterval.timer = setTimeout(() => {
    arguments[0]();
    timeoutBuildInterval(...arguments);
  }, arguments[1]);
}

timeoutBuildInterval.clear = function () {
  clearTimeout(timeoutBuildInterval.timer);
};

timeoutBuildInterval(() => {
  console.log(11111);
}, 1000);

setTimeout(() => {
  // 5s 后清理
  timeoutBuildInterval.clear();
}, 5000);
```



##### 2-4-X-3、[window.requestAnimationFrame(cb)](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame)

注意：rAF 不属于宏任务也不属于微任务，它是独立于主线程之外的任务，不归主线程管；

传统的 JS 动画是通过定时器 `setTimeout ` 或 `setInterval` 实现，但定时器动画一直存在两个问题：

- 动画循时间环间隔不确定，间隔过长则动画显得不够平滑流畅，间隔过短则遇浏览器重绘频率瓶颈，推荐最佳循环间隔是`17ms`；
- 定时器第二个时间参数只指定多久后将动画任务添加到浏览器的UI线程队列中，而非执行；此时若 UI 线程忙碌，则动画不会立刻执行；

为了解决这些问题，H5 中加入了 `requestAnimationFrame` 及 `requestIdleCallback`

- `requestAnimationFrame` 会将每帧中的所有 DOM 操作集中起来，在一次重绘或回流中就完成，且重绘或回流的时间间隔，跟随浏览器刷新频率
  - 此外：在隐藏/不可见元素中，`requestAnimationFrame` 将不会进行重绘或回流，即更少的 CPU、GPU 和内存使用量；
- `requestAnimationFrame` 是由浏览器专门为动画提供的 API，在运行时会自动优化方法的调用，且若页面非激活态，动画就会自动暂停，节省 CPU 开销；
- 注意：`requestAnimationFrame` 回调会在每一帧确定执行，属于高优先级任务，而 `requestIdleCallback` 回调则不一定，属于低优先级任务；
- 注意：所看到的网页，都是浏览器逐帧绘制，通常认为 FPS 60 时较流畅，而 FPS 为个位数时用户就会感知到卡顿；每帧包含用户的交互、JS 的执行、及requestAnimationFrame 调用，布局计算以及页面的重绘等工作；
- <img src="/Image/Chromium/706.png" style="zoom:50%;" align="left"/>
- 假如某帧中要执行任务不多，在不到 16ms(1000/60)的时间内就完成了上述任务的话，则此帧就会有一定的空闲时间，这段时间就可用来执行requestIdleCallback
- <img src="/Image/Chromium/707.png" style="zoom:50%;" align="left"/>

参数：cb：下次重绘前要执行的函数；

- cb 会被传入 [DOMHighResTimeStamp](https://developer.mozilla.org/zh-CN/docs/Web/API/DOMHighResTimeStamp) 参数；
- 其由 RAF 排队的回调开始触发的时间 (不明)；
- 其当前被 RAF 排序的回调函数被触发的时间 (不明)；

返回：返回值作为回调列表中唯一标识的非零整数，可传予 [window.cancelAnimationFrame()](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/cancelAnimationFrame) 取消回调；

优势：CPU节能：

- 当页面隐藏时，setTimeout 仍在后台执行，而 rAF 在页面未激活状态下，该页面屏幕绘制任务也会被系统暂停，因此跟着系统步伐走的 rAF 也会停止渲染；
- 当页面被激活时，动画就从上次停留的地方继续执行，有效节省了 CPU 开销；

优势：函数节流：

- 在高频率事件(resize,scroll 等)中，为防止在一个刷新间隔内发生多次函数执行，使用 rAF 可保证每个绘制间隔内，函数只被执行一次，如此既能保证流畅性，又能更好的节省函数执行的开销；
- 因为一个绘制间隔内函数执行多次时没有意义的，因为显示器每16.7ms 绘制一次，多次绘制并无意义；

原理：系统每次绘制之前会主动调用 rAF 中的回调函数，由系统决定回调函数执行时机，并保证回调函数在屏幕每一次的绘制间隔中只被执行一次；

- 注意：刷新频率值因浏览器刷新频率不同而不同，通常执行次数：60次/s；
- 注意：大多数浏览器，会将暂停后台标签页/隐藏 iframe 中的 RAF 调用，以提升性能和电池寿命；
- 注意：RAF 只会在下次重绘前调用1次，若想连续调用需配合递归使用；
- 注意：如果同一帧中，存在多个 cb，则它们均会收一个相同时间戳(ms)，即便执行上一个 cb 已消耗一些时间；

兼容：

```js
// 使用 setTimeout 兼容 raf

// 简化版
// 没有考虑 cancelAnimationFrame 的兼容性，并且不是所有的设备绘制时间间隔都是 1000/60
window.requestAnimFrame = (function(){
  return  window.requestAnimationFrame       ||
          window.webkitRequestAnimationFrame ||
          window.mozRequestAnimationFrame    ||
          function( callback ){
            window.setTimeout(callback, 1000 / 60);
          };
})();

// 优化版
if (!Date.now) Date.now = function() { return new Date().getTime(); };
(function() {
    'use strict';
    var vendors = ['webkit', 'moz'];
    for (var i = 0; i < vendors.length && !window.requestAnimationFrame; ++i) {
        var vp = vendors[i];
        window.requestAnimationFrame = window[vp+'RequestAnimationFrame'];
        window.cancelAnimationFrame = (window[vp+'CancelAnimationFrame']
                                   || window[vp+'CancelRequestAnimationFrame']);
    }
    if (/iP(ad|hone|od).*OS 6/.test(window.navigator.userAgent) // iOS6 is buggy
        || !window.requestAnimationFrame || !window.cancelAnimationFrame) {
        var lastTime = 0;
        window.requestAnimationFrame = function(callback) {
            var now = Date.now();
            var nextTime = Math.max(lastTime + 16, now);
            return setTimeout(function() { callback(lastTime = nextTime); },
                              nextTime - now);
        };
        window.cancelAnimationFrame = clearTimeout;
    }
}());

// https://github.com/darius/requestAnimationFrame/blob/master/requestAnimationFrame.js
```

**<u>*RAF 实现 setInterval：*</u>**

```js
// 实现1
function setInterval2(cb, delay, ...args) {
  // 记录所有正在运⾏的 interval ⽤于撤销
  let pool = window[Symbol.for("IntervalPool")];
  if (!pool) {
    pool = {};
    window[Symbol.for("IntervalPool")] = pool;
  }
  // interval 最低 10ms，虽然每 frame ⾄少得 16ms
  delay = delay >= 10 ? delay : 10;
  // interval id
  let ticket = Date.now();
  // 每次 interval 开始时间
  let startTime = ticket;
  pool[ticket] = true;
  loop();
  return ticket;
  function loop() {
    if (!pool[ticket]) {
      return;
    }
    const now = Date.now();
    if (now - startTime >= delay) {
      startTime = now;
      cb(...args);
    }
    requestAnimationFrame(loop);
  }
}
function clearInterval2(ticket) {
  let pool = window[Symbol.for("IntervalPool")];
  if (pool && pool[ticket]) {
    delete pool[ticket];
  }
}




// 实现2
var timer = null;
function newSetInterval(callback, time, ...args){
  var set = function(callback, time, ...args){
    return function(){
      var start = +new Date();
      var end = start;
      while(end-start<time){
        end = +new Date();
      }
      callback(...args);
      timer = requestAnimationFrame(set(callback, time, ...args));
    }
  }
  set(callback, time, ...args)();
}
function newClearInterval(timer){
  cancelAnimationFrame(timer);
}

// 实践
$("#run").on("click", function(){
  newSetInterval(function(a, b){
    console.log(a+b);
  }, 500, 1, 2);
});
$("#stop").on("click", function(){
  console.log("stop", timer);
  newClearInterval(timer);
});
// https://segmentfault.com/q/1010000013909430
// https://blog.csdn.net/csm0912/article/details/84066966
```

**<u>*RAF 实现 setTimeout：*</u>**

```js
// 示例
var i = 0;
fun();
function fun() {
  console.log(i);
  if (i < 100) {
    requestAnimationFrame(fun);
  }
  i++;
}
// 封装
(function () {
  var lastTime = 0;
  var vendors = ["ms", "moz", "webkit", "o"];
  for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
    window.requestAnimationFrame = window[vendors[x] + "RequestAnimationFrame"];
    window.cancelAnimationFrame =
      window[vendors[x] + "CancelAnimationFrame"] ||
      window[vendors[x] + "CancelRequestAnimationFrame"];
  }
  if (!window.requestAnimationFrame)
    window.requestAnimationFrame = function (callback, element) {
      var currTime = new Date().getTime();
      var timeToCall = Math.max(0, 16 - (currTime - lastTime));
      var id = window.setTimeout(function () {
        callback(currTime + timeToCall);
      }, timeToCall);
      lastTime = currTime + timeToCall;
      return id;
    };
  if (!window.cancelAnimationFrame)
    window.cancelAnimationFrame = function (id) {
      clearTimeout(id);
    };
})();
// https://blog.csdn.net/u011500781/article/details/51953217
```

RAF 和 setInterval 在浏览器标签页闲值时的频率(主因是浏览器的线程管理问题)：

- 详看：[文1](https://segmentfault.com/a/1190000000386368)、[文2](https://stackoverflow.com/questions/15871942/how-do-browsers-pause-change-javascript-when-tab-or-window-is-not-active)

RAF 使用示例：

<img src="/Image/Chromium/708.png" style="zoom:50%;" align="left"/>

<img src="/Image/Chromium/709.png" style="zoom:50%;" align="left"/>

<img src="/Image/Chromium/710.png" style="zoom:50%;" align="left"/>





### 三、V8 垃圾回收机制

**新生代内存**：用于存活较短的对象；

- 可再分成两个空间：from 空间 与 to 空间；
- Scavenge GC 算法：当 from 空间被占满时启动 GC；
  - 存活的对象从 from space 按一定顺序转移到 to space；
  - 清空 from space；
  - from space 与 to space 互换，完成 GC；
  - 以上过程不断循环；

**老生代内存**：用于存活时间较长的对象；

- 从 新生代 转移到 老生代 的条件：
  - 经历过一次以上 Scavenge GC 的对象；
  - 当 to space 体积超过 25%；
- Mark-Sweep GC 算法：标记存活的对象，未被标记的则被释放；
- Mark-Compact 整理算法：将内存中清除后导致的碎片化对象往内存堆的一端移动；

**增量标记**：小模块标记，在代码执行间隙执行，缓解因 GC 的阻塞现象；

**并发标记**(最新技术)：不阻塞 JS 执行；



#### 3-1、V8内存限制与回收策略

V8 只能使用系统的一部分内存，比如在 64 位系统最多只能分配 1.4G，32 位系统最多只能分配 0.7G；而之所以这样限制，是因为：

- JS 是单线程的执行机制：一旦进入到垃圾回收，其它的各种运行逻辑都要暂停；
- JS垃圾回收机制的限制：垃圾回收过程非常耗时间；

<u>与其代码执行会一直没有响应，造成应用卡顿，所以还不如直接限制内存</u>；但注意某些场景还是可以提高内存限制的：

```js
// 调整老生代这部分的内存，单位是 MB
node --max-old-space-size=2048
```

```js
// 调整新生代这部分的内存，单位是 KB
node --max-new-space-size=2048
```



##### 3-1-1、突破限制实际案例

Angular：打包项目的时候就遇到过频繁报内存溢出：

`FATAL ERROR: CALL_AND_RETRY_LAST Allocation failed - process out of memory`

解决：修改项目根目录  `node_modeles` 文件夹、`.bin` 目录、`ng`的文件首行：

`#!/usr/bin/env node --max_old_space_size=4096`

VueReact：[详看](https://blog.csdn.net/qq_35624642/article/details/81084331)



##### 3-1-2、回收策略

通常情况下，垃圾数据回收分为 <u>手动回收</u> 和 <u>自动回收</u> 两种策略：

- **手动回收策略**：何时分配内存、何时销毁内存都是由代码控制的；
- **自动回收策略**：产生的垃圾数据是由垃圾回收器来释放的，并不需要手动通过代码来释放；



##### 3-1-3、引用计数与标记清除

- **引用计数**：给一个变量赋值引用类型，则该对象的引用次数 +1，若此变量变成了其他值，则该对象的引用次数-1，垃圾回收器会回收引用次数为 0 的对象；但当对象循环引用时，会导致引用次数永远无法归零，导致内存无法释放；
- **标记清除**：垃圾收集器先给内存中所有对象加上标记，然后从根节点开始遍历，去掉被引用的对象和运行环境中对象的标记，剩下的被标记的对象即无法访问的、等待回收的对象；



##### 3-1-4、内存生命周期

- 分配内存空间
- 读写内存
- 释放内存空间
  - 注意：对于分配内存和读写内存的行为所有语言都较为一致，但释放内存空间在不同语言之间有差异；

```js
var foo = 'bar' // 在堆内存中给变量分配空间
alert(foo)  // 使用内存
foo = null // 释放内存空间
```



##### 3-1-5、内存空间分类

- 栈空间：由操作系统自动分配释放，存放函数的参数值，局部变量的值等，其操作方式类似于数据结构中的栈。
- 堆空间：一般由开发者分配释放，这部分空间就要考虑垃圾回收的问题。




#### 3-2、栈内存数据回收管理

引擎会通过向下移动 ESP (记录当前执行状态的指针) 来销毁该函数保存在栈中的执行上下文；

栈的功能除了保存变量外，还有创建并切换函数执行上下文的功能；当栈指针 ESP 下移，即上下文切换后，栈顶的空间会自动被回收；

```js
function f(a) {
  console.log(a);
}
function func(a) {
  f(a);
}
func(1);

// 首先，调用 func, 将 func 函数的上下文压栈，ESP 指向栈顶；
// 然后，执行 func，又调用 f 函数，将 f 函数的上下文压栈，ESP 指针上移；
// 然后，执行完 f 函数，将 ESP 下移，f 函数对应的栈顶空间被回收；
// 然后，执行完 func，ESP 下移，func 对应的空间被回收；
```

<img src="/Image/Chromium/500.png" style="zoom:30%;" align="left"/>



#### 3-3、堆内存数据回收管理

<img src="/Image/Chromium/702.png" style="zoom:30%;" align="left"/>

V8 的垃圾回收策略主要基于分代式垃圾回收机制，V8 引擎对堆内存中的 JS 对象进行了分代管理：**新生代**、 **老生代**，并根据不同种类的堆内存，采用不同的回收策略，来根据不同的场景做针对性的优化：

- 新生代内存：临时分配的内存，存活时间短的对象；如字符串、临时变量；
- 老生代内存：常驻内存，存活时间长的对象或常驻内存对象；如主控制器、服务器对象；
- 注意：V8 堆的整体大小=新生代所用内存空间+老生代的内存空间，且只能在启动时指定，即运行时无法自动扩充，若超过了极限值，就会引起进程出错；
- 注意：新生区通常只支持 1～8M 的容量，远小于老生区支持容量；对于两个区域，V8 分别使用两个不同的垃圾回收器，以便更高效地实施垃圾回收：
  - 副垃圾回收器，主要负责新生代的垃圾回收；
  - 主垃圾回收器，主要负责老生代的垃圾回收；
- 注意：不论什么类型的垃圾回收器，都有一套共同的执行流程：
  - 首先，标记空间中活动对象和非活动对象；前者即尚在使用的对象，后者即可进行垃圾回收的对象；
  - 然后，回收非活动对象所占据的内存；其实就是在所有的标记完成之后，统一清理内存中所有被标记为可回收的对象；
  - 最后，做内存整理：一般来说，频繁回收对象后，内存中就会存在大量不连续空间(内存碎片)，当内存中出现了大量的内存碎片之后，若需要分配较大连续内存的时候，就有可能出现内存不足的情况；所以最后一步需要整理这些内存碎片；(实际可选，因为有的垃圾回收器不会产生内存碎片)；



#### 3-4、新生代内存回收算法—Scavenge 算法

##### 3-4-1、Scavenge 算法回收流程

<img src="/Image/Chromium/501.png" style="zoom:50%;" align="left"/>

<img src="/Image/Chromium/505.png" style="zoom:30%;" align="left"/>

<img src="/Image/Chromium/703.png" style="zoom:30%;" align="left"/>

首先，在 Scavenge 具体实现中，主要采用了一种复制的方式的方法—— Cheney 算法，此算法将新生代内存空间一分为二：处于使用状态的 From 部分，为 <u>对象区域</u>，表示正在使用的内存，处于闲置状态的 To 部分 为 <u>空闲区域</u>，是目前闲置的内存；

- 注意：分配对象时，先是在 From 空间中进行分配；

- 注意：新加入的对象都会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作；
- 注意：在垃圾回收过程中，首先要对对象区域中的垃圾做标记，标记完成之后，才进入垃圾清理阶段；

然后，当进行垃圾回收时，V8 将 From 部分的对象检查一遍，

- 若是存活对象，副垃圾回收器会把这些存活的对象复制到空闲区域 To，同时将这些对象有序地排列(即同时完成了内存整理操作)

- 若是非存活对象则直接回收；

然后，当所有 From 中的存活对象按照顺序进入 To 内存后，From 和 To 两者的角色<u>翻转</u>，即 From 现在被闲置，To 被使用，完成回收操作，如此循环；

- 注意：这种角色翻转操作，还能让新生代中的这两块区域无限重复使用下去；

不足：内存只能使用新生代内存的一半，但只存放生命周期短的对象，这种对象 `一般很少`，因此`时间`性能非常优秀；

优化：为提升执行效率，一般新生区空间会被设置得较小，故也容易被存活对象装满整个区域，为了解决此问题，JS 引擎采用了`对象晋升策略`：

- 已历过一次 Scavenge 回收：当一对象经过多次复制后依然存活，其将会被认为是生命周期较长的对象，随后会被移动到老生代中，采用新的算法进行管理；
- To (闲置) 空间的内存占用超过25%：若复制一个对象到 To 空间时，To 空间占用超过了 25%，则这个对象会被直接晋升到老生代空间中；



##### 3-4-2、内存碎片处理策略

为解决存活对象的空间不连续对后续的空间分配造成障碍，To 内存按照一定顺序放置，以解决内存碎片问题：

- 比如：深色方块代表存活对象，白色部分表示待分配内存，因堆内存是连续分配，但零散的空间(内存碎片)会导致稍大对象无法进行空间分配；

- 注意：堆包含一个链表来维护已用和空闲的内存块。在堆上新分配(用 new 或者 malloc)内存是从空闲的内存块中找到一些满足要求的合适块，就须要一整块连续的内存空间才能申请成功；



<img src="/Image/Chromium/502.png" style="zoom:50%;" align="left"/>

<img src="/Image/Chromium/503.png" style="zoom:50%;" align="left"/>



#### 3-5、旧生代内存回收—Mark-Sweep 算法

对于老生代中的对象，主要采用标记-清除和标记-整理算法；

标记-清除 和前文提到的标记一样，与 Scavenge 算法相比，标记清除不会将内存空间划为两半，标记清除在标记阶段会标记活着的对象，而在内存回收阶段，它会清除没有被标记的对象；而标记整理是为了解决标记清除后留下的内存碎片问题；

##### 3-5-1、Mark-Sweep 算法回收流程

<img src="/Image/Chromium/506.png" style="zoom:30%;" align="left"/>

首先，`标记阶段` 会遍历堆中所有对象，并做上标记；然后取消代码环境中 `使用的变量` 以及被 `强引用` 的变量的标记；

- 注意：标记阶段从一组根元素开始，递归遍历这组根元素(遍历调用栈)，在遍历过程中，能到达的元素称为 <u>活动对象</u>，否则可判断为 <u>垃圾数据</u>；

然后，`清除阶段` 对标记变量进行空间回收；

然后，整理内存碎片，将存活的对象全部往一端靠拢(最耗时)；

- 注意：清除算法后，会产生大量不连续的内存碎片，而碎片过多会导致大对象无法分配到足够的连续内存，于是又产生了 <u>标记—整理(Mark-Compact) 算法</u>，其标记过程仍然与 Mark-Sweep 一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存，从而让存活对象占用连续的内存块；

不足：内存碎片最耗时；



##### 3-5-2、内存碎片处理策略

为解决存活对象的空间不连续对后续的空间分配造成障碍，将存活的对象全部往一端靠拢，以解决内存碎片问题；

<img src="/Image/Chromium/504.png" style="zoom:50%;" align="left"/>



##### 3-5-3、算法比较

<img src="/Image/Chromium/507.png" style="zoom:50%;" align="left"/>



#### 3-6、增量标记—Incremental Marking 算法

<img src="/Image/Chromium/704.png" style="zoom:50%;" align="left"/>

前面的三种算法，均需将正在执行的 JS 应用逻辑暂停下来，待垃圾回收完毕后再恢复，这种行为叫作"全停顿"(stop-the-world)；

在 V8 新生代的分代回收中，只收集新生代，而新生代通常配置较小，且存活对象较少，所以全停顿的影响不大，而老生代则相反；

为降低全部老生代全堆垃圾回收带来的停顿时间，V8 将标记过程分为一个个的子标记过程，同时让垃圾回收标记和JS应用逻辑交替进行，直到标记阶段完成；

补充：

V8 在进行垃圾回收时，由于 JS 单线程机制，不可避免地会阻塞业务逻辑执行(<u>全停顿</u>)；在 V8 新生代的垃圾回收中，因其空间较小，且存活对象较少，故全停顿影响不大，但老生代则不同，为了降低老生代的垃圾回收而造成的卡顿，V8 采取 **<u>增量标记(Incremental Marking)算法</u>** ：

将标记过程分为一个个的子标记过程，同时让垃圾回收标记和 JS 应用逻辑交替进行，直到标记阶段完成，才进入内存碎片的整理；

- 使用增量标记算法，可将一完整的垃圾回收任务拆分为很多小的任务，而小任务执行时间较短，可穿插在其他的 JS 任务中间执行，如此当执行某些动画效果时，就不会让用户因为垃圾回收任务而感受到页面的卡顿；使得垃圾回收过程对 JS 应用的阻塞时间减少为原来的 1 / 6；





#### 3-7、内存泄露—Memory Leak

不再用到的内存，没有及时释放，就叫做内存泄漏；补充：指程序中己动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果；



##### 3-7-1、内存泄露原因

- 意外的**全局变量**: 无法被回收
- **定时器**: 未被正确关闭，导致所引用的外部变量无法被释放
- **闭包**: 会导致父级中的变量无法被释放；
- **事件监听**: 没有正确销毁 (低版本浏览器可能出现)
- **dom 引用**: dom 元素被删除时，内存中的引用未被正确清空

- 缓存：缓存须有存储容量上限，否则高内存消耗将会导致缓存突破上限，而缓存内容无法被回收；

- 队列消费不及时：当浏览器队列消费不及时时，会导致一些作用域变量得不到及时的释放，因而导致内存泄漏；

- 全局变量：意外导致的全局变量，如：

```js
function foo(arg) {
	// 由于 this 使用不当导致的全局变量
	this.bar = "this is a hidden global variable"
	// 没有使用 var/let/const 定义变量导致全局变量
  bar = "this is a hidden global variable";
}
```

- 计时器中引用没有清除

```
var someData = getData();
setInterval(function() {
    var node = document.getElementById('Node');
    if(node) node.innerHTML = JSON.stringify(someData));
}, 1000);
// Node 节点被删除后，会导致计时器中的回调函数无法被回收，同时，someData 数据也是无法被回收的；
```

- 闭包

```js
var theThing = null;
var replaceThing = function () {
  var originalThing = theThing;
  // 变量 unused 是一个引用 originalThing(theThing) 的闭包，闭包的作用域一旦创建，便有同样的父级作用域，作用域是共享的
  var unused = function () {
    if (originalThing)
      console.log("hi");
  };
  theThing = {
    longStr: new Array(1000000).join('*'),
    // someMethod 可通过 theThing 使用，someMethod 与 unused 分享闭包作用域
    // 尽管 unused 从未使用，它引用的 originalThing 迫使它保留在内存中
    someMethod: function () {
      console.log(someMessage);
    }
  };
};
setInterval(replaceThing, 1000);
// 每次调用 replaceThing ，theThing 会创建一个大数组和一个新闭包(someMethod)的新对象
// 闭包的链表已创建，每一个闭包作用域携带一个指向大数组的间接的引用，造成严重的内存泄漏
```

- 事件监听：
  - 比如：Node.js 中 Agent 的 keepAlive 为 true 时，可能造成的内存泄漏；
  - 因为：当 Agent keepAlive 为 true 时，将会复用之前使用过的 socket，若在 socket 上添加事件监听而忘记清除的话，因为 socket 的复用，将导致事件重复监听从而产生内存泄漏；
  
- Dom 引用

  - <img src="/Image/Chromium/99.png" style="zoom:50%;" align="left"/>

  - 应当增加：element = null

  - ```js
    // 例子2
    var element = document.getElementById('element')
    element.innerHTML = '<button id="button">点击</button>'
    
    var button = document.getElementById('button')
    button.addEventListener('click', function() {
        // ...
    })
    
    element.innerHTML = ''
    // 代码执行后，因 element.innerHTML = ''，button 元素已从 DOM 中移除了，但由于其事件处理句柄还在，所以依然无法被垃圾回收；还需增加 removeEventListener
    ```

    



##### 3-7-2、[内存泄露识别](https://juejin.im/post/5db2beb8e51d455b450a64b4#heading-8)

用 chrome 中的 timeline 进行内存标记，可视化查看内存的变化情况，找出异常点；



##### 3-7-3、内存泄露避免

- 避免使用全局变量，避免意外产生全局变量；
- 使用闭包要及时注意，有 DOM 元素的引用要及时清理;
- 计时器里的回调没用时要记得销毁；
- 为避免疏忽导致的遗忘，可使用 `WeakSet` 和 `WeakMap` 结构，它们对于值的引用都是不计入垃圾回收机制的，表示这是弱引用：

```js
// 基本上，如果你要往对象上添加数据，又不想干扰垃圾回收机制，就可以使用 WeakMap
const wm = new WeakMap();
const element = document.getElementById('example');

// 一旦消除对该节点的引用，它占用的内存就会被垃圾回收机制释放, Weakmap 保存的这个键值对，也会自动消失
wm.set(element, 'some information');
wm.get(element) // "some information"
```



#### 3-X、V8 优化

JS 问题：

- **动态类型**：导致每次存取属性/寻求方法时，都需要先检查类型；此外动态类型也很难在编译阶段进行优化；
- **属性存取**：C++/Java等语言中方法、属性是存储在数组中的，仅需数组位移就可以获取，而 JS 存储在对象中，每次获取都要进行哈希查询；

V8 优化：

- **优化 JIT (即时编译)**：相较于C++/Java这类编译型语言，JS 边解释边执行，效率低；
  - V8 对此过程进行了优化：若一段代码被执行多次，则将此段代码转化为机器码缓存下来，下次运行时直接使用机器码；
- **隐藏类**：C++ 这类语言仅需几个指令就能通过偏移量获取变量信息，而 JS 需要进行字符串匹配，效率低下；
  - V8 借用类和偏移位置的思想，将对象划分成不同的组，即隐藏类；
- **内嵌缓存**：即缓存对象查询的结果；常规查询过程是：获取隐藏类地址 -> 根据属性名查找偏移值 -> 计算该属性地址，内嵌缓存就是对这一过程结果的缓存；
- **垃圾回收**：前文已介绍；