---
typora-root-url: ../Source
---



### 一、V8 JS 数据存储

基本数据类型用 **<u>栈</u>** 存储，引用数据类型用 **<u>堆</u>**  存储

- boolean、null、undefined、number、string、symbol、bigint

- 注意：对于赋值操作，原始类型的数据直接完整地赋值变量值，对象数据类型的数据则是复制引用地址；
- 注意：栈的功能除了保存变量外，还有创建并切换函数执行上下文的功能；当栈指针 ESP 下移，即上下文切换后，栈顶的空间会自动被回收；

```js
function f(a) {
  console.log(a);
}
function func(a) {
  f(a);
}
func(1);

// 首先，调用 func, 将 func 函数的上下文压栈，ESP 指向栈顶；
// 然后，执行 func，又调用 f 函数，将 f 函数的上下文压栈，ESP 指针上移；
// 然后，执行完 f 函数，将 ESP 下移，f 函数对应的栈顶空间被回收；
// 然后，执行完 func，ESP 下移，func 对应的空间被回收；
```

<img src="/Image/Chromium/500.png" style="zoom:40%;" align="left"/>

此外，可观察到，若采用栈来存储相对基本类型更加复杂的对象数据，则切换上下文的开销将变得巨大；



### 二、V8 JS 运行机制

#### 2-1、Make—执行代码

<img src="/Image/Chromium/600.png" style="zoom:40%;" align="left"/>

机器读不懂 JS 代码，机器只能理解特定的机器码；而 JS 属于解释型语言，需要先用解释器会对源代码进行解释转换；

- **预解析**：检查语法错误；
- **生成 AST**：经过词法分析/语法分析，生成  **<u>AST 抽象语法树</u>**；
- **生成字节码**：**<u>基线编译器 (Ignition)</u>** 将 AST 转换成 **<u>字节码</u>**；
- **生成机器码**：**<u>优化编译器 (Turbofan)</u>** 将字节码转换成优化过的 **<u>机器码</u>**，此外在逐行执行字节码的过程中，若某段代码经常被执行， V8 会将这段代码直接转换成机器码保存起来，下一次执行就不必经过字节码转换阶段，优化执行速度；
- **执行代码**；



##### 2-1-1、预解析

##### 2-1-2、生成 AST

生成 AST 分为两步：词法分析和语法分析：

- 词法分析：即分词，将一行行的代码分解成一个个 token；
- 语法分析：将生成的 token 数据，根据一定的语法规则转化为 AST；

注意：生成了 AST 后，编译器/解释器后续的工作都将依靠 AST 而非源代码；

注意：babel 工作原理即将 ES5 的代码解析生成 <u>ES5 的 AST</u>，然后将 ES5 的 AST 转换为 <u>ES6 的 AST</u>，最后才将 ES6 的 AST 转化为具体的 ES6 代码；





##### 2-1-3、生成字节码

生成 AST 之后，通过 V8 **<u>基线解释器(Ignition)</u>** 生成字节码；

- 子节码：是介于 AST 和 机器码间的代码，但与特定类型的机器码无关，字节码需要通过解释器将其转换为机器码然后执行；
- 注意：V8 早期是直接转为机器码，但体积太大，会有严重内存占用问题；后来通过解释器逐行执行字节码，省去了生成二进制文件的操作，减少内存压力；





##### 2-1-4、生成机器码

生成字节码后，通过 **<u>优化编译器 (Turbofan)</u>** 将字节码编译成优化过的 **<u>机器码</u>**；

注意：在逐行执行字节码的过程中，若 Turbofan 发现某段代码经常被执行， 则 V8 会将这段代码标记为 <u>热点代码(HotSpot)</u>，并将这段代码直接转换成机器码保存起来，下一次执行就不必经过字节码转换阶段，以优化执行速度；如此执行时间越久，执行效率越高；

注意：JS 并非纯粹的解释器语言，因为字节码不仅配合解释器，还有编译器的参与，而<u>两者根本区别</u>在于：前者会编译生成二进制文件，但后者不会；此外，这种字节码跟编译器、解释器结合的技术，称为 **<u>即时编译(JIT)</u>**；

<img src="/Image/Chromium/601.png" style="zoom:50%;" align="left"/>



##### 2-1-5、执行代码









#### 2-2、Context—执行上下文

https://juejin.im/post/5e572a34518825490f722b9e#heading-12

#### 2-3、Call Stack —调用栈

https://juejin.im/post/5e572a34518825490f722b9e#heading-12

#### 2-4、Event Loop—事件循环机制

https://juejin.im/post/5e572a34518825490f722b9e#heading-12





### 三、V8 垃圾回收机制

**新生代内存**：用于存活较短的对象；

- 可再分成两个空间：from 空间 与 to 空间；
- Scavenge GC 算法：当 from 空间被占满时启动 GC；
  - 存活的对象从 from space 按一定顺序转移到 to space；
  - 清空 from space；
  - from space 与 to space 互换，完成 GC；
  - 以上过程不断循环；

**老生代内存**：用于存活时间较长的对象；

- 从 新生代 转移到 老生代 的条件：
  - 经历过一次以上 Scavenge GC 的对象；
  - 当 to space 体积超过 25%；
- Mark-Sweep GC 算法：标记存活的对象，未被标记的则被释放；
- Mark-Compact 整理算法：将内存中清除后导致的碎片化对象往内存堆的一端移动；

**增量标记**：小模块标记，在代码执行间隙执行，缓解因 GC 的阻塞现象；

**并发标记**(最新技术)：不阻塞 JS 执行；



#### 3-1、V8内存限制与回收策略

V8 只能使用系统的一部分内存，比如在 64 位系统最多只能分配 1.4G，32 位系统最多只能分配 0.7G；而之所以这样限制，是因为：

- JS 是单线程的执行机制：一旦进入到垃圾回收，其它的各种运行逻辑都要暂停；
- JS垃圾回收机制的限制：垃圾回收过程非常耗时间；

<u>与其代码执行会一直没有响应，造成应用卡顿，所以还不如直接限制内存</u>；但注意某些场景还是可以提高内存限制的：

```js
// 调整老生代这部分的内存，单位是 MB
node --max-old-space-size=2048
```

```js
// 调整新生代这部分的内存，单位是 KB
node --max-new-space-size=2048
```



##### 3-1-1、突破限制实际案例

Angular：打包项目的时候就遇到过频繁报内存溢出：`FATAL ERROR: CALL_AND_RETRY_LAST Allocation failed - process out of memory`

解决：修改项目根目录  `node_modeles` 文件夹、`.bin` 目录、`ng`的文件首行：`#!/usr/bin/env node --max_old_space_size=4096`

VueReact：[详看](https://blog.csdn.net/qq_35624642/article/details/81084331)



##### 3-1-2、回收策略

通常情况下，垃圾数据回收分为 <u>手动回收</u> 和 <u>自动回收</u> 两种策略：

- **手动回收策略**：何时分配内存、何时销毁内存都是由代码控制的；
- **自动回收策略**：产生的垃圾数据是由垃圾回收器来释放的，并不需要手动通过代码来释放；



##### 3-1-3、引用计数与标记清除

- **引用计数**：给一个变量赋值引用类型，则该对象的引用次数 +1，若此变量变成了其他值，则该对象的引用次数-1，垃圾回收器会回收引用次数为 0 的对象；但当对象循环引用时，会导致引用次数永远无法归零，导致内存无法释放；
- **标记清除**：垃圾收集器先给内存中所有对象加上标记，然后从根节点开始遍历，去掉被引用的对象和运行环境中对象的标记，剩下的被标记的对象即无法访问的、等待回收的对象；




#### 3-2、栈内存数据回收管理

引擎会通过向下移动 ESP (记录当前执行状态的指针) 来销毁该函数保存在栈中的执行上下文；

栈的功能除了保存变量外，还有创建并切换函数执行上下文的功能；当栈指针 ESP 下移，即上下文切换后，栈顶的空间会自动被回收；

```js
function f(a) {
  console.log(a);
}
function func(a) {
  f(a);
}
func(1);

// 首先，调用 func, 将 func 函数的上下文压栈，ESP 指向栈顶；
// 然后，执行 func，又调用 f 函数，将 f 函数的上下文压栈，ESP 指针上移；
// 然后，执行完 f 函数，将 ESP 下移，f 函数对应的栈顶空间被回收；
// 然后，执行完 func，ESP 下移，func 对应的空间被回收；
```

<img src="/Image/Chromium/500.png" style="zoom:30%;" align="left"/>



#### 3-3、堆内存数据回收管理

V8 引擎对堆内存中的 JS 对象进行了分代管理：**新生代**、 **老生代**，并根据不同种类的堆内存，采用不同的回收策略，来根据不同的场景做针对性的优化：

- 新生代内存：临时分配的内存，存活时间短；如字符串、临时变量；
- 老生代内存：常驻内存，存活时间长；如主控制器、服务器对象；
- 注意：新生区通常只支持 1～8M 的容量，远小于老生区支持容量；对于两个区域，V8 分别使用两个不同的垃圾回收器，以便更高效地实施垃圾回收：
  - 副垃圾回收器，主要负责新生代的垃圾回收；
  - 主垃圾回收器，主要负责老生代的垃圾回收；
- 注意：不论什么类型的垃圾回收器，都有一套共同的执行流程：
  - 首先，标记空间中活动对象和非活动对象；前者即尚在使用的对象，后者即可进行垃圾回收的对象；
  - 然后，回收非活动对象所占据的内存；其实就是在所有的标记完成之后，统一清理内存中所有被标记为可回收的对象；
  - 最后，做内存整理：一般来说，频繁回收对象后，内存中就会存在大量不连续空间(内存碎片)，当内存中出现了大量的内存碎片之后，若需要分配较大连续内存的时候，就有可能出现内存不足的情况；所以最后一步需要整理这些内存碎片；(实际可选，因为有的垃圾回收器不会产生内存碎片)；



#### 3-4、新生代内存回收算法—Scavenge 算法

##### 3-4-1、Scavenge 算法回收流程

<img src="/Image/Chromium/501.png" style="zoom:50%;" align="left"/>

<img src="/Image/Chromium/505.png" style="zoom:30%;" align="left"/>

首先，将新生代内存空间一分为二：From 部分，为 <u>对象区域</u>，表示正在使用的内存，To  为 <u>空闲区域</u>，是目前闲置的内存；

- 注意：新加入的对象都会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作；
- 注意：在垃圾回收过程中，首先要对对象区域中的垃圾做标记，标记完成之后，才进入垃圾清理阶段；

然后，当进行垃圾回收时，V8 将 From 部分的对象检查一遍，

- 若是存活对象，副垃圾回收器会把这些存活的对象复制到空闲区域 To，同时将这些对象有序地排列(即同时完成了内存整理操作)

- 若是非存活对象则直接回收；

然后，当所有 From 中的存活对象按照顺序进入 To 内存后，From 和 To 两者的角色<u>翻转</u>，即 From 现在被闲置，To 被使用，完成回收操作，如此循环；

- 注意：这种角色翻转操作，还能让新生代中的这两块区域无限重复使用下去；

不足：内存只能使用新生代内存的一半，但只存放生命周期短的对象，这种对象 `一般很少`，因此`时间`性能非常优秀；

优化：为提升执行效率，一般新生区空间会被设置得较小，故也容易被存活对象装满整个区域，为了解决此问题，JS 引擎采用了`对象晋升策略`：

- 已经历过一次 Scavenge 回收；
- To (闲置) 空间的内存占用超过25%；



##### 3-4-2、内存碎片处理策略

为解决存活对象的空间不连续对后续的空间分配造成障碍，To 内存按照一定顺序放置，以解决内存碎片问题：

- 比如：深色方块代表存活对象，白色部分表示待分配内存，因堆内存是连续分配，但零散的空间(内存碎片)会导致稍大对象无法进行空间分配；

- 注意：堆包含一个链表来维护已用和空闲的内存块。在堆上新分配（用 new 或者 malloc）内存是从空闲的内存块中找到一些满足要求的合适块，就须要一整块连续的内存空间才能申请成功；



<img src="/Image/Chromium/502.png" style="zoom:50%;" align="left"/>

<img src="/Image/Chromium/503.png" style="zoom:50%;" align="left"/>



#### 3-5、旧生代内存回收—Mark-Sweep 算法

##### 3-5-1、Mark-Sweep 算法回收流程

<img src="/Image/Chromium/506.png" style="zoom:30%;" align="left"/>

首先，`标记阶段` 会遍历堆中所有对象，并做上标记；然后取消代码环境中 `使用的变量` 以及被 `强引用` 的变量的标记；

- 注意：标记阶段从一组根元素开始，递归遍历这组根元素(遍历调用栈)，在遍历过程中，能到达的元素称为 <u>活动对象</u>，否则可判断为 <u>垃圾数据</u>；

然后，`清除阶段` 对标记变量进行空间回收；

然后，整理内存碎片，将存活的对象全部往一端靠拢(最耗时)；

- 注意：清除算法后，会产生大量不连续的内存碎片，而碎片过多会导致大对象无法分配到足够的连续内存，于是又产生了 <u>标记—整理(Mark-Compact) 算法</u>，其标记过程仍然与 Mark-Sweep 一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存，从而让存活对象占用连续的内存块；

不足：内存碎片最耗时；



##### 3-5-2、内存碎片处理策略

为解决存活对象的空间不连续对后续的空间分配造成障碍，将存活的对象全部往一端靠拢，以解决内存碎片问题；

<img src="/Image/Chromium/504.png" style="zoom:50%;" align="left"/>



##### 3-5-3、算法比较

<img src="/Image/Chromium/507.png" style="zoom:50%;" align="left"/>



#### 3-6、增量标记—Incremental Marking 算法

V8 在进行垃圾回收时，由于 JS 单线程机制，不可避免地会阻塞业务逻辑执行(<u>全停顿</u>)；在 V8 新生代的垃圾回收中，因其空间较小，且存活对象较少，故全停顿影响不大，但老生代则不同，为了降低老生代的垃圾回收而造成的卡顿，V8 采取 **<u>增量标记(Incremental Marking)算法</u>** ：

将标记过程分为一个个的子标记过程，同时让垃圾回收标记和 JS 应用逻辑交替进行，直到标记阶段完成，才进入内存碎片的整理；

使用增量标记算法，可将一完整的垃圾回收任务拆分为很多小的任务，而小任务执行时间较短，可穿插在其他的 JS 任务中间执行，如此当执行某些动画效果时，就不会让用户因为垃圾回收任务而感受到页面的卡顿；使得垃圾回收过程对 JS 应用的阻塞时间减少为原来的 1 / 6；




#### 3-7、内存泄露—Memory Leak

不再用到的内存，没有及时释放，就叫做内存泄漏；

##### 3-7-1、内存泄露原因

- 意外的**全局变量**: 无法被回收
- **定时器**: 未被正确关闭，导致所引用的外部变量无法被释放
- **事件监听**: 没有正确销毁 (低版本浏览器可能出现)
- **闭包**: 会导致父级中的变量无法被释放
- **dom 引用**: dom 元素被删除时，内存中的引用未被正确清空



- 缓存：缓存须有存储容量上限，否则高内存消耗将会导致缓存突破上限，而缓存内容无法被回收；

- 队列消费不及时：当浏览器队列消费不及时时，会导致一些作用域变量得不到及时的释放，因而导致内存泄漏；

- 全局变量：意外导致的全局变量，如：

```js
function foo(arg) {
	// 由于 this 使用不当导致的全局变量
	this.bar = "this is a hidden global variable"
	// 没有使用 var/let/const 定义变量导致全局变量
  bar = "this is a hidden global variable";
}
```

- 计时器中引用没有清除

```
var someData = getData();
setInterval(function() {
    var node = document.getElementById('Node');
    if(node) node.innerHTML = JSON.stringify(someData));
}, 1000);
// Node 节点被删除后，会导致计时器中的回调函数无法被回收，同时，someData 数据也是无法被回收的；
```

- 闭包

```js
var theThing = null;
var replaceThing = function () {
  var originalThing = theThing;
  // 变量 unused 是一个引用 originalThing(theThing) 的闭包，闭包的作用域一旦创建，便有同样的父级作用域，作用域是共享的
  var unused = function () {
    if (originalThing)
      console.log("hi");
  };
  theThing = {
    longStr: new Array(1000000).join('*'),
    // someMethod 可通过 theThing 使用，someMethod 与 unused 分享闭包作用域
    // 尽管 unused 从未使用，它引用的 originalThing 迫使它保留在内存中
    someMethod: function () {
      console.log(someMessage);
    }
  };
};
setInterval(replaceThing, 1000);
// 每次调用 replaceThing ，theThing 会创建一个大数组和一个新闭包（someMethod）的新对象
// 闭包的链表已创建，每一个闭包作用域携带一个指向大数组的间接的引用，造成严重的内存泄漏
```

- 事件监听：
  - 比如：Node.js 中 Agent 的 keepAlive 为 true 时，可能造成的内存泄漏；
  - 因为：当 Agent keepAlive 为 true 时，将会复用之前使用过的 socket，若在 socket 上添加事件监听而忘记清除的话，因为 socket 的复用，将导致事件重复监听从而产生内存泄漏；



##### 3-7-2、[内存泄露识别](https://juejin.im/post/5db2beb8e51d455b450a64b4#heading-8)

用 chrome 中的 timeline 进行内存标记，可视化查看内存的变化情况，找出异常点；



##### 3-7-3、内存泄露避免

- 避免使用全局变量，避免意外产生全局变量；
- 使用闭包要及时注意，有 DOM 元素的引用要及时清理;
- 计时器里的回调没用时要记得销毁；
- 为避免疏忽导致的遗忘，可使用 `WeakSet` 和 `WeakMap` 结构，它们对于值的引用都是不计入垃圾回收机制的，表示这是弱引用：

```js
// 基本上，如果你要往对象上添加数据，又不想干扰垃圾回收机制，就可以使用 WeakMap
const wm = new WeakMap();
const element = document.getElementById('example');

// 一旦消除对该节点的引用，它占用的内存就会被垃圾回收机制释放, Weakmap 保存的这个键值对，也会自动消失
wm.set(element, 'some information');
wm.get(element) // "some information"
```



#### 3-X、V8 优化

JS 问题：

- **动态类型**：导致每次存取属性/寻求方法时，都需要先检查类型；此外动态类型也很难在编译阶段进行优化；
- **属性存取**：C++/Java等语言中方法、属性是存储在数组中的，仅需数组位移就可以获取，而 JS 存储在对象中，每次获取都要进行哈希查询；

V8 优化：

- **优化 JIT (即时编译)**：相较于C++/Java这类编译型语言，JS 边解释边执行，效率低；
  - V8 对此过程进行了优化：若一段代码被执行多次，则将此段代码转化为机器码缓存下来，下次运行时直接使用机器码；
- **隐藏类**：C++ 这类语言仅需几个指令就能通过偏移量获取变量信息，而 JS 需要进行字符串匹配，效率低下；
  - V8 借用类和偏移位置的思想，将对象划分成不同的组，即隐藏类；
- **内嵌缓存**：即缓存对象查询的结果；常规查询过程是：获取隐藏类地址 -> 根据属性名查找偏移值 -> 计算该属性地址，内嵌缓存就是对这一过程结果的缓存；
- **垃圾回收**：前文已介绍；