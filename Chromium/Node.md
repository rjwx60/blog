---
typora-root-url: ../Source
---



### 关键词 & 路线：翻墙文章 How Node work internally + 书

https://medium.com/@sahityakumarsuman/how-nodejs-works-internally-6cf508e61548

[https://stackoverflow.com/questions/9497076/how-node-js-works#:~:text=Node%20JS%20applications%20uses%20single,accommodate%20the%20main%20event%20loop.](https://stackoverflow.com/questions/9497076/how-node-js-works#:~:text=Node JS applications uses single,accommodate the main event loop.)







### 一、基本

#### 1-1、诞生

​	缘由：其他语言存在各种问题，诸如开发门槛高、包含很多阻塞 I/O 库、性能缺陷，而 JS 无后端历史包袱、符合事件驱动、V8高性能、无压导入非阻塞 I/O 库；

​	诞生：09年3月 RyanDahl，基于 V8 引擎，轻量级 Web 服务器，12年1月转由 Isaac Z. Schlueter 接手；因目的为构建大型网络应用，而每一 Node 进程均参与构成此网络应用的节点，故取名 Node；相比于 Chrome，缺少 Webkit 布局引擎、Html 层、显卡支持等，但支持访问本地文件，基于事件驱动的异步架构；此外还有 node-webkit 项目，其将 Node 与 Webkit 的事件循环相融合，使得既可 UI 构建，又可访问本地资源，实现桌面开发；总结即Node 是 JS 在服务端的运行环境，构建在 chrome 的 V8 引擎之上；



#### 1-2、特点

1.异步非阻塞 IO：底层拥有大量异步 IO(从文件读取到网络请求)，可实现并行 IO 操作，并拥有提升效率方式；

2.事件编程：轻量级、轻耦合，只关注事务，回调通知机制，有回调问题但可通过 Promise 改善，程序无需阻塞等待结果返回，原因同步模式等待的时间则可来处理其它任务；

3.单线程：无状态同步问题，无死锁，无线程上下文交换导致的性能开销，但也无法利用多核、缺乏健壮性、执行时间长也会导致线程阻塞，但可通过 child_process 子进程改善；

4.跨平台：通过 libuv (操作系统与 Node 上层模块间的平台架构层)，兼容统一多平台接口；

- 注意：Nginx 也是采用事件驱动机制，其避免多线程的线程创建、线程上下文切换的开销；但 Nginx 采用 C 语言编写，主用于高性能 Web 服务器，不适合业务开发；
- 注意：虽单线程模型，但 Node 基于事件驱动和异步非阻塞模式，可用于高并发场景，避免线程创建、线程间上下文切换产生资源开销；
- 注意：实际上，应结合场景，单核 CPU 系统上，可采用单进程 + 单线程 模式开发；多核则可采用多进程 + 单线程模式开发；
  - 补充：进程：系统进行资源分配和调度的基本单位；计算机中程序关于某数据集合上的一次运行活动，线程的容器，是操作系统结构的基础，每当启动一个服务、运行一个实例即开辟一个服务进程；比如 JVM、node app.js；多进程即进程复制，复制出的每个进程均拥有独立空间地址、数据栈等资源；此时 A 进程无法访问 B 进程中定义的变量、数据结构，只有建立 IPC 通信，进程间才可进行数据通信与共享；
  - 补充：线程：操作系统能够进行运算调度的最小单位；隶属于进程，被包含于进程中，一线程只能隶属于一进程，但1进程可拥有多个线程；单线程即一进程只开一线程；
- 注意：开启多进程并非解决高并发，而主要解决单进程模式下 CPU 利用率不足情况以充分利用多核性能；

- - 使用：通过 child_process.fork 开启多进程 (Node 在 v0.8 版本后新增 Cluster 实现多进程架构)；

- 注意：Node 开发过程中，错误会引起整个应用退出，故需考虑应用健壮性(异常抛出、进程守护等)；
- 注意：单线程无法利用多核 CPU，但后来 Node 提供相应 API 以及三方工具以解决；



#### 1-3、场景

IO 密集型：

- 优势：利用事件驱动，而非启动线程为每一请求服务，资源占用极少；
- 优势：异步非阻塞IO，极好解决单线程上，CPU 与 IO 间阻塞无法重叠问题，IO 阻塞造成的性能浪费远比 CPU 影响要小；

CPU 密集型：

- 劣势：执行时间长的计算，将导致 CPU 时间片不能释放，导致无法发起后续 IO；
- 解决1：可适当调整/分解大型计算任务为小任务(时间分片??)，使运算及时释放；
- 解决2：可编写 C/C++ 扩展，以高效地利用 CPU，实现某些 V8 自身难以实现的需求；
- 解决3：倘若单线程 Node、C/C++ 扩展均无法满足需求，还可将部分 Node 进程当做常驻服务用于计算，然后利用进程间消息传递结果，将计算与IO分离，充分利用多核 CPU；



### 二、运作机制

### 三、模块机制

#### 3-1、基本：Node 借鉴 CommonJS 的 Modules 规范实现自身模块系统；

#### 3-2、分类

3-2-1、核心模块：

- 描述：由 Node 自身提供，其在源码编译时即被编译进二进制执行文件，当进程启动时便被直接加载进内存；
- 注意：因上述原因，此类模块的引入/文件定位/编译执行步骤均可忽略，而在路径分析中，其优先级更高，加载速度也更快；

3-2-2、文件模块：用户提供的，运行时加载的，速度比核心慢，需经过3阶段：路径分析、文件定位、编译执行；

3-2-3、模块异同：

- 相同：引入的模块均会进行缓存(缓存内容：编译 & 执行后的对象)，以减少二次引入时的开销；
- 不同：
  - 缓存检查优先度中，核心模块依然优先于文件模块；
  - 文件模块无须将源代码编译进 Node，而是通过 `dlopen` 方法动态加载；
  - 文件模块在编写时无须将源代码写入 Node 命名空间，也无需提供头文件；



#### 3-3、路径分析

3-3-1、描述

模块标识符分析(require() 中的标识符参数分析)，基于此标识符进行模块查找；等同npm包路径分析；

- 核心模块：http、fs、path 等；

- - 首先，路径优先级最高，其次是缓存；
  - 其次，无需定位、无需编译，直接使用；

- 文件模块：以点开始的相对路径文件模块 & 以斜杠开始的绝对路径文件模块；

- - 首先，`require` 会将其转为真实路径，并以此作为索引；
  - 然后，根据模块路径查找策略定位文件，并进行编译；
  - 随后，将编译后的执行结果存放在缓存，以便二次加载更快；

- 自定模块：非路径形式的文件模块，形式为文件/包，比如自定义 connect 模块；

- - 首先，根据模块路径查找策略定位文件；
  - 注意：自定义模块均在文件最外层，故加载速度最慢 (除非写在当前文件的 `node_modules` 中..)；



3-3-2、路径形式

模块路径具体表现为由路径组成的数组；

- 生成方式：创建任意 JS 文件，内容为 `console.log(module.paths)`，然后 `node 目标文件.js` 即可输出；



3-3-3、模块查找策略

加载过程中，Node 会逐个尝试模块路径中的路径，直到找到目标文件为止，路径越深，模块查找耗时越多；

- 搜寻当前文件目录下的 `node_modules` 目录；
- 搜寻父级文件目录下的 `node_modules` 目录；
- 搜寻爷级文件目录下的 `node_modules` 目录；
- 沿路径向上逐级递归，直至根目录下的 `node_modules` 目录；



#### 3-4、文件定位

文件扩展名分析：

若不包含扩展名，则调用 fs 模块同步阻塞式判断文件是否存在，并按 `.js > .json > .node` 顺序补足扩展名；

- 注意：对 node、json 文件，可在使用 require 时，顺带添加扩展名，以稍微提高速度；
- 注意：因缓存优化策略，二次引入时无需路径分析、文件定位、编译执行等过程；

3-4-2、目录与包分析：

若通过文件扩展名分析后，仍无法找到对应文件(或得到一个目录<常见于自定义模块，逐个模块路径查找时>)，此时 Node 会将目录当作包来处理；

- 首先，在所在目录查找 `package.json`：
  - 若有，则通过 `JSON.parse` 解析出包描述对象，并取出 main 属性指定的文件名进行定位；
    - 若缺少文件名扩展名，则进入文件扩展名分析流程；
    - 若文件名错误，则将 index 作为默认文件名，依次查找 `index.js  index.json index.node；`
  - 若无，则将 index 作为默认文件名，依次查找 `index.js  index.json index.node；`
- 最后，若还是没有成功定位任何文件，则继续查找下一个模块路径，直至路径数组遍历完毕，若依然没有找到，则向上抛出查找失败错误；
- 示例：
  - <img src="/Image/Chromium/1.png" style="zoom:50%;" align="left" />



#### 3-5、模块编译

编译后进行加载并导出，此节亦是 CommonJS 模块规范的 Node 实现 

- 原理：编译过程中，Node 对获取到的 JS 文件，进行头尾包装，以实现每个模块文件的作用域隔离：

- - 头部增加：`(function(*exports*, *require*, *module*, *__filename*, *__dirname*){ \n；` 
  - 尾部增加：`\n })`

- 然后，通过执行 vm 原生模块的 `runInThisContext` ，返回一个具体的 function 对象，并将当前模块的 exports、require、module(模块自身)、查找到的文件路径、文件目录作为参数传递此 function 执行；

- - 这也是为何：`require、exports、module` 变量没有在模块中定义，却可在每个模块中存在的原因；

- 最后，对象执行后，将模块的 `exports` 属性返回给调用方，此后属性上的方法 & 属性，均可被外部调用，但其余变量则不可直接调用；

- <img src="/Image/Chromium/2.png" style="zoom:50%;" align="left" />



3-5-1、文件模块编译

- 普通文件模块：

- - 首先，定位到具体文件后，新建模块对象；

  - 然后，按照路径 & 文件扩展名载入并进行相应编译 (具体编译实现看核心模块的JS模块编译)：

  - - `.js`：用 fs 模块同步读取，随后编译执行；
    - `.json` ：用 fs 模块同步读取并用 `JSON.parse` 解析，将结果赋给模块对象的 `exports` 供外部调用；
    - `.node` ：使用 dlopen 方法加载最后编译生成的文件；
    - `.else`  ：处理同 `.js` 文件；

  - 最后，编译成功的模块，将其文件路径作为索引，在 `Module._cache` 对象上缓存以提高二次导入性能；

- 特殊文件模块：C/C++ 模块

  - 描述：即上述提到的 node 文件，用于提升性能与执行效率；

- - 注意：使用 `dlopen` 方法动态加载最后编译生成的文件；
  - 注意：`dlopen` 的实现因平台而不同，但均通过 libux 兼容层封装统一；
  - 注意：实际上，node 文件是用 C/C++ 编写的扩展文件，经编译后生产，故无需编译，只需加载 & 执行；
  - 注意：执行时，模块的 exports 与 .node 模块相关联，然后返回给调用者；

- 特殊文件模块：C/C++扩展模块

- - 编写：与核心模块相比，无需编写如 node 命名空间，即 `namespace node { ..`
  - 加载：仅通过 `process.dlopeen` 动态加载；
  - 导出：详看 31-33；



3-5-2、核心模块编译

核心模块实际可分成 C/C++ 编写部分和 JS 编写两部分：

- 核心模块 JS 编写部分：

- - 存储：在 lib 目录；

  - 转换：使用 V8 的 `js2c.py` 工具，将 JS 代码 (`src/node.js & lib/*.js`) 转换成 C++ 数组，生成 `node_natives.h` 文件，并存储在 `NativeModule._source` 中；

  - - 首先，通过 `process.binding(‘natives’)` 取出上述通过 `js2c.py` 转换的字符串数组，并将其重新转为普通字符串；
    - 然后，进行头尾包装以导出 `export` 对象；
    - 最后，编译成功的模块，将其文件路径作为索引，缓存在 `NativeModule._cache` 对象上；
    - 注意：转换 JS 码时，JS 代码以字符串形式，存储在 node 命名空间中，不可直接执行；
    - 注意：核心模块需编译，而文件模块还需进行路径分析、文件定位；
    - 注意：文件模块缓存中在 `Module._cache` 对象中；
    - 注意：当 Node 进程启动时，JS 代码将直接加载进内存JS 核心模块经标识符分析后直接定位到内存；

- 核心模块 C/C++ 编写部分：

- - 存储：在 src 目录；

  - 转换：因原本即用 C/C++ 编写，随后又被编译成二进制文件，故无需再转换；

  - - 注意：当 Node 进程启动时，便被直接加载进内存，无需定位、分析、编译等步骤，直接可执行；
    - 协助加载：在 Node 启动过程中，还会生成全局变量 `process`，其提供 `Binding` 方法协助加载；
    - 真正加载：此时，会先构建 `exports` 对象，调用 `get_builtin_module` 方法取出模块，执行 `register_func` 填充 `exports` 对象，最后 `exports` 对象按模块名缓存，并返回给调用方完成导出；



### 四、异步机制

### 五、内存管理