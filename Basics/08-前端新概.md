---
typora-root-url: ../../BlogImgsBed/Source
---



### 一、函数柯里化

在一个函数中，首先填充几个参数，然后再返回一个新的函数的技术，称为函数的柯里化。通常可用于在不侵入函数的前提下，为函数 **预置通用参数**，供多次重复调用。

```
const add = function add(x) {
	return function (y) {
		return x + y
	}
}

const add1 = add(1)

add1(2) === 3
add1(20) === 21
```



### 二、高阶函数

<u>一个函数</u> 就可接收另一个函数作为参数或者返回值为一个函数，<u>这种函数</u>就称之为 **<u>高阶函数</u>**；

#### 2-1、数组中的高阶函数

##### 2-1-1、map

- 参数：接受两个参数：回调函数、回调函数的this值(可选)；
  - 其中：回调函数被默认传入三个值，依次为：当前元素、当前索引、整个数组；

- 创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果；
- 对原来的数组没有影响

```js
let nums = [1, 2, 3];
let obj = {val: 5};
let newNums = nums.map(function(item,index,array) {
  return item + index + array[index] + this.val; 
  // 对第一个元素，1 + 0 + 1 + 5 = 7
  // 对第二个元素，2 + 1 + 2 + 5 = 10
  // 对第三个元素，3 + 2 + 3 + 5 = 13
}, obj);
console.log(newNums);  // [7, 10, 13]
```

当然，后面的参数都是可选的 ，不用的话可以省略。

##### 2-1-2、reduce

- 参数：接收两个参：回调函数，另一个为初始值；
  - 回调函数中四个默认参数，依次为：积累值、当前值、当前索引、整个数组；

```js
let nums = [1, 2, 3];
// 多个数的加和
let newNums = nums.reduce(function(preSum,curVal,currentIndex,array) {
  return preSum + curVal; 
}, 0);
console.log(newNums); // 6
```

- 注意：不传默认值：会自动以第一个元素为初始值，然后从第二个元素开始依次累计；



##### 2-1-3、filter

参数：一个函数参数；此函数接受一个默认参数，就是当前元素；这个作为参数的函数返回值为一个布尔类型，决定元素是否保留；

filter 方法返回值为一个新的数组，此数组里面包含参数里面所有被保留的项；

```js
let nums = [1, 2, 3];
// 保留奇数项
let oddNums = nums.filter(item => item % 2);
console.log(oddNums);
```

##### 2-1-4、sort

参数：一个用于比较的函数，它有两个默认参数，分别是代表比较的两个元素；

```js
let nums = [2, 3, 1];
//两个比较的元素分别为a, b
nums.sort(function(a, b) {
  if(a > b) return 1;
  else if(a < b) return -1;
  else if(a == b) return 0;
})
```

- 当比较函数返回值大于 0，则 a 在 b 的后面，即 a 的下标比 b 大；
- 当比较函数返回值小于 0，则 a 在 b 的后面，即 a 的下标比 b 小；
- 当比较函数返回值等于 0，则 a 与 b 不做操作；
- 整个过程就完成了一次升序的排列；

- 注意：若不传比较函数时，按如下规则排序：
  - 将数字转换为字符串，然后根据字母 unicode 值进行升序排序，也即根据字符串的比较规则进行升序排序；



##### 2-1-5、forEach

在 forEach 中用 return 不会返回，函数会继续执行；

```js
let nums = [1, 2, 3];
nums.forEach((item, index) => {
  return; // 无效
})
```

中断方法：

- 使用 try 监视代码块，在需要中断的地方抛出异常；
- 官方推荐方法(替换方法)：用 every 和 some 替代 forEach：
  - every 在碰到 return false 时，中止循环；
  - some 在碰到 return true 时，中止循环；



### 三、SSR/CSR

#### 3-1、SSR

Server Side Rendering(服务端渲染)，将渲染的工作放在服务端进行并回传客户端，后者得到完整结构后就可直接进行 DOM 解析、构建、加载资源及后续渲染；

优点是：首屏加载快、对搜索引擎友好，利于 SEO;

缺点是：访问量较大时，会对服务器造成很大压力、页面间频繁刷新跳转体验不友好；

#### 3-2、CSR

Client Side Rendering(客户端渲染)，服务器返回初始 HTML 内容，然后再通过 JS 异步加载数据，完成页面渲染，如基于vue/react 开发的 SPA 应用；

优点是：页面路由放在客户端，页面间切换快、数据渲染放在客户端大为降低服务器压力；

缺点是：首屏渲染较慢或出现白屏现象、不利于 SEO；

#### 3-3、两者结合的方案

首页基于SSR，后续点击等事件交互基于 CSR 渲染，可避免首页加载较慢，又能解决SEO问题；**<u>*对于客户端和服务端代码采用同构；*</u>**

```js
// 服务端采用 react-dom/server 的 renderToString 方法，将 Index 组件直出：
const { renderToString}  = require( 'react-dom/server');
const http = require('http');

// Index 组件
class Index extends React.Component{
    constructor(props){
        super(props);
    }

    render(){
        return <h1>{this.props.data.title}</h1>
    }
}

// server服务
http.createServer((req, res) => {
    if (req.url === '/') {
        res.writeHead(200, {
            'Content-Type': 'text/html'
        });
        const html = renderToString(<Index />);
        res.end(html);
    }
}).listen(8080);
```



```js
// 客户端使用 react-dom 的 ReactDOM.hydrate 方法替代 ReactDOM.render 方法
// 它用于在 ReactDOMServer 渲染的容器中对 HTML 的内容进行 hydrate 操作 React 会尝试在已有标记上绑定事件监听器。
import ReactDOM from 'react-dom';
// 绑定 Index 组件的事件监听到页面
ReactDom.hydrate(<Index />, document.getElementById('root'));
```