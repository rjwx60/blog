---
typora-root-url: ../../Source
---



https://juejin.im/post/6844903962529759239

https://juejin.im/post/6844903896473665550



### 一、HTML

#### 1-1、HTML5

- 标签：
  - 新增语义化标签(`aside / figure / section / header / footer / nav`等)
  - 增加多媒体标签 `video` 和 `audio`，使样式和结构更加分离；
- 属性：
  - 增强表单，主要是增强了`input`的 type 属性；
  - `meta`增加charset以设置字符集；
  - `script`增加async以异步加载脚本
- 存储：
  - 增加 `localStorage`、`sessionStorage` 和 `indexedDB`；
  - 引入 `application cache` 对 web 和 应用进行缓存；
- API：
  - 增加 `拖放API`、`地理定位`、`SVG绘图`、`canvas绘图`、`Web Worker`、`WebSocket`



#### 1-2、doctype

声明文档类型，告知浏览器用什么文档标准解析这个文档：

- 怪异模式：浏览器使用自己的模式解析文档，不加doctype时默认为怪异模式
- 标准模式：浏览器以W3C的标准解析文档



#### 1-3、href 与 src

- `href(hyperReference)` 即超文本引用：当浏览器遇到 href 时，会并行的地下载资源，不会阻塞页面解析，例如我们使用 `<link>` 引入CSS，浏览器会并行地下载 CSS 而不阻塞页面解析. 因此在引入CSS时建议使用 `<link>` 而不是 `@import`

```html
<link href="style.css" rel="stylesheet" />
```

- `src(resource` 即资源，当浏览器遇到 src 时会暂停页面解析，直到该资源下载或执行完毕，此亦 script 标签之所以放底部的原因；

```html
<script src="script.js"></script>
```



#### 1-4、meta

meta 标签用于描述网页的 <u>元信息</u>；比如网站作者、描述、关键词；

meta 通过 `name=xxx` 和 `content=xxx` 的形式来定义信息，常用设置如下：

- charset：定义HTML文档的字符集

```html
 <meta charset="UTF-8" >
```

- http-equiv：可用于模拟http请求头，可设置过期时间、缓存、刷新

```html
＜meta http-equiv="expires" content="Wed, 20 Jun 2019 22:33:00 GMT"＞
```

- viewport：视口，用于控制页面宽高及缩放比例

```html
<meta  name="viewport"  content="width=device-width, initial-scale=1, maximum-scale=1">
```

##### 1-4-1、viewport

- width/height，宽高，默认宽度980px
- initial-scale，初始缩放比例，1~10
- maximum-scale/minimum-scale，允许用户缩放的最大/小比例
- user-scalable，用户是否可以缩放 (yes/no)

##### 1-4-2、http-equive

- expires，指定过期时间
- progma，设置no-cache可以禁止缓存
- refresh，定时刷新
- set-cookie，可以设置cookie
- X-UA-Compatible，使用浏览器版本
- apple-mobile-web-app-status-bar-style，针对WebApp全屏模式，隐藏状态栏/设置状态栏颜色





### 二、CSS

#### 2-1、盒模型

##### 2-1-1、问题

- 不加声明：浏览器自身理解，IE 使用 IE盒子模型；
- 盒子范围：margin、content (元素宽高 - width & height：border、padding、content)

- 加上声明：浏览器遵从标准，均使用 标准盒子模型；
- 盒子范围：margin、border、padding、content (内容宽高 - width、height)
  - 导致 content-box 情况下，宽高设置与实际表现不符 (设置的是内容宽高，但想要效果为元素宽高)

##### 2-1-2、解决 CSS3 - box-sizing 

- inherit：继承父级 box-sizing 属性值；
- content-box：计算 content 宽高；(整体宽高会改变)
- padding-box：计算 content + padding 宽高；(整体宽高不随后期 border 值改变而改变)
- border-box：计算 content + padding + border 宽高；(整体宽高不随后期 padding、border 值改变而改变)

##### 2-1-3、注意事项

- 盒子高度，使用百分比，则总会采用盒子内容高度；
- 盒子背景，由颜色、图像组成，可通过 background 引入，还可通过 background-clip 设置画布；
- 盒子轮廓，outline 不属于盒模型一部分，在盒子的上面一层，ouline 是画在边界框之外，外边距区域之内；

##### 2-1-X、display 补充

<img src="/Image/Basics/Special/Base/6.png" style="zoom:50%;" align="left"/>





#### 2-2、层叠上下文

层叠上下文是元素提升为一个比较特殊的图层，在三维空间中 (z轴) 高出普通元素一等；

<img src="/Image/Basics/Special/Base/2.png" style="zoom:30%;" align="left"/>

**<u>*触发条件*</u>**

- 根层叠上下文(`html`)
- `position`
- css3属性
  - `flex`
  - `transform`
  - `opacity`
  - `filter`
  - `will-change`
  - `-webkit-overflow-scrolling`

**<u>*层叠等级：层叠上下文在z轴上的排序*</u>**

- 在同一层叠上下文中，层叠等级才有意义
- `z-index`的优先级最高

























#### 2-3、浮动

##### 2-3-1、浮动初衷

初衷是用于文字环绕，即在图文混排时可很好的使文字环绕在图片周围；

当元素浮动后可向左或向右移动，直到它的外边缘碰到包含它的框或者另外一个浮动元素的边框为止；



##### 2-3-2、浮动特性

- 破坏性：浮动元素脱离普通流(引起高度塌陷)，且 display 值变为 block ；
- 包裹性：体现在原本默认撑满行的 div 缩小至内容宽度；
- 补充：只有横向浮动；浮动元素的前一元素不会受到任何影响，但后一元素会围绕着浮动元素
- 补充：若 position: relative  同处 float，先浮动，再根据 position 的 left 等值移动，可清浮动，因为创建了BFC；
- 补充：若 position: absolute 同处 float，float失效，也无法清浮动；



##### 2-3-3、闭合浮动

- **<u>*添加额外标签*</u>**

  - FD元素后面 + clear: both 的兄弟元素；有违结构与表现的分离

  - FD元素后面 + clear="all | left | right | none" 的  br 元素；有违结构与表现的分离 

  - ```html
    <div class="parent">
        // 添加额外标签并且添加 clear 属性
        <div style="clear:both"></div>
        //亦可添加 br 标签
    </div>
    ```

- **<u>*触发 BFC*</u>**：
  - FD元素父级 + overflowHidden/Auto 触发 BFC；IE6 则加 zoom 触发 hasLayout；

  - FD元素父级 + displayTable 触发 BFC；

  - FD元素父级 + 浮动 触发 BFC；破坏布局；

  - ```html
    <div class="parent" style="overflow:hidden">//auto 也可以
        //将父元素的overflow设置为hidden
        <div class="f"></div>
    </div>
    ```

上述闭合浮动的本质：

- 或末尾创建元素，闭合之前元素的浮动；
- 或触发BFC / hasLayout 闭合浮动；

但或多或少存在问题，比如<u>触发 BFC 衍生各种问题、影响布局 & 结构分离</u>等；

解决：<u>使用伪元素，FD元素父级 + 伪元素 content、height: 0、display: block、*zoom:1、clear:both</u>

- **<u>*建立伪类选择器清除浮动：*</u>**

  - ```html
    // 在 css 中添加 :after 伪元素
    .parent:after{
        /* 设置添加子元素的内容是空 */
        content: '';  
        /* 设置添加子元素为块级元素 */
        display: block;
        /* 设置添加的子元素的高度0 */
        height: 0;
        /* 设置添加子元素看不见 */
        visibility: hidden;
        /* 设置clear：both */
        clear: both;
    }
    <div class="parent">
        <div class="f"></div>
    </div>
    
    // 更为规范的写法1
    .clearfix:after {
    	content: '/200B',
    	display: block;
    	height: 0;
    	clear: both;
    }
    .clearfix {
    	*zoom: 1;
    }
    
    // 更为规范的写法2
    .clearfix:after {
    	content: '/200B',
    	display: table;
    	clear: both;
    }
    .clearfix {
    	*zoom: 1;
    }
    ```

  - 注意：clear：是对当前元素产生约束，约束的边界为其他的浮动元素，以避免其某一边有浮动元素；已浮动的元素，设置 *clear* 是无效;

    - <img src="/Image/Basics/Special/Base/4.png" style="zoom:50%;" align="left"/>

  - 注意：display:table 和 display:block区别：前者会创建一个匿名框，其创建 BFC 以闭合浮动；





##### 2-3-X、BFC

含义：Block Formatting Context—BFC 块级格式上下文、页面盒模型布局中的一种 CSS 渲染模式、隔离的渲染区域；

特点：<u>*相当于一个独立的容器，里面的元素和外部的元素相互不影响*</u>；

创建方式：

- 根元素
- `float` !== `none`
- `ovevflow` !== `visible`
- `position: absolute/fixed`
- `display: inline-block / table / table-cell / grid / table-caption / flex / inline-flex`
- 其他方式：网格布局、contain 值为 layout、content 或 strict 的元素等；

特性：

- 不同 BFC 间，不会发生外边距塌陷(可用于解决相邻元素边距塌陷问题)；
- 计算 BFC 高度时，浮动元素也参与计算(即内部有浮动元素时也不会发生高度塌陷，可用于解决子元素浮动父级高度塌陷问题)；
- BFC 区域，不会与 float 元素区域重叠 (可用于去除文字环绕)；
- BFC 中每个子元素的左外边缘(margin-left)会触碰到容器的左边缘(border-left)(对于从右到左的格式来说，则触碰到右边缘)；
- BFC 是页面上的一个隔离、独立容器，不受外界干扰或干扰外界；
  - 属于同一个 BFC 的两个相邻 Box 垂直排列
  - 属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠

应用：

- 固定浮动 (上述特性2，BFE高度计算包含浮动元素)
- 避免外边距重叠问题：防止同一 BFC 容器中的，相邻元素间的，外边距重叠问题 (上述特性1)
- 防止父级，与第一个子级元素的 margin-top 重叠
- 去除 float 文字环绕 (上述特性3)
- 注意 - 创建 BFC 带来衍生问题：
  - position： 脱离文档流
  - float：包裹性，失去流体自适应性；
  - overflow:hidden：无法整站地，大规模地使用；
  - display:inline-block：元素尺寸包裹收缩 失去block水平的流动特性；

<img src="/Image/Basics/Special/Base/1.png" style="zoom:45%;" align="left"/>



##### 2-3-Y、IFC





##### 2-3-G、区别

**<u>*BFC、IFC、GFC 和 FFC 区别*</u>**

块级格式化上下文 BFC：

- 定义：同上
- 使用：常见布局、或需要相对隔离环境下的元素；

内联格式化上下文 IFC：

- 定义：自行搜索；
- 使用：设置IFC后，通过 text-align:center 或 vertical-align:middle 可实现行内水平垂直居中；

网格布局格式化上下文 GFC：

- 定义：为元素设置display：grid 时获得的独立渲染区域；
- 使用：自行搜索；

自适应格式化上下文 FFC：

- 定义：为元素设置display：flex/inline-flex 时获得的自适应容器：
- 使用：自行搜索；



##### 2-3-Z、margin 塌陷 + 负值

- 常用：margin: 0 auto 居中
- margin 在空间有剩余的同时，若左右margin为auto，将会均分剩余空间，但若上下margin为auto，其计算值为0



##### 2-3-Z-1、margin 塌陷

定义：普通文档流中，相邻块级元素的垂直外边距合并(非缺陷，段落相邻需要塌陷)；问题如下：

- 比如：同级、相邻元素合并(1个marginBottom，1个marginTop)；
- 比如：父子、首个元素合并(marginTop)；
- 比如：父子、末个元素合并(marginBottom)；
- 比如：空块，元素上下合并；
- 注意：自身元素，需保证无 minHeight、height、lineBox(即没有内容)才能触发；
- 注意：相邻元素，需保证无 padding、bord

<u>*解决：创建 BFC，比如：行内框、浮动框、定位框；*</u>

- 计算：同号计算，Math.max(绝对值1，绝对值2)；
- 计算：异号计算，绝对值后相加；



##### 2-3-Z-2、margin 负值

- 静止元素负值 margin(left/top)，元素向 left/top 位移；
- 静止元素负值 margin(right/bottom)，元素却不向 right/bottom 位移，而会减少自身供 CSS 读取的高度，影响下方元素位置；
  - 表现：后续的元素拖拉进来并覆盖当前元素；

- 注意：元素不存在宽度值，或 width: auto 时，负值 margin 会增加元素宽度；
- 注意：元素上下相邻，且两者 margin 均为负值时，效果不叠加，取负值最大的效果；

- 注意：单独使用负值 margin 不会破坏页面的文档流；使用负 margin 上移一个元素，所有跟随的元素都会被上移，而 relative 定位的负值 margin 元素则不同，会保留原位置，影响文档流；



#### 2-4、布局

水平居中

- 行内元素: `text-align: center`
- 块级元素: `margin: 0 auto`
- `absolute + transform`
- `flex + justify-content: center`

垂直居中

- `line-height: height`
- `absolute + transform`
- `flex + align-items: center`
- `table`

水平垂直居中

- `absolute + transform`
- `flex + justify-content + align-items`



##### 2-4-1、经典布局

##### 2-4-1-1、垂直居中

- verticalAlignMiddle
- verticalAlignMiddle+displayInlineBlock+伪元素
- 单个元素：position + transformY
- 单行文本：height + line-height
- 多个元素：flex 或 嵌套 使用flex

- **<u>*单行文本+行内+行内块级元素：*</u>**
  - 父级：设置 等值高度 + 行高
  - 父级：设置 after 伪类 displayInlineBlock、verticalAlignMiddle、content、height100%；
    - 元素：设置 displayInlineBlock、verticalAlignMiddle(未经验证)；
  - 元素：内联、设置同值上下内边距
  - 优劣：简单、兼容性、单行、固定高度
- **<u>*多行文本+行内+行内块级元素：*</u>**
  - 父级：设置高度+行高 (行高值根据行数划分，如150高，分5行，则设30)
    - 元素：文本用span包裹；
  - 父级：设置 textAlignCenter
    - 元素：文本用span包裹、设置 margin，故意让其 margin 塌陷；
  - 父级：设置 displayTable、textAlignCenter
    - 元素：文本间用 `<br>` 分割、设置 displayTableCell、verticalAlignMiddle；
  - 父级：设置 displayTableCell、verticalAlignMiddle、宽高；
    - 元素：设置 displayInlineBlock、verticalAlignMiddle；
  - 父级：设置 displayTableCell、verticalAlignMiddle、testAlignCenter
    - 元素：文本用span包裹、设置 displayInlineBlock、verticalAlignMiddle、fontSize0；
    - 注意：父级不能浮动，元素 verticalAlignMiddle 可省略
    - 注意：设置fontSize0，因为里面有文字啊
    - 注意：displayTableCell & margin共用，margin失效，可用padding替换解决
    - 注意：父级宽度足够，以上操作不会换行；宽度不够，才会居中文本
  - flex布局
- **<u>*图片*</u>**
  - 父相子绝 + transform
  - 父级：设置高度 + 行高、并用 fontSize0 消除幽灵空白节点影响；
    - 元素：设置 verticalAlignMiddle
    - 注意：不加 fontSize0，位置会偏上；
    - 注意：或将verticalAlign设为Bottom / top
    - 注意：或将Img元素变为块级元素，使其脱离行内基线影响 
    - 注意：慎用line-height为0
    - 优劣：简单、兼容、需加 fontSize0、父级和元素之间需有换行/空格
- **<u>*单个元素*</u>**
  - 父级：设置 displayTabel、加高度(不可为%值)；
    - 元素：设置 displayTableCell + VerticalAlignMiddle
    - 注意：因设置table-cell，故元素宽高度百分比值无效，需要给它的父元素设置display: table; 才生效； 
    - 注意：table-cell不感知margin，在父元素上设置table-row等属性，也会使其不感知height；
    - 注意：设置float或position会对默认布局造成破坏
    - 注意：内容溢出时会自动撑开父元素
    - 注意：使用displayTableCell，会占满一行影响右边内容的布局
  - 结构：A -> (B+C)
    - A 设置高度，相对定位 
      - B&C 设置 displayInlineBlock + verticalAlignMiddle 
      - B/C 设置与A一致的高度 + fontSize0 
  - 父相子绝，设置 transform、top  (用于未知高度)
  - 父相子绝，设置 marginTop、top (元素高度需设置)
  - 父相子绝，设置 top0、bottom0、margin auto 0、高度
    - 原理：当top、bottom为0、margin-top + bottom会无限延伸占满空间并且平分；
    - 注意：文艺点的说法是格式化宽度；
  - 父级：设置displayFlex、AlignItemsCenter
  - 父级：设置displayFlex、元素：设置 AlignSelfCenter
  - 父级：设置displayFlex、元素：设置 margin auto 0
    - IE89不支持，需要浏览器前缀
- **<u>*多个元素*</u>**
  - 父级设置：displayFlex、AlignItemsCenter；
  - 父级设置：displayFlex、元素：设置 AlignSelfCenter；
  - 父级设置：displayFlex、FlexDirectionColumn、JustifyContentCenter；



##### 2-4-1-2、水平居中

- 不限元素：text-align:center + display:inline-block；
- 单个元素：margin: 0 auto + 定宽且宽度小于父级的宽；
- 单个元素：position + transform:translateX()；
- 不限元素：display:flex + justify-content: center ；
- 不限元素：display:flex +  margin: 0 auto；
- 单个浮动：width:fit-content +  margin: 0 auto；
- 多个浮动：去除覆盖浮动再处理；

- **<u>*文本+行内+行内块级元素*</u>**
  - 父级：设置 text-align:center
  - 优劣：简单、兼容好、自由宽高、仅限行内有效、属性有继承性(前提:后代内容宽度<此宽度)
- **<u>*单个块级元素*</u>**
  - 元素：设置 margin: 0 atuo、定宽且宽度<父级；
    - 注意：低版本的浏览器还需设置父级 textAlignCenter；
  - 元素：设置 display:table、margin:0 auto；
    - 优劣：简单、兼容性好、须定宽、子宽须<父级；
- **<u>*多个块级元素*</u>**
  - 父级：设置 text-align:center；
    - 元素：设置 display:inline-block；
  - flex布局
    - 优劣：简单、兼容性好、仅限行内有效、属性有继承性、换行/空格会产生元素间隔；
- **<u>*单个不论块级行内元素*</u>**
  - 绝对定位：父级相对，子级绝对，利用 left:50% 和 transform:translateX(-50%)
  - flex布局：
    - 优劣：简单、宽高可不定、脱离文档流、兼容性差ie9+；
- **<u>*多个不论块级行内元素*</u>**
  - flex布局：
    - 父级：设置 display:flex；
    - 子级：设置 margin: 0 auto
      - 优劣：简单、宽高可不定、兼容性差
- **<u>*单个浮动元素*</u>**
  - 父级：设置 margin0 auto、宽度 fit-content (收缩但保持block水平);
    - 缺点：严重兼容性问题；
- **<u>*多个浮动元素*</u>**
  - 去浮动、去margin、加 display:inline-block + text-align:center；
  - 父相子绝：宽度固定、left50%、marginLeft负值0.5*元素宽度值；
  - 父相子绝：宽度固定、left0、right0、margin0 auto；
    - 缺点：须知宽高

- **<u>*宽度确定的块级元素*</u>**
  - width和margin实现。margin: 0 auto;
  - 绝对定位和margin-left: -width/2, 前提是父元素position: relative

- **<u>*宽度未知的块级元素*</u>**
  - table 标签配合margin左右auto实现水平居中。使用table标签(或直接将块级元素设值为display:table)，再通过给该标签添加左右margin为auto。
  - inline-block 实现水平居中方法。display：inline-block和text-align:center实现水平居中。
  - 绝对定位+transform，translateX可以移动本身元素的50%。
  - flex布局使用 justify-content:center



##### 2-4-1-3、垂直水平居中

flex布局：

- 父级：设置 JustifyContentCenter、AlignItemsCenter
- 父级：设置 JustifyContentCenter
  - 元素：设置 AlignSelfCenter 或 MarginAuto

相对绝对布局，父相子绝

- 元素：设置 Transform、 left、top；
- 元素：设置 left、top、bottom、right均=0、marginAuto；
- 元素：设置 负值margin宽高值、left=0、top=0 (宽高已知)；

table布局

- 父级：设置 displayTableCell、textAlignCenter、verticalAlignMiddle；
  - 元素：设置 displayInlineBlock、verticalAlignMiddle；
- 父级：设置 displayTableCell、textAlignCenter、verticalAlignMiddle；
  - 元素：设置 margin0 auto；
  - 注意：设置tabl-cell的元素的宽高百分比无效，需将父级设置display: table；
  - 注意：内容溢出时会自动撑开父元素；

传统布局：

- 父级：设置 固定lineHeight、textAlignCenter、fontSize0；
  - 元素：设置 displayInlineBlock、verticalAlignMiddle；
  - 注意：须知元素高度
- 父级：使用button标签、设置outlineNone、borderNone；
  - 元素：设置 displayInlineBlock；
  - 注意：button 在IE下点击会有凹陷效果；
  - 注意：button 自带 textAlignCenter；
- 伪元素实现：
  - 父级：设置 textAlignCenter
  - 父级 before 或 after 伪元素：displayInlineBlock + verticalAlignMiddle、高度100%、宽度0、content为空；
    - 子级：设置 displayInlineBlock、verticalAlignMiddle
- calc实现
  - 元素：设置padding: calc((100% - 100px) / 2); 

- Grid布局：
  - 父级：设置display: grid;
    - 元素：设置justify-self: center、align-self: center;

相对于屏幕的垂直水平居中

- 结构：A->B->C三层结构
  - A：displayTable + positionAbsolute + width: 100% + height: 100%
    - B：displayTableCell + verticalAlignMiddle
      - C：margin: 0 auto; width: xxpx；

另类布局：

- <img src="/Image/Basics/Special/Base/3.png" style="zoom:45%;" align="left"/>
- 结构：A+B
  - A 左浮动，设置高度50%，负值marginBottom120px
  - B clearBoth，高度240px; 相对定位
  - 优势：适用于所有浏览器；
  - 缺点：空间不够时，B不会截断，会出现滚动条；



##### 2-4-2、常见布局

##### 2-4-2-1、多列布局

flex 实现

- 父级 flex、子级设置 flexNumber；

table 实现

- 父级 displayTable + table-layoutFixed、子级 displayTableCell；

float 实现

- 父级 BFC、子级 floatLeft；

Grid 实现

- 。。。

##### 2-4-2-2、两列布局

##### 2-4-2-2-1、左列定宽+右列自适应

普通布局：

- 结构：1+2相邻；
- 其中：1floatLeft、宽度固定；
- 其中：2marginLeft值为1宽、1+2高度固定；

左右浮动+负值margin

- 结构：1+2相邻、2含子3；
- 其中：1floatLeft、宽度固定；
- 其中：2floatRight、宽度100%、2marginLeft负值为1宽；
- 其中：3marginLeft值为1宽、1+3高度固定；

BFC 布局

- 结构：1+2相邻；
- 其中：1floatLeft、宽度固定；
- 其中：2设置BFC、1+2高度固定；

table 布局

- 结构：1>(2+3)；
- 其中：1displayTable、宽度100%、高度固定；
- 其中：2+3displayTableCell、2宽度固定；

position 布局

- 结构：1>(2+3)；
- 其中：1positionRelative
- 其中：2+3positionAbsolute、2left0、宽高固定、3left值为2宽、right0、高度固定；

flex 布局

- 结构：1>(2+3)；
- 其中：1displayFlex、宽度100%、高度固定；
- 其中：2宽度固定；
- 其中：3flex为1；

grid 布局

- 。。。

- 双 inline-block 实现
  - 。。。
- 双 float 实现
  - 。。。

##### 2-4-2-2-2、左列自适应+右列固定

布局1：

- 结构：1>(2+3)；
- 其中：1paddingLeft值为3宽；
- 其中：2floatLeft、宽度100%，marginLeft为负值3宽；
- 其中：3floatRight；

布局2：

- 结构：1>(3+2)；
- 其中：2floatRight、marginLeft为0、宽度固定；
- 其中：3overflowHidden；

布局3：

- 结构：1>(2+3)；
- 其中：1displayTable、宽度100%、高度固定；
- 其中：2+3displayTableCell、3宽度固定；

布局4：绝对定位、flex、grid



##### 2-4-2-3、三列布局

##### 2-4-2-3-1、左中定宽+右侧自适应

flex 实现：

- 父1、子2+3+4、其中2+3定宽、4设置flex=1；

BFC 实现：

- 父1、子2+3+4、其中2+3floatLeft、4设置BFC；

margin 实现：

- 父1、子2+3+4、其中2+3floatLeft、4设置marginLeft为2+3的宽度和；

table 实现： 

- 父1、子2+3+4、其中1displayTable、2+3+4displayTableCell、2+3定宽；

Grid 实现：

- 。。。





##### 2-4-2-3-2、左右定宽+中间自适应

**<u>*左右浮动+margin正值*</u>**

- 结构：1+2+3同级；

- 其中：设置1floatLeft、2floatRight、设置3margin右左值分别为2宽和1宽、父级固定浮动；

**<u>*双飞翼布局*</u>**

- 结构：1+2+3、1有子4(其中1为center、2为left、3为right)
- 其中：设置1floatLeft、宽度100%、高度固定；
- 关键：设置4margin右左值分别为3宽和2宽度
- 此外：设置2floatLeft、marginLeft负值100% (移动到center1左边)、宽度固定；
- 此外：设置3floatLeft、marginLeft负值selfWidth(移动到center1右边)、宽度固定；

**<u>*圣杯布局*</u>**

- 结构：1>(2+3+4)(其中1为container、2为center、3为left、4为right)
- 关键：设置2宽度100%、2+3+4floatLeft (依据流体布局，3+4将会被下挤)；
- 此后：设置3marginLeft值负值100% (margin百分比值相对于父级宽度，此后3将移动到2左侧)；
- 此后：设置4marginLeft值负值selfWidth (此后4将移动到2右侧)；
- 此后：设置1padding左右值分别为3宽和4宽(避免内容被遮盖)；
- 此后：设置3+4positionRelative值各自左右移动自身宽度(解决上一步出现的白条问题)；

**<u>*table布局*</u>**

- 结构：parent1、sonLeft2、sonCenter3、sonRight4；
- 其中：设置1displayTable、宽度100%、高度固定；
- 其中：设置2+3+4displayTableCell、2+4宽度固定；

**<u>*flex布局*</u>**

- 结构：parent1，sonLeft2，sonCenter3，sonRight4；
- 其中：设置1displayFlex、高度固定；
- 其中：设置3Flex、2+4宽度固定；

**<u>*使用position实现*</u>**

- 结构：parent1，sonLeft2，sonCenter3，sonRight4；
- 其中：设置1positionRelative；
- 其中：设置2+3+4positionAbsolute、2Left0、4Right0、宽度固定、高度固定；
- 其中：设置3marginLeft值2宽、3marginRight值4宽；

**<u>*Grid 实现*</u>**

- 。。。

##### 2-4-2-3-3、双飞和圣杯布局区别

- 解决一致：左右定宽，中间自适应，中间栏要在放在文档流前面以优先渲染；
- 思路相似：
  - 首先，三栏全部 float 浮动；
  - 然后，让中间盒子 100% 宽度占满同一高度的空间，此时左右两个盒子被挤出中间盒子所在区域；
  - 再用，margin-left 的负值将左右两个盒子拉回与中间盒子同一高度的空间；
  - 然后，调整来避免中间盒子的内容被左右盒子遮挡；
- 主要区别：
  - 在第4步：如何使中间盒子的内容不被左右盒子遮挡：
  - 前者：在中间盒子里再增加一个子盒子，直接设置这个子盒子的 margin 值来让出空位，而不用再调整左右盒子；
  - 后者：设置父盒子的 padding 值为左右盒子留出空位，再利用相对布局对左右盒子调整位置占据 padding 出来的空位；



##### 2-4-X、Flex

##### 2-4-X-1、容器属性

使用在flex布局容器上的属性

##### 2-4-X-1-1、flex-direction

决定横着排还是竖着排列

```css
.container {
    flex-direction: row | row-reverse | column | column-reverse;
    /* 主轴方向：水平由左至右排列(默认值) | 水平由右向左 | 垂直由上至下 | 垂直由下至上 */
}
```

##### 2-4-X-1-2、flex-wrap

控制换行

```css
.container {
    flex-wrap: nowrap | wrap | wrap-reverse;
    /* 换行方式：不换行(默认值) | 换行 | 反向换行 */
}
```

##### 2-4-X-1-3、flex-flow

前两者的复合属性

```css
.container {
    flex-flow: <flex-direction> || <flex-wrap>;
    /* 默认值：row nowrap */
}
```

##### 2-4-X-1-4、justify-content

用于控制行内项目分布情况(定义子元素在主轴(横轴)上的对齐方式)；

```css
.container {
    justify-content: center | flex-start | flex-end | space-between | space-around;
    /* 主轴对齐方式：居中 | 左对齐(默认值) | 右对齐 | 两端对齐(子元素间边距相等) | 周围对齐(每个子元素两侧margin相等) */
}
```

##### 2-4-X-1-5、align-items

用于控制列内项目的分布情况(定义项目在交叉轴(竖轴)上对齐方式)；

```css
.container {
    align-items: center | flex-start | flex-end | baseline | stretch;
    /* 侧轴对齐方式：居中 | 上对齐 | 下对齐 | 项目的第一行文字的基线对齐 | 如果子元素未设置高度，将占满整个容器的高度(默认值) */
}
```

##### 2-4-X-1-6、align-content

定义多根轴线的对齐方式；

```css
.container {
    align-content: center | flex-start | flex-end | space-between | space-around | stretch;
    /* 默认值：与交叉轴的中点对齐 | 与交叉轴的起点对齐 | 与交叉轴的终点对齐 | 与交叉轴两端对齐 | 每根轴线两侧的间隔都相等 | (默认值)：轴线占满整个交叉轴 */
}
```



##### 2-4-X-2、项目属性

使用在容器内子元素上的属性

##### 2-4-X-2-1、flex-grow

**<u>*用于定义项目放大比例*</u>**，若均为1，则均分空间，以此类推，如下所示；

默认为0，即便有剩余空间也不放大；

- 若所有子元素 flex-grow 为 1，则将等分剩余空间；
- 若某个子元素 flex-grow 为 2，则这个子元素将占据 2 倍的剩余空间；

```css
.item {
  flex-grow: <number>; /* default 0 */
}
```

##### 2-4-X-2-2、flex-shrink

**<u>*用于定义项目的缩小比例*</u>**；

默认为 1，即若空间不足，子元素将缩小；

若所有子元素 `flex-shrink` 都为1，某个子元素 `flex-shrink` 为 0，则该子元素将不缩小

```css
.item {
  flex-shrink: <number>; /* default 1 */
}
```

##### 2-4-X-2-3、flex-basis

定义在分配多余空间之前，项目占据的主轴空间，作用看计算规则；

注意：浏览器根据此属性，计算主轴是否有多余空间；

默认auto，即子元素本来的大小；

若设定为一个固定的值，则子元素将占据固定空间；

```css
.item {
  flex-basis: <length> | auto; /* default auto */
}
```

##### 2-4-X-2-4、flex

前三者的复合属性；`<flex-grow> || <flex-shrink> || <flex-basis>`；

默认值为 0 1 auto；

即有剩余空间不放大，剩余空间不够将缩小，子元素占据自身大小

```css
.item {
  flex: none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]
}
```

flex有两个快捷值：`auto `和 `none`，分别代表：

- `1 1 auto`：有剩余空间则平均分配，空间不够等比缩小，子元素占据空间等于自身大小；
- `0 0 auto`：有剩余空间也不分配，空间不够也不缩小，子元素占据空间等于自身大小；

flex 值的其他表示意思：

- flex: none -->> flex: 0 0 auto;
- flex: auto -->> flex: 1 1 auto;
- flex: 1个非负数字如2 -->> flex: 2 1 0%;
- flex: 2个非负数字如2 3 -->> flex: 2 3 0%;

- flex: 一个长度值如24px -->> flex: 1 1 24px;
- flex: 一个百分比值如20% -->> flex: 1 1 20%;
- flex: 一个非负+一个长度值或百分比值如8 50px/20% -->> flex: 8 1 50px/20%;

##### 2-4-X-2-5、align-self

定义单个子元素的排列方式；

用于继承父级 align-items 值，若无父级，则等同于stretch，常用于，覆盖旧属性自定义列内排列方式；

比如之前的项目属性 align-items 设置了 center，使得所有子元素居中对齐，则可通过给某个子元素设置 align-self 来单独设置子元素的排序方式；

```css
.item {
  align-self: auto | flex-start | flex-end | center | baseline | stretch;
}
```



##### 2-4-X-2-6、order

定义项目的排列顺序；数值越小，排列越靠前，默认为 0

```css
.item {
  order: <integer>;
}
```



##### 2-4-X-3、计算规则

**<u>*flex 计算规则相关属性：margin，flex-grow，flex-shrink，flex-basis；*</u>**

##### 2-4-X-3-1、margin 计算属性

- 注意：Flex 容器每行宽度 = 所有子容器宽度 + 子容器左右 margin 值；
- 故而：所有子容纳器宽度 = Flex 容器每行宽度 - 子容器左右 margin 值：400 - 2 * 50；
- 一般：子容器宽度 = 所有子容器宽度 与 自身 flex-grow 值占总比重的乘积：
- <img src="/Image/Basics/Special/Base/7.png" style="zoom:50%;" align="left"/>



##### 2-4-X-3-2、其他计算属性

##### 3-4-X-3-2-1、flex-grow

**<u>*不足容器大小时的伸张比例*</u>**

值为0，则不伸张；

值非0，且 Max (项目 flex-basis 总值 或 宽度总值) < 容器 padding-box 宽度时，则按各项目 flex-grow 值，所占百分比来分配剩余空间；

- 比如：容器宽度 400，2子均为 100，其中1子设置 flex-grow，则将剩余的200分予此，故最后有200原 + 200分配空间；
- 比如：容器宽度 400，2子均为 300，超出容器宽度，此时 flex-grow 就失效，而2子以均为 200 被限定在 400 内；
- 而若：完整显示 300 宽度：则可设置 flex-wrap：wrap 换行显示、亦可设置 flex-shrink 为 0 禁止压缩；

##### 3-4-X-3-2-2、flex-shrink

**<u>*超过容器大小时的压缩比例 - 默认1*</u>**

- 比如：容器宽度400，2子均为300，超出容器宽度，剩余空间为 -200px；
- 若项目均设置 flex-shrink 为0不能压缩，则会溢出容器显示；
- 若设置1个 flex-shrink 为 0，另 1 个为 1，则将剩余空间全部给取值为 1 项目，即：300 - 200 = 100px；
- 若分别设置 flex-shrink为 2 和 8，则分别为：300 + (-40) = 260、300 + (-160) = 140；

##### 3-4-X-3-2-3、flex-basis 

**<u>*结合 flex-basis 的真实计算过程 <<flex原理>>*</u>**

结构：容器宽度200 + 3子；

分别设置：flex-basis 40px、flex-basis 40px、宽度200；

分别设置：flex-shrink = 1、flex-shrink = 2、flex-shrink = 3；

第1步，计算加权值：

- A = … +（ 各自 flex-shrink 值 * 各自的 width 或 flex-basis ）+ …
- 比如：1*40 + 2*40 + 3*200 = 720;

第2步，求各自的缩小比例：

- Rate =（ 各自 flex-shrink 值 * 各自的 width 或 flex-basis ） / A
- 比如：(40*1) / 720、(40*2) / 720、(200*3) / 720

第3步：得到最后的计算值

- 最终：结果 =（ 超出的值 * 各自的rate ） + 各自的 width/flex-basis 值

注意：若未设置 flex-basis，则依据 width 值；

注意：若 width值也未设置，则依据其内容宽度；

注意：flex-basis 和 width 并存，前者优先，忽略width值；

注意：若 flex-basis 为百分值，则相对于，祖先声明了display:flex的元素；

注意：若 flex-basis 为auto默认值，则代表项目本来的大小；



##### 2-4-X-4、示例

示例A：

<img src="/Image/Basics/Special/Base/8.png" style="zoom:50%;" align="left"/>

超出值：0

基准值：0*1 + 100*1 + 200*1 = 300

然后，因为项目总宽不足容器，所以会伸张：

公式：项目宽度 + flex-grow所占比例 * 基准值

Item1为0 + 300*0.4 = 120

Item2为100 + 300*0.4 = 220

Item3为200 + 300*0.2 = 260



示例B：

<img src="/Image/Basics/Special/Base/9.png" style="zoom:50%;" align="left"/>

超出值：600

基准值：600*4 + 200*4 + 400*2 = 4000

然后，因为项目总宽超过容器，所以会压缩：

公式：项目宽度 - 超出值 * 项目宽度 * flex-shrink值 / 基准值

Item1：600 - 600 * (600 * 4)/4000 = 240

Item2：200 - 600 * (200 * 4)/4000 = 80

Item3：400 - 600 * (400 * 2)/4000 = 280





问题：父级设置 flex-column，子级也设置 flex，则子级会被压缩；

解决：子级同时设置 flex-shrink = 0 不允许压缩即可

参考：https://blog.csdn.net/weixin_37221852/article/details/83141874







##### 2-4-Y、Grid 



##### 2-4-Z、特殊布局

- **<u>*多个元素、宽高已知、实现垂直水平居中、间隔等距布局*</u>**
  - flex思路一：
    - 父级：设置displayFlex，元素间插入li空标签，并设置flex1；
    - 元素：使用中级标签包裹、设置宽度；若有3个元素，则第1、3中级标签设置flex1，第2个中级标签设置宽高度；
  - flex思路二：
    - 手动计算间隔宽度；如(100% - 80px * 3)/ 4 = 25% - 60px；
    - 配合父级before、after伪元素实现；
  - table思路
  - position思路

- **<u>*图片大小不固定、实现垂直水平居中布局*</u>**
  - 父级：设置宽高固定；
    - 元素：设置宽高 100%、display-block、background:posiiton-center；
    - 注意：元素 background-url 需写在内嵌样式中；
  - 父级：设置 display：Inline-block、宽度固定、text-align：center、vertical-align:middle；
    - 元素：设置 vertical-align:middle；
  - 父级：设置text-align：center、fontSize0；
    - 增加空白图片元素：高度100%、宽度1px、设置vertical-align:middle；
    - 元素：设置 vertical-align:middle；
  - 父级：设置test-align：center，fontSize0；
    - 父级after伪元素：设置content为空、vertical-align:middle；
    - 元素：设置vertical-align:middle；
- <u>**父级垂直居中，高度适中为宽度一半，且含垂直水平居中子级**</u>
  - 思路1：三层结构：
    - 外层控制垂直居中，比如 flex 控制
    - 中层使用 width: 100%; height: 0; padding-bottom: 50%; 控制；
    - 内层使用垂直水平居中方案；
  - 思路2：calc布局
    - width: calc(100vw - 20px); height: calc(50vw - 10px); 
    - position: absolute;   top: 50%; transform: translateY(-50%);
    - display: flex;  align-items: center;  justify-content: center;

- **<u>*父级高度自适应，1子级高度固定，另1子级高度自动填满*</u>**
  - flex思路一：
    - 父级：设置 display：flex、flex-direction：colum、height：100%；
    - 上子级：设置高度固定；
    - 下子级：设置flex1；
  - flex思路二：
    - 父级：设置 box-sizing：border-box、paddingTop为上子级高度、height随意；
    - 上子级：设置 position-absolute、top0、left0、width100%；
    - 下子级：设置高度100%；
  - calc思路：
    - 父级：设置 calc(100% - xxpx)；
    - 注意：calc 减号两侧需有空格；

- **<u>*3元素高度固定、“品”字布局*</u>**
  - 思路：
    - 上方：设置 margin 0 auto；
    - 下方：按两列布局设置；

- **<u>*九宫格布局*</u>**

- - 结构：3个子级、每个子级3个孙级：

  - - 父级：设置 display：table、table-layout：fixed；
    - 子级：设置 display：table-row；
    - 孙级：设置 display：table-cell、高度；

  - 结构：3个子级、每个子级3个孙级：

  - - 父级：设置 display：flex、flex-direction：column；
    - 子级：设置 display：flex；
    - 孙级：设置 flex1

- **<u>*文字环绕图片*</u>**

- - 父级：设置 work-break：break-all(为了让英文内容换行)
  - 子级一：设置 float：left、或right、或none+clear：both；
  - 子级二：使用标签包裹、或文字内容；

- **<u>*高度随自身宽度变化、而变化布局*</u>**

- - padding-bottom 百分比思路：

  - - 父级：设置 top、bottom、left、right为0，margin-auto、width100% 

    - - 子级：设置 before 伪元素 padding-bottom100%、width0.1px、vertical-align：middle；

    - 父级：设置宽度 

    - - 子级：设置 paddingBottom 

  - JS 实现思路：

  - - 使用JS判断图片具体数值、再设置图片高度；
    - 缺点：只能在页面刷新时触发，浏览器屏幕变动时不能触发

- **<u>*底部置底*</u>**
  - 方法1：绝对定位
    - 结构：父级 + 子级 content、子级 footer
    - 父级：PositionRelative、HeightAuto、MinHeight100%(heightAuto 保证页面能撑开浏览器高度时正常显示)
    - 子级 footer：positionAbsolute、left0、botton0，高度固定
    - 子级 content：设置PaddingBottom、值为 footer 高度
  - 方法2：margin负值
    - 结构：content + footer
    - content：MinHeight100%、负值 MarginBottom、值为 footer 高度；
    - footer：高度固定；
    - 结构：container + footer、其中 container 中有子级 header + main；
    - container：MinHeight100%；
    - main：设置 PaddingBottom 为 footer 高度；
    - footer：负值 MarginTop、值为自身高度；
  - 方法3：利用calc()
    - 结构：content + footer；
    - content：设置 MinHeight: calc( 100vh - footer高度 )；
    - footer：高度固定；
  - 方法4：Flex布局
    - 结构：父级 + 子级 content + 子级 footer；
    - 父级：设置 Flex 布局 和 Column 排列；
  - 方法5：Grid布局
    - 结构：父级 + 子级 content + 子级 footer；
    - 父级：设置 MinHeight100%、DisplayGrid、grid-template-rows: 1fr auto;
    - 子级：grid-row-start: 2、grid-row-end: 3; 
    - 注意：各方法的 MinHeight 生效前提为父级设置 Height；





#### 2-10、动画

`transition`: 过渡动画

- `transition-property`: 属性
- `transition-duration`: 间隔
- `transition-timing-function`: 曲线
- `transition-delay`: 延迟
- 常用钩子: `transitionend`

```
animation / keyframes
```

- `animation-name`: 动画名称，对应`@keyframes`

- `animation-duration`: 间隔

- `animation-timing-function`: 曲线

- `animation-delay`: 延迟

- ```
  animation-iteration-count
  ```

  : 次数

  - `infinite`: 循环动画

- ```
  animation-direction
  ```

  : 方向

  - `alternate`: 反向播放

- ```
  animation-fill-mode
  ```

  : 静止模式

  - `forwards`: 停止时，保留最后一帧
  - `backwards`: 停止时，回到第一帧
  - `both`: 同时运用 `forwards / backwards`

- 常用钩子: `animationend`

动画属性: 尽量使用动画属性进行动画，能拥有较好的性能表现

- `translate`
- `scale`
- `rotate`
- `skew`
- `opacity`
- `color`





#### 2-X、其他

##### 2-X-1、选择器优先级

- `!important` > 行内样式 > `#id` > `.class` > `tag` > * > 继承 > 默认
- 选择器 **从右往左** 解析

##### 2-X-2、link 与 @import

`link`功能较多，可以定义 RSS，定义 Rel 等作用，而`@import`只能用于加载 css

当解析到`link`时，页面会同步加载所引的 css，而`@import`所引用的 css 会等到页面加载完才被加载

`@import`需要 IE5 以上才能使用

`link`可以使用 js 动态引入，`@import`不行

