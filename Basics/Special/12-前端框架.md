---
typora-root-url: ../../Source
---



## 一、基本

### 1-1、基本使用

### 1-2、生命周期

#### 1-2-1、Vue

#### 1-2-2、Angular





### 1-3、路由机制

#### 1-3-1、Vue 

详看：[文章](https://juejin.im/post/6844903615283363848#heading-4)

#### 1-3-2、Angular







### 1-4、数据绑定

#### 1-4-1、Vue

Vue2 数据绑定依靠 [Object.defineProperty](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty)

<img src="/Image/Frame/Vue/1.png" style="zoom:50%;" align="left" />



##### 1-4-1、initData

首先，initData，获取 data 的 key，并获取 props，并确保 props 优先，不能与 data 重复，并判断是否保留字段，并将 data 属性代理到 vm 实例上(this.key == this.data.key)，随后进行 observer(data) - 数据绑定操作；

```js
function initData (vm: Component) {
  /* 获取 data */
  let data = vm.$options.data
  data = vm._data = typeof data === 'function'
    ? getData(data, vm)
    : data || {}

  /* data 是否为对象 */
  if (!isPlainObject(data)) {
    data = {}
    process.env.NODE_ENV !== 'production' && warn(
      'data functions should return an object:\n' +
      'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',
      vm
    )
  }

  // proxy data on instance
  /* 获取 props */
  const keys = Object.keys(data)
  const props = vm.$options.props
  let i = keys.length

 	/* 遍历对象 data 的键值进行处理 */
  while (i--) {
    /* 确保 data 的键值 key 不与 props 键值重复，props 优先*/
    if (props && hasOwn(props, keys[i])) {
      process.env.NODE_ENV !== 'production' && warn(
        `The data property "${keys[i]}" is already declared as a prop. ` +
        `Use prop default value instead.`,
        vm
      )
    // 如果不是保留字段，则继续进行代理操作，将 data 上的属性代理到 vm 实例上，即实现：vm.key == vm._data.key
    } else if (!isReserved(keys[i])) {
      proxy(vm, `_data`, keys[i])
    }
  }

  // observe data
  // observe: 开始对数据进行绑定，asRootData，表示此步作为数据的最初操作，后续会进行递归 observe 从而实现对深层对象的绑定
  observe(data, true /* asRootData */)
}






// Proxy - 负责代代理 - 通过 Object.defineProperty 实现
export function proxy (target: Object, sourceKey: string, key: string) {
  sharedPropertyDefinition.get = function proxyGetter () {
    return this[sourceKey][key]
  }
  sharedPropertyDefinition.set = function proxySetter (val) {
    this[sourceKey][key] = val
  }
  Object.defineProperty(target, key, sharedPropertyDefinition)
}
```



##### 1-4-2、observe

observe 作用是防止 Observer 的重复绑定

```js
/**
 * Attempt to create an observer instance for a value,
 * returns the new observer if successfully observed,
 * or the existing observer if the value already has one.
 */
// 尝试创建一个 Observer 实例（__ob__），若成功创建 Observer 实例则返回新的 Observer 实例，若已有 Observer 实例则返回现有的 Observer 实例
export function observe (value: any, asRootData: ?boolean): Observer | void {
  if (!isObject(value)) { return }
  let ob: Observer | void

  // 若已有 Observer 实例则直接返回该实例，若没有则会新建一个 Observer 实例并赋值给 __ob__ 属性
  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
    ob = value.__ob__
  } else if (
    // 确保 value 是单纯的对象，而非函数或是Regexp等情况。*/
    observerState.shouldConvert &&
    !isServerRendering() &&
    (Array.isArray(value) || isPlainObject(value)) &&
    Object.isExtensible(value) &&
    !value._isVue
  ) {
    // ob 存放 Observer 实例/该属性的观察器，防止重复绑定
    ob = new Observer(value)
  }
  if (asRootData && ob) {
    // 若为根数据则计数，后面 Observer 中的 observe 的 asRootData 均为 false 则不计数
    ob.vmCount++
  }
  return ob
}
```



##### 1-4-3、Observer

Observer 作用是遍历对象的所有属性将其进行双向绑定—walk 方法—针对数组/对象处理+赋值操作 `data.__ob__ = Observer 实例`；

```js
/**
 * Observer class that are attached to each observed
 * object. Once attached, the observer converts target
 * object's property keys into getter/setters that
 * collect dependencies and dispatches updates.
 */
export class  {
  value: any;
  dep: Dep;
  vmCount: number; // number of vms that has this object as root $data

  constructor (value: any) {
    this.value = value
    // 含有 id & subs 用于管理 watchers
    this.dep = new Dep()
    this.vmCount = 0

    // 将 Observer 实例绑定到 data 的 __ob__ 属性上，前面的 observe 方法就是检测这个属性：data.__ob__
    def(value, '__ob__', this)
    
    // 若值为数组，则利用被劫持的数组方法，实现对数组操作的监听(重写push、pop、shift、unshift、splice、sort、reverse)
    if (Array.isArray(value)) {
      // 若当前浏览器支持 __proto__ 属性，则直接覆盖当前数组对象原型上的原生数组方法(直接覆盖该属性则使数组对象具有了重写后的数组方法)
      // 若不支持该属性，则通过遍历 def 所有需要重写的数组方法(arrayMethods 中有调用 def，显然前者效率更高，优先使用前者)
      const augment = hasProto
        ? protoAugment  // 直接覆盖原型的方法来修改目标对象
        : copyAugment   // 定义（覆盖）目标对象或数组的某一个方法
      augment(value, arrayMethods, arrayKeys)
     	// 对每一个数组成员进行 observe
      this.observeArray(value)
      
    // 若是对象则直接利用 walk 进行绑定
    } else {
      this.walk(value)
    }
  }

  /**
   * Walk through each property and convert them into
   * getter/setters. This method should only be called when
   * value type is Object.
   */
  walk (obj: Object) {
    const keys = Object.keys(obj)

    // walk 方法会遍历对象的每一个属性进行 defineReactive 绑定
    for (let i = 0; i < keys.length; i++) {
      defineReactive(obj, keys[i], obj[keys[i]])
    }
  }

  /**
   * Observe a list of Array items.
   */
  observeArray (items: Array<any>) {
    for (let i = 0, l = items.length; i < l; i++) {
      observe(items[i])
    }
  }
}






// arrayMethods
/*
 * not type checking this file because flow doesn't play well with
 * dynamically accessing methods on Array prototype
 */

import { def } from '../util/index'

// 原生数组的原型
const arrayProto = Array.prototype
// 数组对象，劫持 7 个原生数组方法
export const arrayMethods = Object.create(arrayProto)
/**
 * Intercept mutating methods and emit events
 */
// 在保证不污染原生数组原型的情况下重写数组方法，截获数组的成员发生的变化，执行原生数组操作的同时 dep 通知关联的所有观察者进行响应式处理
;[
  'push',
  'pop',
  'shift',
  'unshift',
  'splice',
  'sort',
  'reverse'
]
.forEach(function (method) {
  // 缓存原生数组方法
  const original = arrayProto[method]
  def(arrayMethods, method, function mutator () {
    // avoid leaking arguments:
    // http://jsperf.com/closure-with-arguments
    let i = arguments.length
    const args = new Array(i)
    while (i--) {
      args[i] = arguments[i]
    }
    // 调用原生的数组方法执行结果
    const result = original.apply(this, args)

		// 通过 ob 属性获取 Observer 实例
    const ob = this.__ob__
    let inserted
    switch (method) {
      case 'push':
        inserted = args
        break
      case 'unshift':
        inserted = args
        break
      case 'splice':
        inserted = args.slice(2)
        break
    }
    // 数组新插入元素需重新进行 observe
    if (inserted) ob.observeArray(inserted)

    // notify change
    // dep 通知所有注册的观察者进行响应式处理 
    ob.dep.notify()
    return result
    // arrayMethods 做了两件事:
    // 一是通知所有注册的观察者进行响应式处理
    // 二是若是添加成员的操作，需要对新成员进行 observe
    // 注意：修改了数组的原生方法后，还是没法像原生数组一样直接通过数组的下标或者设置 length 来修改数组，但 Vue 提供了 $set() 及 $remove()方法弥补
  })
})
```



##### 1-4-4、defineReactive

defineReactive 作用是通过 Object.defineProperty 为数据定义上 getter\setter 方法，进行依赖收集后闭包中的 Deps 会存放 Watcher 对象。触发 setter 改变数据的时候会通知 Deps 订阅者通知所有的 Watcher 观察者对象进行试图的更新；

- 补充：defineReactive 接收整一个 data 对象，并每一个 key 与与之对应的 value
- 补充：关键理解 Dep，每一个 key 都有自己的 Dep 对象实例，此实例在 getSet 使用；

```js
/**
 * Define a reactive property on an Object.
 */
// defineReactive(obj, keys[i], obj[keys[i]])
export function defineReactive (
  obj: Object,
  key: string,
  val: any,
  customSetter?: Function
) {
  // 获取 Dep 实例
  // 关键理解 Dep，每一个 key 都有自己的 Dep 对象实例，此实例在 getSet 使用
  const dep = new Dep()

  const property = Object.getOwnPropertyDescriptor(obj, key)
  if (property && property.configurable === false) {
    return
  }
	// 若先前该对象已预设 getter 或 setter 函数则将其取出，并在新定义的 getter/setter 中执行，从而避免发生覆盖 
  const getter = property && property.get
  const setter = property && property.set

  // 将当前键值进行 observe 并获取其返回值 new Observer 实例
  // 注意：只在 val 为对象时才如此: observe: if (!isObject(value)) { return }
  // 注意：new Observer 实例化时，执行了 walk 方法，即对 val 的子属性进行 defineReactive，并实例了一个 dep = new Dep
  let childOb = observe(val)
  
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter () {
      // 执行原本对象拥有的 getter 方法
      const value = getter ? getter.call(obj) : val
      
      // 1、执行 new Vue 时，进行 data 代理，data 下的属性的绑定 Observer，此时 Dep.target 也即 Watcher 仍为被实例化，为 undefined
      // 2、随后进行 vue.mount 时，执行了 new Watcher...，此时 Dep.target 不为 undefined，也就在此时进行依赖的收集
      // 3、Dep.target 是全局 watcher 对象
      if (Dep.target) {
        // 进行依赖收集 - 通过闭包传递 dep/watcher 对象
        // 即 Dep.target.addDep(this/dep) -> Watcher.addDep(this/dep) -> dep.addSub(this/watcher) -> this/dep.subs.push(watcher)
        // 通过闭包获取必要参数：watcher 想要 dep，dep 想要 watcher
        dep.depend()
        
        // 子对象也进行依赖收集，实际就是将同一个 watcher 观察者实例放进了两 dep.subs 中，一个是正在本身闭包中的 dep.subs，另一个是子元素的 dep.subs
        if (childOb) { childOb.dep.depend() }
        
        // 数组类型则对每一成员进行依赖收集，若数组的成员还是数组，则递归处理
        if (Array.isArray(value)) { dependArray(value)}
      }
      return value
    },
    
    
    set: function reactiveSetter (newVal) {
      // getter 方法获取当前值
      // 并与新值进行比较，一致则不需要执行下面的操作
      const value = getter ? getter.call(obj) : val
      /* eslint-disable no-self-compare */
      if (newVal === value || (newVal !== newVal && value !== value)) { return }
      
 
      /* eslint-enable no-self-compare */
      if (process.env.NODE_ENV !== 'production' && customSetter) {
        customSetter()
      }
      
      // 若原本对象拥有 setter 方法则执行
      val = setter ? setter.call(obj, newVal) : newVal

      // 新值需要重新进行 observe，保证数据响应式
      childOb = observe(newVal)

      // dep 对象通知所有的观察者
      // 即 subs[i].update() -> watcher.run()
      dep.notify()
    }
  })
}
```





##### 1-4-5、Dep

Dep 是一个发布者，可订阅多个观察者，依赖收集之后，Deps中会存在一或多个 Watcher 对象，在数据变更时通知所有 Watcher；

```js
/**
 * A dep is an observable that can have multiple
 * directives subscribing to it.
 */
export default class Dep {
  static target: ?Watcher;
  id: number;
  subs: Array<Watcher>;

  constructor () {
    this.id = uid++
    this.subs = []
  }

  // 添加一个观察者对象
  addSub (sub: Watcher) {
    this.subs.push(sub)
  }

  // 移除一个观察者对象
  removeSub (sub: Watcher) {
    remove(this.subs, sub)
  }

  // 依赖收集，当存在 Dep.target 时添加观察者对象
  depend () {
    if (Dep.target) {
      // Watcher.addDep
      Dep.target.addDep(this)
    }
  }

  // 通知所有订阅者
  notify () {
    // stabilize the subscriber list first
    const subs = this.subs.slice()
    for (let i = 0, l = subs.length; i < l; i++) {
      // Watcher.update()
      subs[i].update()
    }
  }
}

// the current target watcher being evaluated.
// this is globally unique because there could be only one
// watcher being evaluated at any time.
Dep.target = null
// 依赖收集完需要将 Dep.target 设为 null，防止后面重复添加依赖
```



##### 1-4-6、Watcher

Watcher 是一个观察者对象，依赖收集后 Watcher 对象会被保存在 Deps 中，数据变动时 Deps 会通知 Watcher 实例，然后由实例回调进行视图更新；

```js
export default class Watcher {
  vm: Component;
  expression: string;
  cb: Function;
  id: number;
  deep: boolean;
  user: boolean;
  lazy: boolean;
  sync: boolean;
  dirty: boolean;
  active: boolean;
  deps: Array<Dep>;
  newDeps: Array<Dep>;
  depIds: ISet;
  newDepIds: ISet;
  getter: Function;
  value: any;

  constructor (
    vm: Component,
    expOrFn: string | Function,
    cb: Function,
    options?: Object
  ) {
    this.vm = vm
    // watchers 存放订阅者实例
    vm._watchers.push(this)
    // options
    if (options) {
      this.deep = !!options.deep
      this.user = !!options.user
      this.lazy = !!options.lazy
      this.sync = !!options.sync
    } else {
      this.deep = this.user = this.lazy = this.sync = false
    }
    this.cb = cb
    // uid for batching
    this.id = ++uid
    this.active = true
    // for lazy watchers
    this.dirty = this.lazy 
    // Note
    this.deps = []
    this.newDeps = []
    this.depIds = new Set()
    this.newDepIds = new Set()
    this.expression = process.env.NODE_ENV !== 'production'
      ? expOrFn.toString()
      : ''
    // parse expression for getter
    // 将表达式 expOrFn 解析成 getter
    if (typeof expOrFn === 'function') {
      this.getter = expOrFn
    } else {
      this.getter = parsePath(expOrFn)
      if (!this.getter) {
        this.getter = function () {}
        process.env.NODE_ENV !== 'production' && warn(
          `Failed watching path: "${expOrFn}" ` +
          'Watcher only accepts simple dot-delimited paths. ' +
          'For full control, use a function instead.',
          vm
        )
      }
    }
    this.value = this.lazy
      ? undefined
      : this.get()
  }

  /**
   * Evaluate the getter, and re-collect dependencies.
   */
   // 获得 getter 的值并且重新进行依赖收集
  get () {
    // 将自身 watcher 观察者实例设置给 Dep.target，用以依赖收集
    pushTarget(this)
    let value
    const vm = this.vm

		// 执行了 getter 操作，看似执行了渲染操作，其实是执行了依赖收集; 在将 Dep.target 设置为自生观察者实例以后，执行 getter 操作;
    // 比如: data 中可能有 a、b、c三个数据，getter 渲染需要依赖 a & c，则在执行 getter 时就会触发 a & c 两个数据的 getter 函数，在 getter 函数中即可判断 Dep.target是否存在然后完成依赖收集，将该观察者对象放入闭包中的 Dep 的 subs 中去。
    if (this.user) {
      try {
        value = this.getter.call(vm, vm)
      } catch (e) {
        handleError(e, vm, `getter for watcher "${this.expression}"`)
      }
    } else {
      value = this.getter.call(vm, vm)
    }
    // "touch" every property so they are all tracked as
    // dependencies for deep watching
    // 如果存在 deep，则触发每个深层对象的依赖，追踪其变化
    if (this.deep) {
      // 递归每一个对象或者数组，触发它们的 getter，使得对象或数组的每一个成员都被依赖收集，形成一个 "深(deep)" 依赖关系
      traverse(value)
    }

    // 将观察者实例从 target 栈中取出并设置给 Dep.target
    popTarget()
    this.cleanupDeps()
    return value
  }

  /**
   * Add a dependency to this directive.
   */
   // 添加一个依赖关系到 Deps 集合中
  addDep (dep: Dep) {
    const id = dep.id
    if (!this.newDepIds.has(id)) {
      this.newDepIds.add(id)
      this.newDeps.push(dep)
      if (!this.depIds.has(id)) {
        dep.addSub(this)
      }
    }
  }

  /**
   * Clean up for dependency collection.
   */
   // 清理依赖收集
  cleanupDeps () {
    // 移除所有观察者对象
    let i = this.deps.length
    while (i--) {
      const dep = this.deps[i]
      if (!this.newDepIds.has(dep.id)) {
        dep.removeSub(this)
      }
    }
    let tmp = this.depIds
    this.depIds = this.newDepIds
    this.newDepIds = tmp
    this.newDepIds.clear()
    tmp = this.deps
    this.deps = this.newDeps
    this.newDeps = tmp
    this.newDeps.length = 0
  }

  /**
   * Subscriber interface.
   * Will be called when a dependency changes.
   */
  // 调度者接口，当依赖发生改变的时候进行回调
  update () {
    /* istanbul ignore else */
    if (this.lazy) {
      this.dirty = true
    } else if (this.sync) {
      // 同步则执行 run 直接渲染视图
      this.run()
    } else {
      // 异步推送到观察者队列中，由调度者调用
      queueWatcher(this)
    }
  }

  /**
   * Scheduler job interface.
   * Will be called by the scheduler.
   */
	// 调度者工作接口，将被调度者回调
  run () {
    if (this.active) {
      const value = this.get()
      if (
        value !== this.value ||
        // Deep watchers and watchers on Object/Arrays should fire even
        // when the value is the same, because the value may
        // have mutated.
        // 即便值相同，拥有 Deep 属性的观察者以及在对象／数组上的观察者应该被触发更新，因它们的值可能发生改变。
        isObject(value) ||
        this.deep
      ) {
        // set new value
        const oldValue = this.value
        // 设置新的值
        this.value = value

        // 触发回调渲染视图
        if (this.user) {
          try {
            this.cb.call(this.vm, value, oldValue)
          } catch (e) {
            handleError(e, this.vm, `callback for watcher "${this.expression}"`)
          }
        } else {
          this.cb.call(this.vm, value, oldValue)
        }
      }
    }
  }

  /**
   * Evaluate the value of the watcher.
   * This only gets called for lazy watchers.
   */
   /*获取观察者的值*/
  evaluate () {
    this.value = this.get()
    this.dirty = false
  }

  /**
   * Depend on all deps collected by this watcher.
   */
  // 收集该 watcher 的所有 deps 依赖
  depend () {
    let i = this.deps.length
    while (i--) {
      this.deps[i].depend()
    }
  }

  /**
   * Remove self from all dependencies' subscriber list.
   */
  // 将自身从所有依赖收集订阅列表删除
  teardown () {
    if (this.active) {
      // remove self from vm's watcher list
      // this is a somewhat expensive operation so we skip it
      // if the vm is being destroyed.
      /*从vm实例的观察者列表中将自身移除，由于该操作比较耗费资源，所以如果vm实例正在被销毁则跳过该步骤。*/
      if (!this.vm._isBeingDestroyed) {
        remove(this.vm._watchers, this)
      }
      let i = this.deps.length
      while (i--) {
        this.deps[i].removeSub(this)
      }
      this.active = false
    }
  }
}
```



##### 1-4-7、DOM Diff

##### 1-4-7-1、Real DOM

`webkit` 渲染引擎工作流程图：

<img src="/Image/Frame/Vue/32.png" style="zoom:50%;" />

所有的浏览器渲染引擎工作流程大致分为5步：创建  `DOM` 树 —> 创建 `Style Rules` -> 构建 `Render` 树 —> 布局 `Layout` -—> 绘制 `Painting`：

- 第一步，构建 DOM 树：用 HTML 分析器，分析 HTML 元素，构建一棵 DOM 树；
- 第二步，生成样式表：用 CSS 分析器，分析 CSS 文件和元素上的 inline 样式，生成页面的样式表；
- 第三步，构建 Render 树：将 DOM 树和样式表关联起来，构建一棵 Render 树（Attachment）。每个 DOM 节点都有 attach 方法，接受样式信息，返回一个 render 对象（又名 renderer），这些 render 对象最终会被构建成一棵 Render 树；
- 第四步，确定节点坐标：根据 Render 树结构，为每个 Render 树上的节点确定一个在显示屏上出现的精确坐标；
- 第五步，绘制页面：根据 Render 树和节点显示坐标，然后调用每个节点的 paint 方法，将它们绘制出来。
  - 注意：DOM 树的构建是文档加载完成开始的？ 
    - 构建 `DOM` 树是一个渐进过程，为达到更好的用户体验，渲染引擎会尽快将内容显示在屏幕上，它不必等到整个 `HTML` 文档解析完成之后才开始构建 `render` 树和布局；
  - 注意：Render 树是 `DOM` 树和 `CSS` 样式表构建完毕后才开始构建的？ 
    - 这三个过程在实际进行的时候并不是完全独立的，而是会有交叉，会一边加载，一边解析，以及一边渲染。
  - 注意：CSS 的解析注意点？
    -  `CSS` 的解析是从右往左逆向解析的，嵌套标签越多，解析越慢；
  - 注意：JS 操作真实 `DOM` 的代价？
    -  用传统的开发模式，原生 `JS` 或 `JQ` 操作 `DOM` 时，浏览器会从构建 DOM 树开始从头到尾执行一遍流程；
    - 比如：在一次操作中，需要更新 10 个 `DOM` 节点，浏览器收到第一个 `DOM` 请求后并不知道还有 9 次更新操作，因此会马上执行流程，最终执行10 次
    - 第一次计算完，紧接着下一个 `DOM` 更新请求，这个节点的坐标值就变了，前一次计算为无用功；计算 `DOM` 节点坐标值等都是白白浪费的性能。即使计算机硬件一直在迭代更新，操作 `DOM` 的代价仍旧是昂贵的，频繁操作还是会出现页面卡顿，影响用户体验；



##### 1-4-7-2、Virtual DOM

**<u>*虚拟 DOM 诞生意义*</u>**：就是为了解决浏览器性能问题而被设计出来；

- 比如，若一次操作中有 10 次更新 `DOM` 的动作，虚拟 `DOM` 不会立即操作 `DOM`，而是将这 10 次更新的 `diff` 内容保存到本地一个 `JS` 对象中，最终将这个 `JS` 对象一次性 `attch` 到 `DOM` 树上，再进行后续操作，避免大量无谓的计算量；
- 所以，用 `JS` 对象模拟 `DOM` 节点的好处是，页面更新可先全部反映在 `JS` 对象(虚拟 `DOM` )上，操作内存中的 `JS` 对象的速度显然要更快，等更新完成后，再将最终的 `JS` 对象映射成真实的 `DOM`，交由浏览器去绘制；

**<u>*虚拟 DOM 算法实现：*</u>**

- **<u>*1、用 JS 对象模拟 DOM 树*</u>**，并渲染用此对象表示的 DOM 树：

  - ```js
    // 伪码
    var el = require("./element.js");
    var ul = el('div',{id:'virtual-dom'},[
      el('p',{},['Virtual DOM']),
      el('ul', { id: 'list' }, [
    	el('li', { class: 'item' }, ['Item 1']),
    	el('li', { class: 'item' }, ['Item 2']),
    	el('li', { class: 'item' }, ['Item 3'])
      ]),
      el('div',{},['Hello World'])
    ]) 
    
    // 伪码
    Element.prototype.render = function () {
        var el = document.createElement(this.tagName)
        var props = this.props
        // 设置节点的 DOM 属性
        for (var propName in props) {
            var propValue = props[propName]
            el.setAttribute(propName, propValue)
        }
    
        var children = this.children || []
        children.forEach(function (child) {
            var childEl = (child instanceof Element)
                ? child.render() // 若子节点也是虚拟DOM，则递归构建
                : document.createTextNode(child) // 若字符串，只构建文本节点
            el.appendChild(childEl)
        })
        return el
    } 
    ```

- **<u>*2、通过 Diff 算法比较两棵虚拟 DOM 树差异*</u>**

  - 注意：完全比较复杂度会达到 O(n^3)，而前端中很少会跨越层级地移动 `DOM` 元素，故 `Virtual DOM` 只对同一层级元素进行对比，可将复杂度降至 O(n)

  - **<u>*首先*</u>**，深度优先遍历，记录差异：

    - 对新旧两棵树进行一个深度优先的遍历，这样每个节点都会有一个唯一的标记；

    - 在深度优先遍历的时候，每遍历到一个节点就把该节点和新的的树进行对比；若有差异的话就记录到一个对象中

    - <img src="/Image/Frame/Vue/33.png" style="zoom:50%;" align="left"/>

    - ```js
      // diff 函数，对比两棵树
      function diff(oldTree, newTree) {
        var index = 0 // 当前节点的标志
        var patches = {} // 用来记录每个节点差异的对象
        dfsWalk(oldTree, newTree, index, patches)
        return patches
      }
      
      // 对两棵树进行深度优先遍历
      function dfsWalk(oldNode, newNode, index, patches) {
        var currentPatch = []
        if (typeof (oldNode) === "string" && typeof (newNode) === "string") {
          // 文本内容改变
          if (newNode !== oldNode) {
            currentPatch.push({ type: patch.TEXT, content: newNode })
          }
        } else if (newNode!=null && oldNode.tagName === newNode.tagName && oldNode.key === newNode.key) {
          // 节点相同，比较属性
          var propsPatches = diffProps(oldNode, newNode)
          if (propsPatches) {
            currentPatch.push({ type: patch.PROPS, props: propsPatches })
          }
          // 比较子节点，如果子节点有'ignore'属性，则不需要比较
          if (!isIgnoreChildren(newNode)) {
            diffChildren(
              oldNode.children,
              newNode.children,
              index,
              patches,
              currentPatch
            )
          }
        } else if(newNode !== null){
          // 新节点和旧节点不同，用 replace 替换
          currentPatch.push({ type: patch.REPLACE, node: newNode })
        }
      
        if (currentPatch.length) {
          patches[index] = currentPatch
        }
      } 
      ```

  - **<u>*然后*</u>**，差异类型：DOM 操作导致的差异类型包括以下几种：

    - 节点替换：节点改变了，例如将上面的 `div` 换成 `h1`;

    - 顺序互换：移动、删除、新增子节点，例如上面 `div` 的子节点，把 `p` 和 `ul` 顺序互换；

    - 属性更改：修改了节点的属性，例如把上面 `li` 的 `class` 样式类删除；

    - 文本改变：改变文本节点的文本内容，例如将上面 `p` 节点的文本内容更改为 “`Real Dom`”；

    - ```js
      var REPLACE = 0 // 替换原先的节点
      var REORDER = 1 // 重新排序
      var PROPS = 2 // 修改了节点的属性
      var TEXT = 3 // 文本内容改变 
      ```

  - **<u>*然后*</u>**，列表对比算法

    - 比如：`p, ul, div` 顺序换成了 `div, p, ul`；若按同层级进行顺序对比，则都会被替换掉；这样 DOM 开销非常大；而实际上是不需要替换的节点，而只需要经过节点移动就可达到，即只需知道怎么进行移动；
    - 解决：问题可抽象为：字符串的最小编辑距离问题 (`Edition Distance`)，最常见解决方法是： `Levenshtein Distance` ；其是一个度量两个字符序列之间差异的字符串度量标准，两个单词间的 `Levenshtein Distance` 是将一个单词转换为另一个单词所需的单字符编辑(插入、删除或替换)的最小数量。`Levenshtein Distance` 是1965 年由苏联数学家 Vladimir Levenshtein 发明；`Levenshtein Distance` 也被称为编辑距离（`Edit Distance`），通过动态规划求解，时间复杂度为 `O(M*N)`；
    - 比如：对于两个字符串 `a、b`，则他们的 `Levenshtein Distance` 为：
      - <img src="/Image/Frame/Vue/35.png" style="zoom:50%;" align="left"/>
    - 示例：字符串 `a` 和 `b`，`a=“abcde” ，b=“cabef”`，根据上面给出的计算公式，则他们的 `Levenshtein Distance` 的计算过程如下：
      - <img src="/Image/Frame/Vue/34.png" style="zoom:50%;" align="left"/>

  - **<u>*最后*</u>**，实例输出

    - ```js
      // 伪码
      // 其中 ul1 表示原有的虚拟 DOM 树，ul2 表示改变后的虚拟 DOM 树
      var ul1 = el('div',{id:'virtual-dom'},[
        el('p',{},['Virtual DOM']),
        el('ul', { id: 'list' }, [
      	el('li', { class: 'item' }, ['Item 1']),
      	el('li', { class: 'item' }, ['Item 2']),
      	el('li', { class: 'item' }, ['Item 3'])
        ]),
        el('div',{},['Hello World'])
      ]) 
      var ul2 = el('div',{id:'virtual-dom'},[
        el('p',{},['Virtual DOM']),
        el('ul', { id: 'list' }, [
      	el('li', { class: 'item' }, ['Item 21']),
      	el('li', { class: 'item' }, ['Item 23'])
        ]),
        el('p',{},['Hello World'])
      ]) 
      var patches = diff(ul1,ul2);
      console.log('patches:',patches);
      ```

    - <img src="/Image/Frame/Vue/36.png" style="zoom:50%;" align="left"/>

- **<u>*3、通过 patch 将两个虚拟 DOM 对象的差异应用到真正的 DOM 树*</u>**

  - 首先，深度优先遍历 DOM 树

    - ```js
      // 伪码
      function patch (node, patches) {
        var walker = {index: 0}
        dfsWalk(node, walker, patches)
      }
      
      function dfsWalk (node, walker, patches) {
        // 从patches拿出当前节点的差异
        var currentPatches = patches[walker.index]
      
        var len = node.childNodes
          ? node.childNodes.length
          : 0
        // 深度遍历子节点
        for (var i = 0; i < len; i++) {
          var child = node.childNodes[i]
          walker.index++
          dfsWalk(child, walker, patches)
        }
        // 对当前节点进行DOM操作
        if (currentPatches) {
          applyPatches(node, currentPatches)
        }
      } 
      ```

  - 然后，对原有 DOM 树进行 DOM 操作

    - ```js
      // 伪码
      function applyPatches (node, currentPatches) {
        currentPatches.forEach(currentPatch => {
          switch (currentPatch.type) {
            case REPLACE:
              var newNode = (typeof currentPatch.node === 'string')
                ? document.createTextNode(currentPatch.node)
                : currentPatch.node.render()
              node.parentNode.replaceChild(newNode, node)
              break
            case REORDER:
              reorderChildren(node, currentPatch.moves)
              break
            case PROPS:
              setProps(node, currentPatch.props)
              break
            case TEXT:
              node.textContent = currentPatch.content
              break
            default:
              throw new Error('Unknown patch type ' + currentPatch.type)
          }
        })
      } 
      ```

  - 最后，DOM 结构改变



##### 1-4-7-3、VNode Created

Vue 中，Virtual DOM 是用 VNode 这个 Class 去描述，实际上 `Vue.js` 中 `Virtual DOM` 是借鉴了一个开源库  [snabbdom](https://github.com/snabbdom/snabbdom) ，然后加入自身的一些特性实现：

```js
export default class VNode {
  tag: string | void;
  data: VNodeData | void;
  children: ?Array<VNode>;
  text: string | void;
  elm: Node | void;
  ns: string | void;
  context: Component | void; // rendered in this component's scope
  key: string | number | void;
  componentOptions: VNodeComponentOptions | void;
  componentInstance: Component | void; // component instance
  parent: VNode | void; // component placeholder node

  // strictly internal
  raw: boolean; // contains raw HTML? (server only)
  isStatic: boolean; // hoisted static node
  isRootInsert: boolean; // necessary for enter transition check
  isComment: boolean; // empty comment placeholder?
  isCloned: boolean; // is a cloned node?
  isOnce: boolean; // is a v-once node?
  asyncFactory: Function | void; // async component factory function
  asyncMeta: Object | void;
  isAsyncPlaceholder: boolean;
  ssrContext: Object | void;
  fnContext: Component | void; // real context vm for functional nodes
  fnOptions: ?ComponentOptions; // for SSR caching
  devtoolsMeta: ?Object; // used to store functional render context for devtools
  fnScopeId: ?string; // functional scope id support

  constructor (
    tag?: string,
    data?: VNodeData,
    children?: ?Array<VNode>,
    text?: string,
    elm?: Node,
    context?: Component,
    componentOptions?: VNodeComponentOptions,
    asyncFactory?: Function
  ) {
    this.tag = tag
    this.data = data
    this.children = children
    this.text = text
    this.elm = elm
    this.ns = undefined
    this.context = context
    this.fnContext = undefined
    this.fnOptions = undefined
    this.fnScopeId = undefined
    this.key = data && data.key
    this.componentOptions = componentOptions
    this.componentInstance = undefined
    this.parent = undefined
    this.raw = false
    this.isStatic = false
    this.isRootInsert = true
    this.isComment = false
    this.isCloned = false
    this.isOnce = false
    this.asyncFactory = asyncFactory
    this.asyncMeta = undefined
    this.isAsyncPlaceholder = false
  }
}
```

- `text` 属性是文本属性；
- `children` 属性是`vnode`的子节点；
- `tag` 属性即这个`vnode`的标签属性；
- `elm` 属性为这个`vnode`对应的真实`dom`节点；
- `key` 属性是`vnode`的标记，在`diff`过程中可以提高`diff`的效率；
- `data` 属性包含了最后渲染成真实`dom`节点后，节点上的`class`，`attribute`，`style`以及绑定的事件；

```js
// 1、初始化 Vue
function Vue (options) {
  if (process.env.NODE_ENV !== 'production' &&
    !(this instanceof Vue)
  ) {
    warn('Vue is a constructor and should be called with the `new` keyword')
  }
  this._init(options)
}

// ... 

// 2、通过 $mount 实例方法去挂载 dom，$mount 会调用原型上的方法
Vue.prototype._init = function (options?: Object) {
  const vm: Component = this

  // ....

  if (vm.$options.el) {
    console.log('vm.$options.el:',vm.$options.el);
    vm.$mount(vm.$options.el)
  }
}

// ... 

const mount = Vue.prototype.$mount
Vue.prototype.$mount = function (
  el?: string | Element,
  hydrating?: boolean
): Component {
  el = el && query(el)
  
   // ...
  return mount.call(this, el, hydrating)
}

// ...

// 3、$mount 方法实际上会去调用 mountComponent 方法，而 mountComponent 核心就是: 
// 先实例化一个渲染 Watcher，在其回调函数中会调用 updateComponent 方法，在此方法中调用 vm._render 方法先生成虚拟 Node，最终调用 vm._update 更新 DOM
Vue.prototype.$mount = function (
  el?: string | Element,
  hydrating?: boolean
): Component {
  el = el && inBrowser ? query(el) : undefined
  return mountComponent(this, el, hydrating)
}

export function mountComponent (
  vm: Component,
  el: ?Element,
  hydrating?: boolean
): Component {
  vm.$el = el

  // ...
  
  let updateComponent
  /* istanbul ignore if */
  if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
    updateComponent = () => {
      // 生成虚拟 VNode   
      const vnode = vm._render()
      // 更新 DOM
      vm._update(vnode, hydrating)
     
    }
  } else {
    updateComponent = () => {
      vm._update(vm._render(), hydrating)
    }
  }

  // 实例化一个渲染 Watcher，在它的回调函数中会调用 updateComponent 方法  
  new Watcher(vm, updateComponent, noop, {
    before () {
      if (vm._isMounted && !vm._isDestroyed) {
        callHook(vm, 'beforeUpdate')
      }
    }
  }, true /* isRenderWatcher */)
  hydrating = false

  return vm
}

// ...

// 4、创建 VNode
// Vue 的 _render 方法是实例的一个私有方法，它用来把实例渲染成一个虚拟 Node
// Vue 利用 _createElement 方法创建 VNode
Vue.prototype._render = function (): VNode {
  const vm: Component = this
  const { render, _parentVnode } = vm.$options
  let vnode
  try {
    // ...
    currentRenderingInstance = vm
    // 调用 createElement 方法来返回 vnode
    vnode = render.call(vm._renderProxy, vm.$createElement)
  } catch (e) {
    handleError(e, vm, `render`){}
  }
  // set parent
  vnode.parent = _parentVnode
  console.log("vnode...:",vnode);
  return vnode
}

// _createElement 方法有 5 个参数
// context 表示 VNode 的上下文环境，它是 Component 类型；
// tag 表示标签，它可以是一个字符串，也可以是一个 Component；
// data 表示 VNode 的数据，它是一个 VNodeData 类型；
// children 表示当前 VNode 的子节点，它是任意类型的，需要被规范为标准的 VNode 数组；
export function _createElement (
  context: Component,
  tag?: string | Class<Component> | Function | Object,
  data?: VNodeData,
  children?: any,
  normalizationType?: number
): VNode | Array<VNode> {
    
  // ...
  
  if (normalizationType === ALWAYS_NORMALIZE) {
    // 场景是 render 函数不是编译生成的
    children = normalizeChildren(children)
  } else if (normalizationType === SIMPLE_NORMALIZE) {
    // 场景是 render 函数是编译生成的
    children = simpleNormalizeChildren(children)
  }
  let vnode, ns
  if (typeof tag === 'string') {
    let Ctor
    ns = (context.$vnode && context.$vnode.ns) || config.getTagNamespace(tag)
    if (config.isReservedTag(tag)) {
      // 创建虚拟 VNode
      vnode = new VNode(
        config.parsePlatformTagName(tag), data, children,
        undefined, undefined, context
      )
    } else if ((!data || !data.pre) && isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {
      // component
      vnode = createComponent(Ctor, data, context, children, tag)
    } else {
      vnode = new VNode(
        tag, data, children,
        undefined, undefined, context
      )
    }
  } else {
    vnode = createComponent(tag, data, context, children)
  }
  if (Array.isArray(vnode)) {
    return vnode
  } else if (isDef(vnode)) {
    if (isDef(ns)) applyNS(vnode, ns)
    if (isDef(data)) registerDeepBindings(data)
    return vnode
  } else {
    return createEmptyVNode()
  }
}


// 5、效果演示
var app = new Vue({
  el: '#app',
  render: function (createElement) {
    return createElement('div', {
      attrs: {
        id: 'app',
        class: "class_box"
      },
    }, this.message)
  },
  data: {
    message: 'Hello Vue!'
  }
})
```

<img src="/Image/Frame/Vue/28.png" style="zoom:50%;" align="left" />



##### 1-4-7-4、Diff Process

```js
// 1、change -> dep.notify -> updateComponent(视图更新)
export function mountComponent (
  vm: Component,
  el: ?Element,
  hydrating?: boolean
): Component {
  vm.$el = el
  // ...
  let updateComponent
  /* istanbul ignore if */
  if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
    updateComponent = () => {
      // 生成虚拟 VNode   
      const vnode = vm._render()
      // 更新 DOM
      vm._update(vnode, hydrating)
     
    }
  } else {
    updateComponent = () => {
      vm._update(vm._render(), hydrating)
    }
  }

  // 实例化一个渲染Watcher，在它的回调函数中会调用 updateComponent 方法  
  new Watcher(vm, updateComponent, noop, {
    before () {
      if (vm._isMounted && !vm._isDestroyed) {
        callHook(vm, 'beforeUpdate')
      }
    }
  }, true /* isRenderWatcher */)
  hydrating = false

  return vm
}

// 2、完成视图的更新工作事实上就是调用了 vm._update 方法，方法接收的第一个参数是刚生成的 Vnode
// 关键是 vm.__patch__ 方法，此亦整个 virtual-dom 中最为核心方法，主要完成了 prevVnode 和 vnode 的 diff 过程并根据需要操作的 vdom 节点打 patch，最后生成新的真实 dom 节点并完成视图的更新工作
Vue.prototype._update = function (vnode: VNode, hydrating?: boolean) {
  const vm: Component = this
  const prevEl = vm.$el
  const prevVnode = vm._vnode
  const restoreActiveInstance = setActiveInstance(vm)
  vm._vnode = vnode
  if (!prevVnode) {
    // 第一个参数为真实的 node 节点，则为初始化
    vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */)
  } else {
    // 若需要 diff 的 prevVnode 存在，则对 prevVnode 和 vnode 进行 diff
    vm.$el = vm.__patch__(prevVnode, vnode)
  }
  restoreActiveInstance()
  // update __vue__ reference
  if (prevEl) {
    prevEl.__vue__ = null
  }
  if (vm.$el) {
    vm.$el.__vue__ = vm
  }
  // if parent is an HOC, update its $el as well
  if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
    vm.$parent.$el = vm.$el
  }
}


// patch 过程中会调用 sameVnode 方法来对传入的2个 vnode 进行基本属性的比较，只有当基本属性相同的情况下才认为这个2个 vnode 只是局部发生了更新，然后才会对这 2 个 vnode 进行 diff，若 vnode 的基本属性存在不一致的情况，则直接跳过 diff 过程，进而依据 vnode 新建一个真实的 dom，同时删除老的 dom节点
function patch (oldVnode, vnode, hydrating, removeOnly) {
    // ......
    if (isUndef(oldVnode)) {
      // 当 oldVnode 不存在时，创建新的节点
      isInitialPatch = true
      createElm(vnode, insertedVnodeQueue)
    } else {
      // 对 oldVnode 和 vnode 进行 diff，并对 oldVnode 打 patch  
      const isRealElement = isDef(oldVnode.nodeType)
      if (!isRealElement && sameVnode(oldVnode, vnode)) {
        // patch existing root node
        patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly)
      } 
	// ......
  }
}
function sameVnode (a, b) {
  return (
    a.key === b.key &&
    a.tag === b.tag &&
    a.isComment === b.isComment &&
    isDef(a.data) === isDef(b.data) &&
    sameInputType(a, b)
  )
}

// 3、diff 过程中主要是通过调用 patchVnode 方法进行
// diff 过程中又分了好几种情况: oldCh 为 oldVnode 的子节点，ch 为 Vnode 的子节点：
// 首先, 进行文本节点的判断，若 oldVnode.text !== vnode.text，则直接进行文本节点的替换；
// 然后, 在 vnode 没有文本节点情况下，进入子节点的 diff；
// 	当 oldCh 和 ch 都存在且不相同的情况下，调用 updateChildren 对子节点进行 diff；
// 	若 oldCh 不存在，ch 存在，首先清空 oldVnode 的文本节点，同时调用 addVnodes 方法将 ch 添加到 elm 真实 dom 节点当中；
// 	若 oldCh 存在，ch不存在，则删除 elm 真实节点下的 oldCh 子节点；
// 	若 oldVnode 有文本节点，而 vnode 没有，那么就清空这个文本节点。
function patchVnode (oldVnode, vnode, insertedVnodeQueue, ownerArray, index, removeOnly) {
  // ...... 
  const elm = vnode.elm = oldVnode.elm
  const oldCh = oldVnode.children
  const ch = vnode.children
  // 若 vnode 没有文本节点
  if (isUndef(vnode.text)) {
    // 若 oldVnode 的 children 属性存在且 vnode 的 children 属性也存在  
    if (isDef(oldCh) && isDef(ch)) {
      // updateChildren，对子节点进行 diff  
      if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly)
    } else if (isDef(ch)) {
      if (process.env.NODE_ENV !== 'production') {
        checkDuplicateKeys(ch)
      }
      // 若 oldVnode 的 text 存在，则首先清空 text 内容, 然后将 vnode 的 children 添加进去  
      if (isDef(oldVnode.text)) nodeOps.setTextContent(elm, '')
      addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue)
    } else if (isDef(oldCh)) {
      // 删除 elm 下的 oldchildren
      removeVnodes(elm, oldCh, 0, oldCh.length - 1)
    } else if (isDef(oldVnode.text)) {
      // oldVnode 有子节点，而 vnode 没有，则清空这个节点  
      nodeOps.setTextContent(elm, '')
    }
  } else if (oldVnode.text !== vnode.text) {
    // 若 oldVnode 和 vnode 文本属性不同，则直接更新真实 dom 节点的文本元素
    nodeOps.setTextContent(elm, vnode.text)
  }
  // ......
}


function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
  // 为 oldCh 和 newCh 分别建立索引，为之后遍历的依据
  // 开始遍历 diff 前，首先给 oldCh 和 newCh 分别分配一个 startIndex 和 endIndex 来作为遍历的索引
  let oldStartIdx = 0
  let newStartIdx = 0
  let oldEndIdx = oldCh.length - 1
  let oldStartVnode = oldCh[0]
  let oldEndVnode = oldCh[oldEndIdx]
  let newEndIdx = newCh.length - 1
  let newStartVnode = newCh[0]
  let newEndVnode = newCh[newEndIdx]
  let oldKeyToIdx, idxInOld, vnodeToMove, refElm

  // 直到 oldCh 或 newCh 被遍历完后跳出循环
  // 当 oldCh 或 newCh 遍历完后(遍历完的条件就是 oldCh 或 newCh 的 startIndex >= endIndex)，就停止 oldCh 和 newCh 的 diff 过程
  while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
    if (isUndef(oldStartVnode)) {
      oldStartVnode = oldCh[++oldStartIdx] // Vnode has been moved left
    } else if (isUndef(oldEndVnode)) {
      oldEndVnode = oldCh[--oldEndIdx]
    } else if (sameVnode(oldStartVnode, newStartVnode)) {
      patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)
      oldStartVnode = oldCh[++oldStartIdx]
      newStartVnode = newCh[++newStartIdx]
    } else if (sameVnode(oldEndVnode, newEndVnode)) {
      patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)
      oldEndVnode = oldCh[--oldEndIdx]
      newEndVnode = newCh[--newEndIdx]
    } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right
      patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)
      canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))
      oldStartVnode = oldCh[++oldStartIdx]
      newEndVnode = newCh[--newEndIdx]
    } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left
      patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)
      canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)
      oldEndVnode = oldCh[--oldEndIdx]
      newStartVnode = newCh[++newStartIdx]
    } else {
      if (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)
      idxInOld = isDef(newStartVnode.key)
        ? oldKeyToIdx[newStartVnode.key]
      : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx)
      if (isUndef(idxInOld)) { // New element
        createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx)
      } else {
        vnodeToMove = oldCh[idxInOld]
        if (sameVnode(vnodeToMove, newStartVnode)) {
          patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)
          oldCh[idxInOld] = undefined
          canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)
        } else {
          // same key but different element. treat as new element
          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx)
        }
      }
      newStartVnode = newCh[++newStartIdx]
    }
  }
  if (oldStartIdx > oldEndIdx) {
    refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm
    addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)
  } else if (newStartIdx > newEndIdx) {
    removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)
  }
}
```

- 无 key Diff
- <img src="/Image/Frame/Vue/30.png" style="zoom:50%;" align="left"/>
- 有 key Diff
- <img src="/Image/Frame/Vue/31.png" style="zoom:50%;" align="left"/>



##### 1-4-7-4、Path Process

```js
// 观察上述代码知，通过 nodeOps 相关的方法对真实 DOM 结构进行操作
export function createElementNS (namespace: string, tagName: string): Element {
  return document.createElementNS(namespaceMap[namespace], tagName)
}

export function createTextNode (text: string): Text {
  return document.createTextNode(text)
}

export function createComment (text: string): Comment {
  return document.createComment(text)
}

export function insertBefore (parentNode: Node, newNode: Node, referenceNode: Node) {
  parentNode.insertBefore(newNode, referenceNode)
}

export function removeChild (node: Node, child: Node) {
  node.removeChild(child)
}

```



##### 1-4-7-X、总结

<img src="/Image/Frame/Vue/29.png" style="zoom:50%;" align="left" />

当数据发生改变时，set 方法会触发 Dep.notify 方法，通知所有订阅者 Watcher，订阅者就会调用 patch 给真实 DOM 打补丁，更新相应视图：

<img src="/Image/Frame/Vue/18.png" style="zoom:50%;" align="" />

**<u>*patch 过程：涉及 DOM Diff 过程*</u>**：DOM Diff 找到并只更新差异部分的 DOM，以减少更新量，提升效率；

- **<u>*同层比较：Diff 比较基础*</u>**。只有两个新旧节点是相同节点时，才会去比较各自子节点(另：最大的根节点一开始可直接比较)；
- 新旧节点：所有新旧节点均为 VNode 节点，使用此类型节点进行比较而不用 DOM 可无视平台限制，比较完成使用平台方法处理即可；
- 相同父级：只有相同父节点才能进行比较，没有则无法实现：
  - <img src="/Image/Frame/Vue/19.png" style="zoom:50%;" align="left" />
  - <img src="/Image/Frame/Vue/20.png" style="zoom:50%;" align="left" />
- **<u>*节点复用：Diff 比较内核*</u>**。建立在上述基础之上。Diff 比较是为了在新旧节点中找到相同节点，所以节点复用，找到相同节点而非无限递归查找；
  - 不同父节点无法复用：
    - <img src="/Image/Frame/Vue/21.png" style="zoom:50%;" align="left" />
    - <img src="/Image/Frame/Vue/22.png" style="zoom:50%;" align="left" />
  - 同级且父节点一致才可复用：
    - <img src="/Image/Frame/Vue/23.png" style="zoom:50%;" align="left" />

**<u>*DOM Diff 比较逻辑：*</u>**

- 比较处理流程：
  - 在新旧节点中
    1. 首先，找到 不需要移动的相同节点，消耗最小；
    2. 然后，再找相同但是需要移动的节点，消耗次小；
    3. 最后，找不到才会去新建/删除节点，保底处理；
- 比较是为修改 DOM 树：
  - 存在三种树：页面 DOM 树、旧 VNode 树、新 Vnode 树；
  - 页面 DOM 树与旧 VNode  树节点一一对应，而新 Vnode 树则是表示更新后页面 DOM 树 该有的样子
  - 注意：在旧 Vnode 树与新 Vnode 树 进行比较过程中：不会对此两棵 Vode 树进行修改，而是以比较的结果，直接对真实 DOM 进行修改
  - 比如：旧 Vnode 树同一层中，找到和新 Vnode 树 中一样但位置不一样节点，此时需要移动此节点，但不是移动旧 Vnode 树中节点，而是直接移动 DOM
  - 总之：新旧 Vnode 树是拿来比较，页面 DOM 树是拿来根据比较结果修改；

**<u>*DOM Diff 比较示例*</u>**：

<img src="/Image/Frame/Vue/24.png" style="zoom:50%;" align="left" />

首轮，父节点相同，符合规则，进行子节点比较，进行第一流程：先找无需移动的相同节点，找到节点 2，根据比较结果，无需修改 DOM，DOM 保留原位置；

<img src="/Image/Frame/Vue/25.png" style="zoom:50%;" align="left" />

二轮，再无<u>相同且无需移动的节点</u>，进行第二流程：找<u>相同但是需要移动的节点</u>，找到节点 5，根据比较结果，需要移动 DOM；

<img src="/Image/Frame/Vue/26.png" style="zoom:50%;" align="left" />

三轮，无相同节点，进行流程三，新建或删除节点，在旧 Vnode 中，若新 Vnode 不存在的节点要删除，在新 Vnode 中，旧 Vnode 不存在节点要新建；

<img src="/Image/Frame/Vue/27.png" style="zoom:50%;" align="left" />

最后，页面更新完毕；



**<u>*DOM Diff 总结：*</u>**

关键：一JS 模拟 DOM 树(虚拟DOM)、二比较虚拟DOM树差异，三将差异应用真正DOM上；

思想：Vue 虚拟DOM思想，初次渲染或更新都用 JSAST 将 DOM 化为虚拟 DOM 树，若为更新则按照一定规则(DIff)比对前后虚拟DOM树变化，随后将变化结果应用到真正DOM树上；

初次流程：vue.init 初始化、vm.$mounnt 挂载->return mountCompent(this, el, …)->实例化Watcher，然后再在里面调用 updateComponent -> vm.render 将实例渲染为 VNode(虚拟Node)(使用 createElement 创建 VNode)-> vm.update (vnode, …)->`vm.__patch__`(核心方法，完成 preVnode(旧VNode) 与 vnode (新VNode) 的 diff 过程并根据需要操作的 vdom 节点打 patch，最后生成新的真实DOM以完成视图更新操作)；

- `vm.__patch__`：先用 sameVnode 比对新旧Vnode的基本属性，若相同则认为发生局部更新，然后进行 diff，若不同则直接跳过 diff 过程，根据 vnode 新建一个真实 DOM，同时删除 旧 dom 节点；
- diff：主要通过调用 patchVNode 进行：
- 首先，进行文本节点的判断，若oldVnode.text !== vnode.text 则直接进行文本节点的替换==>nodeOps.setTextContent(elm, vnode.text)
- 然后，若非文本节点，则进入子节点 diff，
- 其他，若 oldVnode 子节点和 vnode 子节点均存在但不相同时，调用 updateChildren 对子节点进行 diff；
- 其他，若 oldVnode 子节点不存在但 vnode 子节点存在，则清空 oldVnode 文本节点，同时调用 addVnodes 将 vnode 子节点添加到 el 真实 dom 节点中；
- 其他，若 oldVnode 子节点存在，但 vnode 子节点不存在，则删除 elm 真实节点下的 oldVnode 子节点；
- 其他，若 oldVnode 有文本节点，但 vnode 没有，则清空此文本节点；

更新流程：调用响应式数据所维护的 dep，随后调用 dep.notify 方法，其中包含 updateComponent…此后流程同上；









##### 1-4-X、总结

<img src="/Image/Frame/Vue/2.png" style="zoom:50%;" align="" />

**<u>*首先*</u>**，initData，获取 data 的 key，并获取 props，并确保 props 优先，不能与 data 重复，并判断是否保留字段，并将 data 属性代理到 vm 实例上(即 vm.key == vm._data.key)，随后进行 observer(data) 数据绑定操作；

然后，new Observer(data)(对数组方法及数组元素的处理，最终执行 walk 方法)、defineReactive(data, keys, values)、定义数据的 get 和 set 操作：

- `Object.defineProperty-get-(dep.depend->Dep.target.addDep->this.subs.push(watcher))`
- `Object.defineProperty-set-(dep.notify->subs[i].update-watcher.run)；`

**<u>*然后*</u>**，初次渲染时，DepTarget 不为 undefined，触发 Data 的 get 操作(保证只有视图中需要被用到的 data 才会触发 getter)，进行依赖收集：将组件 watcher (和 data 相关联的 watcher (存疑))添加到变量的 dep 的 subs 容器中；此时 Watcher 与 data 可看成是一种相互绑定状态；

**<u>*最后*</u>**，data 发生变化，set 被触发时，遍历执行 data.dep.subs 数组下的元素，即执行 watcher.run 方法、执行 render 函数的生成，进入 DOM diff 渲染流程；

**<u>*注意*</u>**：Vue 在初始化组件数据时，在生命周期 [beforeCreate](https://github.com/vuejs/vue/blob/dev/src/core/instance/init.js#L55)与[created ](https://github.com/vuejs/vue/blob/dev/src/core/instance/init.js#L59)钩子函数间实现了对 [data、props、computed、methods、events及watch](https://github.com/vuejs/vue/blob/dev/src/core/instance/state.js#L43) 的处理；

**<u>*补充*</u>**：依赖收集：

1. ObjectdefineProperty - get 时进行收集
2. data 中每个声明的属性，都会有一个 专属的依赖收集器 subs
3. 当页面使用到 某个属性时，页面的 watcher 就会被 放到 依赖收集器 subs 中
4. 总结即当 页面 A 读取了 name 时，会触发 name 的 get 函数，此时，name 就会保存 页面A 的 watcher；

**<u>*补充*</u>**：依赖更新：

1. Object.defineProperty - set触发依赖更新
2. 总结即当 name 改变时，name 会遍历自身的依赖收集器 subs，逐个通知其中的 watcher，让 watcher 完成更新；

**<u>*补充*</u>**：稍微总结：

1. Object.defineProperty - get ，用于 依赖收集
2. Object.defineProperty - set，用于 依赖更新
3. 每个 data 声明的属性，都拥有一个的专属依赖收集器 subs
4. 依赖收集器 subs 保存的依赖是 watcher
5. watcher 可用于 进行视图更新









##### 1-4-Y、补充

##### 1-4-Y-1、数据绑定补充

**<u>*前期数据处理*</u>**：new Vue -> this._init(options) -> 各种 init 包含 initState -> data属性的各种初始化，比如 initProps、initMethods、initData、initComputed、initWatch，此处重点在 initData，而 initData 中，组件 options 中的 data 会被赋给 vm._data，并进行代理操作，最后会执行 observe(data，true)

**<u>*依赖收集流程*</u>**

- defineReactive 接收整一个 data 对象，并每一个 key 与与之对应的 value
- <img src="/Image/Frame/Vue/3.png" style="zoom:50%;" align="left"/>
- Dep.target 在 Watcher 实例化时赋值：Vue实例化 initState 中调用，实例化时调用 this.get，随后调用 pushTarget，即可赋值：
- <img src="/Image/Frame/Vue/4.png" style="zoom:50%;" align="left"/>
- <img src="/Image/Frame/Vue/5.png" style="zoom:50%;" align="left"/>
- <img src="/Image/Frame/Vue/6.png" style="zoom:50%;" align="left"/>
- 回到 Dep.target.addDep(this)，由上述推导即 watcher.addDdep(dep)
- <img src="/Image/Frame/Vue/7.png" style="zoom:50%;" align="left"/>
- <img src="/Image/Frame/Vue/8.png" style="zoom:50%;" align="left"/>
- <img src="/Image/Frame/Vue/9.png" style="zoom:50%;" align="left"/>

依赖收集最终：

- 在 watcher.newDeps 中 push了闭包中传过来的 dep 对象；
- 在 dep.subs中push了初始化 Vue 是建立的 Watcher 对象；
- 即：watcher.newDeps.push(dep)、dep.subs.push(Watcher)；
- 而：后者中包含：this.getter = expOrFn，传过来的expOrFn是后期数据更新页面渲染的核心步骤；

**<u>*组件渲染流程*</u>**：

- 注意：初次依赖收集发生首次渲染时，依赖收集后试图更新时才会双绑响应
- <img src="/Image/Frame/Vue/10.png" style="zoom:50%;" align="left"/>

**<u>*视图更新流程*</u>**：

- <img src="/Image/Frame/Vue/11.png" style="zoom:50%;" align="left"/>
- <img src="/Image/Frame/Vue/12.png" style="zoom:50%;" align="left"/>
- <img src="/Image/Frame/Vue/13.png" style="zoom:50%;" align="left"/>
- <img src="/Image/Frame/Vue/14.png" style="zoom:50%;" align="left"/>
- <img src="/Image/Frame/Vue/15.png" style="zoom:50%;" align="left"/>
- <img src="/Image/Frame/Vue/16.png" style="zoom:50%;" align="left"/>
- 在上面 Watcher.get 方法中：
- 首先，会调用 `pushTarget` 函数将 `Watcher` 对象设为 `Dep.target`；
- 然后，会调用 getter 函数获取 value，即：调用 `updateCompent` 方法 —> `vm._update(vm._render(), hydrating)` —>  `compileToFunctions` 函数生成的 `render` 函数；
- 然后，上述 `render` 函数会返回一个 `VNode` 对象，同时会去获取模板中所使用到的数据，从而又触发数据 `Observer` 的 `getter` (即初次依赖收集通过 `mount`，后续依赖收集随 get 触发)；
- 最后，后面会调用 `vm.__patch__` 方法，进而执行虚拟 DOM 的 diff 过程实时的更新界面；
- <img src="/Image/Frame/Vue/17.png" style="zoom:50%;" align="left"/>

视图更新流程总结：

触发 getter 时，数据的 Dep 对象会将 Watcher 对象收集为依赖，这样就完成了渲染的依赖收集；而每当去修改响应式数据时，setter 就会通过 dep.notify 方法来调用 Watcher 的 update 方法。在 update 调用完 getter 函数后，会通过 popTarget 函数将 Dep.target 置空(途中没有展示)；





##### 1-4-Z、实现

```js
/**
 * Vue Minimalist implementation
 * By rjwx60
 */


const Observer = function(data) {
  // 遍历设置 getSet 方法
  for (let key in data) {
    defineReactive(data, key);
  }
};


const defineReactive = function(obj, key) {
  // 局部变量 dep，用于 getSet 内部调用, 发布者，用于管理观察者 watcher
  const dep = new Dep();
  // 获取当前值
  let val = obj[key];
  Object.defineProperty(obj, key, {
    // 设置可被循环
    enumerable: true,
    // 设置可被修改
    configurable: true,

    // 主体
    get() {
      console.log("in get");
      // 调用依赖收集器中的 addSub，用于收集当前属性与 Watcher 中的依赖关系
      dep.depend();
      return val;
    },
    set(newVal) {
      if (newVal === val) return;
      
      val = newVal;
      // 当值变更时，通知依赖收集器，更新每个需要更新的 Watcher，
      // 这里每个需要更新通过什么断定？dep.subs
      dep.notify();
    }
  });
};


const observe = function(data) {
  // 缺少对依赖重复收集的防御
  return new Observer(data);
};


const Vue = function(options) {
  const self = this;
  // 将 data 赋值给 this._data，源码此部分用的 Proxy 实现
  if (options && typeof options.data === "function") {
    this._data = options.data.apply(this);
  }
  // 挂载函数
  this.mount = function() {
    // 挂载后，Dep.target 才不为 undefined，才可以进行依赖收集
    new Watcher(self, self.render);
  };
  // 渲染函数
  this.render = function() {
    with (self) {
      _data.text;
      // _data.text2;
    }
  };
  // 监听 this._data
  observe(this._data);
};



// 观察者
const Watcher = function(vm, fn) {
  const self = this;
  this.vm = vm;
  // 将当前 Dep.target 指向自身，当 mount 时实例化
  Dep.target = this;
  
  this.addDep = function(dep) {
    // 闭包获取遍历 dep, 即调用 dep.addSub 方法，实现当前 Wathcer 的变量传递
    dep.addSub(self);
  };
  
  // 用于触发 vm._render
  this.update = function() {
    console.log("Watcher updated");
    fn();
  };

  // 此处负责首次调用 vm._render，从而触发 text 的 get 从而将当前的 Wathcer 与 Dep 相关联
  this.value = fn();

  // 清空 Dep.target，防止 notify 触发时，不停绑定 Watcher 与 Dep 造成死循环
  Dep.target = null;
};



// 发布者
const Dep = function() {
  const self = this;
  // 收集目标
  this.target = null;
  // 存储收集器中需要通知的 Watcher
  this.subs = [];
  // 当有目标时，绑定 Dep 与 Wathcer 关系
  this.depend = function() {
    if (Dep.target) {
      Dep.target.addDep(self);
    }
  };
  // 为当前收集器添加 Watcher
  this.addSub = function(watcher) {
    self.subs.push(watcher);
  };
  // 通知收集器中所的所有 Wathcer，调用其 update 方法
  this.notify = function() {
    for (let i = 0; i < self.subs.length; i += 1) {
      self.subs[i].update();
    }
  };
};





// 示例1:
const vue1 = new Vue({
  data() {
    return {
      text: "hello guys"
    };
  }
});

vue1.mount(); // in get
// new Vue -> Vue._data = data && observe(this._data)
// 初始化时，即 new Vue 时即进行了 data 的代理、data 下的每一属性的绑定 observer、此时的 DepTarget 为 undefined
// -> vue.mount -> new Watcher(Vue.this, Vue.render)
// 进行 mount 时，实例化 Watcher, 此时的 Watcher.DepTarget 不为 undefined，并进行首次的依赖收集(this.value = fn()(Vue.render()))
// -> this.value = Vue.render() = Vue._data.text, 即触发 get, 完成收集, 核心是 dep.depend(), (收集依赖, 未被依赖的属性值不会 get)
// dep.depend 通知 Dep.target(即 watcher).addDep(dep)，再折返给 Dep.dep.addSub(watcher)(来回传值是为了传递 watcher)，最终 dep.subs.push(watcher)
vue1._data.text = "123"; // Watcher updated /n in get
// 当发生变化时触发 set，即 dep.notify()，进行更新 subs[i].update()也即 watcher.update()，即 Vue.render




// 示例2:
const vue2 = new Vue({
  data() {
    return {
      text: 'hello guys',
      text2: 'hey'
    };
  }
})

vue2.mount(); // in get
// vue2._data.text = '456'; // Watcher updated /n in get
vue2._data.text2 = '123'; // nothing
// 流程与上述类似，但为何 text2 没有打印是因为没有进行依赖收集，render 中只进行了 Vue._data.text
// 并无 Vue._data.text2 所以没有触发 text2 的 Observer.get 也即没有收集和后续的相应改变
// 即核心关键在于 render 中没有它的身影
```





#### 1-4-2、Angular



### 1-5、状态管理

#### 1-5-1、Vue

<img src="/Image/Frame/Vue/37.png" style="zoom:50%;" />

Vue 通过 [Vuex](https://vuex.vuejs.org/zh-cn/intro.html) 进行应用的状态管理，其借鉴了Flux、redux 基本思想，将共享数据抽离到全局，以单例形式存放，同时利用 Vue 的响应式机制来进行数据状态管理与更新；Vuex实现了一个单向数据流：

- 首先，在全局通过 State 存放数据，而所有修改 State 的操作，均须通过 Mutation 进行，同时其还提供订阅者模式以供外部插件调用获取 State 数据更新；
- 然后，所有异步接口均须通过 Action 操作(常见于调用后端接口异步获取更新数据)；
  - 注意 Action也是无法直接修改 State，仍需通过 Mutation 来修改 State 中数据；
- 最后，根据 State 变化，渲染到视图上；
  - 注意：Vuex 运行依赖于 Vue 内部数据双向绑定机制，故需 new一个Vue对象来实现"响应式化”；

安装：只需提供 store，然后执行下述代码即可完成 Vuex 的引入：

```js
Vue.use(Vuex);
// 将 store 放入 Vue 创建时的 option 中
new Vue({
    el: '#app',
    store
});
```

补充：Vue.use 原理 & Vuex.init

Vue 提供 [Vue.use ](https://cn.vuejs.org/v2/api/#Vue-use)方法来给 Vue 安装插件，其内部通过调用插件的 install 方法(当插件是一个对象时)来进行插件安装，从而将上述代码中的 store 注入到 Vue 实例中去；注意：因 Vue 版本不同；Vue.use 会有不同处理(applyMixin->VueInit)，若为版本1则将 VueInit 放入 init 方法中，若为版本2则将 VueInit 混淆进 beforeCreate 钩子中；

在 Vuex.init 中，根节点执行或使用 store，子组件则直接从父组件中获取 $store，保证所有组件都公用了全局的同一份 store

```js
// 一是防止 Vuex 被重复安装
// 二是执行 applyMixin，目的是执行 vuexInit 方法初始化 Vuex
export function install (_Vue) {
  if (Vue) {
    // 避免重复安装
    if (process.env.NODE_ENV !== 'production') {
      console.error(
        '[vuex] already installed. Vue.use(Vuex) should be called only once.'
      )
    }
    return
  }
  // 保存 Vue，同时用于检测是否重复安装
  Vue = _Vue
  // 将 vuexInit 混淆进 Vue 的 beforeCreate(Vue2.0) 或 _init方法(Vue1.0)
  applyMixin(Vue)
}

// ...

// Vuex 的 init 钩子，会存入每一个 Vue 实例等钩子列表
function vuexInit () {
  const options = this.$options
  // store injection
  if (options.store) {
    // 存在 store 其实代表的就是 Root 节点，直接执行 store(function时) 或使用 store(非function)
    this.$store = typeof options.store === 'function'
      ? options.store()
    : options.store
  } else if (options.parent && options.parent.$store) {
    // 子组件直接从父组件中获取 $store，以保证了所有组件都公用了全局的同一份 store
    // 如此便可以在每一个组件中通过 this.$store 访问全局的 Store 实例
    this.$store = options.parent.$store
  }
}
```



##### 1-5-1-1、Store

上述传入根组件的 store，即 Store 实例，其使用 Vuex 提供的 Store 方法构造：

Store 构造类初始化了些内部变量，并主要执行 installModule (初始化module) 以及 resetStoreVM (通过 VM 使 store "响应式")

```js
export default new Vuex.Store({
    strict: true,
    modules: {
        moduleA,
        moduleB
    }
});

// Store constructor
constructor (options = {}) {
    // Auto install if it is not done yet and `window` has `Vue`.
    // To allow users to avoid auto-installation in some cases,
    // this code should be placed here. See #731
  	// 在浏览器环境下，如果插件还未安装（!Vue即判断是否未安装），则它会自动安装。
  	// 允许用户在某些情况下避免自动安装;
    if (!Vue && typeof window !== 'undefined' && window.Vue) {
      install(window.Vue)
    }

    if (process.env.NODE_ENV !== 'production') {
      assert(Vue, `must call Vue.use(Vuex) before creating a store instance.`)
      assert(typeof Promise !== 'undefined', `vuex requires a Promise polyfill in this browser.`)
      assert(this instanceof Store, `Store must be called with the new operator.`)
    }

    const {
      // 包含应用在 store 上的插件方法
      // 这些插件直接接收 store 作为唯一参数
      // 可监听 mutation（用于外部地数据持久化、记录或调试）或提交 mutation （用于内部数据，例如 websocket 或 某些观察者）
      plugins = [],
      // 让 Vuex store 进入严格模式，此时的任何 mutation 处理函数以外修改 Vuex state 都会抛出错误
      strict = false
    } = options

    // 从 option 中取出 state，若为 function 则执行，最终得到一个对象
    let { state = {} } = options
    if (typeof state === 'function') { state = state() }

    // store internal state
    // 用来判断严格模式下是否是用 mutation 修改 state
    this._committing = false
    // 存放 action
    this._actions = Object.create(null)
    // 存放 mutation
    this._mutations = Object.create(null)
    // 存放 getter
    this._wrappedGetters = Object.create(null)
    // module 收集器
    this._modules = new ModuleCollection(options)
    // 根据 namespace 存放 module
    this._modulesNamespaceMap = Object.create(null)
    // 存放订阅者
    this._subscribers = []
    // 用以实现 Watch 的 Vue 实例
    this._watcherVM = new Vue()

    // bind commit and dispatch to self
    // 将 dispatch 与 commit 调用的 this 绑定为 store 对象本身，否则在组件内部 this.dispatch 时的 this 会指向组件的 vm
    const store = this
    const { dispatch, commit } = this
    // 为 dispatch 与 commit 绑定 this (Store实例本身)
    this.dispatch = function boundDispatch (type, payload) {
      return dispatch.call(store, type, payload)
    }
    this.commit = function boundCommit (type, payload, options) {
      return commit.call(store, type, payload, options)
    }

    // strict mode
    // 严格模式(使 Vuex store 进入严格模式，此时任何 mutation 处理函数以外修改 Vuex state 都会抛出错误)
    this.strict = strict

    // init root module.
    // this also recursively registers all sub-modules
    // and collects all module getters inside this._wrappedGetters
    // 初始化根 module，同时递归注册了所有子 modle，收集所有 module 的 getter 到 _wrappedGetters 中去
  	// this._modules.root 代表根 module才独有保存的 Module 对象
    installModule(this, state, [], this._modules.root)

    // initialize the store vm, which is responsible for the reactivity
    // (also registers _wrappedGetters as computed properties)
    // 通过 vm 重设 store，新建 Vue 对象使用 Vue 内部的响应式实现注册 state 及 computed
    resetStoreVM(this, state)

    // apply plugins
    // 调用插件
    plugins.forEach(plugin => plugin(this))

    // devtool 插件
    if (Vue.config.devtools) {
      devtoolPlugin(this)
    }
  }
```

##### 1-5-1-2、Store-installModule

作用是用为 module 加上 namespace名字空间后，注册 mutation、action 及 getter，同时递归安装所有子 module

```js
//  初始化 module
function installModule (store, rootState, path, module, hot) {
  //  是否是根 module 
  const isRoot = !path.length
  //  获取 module 的 namespace 
  const namespace = store._modules.getNamespace(path)

  // register in namespace map
  //  若有 namespace 则在 _modulesNamespaceMap 中注册 
  if (module.namespaced) {
    store._modulesNamespaceMap[namespace] = module
  }

  // set state
  if (!isRoot && !hot) {
    //  获取父级的 state 
    const parentState = getNestedState(rootState, path.slice(0, -1))
    //  module 的 name 
    const moduleName = path[path.length - 1]
    store.`_withCommit`(() => {
      //  将子 module 设置称响应式的 
      Vue.set(parentState, moduleName, module.state)
    })
  }

  const local = module.context = makeLocalContext(store, namespace, path)

  //  遍历注册 mutation 
  module.forEachMutation((mutation, key) => {
    const namespacedType = namespace + key
    registerMutation(store, namespacedType, mutation, local)
  })

  //  遍历注册 action 
  module.forEachAction((action, key) => {
    const namespacedType = namespace + key
    registerAction(store, namespacedType, action, local)
  })

  //  遍历注册 getter 
  module.forEachGetter((getter, key) => {
    const namespacedType = namespace + key
    registerGetter(store, namespacedType, getter, local)
  })

  //  递归安装 mudule 
  module.forEachChild((child, key) => {
    installModule(store, rootState, path.concat(key), child, hot)
  })
}
```



##### 1-5-1-3、Store-resetStoreVM-Core

```js
//  通过 vm 重设 store，新建 Vue 对象使用 Vue 内部的响应式实现注册 state 及 computed 
function resetStoreVM (store, state, hot) {
  //  存放之前的 vm 对象 
  const oldVm = store._vm 

  // bind store public getters
  store.getters = {}
  const wrappedGetters = store._wrappedGetters
  const computed = {}

  // 遍历 wrappedGetters，使用 Object.defineProperty 方法为每一个 getter 绑定上get方法
  // 如此在组件里访问 this.$store.getter.test 就等同于访问 store._vm.test，也即 Vue 对象的 computed 属性 
  forEachValue(wrappedGetters, (fn, key) => {
    // use computed to leverage its lazy-caching mechanism
    computed[key] = () => fn(store)
    Object.defineProperty(store.getters, key, {
      get: () => store._vm[key],
      enumerable: true // for local getters
    })
  })

  // use a Vue instance to store the state tree
  // suppress warnings just in case the user has added
  // some funky global mixins
  const silent = Vue.config.silent
  //  Vue.config.silent 暂时设置为 true，原因是 new 一个 Vue 实例过程中不会报出一切警告 
  Vue.config.silent = true
  // 关键: Vuex 采用了 new 一个 Vue对象来实现数据的"响应式化"，运用 Vue 内部提供的数据双向绑定功能来实现 store 的数据与视图的同步更新
  // 此时访问 store._vm.test 也即访问 Vue 实例中的属性
  store._vm = new Vue({
    data: {
      ?state: state
    },
    computed
  })
  Vue.config.silent = silent

  // enable strict mode for new vm
  //  使能严格模式，保证修改 store 只能通过 mutation 
  if (store.strict) {
    enableStrictMode(store)
  }

  if (oldVm) {
    //  解除旧 vm 的 state 的引用，及销毁旧 Vue 对象 
    if (hot) {
      // dispatch changes in all subscribed watchers
      // to force getter re-evaluation for hot reloading.
      store._withCommit(() => {
        oldVm._data.?state = null
      })
    }
    Vue.nextTick(() => oldVm.$destroy())
  }
}
  
// 上述两步完成后，即可通过 this.$store.getter.test 访问 vm 中的 test 属性
```



##### 1-5-1-4、VuexStrictMode

Vuex 的 Store 构造类的 option 有 strict 参数，可控制 Vuex 执行严格模式，严格模式下，所有修改 state 的操作须通过 mutation 实现，否则会抛出错误；

总的来说局势通过标志位判断；只有正确方法调用标志位才会放开，从而实现 Vuex 的严格模式；

```js
// 使能严格模式
function enableStrictMode (store) {
  // Vuex 利用 vm 的 $watch 方法来观察 ?state，也即 Store 的 state，在它被修改时进入回调
  // 回调中用 assert 断言来检测 store._committing，当 store._committing 为 false 时触发断言，抛出异常
  store._vm.$watch(function () { return this._data.?state }, () => {
    if (process.env.NODE_ENV !== 'production') {
      // 检测 store 中的 _committing 值，若是 true 代表不是通过 mutation 方法修改
      assert(store._committing, `Do not mutate vuex store state outside mutation handlers.`)
    }
  }, { deep: true, sync: true })
}

// Store 的 commit 方法中，执行 mutation 的语句是这样
this._withCommit(() => {
  entry.forEach(function commitIterator (handler) {
    handler(payload)
  })
})

_withCommit (fn) {
  // 调用 withCommit 修改 state 值时，会将 store 的 committing 值置为 true，内部会有断言检查该值
  // 在严格模式下只允许使用 mutation 来修改 store 中值，而不允许直接修改 store 的数值

  // 通过 commit（mutation）修改 state 数据时，会再调用 mutation 方法之前将 committing 置为 true，
  // 接下来再通过 mutation 函数修改 state 中的数据，此时触发 $watch 中的回调断言 committing 是不会抛出异常的（此时committing为true）
  // 而当直接修改 state 数据时，触发 $watch 的回调执行断言，此时 committing 为 false，则会抛出异常
  const committing = this._committing
  this._committing = true
  fn()
  this._committing = committing
}
```



##### 1-5-1-5、Commit-mutation

commit 方法会根据 type 找到并调用 _mutations 中的所有 type 对应的 mutation 方法，然后会执行 _subscribers 中的所有订阅者

```js
// 调用 mutation 的 commit 方法
commit (_type, _payload, _options) {
  // check object-style commit
  // 校验参数
  const {
    type,
    payload,
    options
  } = unifyObjectStyle(_type, _payload, _options)

  const mutation = { type, payload }
  // 取出 type 对应的 mutation 方法
  const entry = this._mutations[type]
  if (!entry) {
    if (process.env.NODE_ENV !== 'production') {
      console.error(`[vuex] unknown mutation type: ${type}`)
    }
    return
  }
  // 执行 mutation 中所有方法
  this._withCommit(() => {
    entry.forEach(function commitIterator (handler) {
      handler(payload)
    })
  })
  // 通知所有订阅者
  this._subscribers.forEach(sub => sub(mutation, this.state))

  if (
    process.env.NODE_ENV !== 'production' &&
    options && options.silent
  ) {
    console.warn(
      `[vuex] mutation type: ${type}. Silent option has been removed. ` +
      'Use the filter functionality in the vue-devtools'
    )
  }
}
// commit 方法会根据 type 找到并调用 _mutations 中的所有 type 对应的 mutation 方法
// 所以当没有 namespace 时，commit 方法会触发所有 module 中的 mutation 方法, 再执行完所有的 mutation 后会执行 _subscribers 中的所有订阅者


// Store 向外部提供了一个 subscribe 方法
// 用以注册一个订阅函数，会 push 到 Store 实例的 _subscribers 中，同时返回一个从 _subscribers 中注销该订阅者的方法。
// 注册一个订阅函数，返回取消订阅的函数
subscribe (fn) {
  const subs = this._subscribers
  if (subs.indexOf(fn) < 0) {
    subs.push(fn)
  }
  return () => {
    const i = subs.indexOf(fn)
    if (i > -1) {
      subs.splice(i, 1)
    }
  }
}

// 在 commit 结束后则会调用这些 _subscribers 中的订阅者，此订阅者模式提供给外部一个监视 state 变化的可能 state 通过 mutation改变时，可有效补获这些变化
```

##### 1-5-1-6、Dispatch-action

```js
// 调用 action 的 dispatch 方法
dispatch (_type, _payload) {
  // check object-style dispatch
  const {
    type,
    payload
  } = unifyObjectStyle(_type, _payload)

  // actions 中取出 type 对应的 ation
  const entry = this._actions[type]
  if (!entry) {
    if (process.env.NODE_ENV !== 'production') {
      console.error(`[vuex] unknown action type: ${type}`)
    }
    return
  }

  // 若是数组则包装 Promise 形成一个新 Promise，只有一个则直接返回第0个
  return entry.length > 1
    ? Promise.all(entry.map(handler => handler(payload)))
    : entry[0](payload)
}


// 遍历注册 action
function registerAction (store, type, handler, local) {
  // 取出 type 对应的 action
  const entry = store._actions[type] || (store._actions[type] = [])
  entry.push(function wrappedActionHandler (payload, cb) {
    let res = handler.call(store, {
      dispatch: local.dispatch,
      commit: local.commit,
      getters: local.getters,
      state: local.state,
      rootGetters: store.getters,
      rootState: store.state
    }, payload, cb)
    // 判断是否是 Promise
    if (!isPromise(res)) {
      // 不是 Promise 对象则转化 Promise 对象
      res = Promise.resolve(res)
    }
    if (store._devtoolHook) {
      // 存在 devtool 插件时触发 vuex 的 error 给 devtool
      return res.catch(err => {
        store._devtoolHook.emit('vuex:error', err)
        throw err
      })
    } else {
      return res
    }
  })
}


// 因 registerAction 时将 push 进 _actions 的 action 进行了一层封装（wrappedActionHandler）
// 所以在进行 dispatch 的第一个参数中获取 state、commit 等方法
// 之后，执行结果 res 会被进行判断是否是 Promise，不是则会进行一层封装，将其转化成 Promise 对象, 
// dispatch 时则从 _actions 中取出，只有一个的时候直接返回，否则用P romise.all 处理再返回。
```

##### 1-5-1-7、watch

```js
// 观察一个 getter 方法
// _watcherVM 是一个 Vue 实例，所以 watch 就可以直接采用 Vue 内部的 watch 特性提供了一种观察数据 getter 变动的方法
watch (getter, cb, options) {
  if (process.env.NODE_ENV !== 'production') {
    assert(typeof getter === 'function', `store.watch only accepts a function.`)
  }
  return this._watcherVM.$watch(() => getter(this.state, this.getters), cb, options)
}
```

##### 1-5-1-8、un/registerModule

```js
// registerModule 用以注册一个动态模块，也即在 store 创建后再注册模块的时候用该接口
// 注册一个动态 module，当业务进行异步加载的时候，可通过该接口进行注册动态 module
registerModule (path, rawModule) {
  // 转化称 Array
  if (typeof path === 'string') path = [path]

  if (process.env.NODE_ENV !== 'production') {
    assert(Array.isArray(path), `module path must be a string or an Array.`)
    assert(path.length > 0, 'cannot register the root module by using registerModule.')
  }

  // 注册
  this._modules.register(path, rawModule)
  // 初始化 module
  installModule(this, this.state, path, this._modules.get(path))
  // reset store to update getters...
  // 通过 vm 重设 store，新建 Vue 对象使用 Vue 内部的响应式实现注册 state 及 computed
  resetStoreVM(this, this.state)
}



//  注销一个动态 module
// 动态注销模块, 通过先从 state 中删除模块，然后用 resetStore 来重制 store
unregisterModule (path) {
  // 转化称 Array
  if (typeof path === 'string') path = [path]

  if (process.env.NODE_ENV !== 'production') {
    assert(Array.isArray(path), `module path must be a string or an Array.`)
  }

  // 注销
  this._modules.unregister(path)
  this._withCommit(() => {
    // 获取父级的 state
    const parentState = getNestedState(this.state, path.slice(0, -1))
    // 从父级中删除
    Vue.delete(parentState, path[path.length - 1])
  })
  // 重制 store
  resetStore(this)
}
```



##### 1-5-1-9、ResetStore

```js
// 重制 store
// 将 store 中的 _actions 等进行初始化以后，重新执行 installModule 与 resetStoreVM 来初始化 module 及用 Vue 特性使其"响应式化"
function resetStore (store, hot) {
  store._actions = Object.create(null)
  store._mutations = Object.create(null)
  store._wrappedGetters = Object.create(null)
  store._modulesNamespaceMap = Object.create(null)
  const state = store.state
  // init all modules
  installModule(store, state, [], store._modules.root, true)
  // reset vm
  resetStoreVM(store, state, hot)
}
```



### 1-X、其他具体





