---
typora-root-url: ../../Source
---



## 一、基本

Vue

**特点**：**响应式**和**组件化**。

- **响应式**：通过 MVVM 思想实现数据双向绑定，通过虚拟 DOM 来让数据来操作DOM，而不必去操作真实 DOM，提升性能；让开发者将重心放在业务逻辑；
- **组件化**：将单页应用中的各个模块拆分到一个个组件当中，或将一些公共部分抽离出来做成一个可复用组件；提高开发效率&可维护性，方便重复使用；

**缺点**：

- 不利于seo；
- 初次加载时耗时多；
- 基于对象配置文件的写法，也就是 options 写法，开发时不利于对一个属性的查找；
- 导航不可用，如果一定要导航需要自行实现前进、后退(单页面不能用浏览器的前进后退功能，要自己建立堆栈管理)；





### 1-1、基本内容



### 1-2、生命周期

#### 1-2-1、Vue

#### 1-2-2、Angular





### 1-3、路由机制

#### 1-3-1、Vue 

详看：[文章](https://juejin.im/post/6844903615283363848#heading-4)

Vue 路由的 hash 模式 与 history 模式：

hash 模式的 URL 中会夹杂着#号，而 history 没有；Vue 底层实现有别：

- `hash` 模式是依靠 `onhashchange` 事件(监听`location.hash`的改变)；
- `history` 模式是主要依靠的`HTML5 history`中新增的两个方法，`pushState() `可改变 `url` 地址且不会发送请求，`replaceState() `可读取历史记录栈，还可对浏览器记录进行修改；



当真正需要通过`URL`向后端发送`HTTP`请求的时候，比如常见的用户手动输入`URL`后回车，或者是刷新(重启)浏览器，这时候`history`模式需要后端的支持。因为`history`模式下，前端的`URL`必须和实际向后端发送请求的`URL`一致，例如有一个`URL`是带有路径`path`的(例如`www.lindaidai.wang/blogs/id`)，如果后端没有对这个路径做处理的话，就会返回`404`错误。所以需要后端增加一个覆盖所有情况的候选资源，一般会配合前端给出的一个`404`页面

```
window.onhashchange = function(event){
  // location.hash获取到的是包括#号的，如"#heading-3"
  // 所以可以截取一下
  let hash = location.hash.slice(1);
}
```



#### 1-3-2、Angular







### 1-4、数据绑定

#### 1-4-1、Vue

Vue2 数据绑定依靠 [Object.defineProperty](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty)

<img src="/Image/Frame/Vue/1.png" style="zoom:50%;" align="left" />



##### 1-4-1-1、initData

首先，initData，获取 data 的 key，并获取 props，并确保 props 优先，不能与 data 重复，并判断是否保留字段，并将 data 属性代理到 vm 实例上(this.key == this.data.key)，随后进行 observer(data) - 数据绑定操作；

```js
function initData (vm: Component) {
  /* 获取 data */
  let data = vm.$options.data
  data = vm._data = typeof data === 'function'
    ? getData(data, vm)
    : data || {}

  /* data 是否为对象 */
  if (!isPlainObject(data)) {
    data = {}
    process.env.NODE_ENV !== 'production' && warn(
      'data functions should return an object:\n' +
      'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',
      vm
    )
  }

  // proxy data on instance
  /* 获取 props */
  const keys = Object.keys(data)
  const props = vm.$options.props
  let i = keys.length

 	/* 遍历对象 data 的键值进行处理 */
  while (i--) {
    /* 确保 data 的键值 key 不与 props 键值重复，props 优先*/
    if (props && hasOwn(props, keys[i])) {
      process.env.NODE_ENV !== 'production' && warn(
        `The data property "${keys[i]}" is already declared as a prop. ` +
        `Use prop default value instead.`,
        vm
      )
    // 如果不是保留字段，则继续进行代理操作，将 data 上的属性代理到 vm 实例上，即实现：vm.key == vm._data.key
    } else if (!isReserved(keys[i])) {
      proxy(vm, `_data`, keys[i])
    }
  }

  // observe data
  // observe: 开始对数据进行绑定，asRootData，表示此步作为数据的最初操作，后续会进行递归 observe 从而实现对深层对象的绑定
  observe(data, true /* asRootData */)
}






// Proxy - 负责代代理 - 通过 Object.defineProperty 实现
export function proxy (target: Object, sourceKey: string, key: string) {
  sharedPropertyDefinition.get = function proxyGetter () {
    return this[sourceKey][key]
  }
  sharedPropertyDefinition.set = function proxySetter (val) {
    this[sourceKey][key] = val
  }
  Object.defineProperty(target, key, sharedPropertyDefinition)
}
```



##### 1-4-1-2、observe

observe 作用是防止 Observer 的重复绑定

```js
/**
 * Attempt to create an observer instance for a value,
 * returns the new observer if successfully observed,
 * or the existing observer if the value already has one.
 */
// 尝试创建一个 Observer 实例（__ob__），若成功创建 Observer 实例则返回新的 Observer 实例，若已有 Observer 实例则返回现有的 Observer 实例
export function observe (value: any, asRootData: ?boolean): Observer | void {
  if (!isObject(value)) { return }
  let ob: Observer | void

  // 若已有 Observer 实例则直接返回该实例，若没有则会新建一个 Observer 实例并赋值给 __ob__ 属性
  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
    ob = value.__ob__
  } else if (
    // 确保 value 是单纯的对象，而非函数或是Regexp等情况。*/
    observerState.shouldConvert &&
    !isServerRendering() &&
    (Array.isArray(value) || isPlainObject(value)) &&
    Object.isExtensible(value) &&
    !value._isVue
  ) {
    // ob 存放 Observer 实例/该属性的观察器，防止重复绑定
    ob = new Observer(value)
  }
  if (asRootData && ob) {
    // 若为根数据则计数，后面 Observer 中的 observe 的 asRootData 均为 false 则不计数
    ob.vmCount++
  }
  return ob
}
```



##### 1-4-1-3、Observer

Observer 作用是遍历对象的所有属性将其进行双向绑定—walk 方法—针对数组/对象处理+赋值操作 `data.__ob__ = Observer 实例`；

```js
/**
 * Observer class that are attached to each observed
 * object. Once attached, the observer converts target
 * object's property keys into getter/setters that
 * collect dependencies and dispatches updates.
 */
export class  {
  value: any;
  dep: Dep;
  vmCount: number; // number of vms that has this object as root $data

  constructor (value: any) {
    this.value = value
    // 含有 id & subs 用于管理 watchers
    this.dep = new Dep()
    this.vmCount = 0

    // 将 Observer 实例绑定到 data 的 __ob__ 属性上，前面的 observe 方法就是检测这个属性：data.__ob__
    def(value, '__ob__', this)
    
    // 若值为数组，则利用被劫持的数组方法，实现对数组操作的监听(重写push、pop、shift、unshift、splice、sort、reverse)
    if (Array.isArray(value)) {
      // 若当前浏览器支持 __proto__ 属性，则直接覆盖当前数组对象原型上的原生数组方法(直接覆盖该属性则使数组对象具有了重写后的数组方法)
      // 若不支持该属性，则通过遍历 def 所有需要重写的数组方法(arrayMethods 中有调用 def，显然前者效率更高，优先使用前者)
      const augment = hasProto
        ? protoAugment  // 直接覆盖原型的方法来修改目标对象
        : copyAugment   // 定义（覆盖）目标对象或数组的某一个方法
      augment(value, arrayMethods, arrayKeys)
     	// 对每一个数组成员进行 observe
      this.observeArray(value)
      
    // 若是对象则直接利用 walk 进行绑定
    } else {
      this.walk(value)
    }
  }

  /**
   * Walk through each property and convert them into
   * getter/setters. This method should only be called when
   * value type is Object.
   */
  walk (obj: Object) {
    const keys = Object.keys(obj)

    // walk 方法会遍历对象的每一个属性进行 defineReactive 绑定
    for (let i = 0; i < keys.length; i++) {
      defineReactive(obj, keys[i], obj[keys[i]])
    }
  }

  /**
   * Observe a list of Array items.
   */
  observeArray (items: Array<any>) {
    for (let i = 0, l = items.length; i < l; i++) {
      observe(items[i])
    }
  }
}






// arrayMethods
/*
 * not type checking this file because flow doesn't play well with
 * dynamically accessing methods on Array prototype
 */

import { def } from '../util/index'

// 原生数组的原型
const arrayProto = Array.prototype
// 数组对象，劫持 7 个原生数组方法
export const arrayMethods = Object.create(arrayProto)
/**
 * Intercept mutating methods and emit events
 */
// 在保证不污染原生数组原型的情况下重写数组方法，截获数组的成员发生的变化，执行原生数组操作的同时 dep 通知关联的所有观察者进行响应式处理
;[
  'push',
  'pop',
  'shift',
  'unshift',
  'splice',
  'sort',
  'reverse'
]
.forEach(function (method) {
  // 缓存原生数组方法
  const original = arrayProto[method]
  def(arrayMethods, method, function mutator () {
    // avoid leaking arguments:
    // http://jsperf.com/closure-with-arguments
    let i = arguments.length
    const args = new Array(i)
    while (i--) {
      args[i] = arguments[i]
    }
    // 调用原生的数组方法执行结果
    const result = original.apply(this, args)

		// 通过 ob 属性获取 Observer 实例
    const ob = this.__ob__
    let inserted
    switch (method) {
      case 'push':
        inserted = args
        break
      case 'unshift':
        inserted = args
        break
      case 'splice':
        inserted = args.slice(2)
        break
    }
    // 数组新插入元素需重新进行 observe
    if (inserted) ob.observeArray(inserted)

    // notify change
    // dep 通知所有注册的观察者进行响应式处理 
    ob.dep.notify()
    return result
    // arrayMethods 做了两件事:
    // 一是通知所有注册的观察者进行响应式处理
    // 二是若是添加成员的操作，需要对新成员进行 observe
    // 注意：修改了数组的原生方法后，还是没法像原生数组一样直接通过数组的下标或者设置 length 来修改数组，但 Vue 提供了 $set() 及 $remove()方法弥补
  })
})
```



##### 1-4-1-4、defineReactive

defineReactive 作用是通过 Object.defineProperty 为数据定义上 getter\setter 方法，进行依赖收集后闭包中的 Deps 会存放 Watcher 对象。触发 setter 改变数据的时候会通知 Deps 订阅者通知所有的 Watcher 观察者对象进行试图的更新；

- 补充：defineReactive 接收整一个 data 对象，并每一个 key 与与之对应的 value
- 补充：关键理解 Dep，每一个 key 都有自己的 Dep 对象实例，此实例在 getSet 使用；

```js
/**
 * Define a reactive property on an Object.
 */
// defineReactive(obj, keys[i], obj[keys[i]])
export function defineReactive (
  obj: Object,
  key: string,
  val: any,
  customSetter?: Function
) {
  // 获取 Dep 实例
  // 关键理解 Dep，每一个 key 都有自己的 Dep 对象实例，此实例在 getSet 使用
  const dep = new Dep()

  const property = Object.getOwnPropertyDescriptor(obj, key)
  if (property && property.configurable === false) {
    return
  }
	// 若先前该对象已预设 getter 或 setter 函数则将其取出，并在新定义的 getter/setter 中执行，从而避免发生覆盖 
  const getter = property && property.get
  const setter = property && property.set

  // 将当前键值进行 observe 并获取其返回值 new Observer 实例
  // 注意：只在 val 为对象时才如此: observe: if (!isObject(value)) { return }
  // 注意：new Observer 实例化时，执行了 walk 方法，即对 val 的子属性进行 defineReactive，并实例了一个 dep = new Dep
  let childOb = observe(val)
  
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter () {
      // 执行原本对象拥有的 getter 方法
      const value = getter ? getter.call(obj) : val
      
      // 1、执行 new Vue 时，进行 data 代理，data 下的属性的绑定 Observer，此时 Dep.target 也即 Watcher 仍为被实例化，为 undefined
      // 2、随后进行 vue.mount 时，执行了 new Watcher...，此时 Dep.target 不为 undefined，也就在此时进行依赖的收集
      // 3、Dep.target 是全局 watcher 对象
      if (Dep.target) {
        // 进行依赖收集 - 通过闭包传递 dep/watcher 对象
        // 即 Dep.target.addDep(this/dep) -> Watcher.addDep(this/dep) -> dep.addSub(this/watcher) -> this/dep.subs.push(watcher)
        // 通过闭包获取必要参数：watcher 想要 dep，dep 想要 watcher
        dep.depend()
        
        // 子对象也进行依赖收集，实际就是将同一个 watcher 观察者实例放进了两 dep.subs 中，一个是正在本身闭包中的 dep.subs，另一个是子元素的 dep.subs
        if (childOb) { childOb.dep.depend() }
        
        // 数组类型则对每一成员进行依赖收集，若数组的成员还是数组，则递归处理
        if (Array.isArray(value)) { dependArray(value)}
      }
      return value
    },
    
    
    set: function reactiveSetter (newVal) {
      // getter 方法获取当前值
      // 并与新值进行比较，一致则不需要执行下面的操作
      const value = getter ? getter.call(obj) : val
      /* eslint-disable no-self-compare */
      if (newVal === value || (newVal !== newVal && value !== value)) { return }
      
 
      /* eslint-enable no-self-compare */
      if (process.env.NODE_ENV !== 'production' && customSetter) {
        customSetter()
      }
      
      // 若原本对象拥有 setter 方法则执行
      val = setter ? setter.call(obj, newVal) : newVal

      // 新值需要重新进行 observe，保证数据响应式
      childOb = observe(newVal)

      // dep 对象通知所有的观察者
      // 即 subs[i].update() -> watcher.run()
      dep.notify()
    }
  })
}
```





##### 1-4-1-5、Dep

Dep 是一个发布者，可订阅多个观察者，依赖收集之后，Deps中会存在一或多个 Watcher 对象，在数据变更时通知所有 Watcher；

```js
/**
 * A dep is an observable that can have multiple
 * directives subscribing to it.
 */
export default class Dep {
  static target: ?Watcher;
  id: number;
  subs: Array<Watcher>;

  constructor () {
    this.id = uid++
    this.subs = []
  }

  // 添加一个观察者对象
  addSub (sub: Watcher) {
    this.subs.push(sub)
  }

  // 移除一个观察者对象
  removeSub (sub: Watcher) {
    remove(this.subs, sub)
  }

  // 依赖收集，当存在 Dep.target 时添加观察者对象
  depend () {
    if (Dep.target) {
      // Watcher.addDep
      Dep.target.addDep(this)
    }
  }

  // 通知所有订阅者
  notify () {
    // stabilize the subscriber list first
    const subs = this.subs.slice()
    for (let i = 0, l = subs.length; i < l; i++) {
      // Watcher.update()
      subs[i].update()
    }
  }
}

// the current target watcher being evaluated.
// this is globally unique because there could be only one
// watcher being evaluated at any time.
Dep.target = null
// 依赖收集完需要将 Dep.target 设为 null，防止后面重复添加依赖
```



##### 1-4-1-6、Watcher

Watcher 是一个观察者对象，依赖收集后 Watcher 对象会被保存在 Deps 中，数据变动时 Deps 会通知 Watcher 实例，然后由实例回调进行视图更新；

```js
export default class Watcher {
  vm: Component;
  expression: string;
  cb: Function;
  id: number;
  deep: boolean;
  user: boolean;
  lazy: boolean;
  sync: boolean;
  dirty: boolean;
  active: boolean;
  deps: Array<Dep>;
  newDeps: Array<Dep>;
  depIds: ISet;
  newDepIds: ISet;
  getter: Function;
  value: any;

  constructor (
    vm: Component,
    expOrFn: string | Function,
    cb: Function,
    options?: Object
  ) {
    this.vm = vm
    // watchers 存放订阅者实例
    vm._watchers.push(this)
    // options
    if (options) {
      this.deep = !!options.deep
      this.user = !!options.user
      this.lazy = !!options.lazy
      this.sync = !!options.sync
    } else {
      this.deep = this.user = this.lazy = this.sync = false
    }
    this.cb = cb
    // uid for batching
    this.id = ++uid
    this.active = true
    // for lazy watchers
    this.dirty = this.lazy 
    // Note
    this.deps = []
    this.newDeps = []
    this.depIds = new Set()
    this.newDepIds = new Set()
    this.expression = process.env.NODE_ENV !== 'production'
      ? expOrFn.toString()
      : ''
    // parse expression for getter
    // 将表达式 expOrFn 解析成 getter
    if (typeof expOrFn === 'function') {
      this.getter = expOrFn
    } else {
      this.getter = parsePath(expOrFn)
      if (!this.getter) {
        this.getter = function () {}
        process.env.NODE_ENV !== 'production' && warn(
          `Failed watching path: "${expOrFn}" ` +
          'Watcher only accepts simple dot-delimited paths. ' +
          'For full control, use a function instead.',
          vm
        )
      }
    }
    this.value = this.lazy
      ? undefined
      : this.get()
  }

  /**
   * Evaluate the getter, and re-collect dependencies.
   */
   // 获得 getter 的值并且重新进行依赖收集
  get () {
    // 将自身 watcher 观察者实例设置给 Dep.target，用以依赖收集
    pushTarget(this)
    let value
    const vm = this.vm

		// 执行了 getter 操作，看似执行了渲染操作，其实是执行了依赖收集; 在将 Dep.target 设置为自生观察者实例以后，执行 getter 操作;
    // 比如: data 中可能有 a、b、c三个数据，getter 渲染需要依赖 a & c，则在执行 getter 时就会触发 a & c 两个数据的 getter 函数，在 getter 函数中即可判断 Dep.target是否存在然后完成依赖收集，将该观察者对象放入闭包中的 Dep 的 subs 中去。
    if (this.user) {
      try {
        value = this.getter.call(vm, vm)
      } catch (e) {
        handleError(e, vm, `getter for watcher "${this.expression}"`)
      }
    } else {
      value = this.getter.call(vm, vm)
    }
    // "touch" every property so they are all tracked as
    // dependencies for deep watching
    // 如果存在 deep，则触发每个深层对象的依赖，追踪其变化
    if (this.deep) {
      // 递归每一个对象或者数组，触发它们的 getter，使得对象或数组的每一个成员都被依赖收集，形成一个 "深(deep)" 依赖关系
      traverse(value)
    }

    // 将观察者实例从 target 栈中取出并设置给 Dep.target
    popTarget()
    this.cleanupDeps()
    return value
  }

  /**
   * Add a dependency to this directive.
   */
   // 添加一个依赖关系到 Deps 集合中
  addDep (dep: Dep) {
    const id = dep.id
    if (!this.newDepIds.has(id)) {
      this.newDepIds.add(id)
      this.newDeps.push(dep)
      if (!this.depIds.has(id)) {
        dep.addSub(this)
      }
    }
  }

  /**
   * Clean up for dependency collection.
   */
   // 清理依赖收集
  cleanupDeps () {
    // 移除所有观察者对象
    let i = this.deps.length
    while (i--) {
      const dep = this.deps[i]
      if (!this.newDepIds.has(dep.id)) {
        dep.removeSub(this)
      }
    }
    let tmp = this.depIds
    this.depIds = this.newDepIds
    this.newDepIds = tmp
    this.newDepIds.clear()
    tmp = this.deps
    this.deps = this.newDeps
    this.newDeps = tmp
    this.newDeps.length = 0
  }

  /**
   * Subscriber interface.
   * Will be called when a dependency changes.
   */
  // 调度者接口，当依赖发生改变的时候进行回调
  update () {
    /* istanbul ignore else */
    if (this.lazy) {
      this.dirty = true
    } else if (this.sync) {
      // 同步则执行 run 直接渲染视图
      this.run()
    } else {
      // 异步推送到观察者队列中，由调度者调用
      queueWatcher(this)
    }
  }

  /**
   * Scheduler job interface.
   * Will be called by the scheduler.
   */
	// 调度者工作接口，将被调度者回调
  run () {
    if (this.active) {
      const value = this.get()
      if (
        value !== this.value ||
        // Deep watchers and watchers on Object/Arrays should fire even
        // when the value is the same, because the value may
        // have mutated.
        // 即便值相同，拥有 Deep 属性的观察者以及在对象／数组上的观察者应该被触发更新，因它们的值可能发生改变。
        isObject(value) ||
        this.deep
      ) {
        // set new value
        const oldValue = this.value
        // 设置新的值
        this.value = value

        // 触发回调渲染视图
        if (this.user) {
          try {
            this.cb.call(this.vm, value, oldValue)
          } catch (e) {
            handleError(e, this.vm, `callback for watcher "${this.expression}"`)
          }
        } else {
          this.cb.call(this.vm, value, oldValue)
        }
      }
    }
  }

  /**
   * Evaluate the value of the watcher.
   * This only gets called for lazy watchers.
   */
   /*获取观察者的值*/
  evaluate () {
    this.value = this.get()
    this.dirty = false
  }

  /**
   * Depend on all deps collected by this watcher.
   */
  // 收集该 watcher 的所有 deps 依赖
  depend () {
    let i = this.deps.length
    while (i--) {
      this.deps[i].depend()
    }
  }

  /**
   * Remove self from all dependencies' subscriber list.
   */
  // 将自身从所有依赖收集订阅列表删除
  teardown () {
    if (this.active) {
      // remove self from vm's watcher list
      // this is a somewhat expensive operation so we skip it
      // if the vm is being destroyed.
      /*从vm实例的观察者列表中将自身移除，由于该操作比较耗费资源，所以如果vm实例正在被销毁则跳过该步骤。*/
      if (!this.vm._isBeingDestroyed) {
        remove(this.vm._watchers, this)
      }
      let i = this.deps.length
      while (i--) {
        this.deps[i].removeSub(this)
      }
      this.active = false
    }
  }
}
```



##### 1-4-1-7、DOM Diff

##### 1-4-1-7-1、Real DOM

`webkit` 渲染引擎工作流程图：

<img src="/Image/Frame/Vue/32.png" style="zoom:50%;" />

所有的浏览器渲染引擎工作流程大致分为5步：创建  `DOM` 树 —> 创建 `Style Rules` -> 构建 `Render` 树 —> 布局 `Layout` -—> 绘制 `Painting`：

- 第一步，构建 DOM 树：用 HTML 分析器，分析 HTML 元素，构建一棵 DOM 树；
- 第二步，生成样式表：用 CSS 分析器，分析 CSS 文件和元素上的 inline 样式，生成页面的样式表；
- 第三步，构建 Render 树：将 DOM 树和样式表关联起来，构建一棵 Render 树（Attachment）。每个 DOM 节点都有 attach 方法，接受样式信息，返回一个 render 对象（又名 renderer），这些 render 对象最终会被构建成一棵 Render 树；
- 第四步，确定节点坐标：根据 Render 树结构，为每个 Render 树上的节点确定一个在显示屏上出现的精确坐标；
- 第五步，绘制页面：根据 Render 树和节点显示坐标，然后调用每个节点的 paint 方法，将它们绘制出来。
  - 注意：DOM 树的构建是文档加载完成开始的？ 
    - 构建 `DOM` 树是一个渐进过程，为达到更好的用户体验，渲染引擎会尽快将内容显示在屏幕上，它不必等到整个 `HTML` 文档解析完成之后才开始构建 `render` 树和布局；
  - 注意：Render 树是 `DOM` 树和 `CSS` 样式表构建完毕后才开始构建的？ 
    - 这三个过程在实际进行的时候并不是完全独立的，而是会有交叉，会一边加载，一边解析，以及一边渲染。
  - 注意：CSS 的解析注意点？
    -  `CSS` 的解析是从右往左逆向解析的，嵌套标签越多，解析越慢；
  - 注意：JS 操作真实 `DOM` 的代价？
    -  用传统的开发模式，原生 `JS` 或 `JQ` 操作 `DOM` 时，浏览器会从构建 DOM 树开始从头到尾执行一遍流程；
    - 比如：在一次操作中，需要更新 10 个 `DOM` 节点，浏览器收到第一个 `DOM` 请求后并不知道还有 9 次更新操作，因此会马上执行流程，最终执行10 次
    - 第一次计算完，紧接着下一个 `DOM` 更新请求，这个节点的坐标值就变了，前一次计算为无用功；计算 `DOM` 节点坐标值等都是白白浪费的性能。即使计算机硬件一直在迭代更新，操作 `DOM` 的代价仍旧是昂贵的，频繁操作还是会出现页面卡顿，影响用户体验；



##### 1-4-1-7-2、Virtual DOM

**<u>*虚拟DOM本质*</u>**：是用一原生的 JS 对象去描述一个 DOM 节点；对真实 DOM 的一层抽象；

在浏览器中 DOM 的操作昂贵，而频繁操作 DOM，更会产生性能问题，虚拟 DOM 的这层抽象，能将多次变化尽可能地一次性更新到真实 DOM 中；

此外虚拟 DOM 能很好的跨平台，因为其本质只是一个 JS 对象；`Vue2.x`中的虚拟`DOM`主要是借鉴了`snabbdom.js`，`Vue3`中借鉴`inferno.js`算法进行优化

**<u>*虚拟 DOM 诞生意义*</u>**：就是为了解决浏览器性能问题而被设计出来；

- 比如，若一次操作中有 10 次更新 `DOM` 的动作，虚拟 `DOM` 不会立即操作 `DOM`，而是将这 10 次更新的 `diff` 内容保存到本地一个 `JS` 对象中，最终将这个 `JS` 对象一次性 `attch` 到 `DOM` 树上，再进行后续操作，避免大量无谓的计算量；
- 所以，用 `JS` 对象模拟 `DOM` 节点的好处是，页面更新可先全部反映在 `JS` 对象(虚拟 `DOM` )上，操作内存中的 `JS` 对象的速度显然要更快，等更新完成后，再将最终的 `JS` 对象映射成真实的 `DOM`，交由浏览器去绘制；

**<u>*虚拟 DOM 算法实现：*</u>**

- **<u>*1、用 JS 对象模拟 DOM 树*</u>**，并渲染用此对象表示的 DOM 树：

  - ```js
    // 伪码
    var el = require("./element.js");
    var ul = el('div',{id:'virtual-dom'},[
      el('p',{},['Virtual DOM']),
      el('ul', { id: 'list' }, [
    	el('li', { class: 'item' }, ['Item 1']),
    	el('li', { class: 'item' }, ['Item 2']),
    	el('li', { class: 'item' }, ['Item 3'])
      ]),
      el('div',{},['Hello World'])
    ]) 
    
    // 伪码
    Element.prototype.render = function () {
        var el = document.createElement(this.tagName)
        var props = this.props
        // 设置节点的 DOM 属性
        for (var propName in props) {
            var propValue = props[propName]
            el.setAttribute(propName, propValue)
        }
    
        var children = this.children || []
        children.forEach(function (child) {
            var childEl = (child instanceof Element)
                ? child.render() // 若子节点也是虚拟DOM，则递归构建
                : document.createTextNode(child) // 若字符串，只构建文本节点
            el.appendChild(childEl)
        })
        return el
    } 
    ```

- **<u>*2、通过 Diff 算法比较两棵虚拟 DOM 树差异*</u>**

  - 注意：完全比较复杂度会达到 O(n^3)，而前端中很少会跨越层级地移动 `DOM` 元素，故 `Virtual DOM` 只对同一层级元素进行对比，可将复杂度降至 O(n)

  - **<u>*首先*</u>**，深度优先遍历，记录差异：

    - 对新旧两棵树进行一个深度优先的遍历，这样每个节点都会有一个唯一的标记；

    - 在深度优先遍历的时候，每遍历到一个节点就把该节点和新的的树进行对比；若有差异的话就记录到一个对象中

    - <img src="/Image/Frame/Vue/33.png" style="zoom:50%;" align="left"/>

    - ```js
      // diff 函数，对比两棵树
      function diff(oldTree, newTree) {
        var index = 0 // 当前节点的标志
        var patches = {} // 用来记录每个节点差异的对象
        dfsWalk(oldTree, newTree, index, patches)
        return patches
      }
      
      // 对两棵树进行深度优先遍历
      function dfsWalk(oldNode, newNode, index, patches) {
        var currentPatch = []
        if (typeof (oldNode) === "string" && typeof (newNode) === "string") {
          // 文本内容改变
          if (newNode !== oldNode) {
            currentPatch.push({ type: patch.TEXT, content: newNode })
          }
        } else if (newNode!=null && oldNode.tagName === newNode.tagName && oldNode.key === newNode.key) {
          // 节点相同，比较属性
          var propsPatches = diffProps(oldNode, newNode)
          if (propsPatches) {
            currentPatch.push({ type: patch.PROPS, props: propsPatches })
          }
          // 比较子节点，如果子节点有'ignore'属性，则不需要比较
          if (!isIgnoreChildren(newNode)) {
            diffChildren(
              oldNode.children,
              newNode.children,
              index,
              patches,
              currentPatch
            )
          }
        } else if(newNode !== null){
          // 新节点和旧节点不同，用 replace 替换
          currentPatch.push({ type: patch.REPLACE, node: newNode })
        }
      
        if (currentPatch.length) {
          patches[index] = currentPatch
        }
      } 
      ```

  - **<u>*然后*</u>**，差异类型：DOM 操作导致的差异类型包括以下几种：

    - 节点替换：节点改变了，例如将上面的 `div` 换成 `h1`;

    - 顺序互换：移动、删除、新增子节点，例如上面 `div` 的子节点，把 `p` 和 `ul` 顺序互换；

    - 属性更改：修改了节点的属性，例如把上面 `li` 的 `class` 样式类删除；

    - 文本改变：改变文本节点的文本内容，例如将上面 `p` 节点的文本内容更改为 “`Real Dom`”；

    - ```js
      var REPLACE = 0 // 替换原先的节点
      var REORDER = 1 // 重新排序
      var PROPS = 2 // 修改了节点的属性
      var TEXT = 3 // 文本内容改变 
      ```

  - **<u>*然后*</u>**，列表对比算法

    - 比如：`p, ul, div` 顺序换成了 `div, p, ul`；若按同层级进行顺序对比，则都会被替换掉；这样 DOM 开销非常大；而实际上是不需要替换的节点，而只需要经过节点移动就可达到，即只需知道怎么进行移动；
    - 解决：问题可抽象为：字符串的最小编辑距离问题 (`Edition Distance`)，最常见解决方法是： `Levenshtein Distance` ；其是一个度量两个字符序列之间差异的字符串度量标准，两个单词间的 `Levenshtein Distance` 是将一个单词转换为另一个单词所需的单字符编辑(插入、删除或替换)的最小数量。`Levenshtein Distance` 是1965 年由苏联数学家 Vladimir Levenshtein 发明；`Levenshtein Distance` 也被称为编辑距离（`Edit Distance`），通过动态规划求解，时间复杂度为 `O(M*N)`；
    - 比如：对于两个字符串 `a、b`，则他们的 `Levenshtein Distance` 为：
      - <img src="/Image/Frame/Vue/35.png" style="zoom:50%;" align="left"/>
    - 示例：字符串 `a` 和 `b`，`a=“abcde” ，b=“cabef”`，根据上面给出的计算公式，则他们的 `Levenshtein Distance` 的计算过程如下：
      - <img src="/Image/Frame/Vue/34.png" style="zoom:50%;" align="left"/>

  - **<u>*最后*</u>**，实例输出

    - ```js
      // 伪码
      // 其中 ul1 表示原有的虚拟 DOM 树，ul2 表示改变后的虚拟 DOM 树
      var ul1 = el('div',{id:'virtual-dom'},[
        el('p',{},['Virtual DOM']),
        el('ul', { id: 'list' }, [
      	el('li', { class: 'item' }, ['Item 1']),
      	el('li', { class: 'item' }, ['Item 2']),
      	el('li', { class: 'item' }, ['Item 3'])
        ]),
        el('div',{},['Hello World'])
      ]) 
      var ul2 = el('div',{id:'virtual-dom'},[
        el('p',{},['Virtual DOM']),
        el('ul', { id: 'list' }, [
      	el('li', { class: 'item' }, ['Item 21']),
      	el('li', { class: 'item' }, ['Item 23'])
        ]),
        el('p',{},['Hello World'])
      ]) 
      var patches = diff(ul1,ul2);
      console.log('patches:',patches);
      ```

    - <img src="/Image/Frame/Vue/36.png" style="zoom:50%;" align="left"/>

- **<u>*3、通过 patch 将两个虚拟 DOM 对象的差异应用到真正的 DOM 树*</u>**

  - 首先，深度优先遍历 DOM 树

    - ```js
      // 伪码
      function patch (node, patches) {
        var walker = {index: 0}
        dfsWalk(node, walker, patches)
      }
      
      function dfsWalk (node, walker, patches) {
        // 从patches拿出当前节点的差异
        var currentPatches = patches[walker.index]
      
        var len = node.childNodes
          ? node.childNodes.length
          : 0
        // 深度遍历子节点
        for (var i = 0; i < len; i++) {
          var child = node.childNodes[i]
          walker.index++
          dfsWalk(child, walker, patches)
        }
        // 对当前节点进行DOM操作
        if (currentPatches) {
          applyPatches(node, currentPatches)
        }
      } 
      ```

  - 然后，对原有 DOM 树进行 DOM 操作

    - ```js
      // 伪码
      function applyPatches (node, currentPatches) {
        currentPatches.forEach(currentPatch => {
          switch (currentPatch.type) {
            case REPLACE:
              var newNode = (typeof currentPatch.node === 'string')
                ? document.createTextNode(currentPatch.node)
                : currentPatch.node.render()
              node.parentNode.replaceChild(newNode, node)
              break
            case REORDER:
              reorderChildren(node, currentPatch.moves)
              break
            case PROPS:
              setProps(node, currentPatch.props)
              break
            case TEXT:
              node.textContent = currentPatch.content
              break
            default:
              throw new Error('Unknown patch type ' + currentPatch.type)
          }
        })
      } 
      ```

  - 最后，DOM 结构改变



##### 1-4-1-7-3、VNode Created

Vue 中，Virtual DOM 是用 VNode 这个 Class 去描述，实际上 `Vue.js` 中 `Virtual DOM` 是借鉴了一个开源库  [snabbdom](https://github.com/snabbdom/snabbdom) ，然后加入自身的一些特性实现：

```js
export default class VNode {
  tag: string | void;
  data: VNodeData | void;
  children: ?Array<VNode>;
  text: string | void;
  elm: Node | void;
  ns: string | void;
  context: Component | void; // rendered in this component's scope
  key: string | number | void;
  componentOptions: VNodeComponentOptions | void;
  componentInstance: Component | void; // component instance
  parent: VNode | void; // component placeholder node

  // strictly internal
  raw: boolean; // contains raw HTML? (server only)
  isStatic: boolean; // hoisted static node
  isRootInsert: boolean; // necessary for enter transition check
  isComment: boolean; // empty comment placeholder?
  isCloned: boolean; // is a cloned node?
  isOnce: boolean; // is a v-once node?
  asyncFactory: Function | void; // async component factory function
  asyncMeta: Object | void;
  isAsyncPlaceholder: boolean;
  ssrContext: Object | void;
  fnContext: Component | void; // real context vm for functional nodes
  fnOptions: ?ComponentOptions; // for SSR caching
  devtoolsMeta: ?Object; // used to store functional render context for devtools
  fnScopeId: ?string; // functional scope id support

  constructor (
    tag?: string,
    data?: VNodeData,
    children?: ?Array<VNode>,
    text?: string,
    elm?: Node,
    context?: Component,
    componentOptions?: VNodeComponentOptions,
    asyncFactory?: Function
  ) {
    this.tag = tag
    this.data = data
    this.children = children
    this.text = text
    this.elm = elm
    this.ns = undefined
    this.context = context
    this.fnContext = undefined
    this.fnOptions = undefined
    this.fnScopeId = undefined
    this.key = data && data.key
    this.componentOptions = componentOptions
    this.componentInstance = undefined
    this.parent = undefined
    this.raw = false
    this.isStatic = false
    this.isRootInsert = true
    this.isComment = false
    this.isCloned = false
    this.isOnce = false
    this.asyncFactory = asyncFactory
    this.asyncMeta = undefined
    this.isAsyncPlaceholder = false
  }
}
```

- `text` 属性是文本属性；
- `children` 属性是`vnode`的子节点；
- `tag` 属性即这个`vnode`的标签属性；
- `elm` 属性为这个`vnode`对应的真实`dom`节点；
- `key` 属性是`vnode`的标记，在`diff`过程中可以提高`diff`的效率；
- `data` 属性包含了最后渲染成真实`dom`节点后，节点上的`class`，`attribute`，`style`以及绑定的事件；

```js
// 1、初始化 Vue
function Vue (options) {
  if (process.env.NODE_ENV !== 'production' &&
    !(this instanceof Vue)
  ) {
    warn('Vue is a constructor and should be called with the `new` keyword')
  }
  this._init(options)
}

// ... 

// 2、通过 $mount 实例方法去挂载 dom，$mount 会调用原型上的方法
Vue.prototype._init = function (options?: Object) {
  const vm: Component = this

  // ....

  if (vm.$options.el) {
    console.log('vm.$options.el:',vm.$options.el);
    vm.$mount(vm.$options.el)
  }
}

// ... 

const mount = Vue.prototype.$mount
Vue.prototype.$mount = function (
  el?: string | Element,
  hydrating?: boolean
): Component {
  el = el && query(el)
  
   // ...
  return mount.call(this, el, hydrating)
}

// ...

// 3、$mount 方法实际上会去调用 mountComponent 方法，而 mountComponent 核心就是: 
// 先实例化一个渲染 Watcher，在其回调函数中会调用 updateComponent 方法，在此方法中调用 vm._render 方法先生成虚拟 Node，最终调用 vm._update 更新 DOM
Vue.prototype.$mount = function (
  el?: string | Element,
  hydrating?: boolean
): Component {
  el = el && inBrowser ? query(el) : undefined
  return mountComponent(this, el, hydrating)
}

export function mountComponent (
  vm: Component,
  el: ?Element,
  hydrating?: boolean
): Component {
  vm.$el = el

  // ...
  
  let updateComponent
  /* istanbul ignore if */
  if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
    updateComponent = () => {
      // 生成虚拟 VNode   
      const vnode = vm._render()
      // 更新 DOM
      vm._update(vnode, hydrating)
     
    }
  } else {
    updateComponent = () => {
      vm._update(vm._render(), hydrating)
    }
  }

  // 实例化一个渲染 Watcher，在它的回调函数中会调用 updateComponent 方法  
  new Watcher(vm, updateComponent, noop, {
    before () {
      if (vm._isMounted && !vm._isDestroyed) {
        callHook(vm, 'beforeUpdate')
      }
    }
  }, true /* isRenderWatcher */)
  hydrating = false

  return vm
}

// ...

// 4、创建 VNode
// Vue 的 _render 方法是实例的一个私有方法，它用来把实例渲染成一个虚拟 Node
// Vue 利用 _createElement 方法创建 VNode
Vue.prototype._render = function (): VNode {
  const vm: Component = this
  const { render, _parentVnode } = vm.$options
  let vnode
  try {
    // ...
    currentRenderingInstance = vm
    // 调用 createElement 方法来返回 vnode
    vnode = render.call(vm._renderProxy, vm.$createElement)
  } catch (e) {
    handleError(e, vm, `render`){}
  }
  // set parent
  vnode.parent = _parentVnode
  console.log("vnode...:",vnode);
  return vnode
}

// _createElement 方法有 5 个参数
// context 表示 VNode 的上下文环境，它是 Component 类型；
// tag 表示标签，它可以是一个字符串，也可以是一个 Component；
// data 表示 VNode 的数据，它是一个 VNodeData 类型；
// children 表示当前 VNode 的子节点，它是任意类型的，需要被规范为标准的 VNode 数组；
export function _createElement (
  context: Component,
  tag?: string | Class<Component> | Function | Object,
  data?: VNodeData,
  children?: any,
  normalizationType?: number
): VNode | Array<VNode> {
    
  // ...
  
  if (normalizationType === ALWAYS_NORMALIZE) {
    // 场景是 render 函数不是编译生成的
    children = normalizeChildren(children)
  } else if (normalizationType === SIMPLE_NORMALIZE) {
    // 场景是 render 函数是编译生成的
    children = simpleNormalizeChildren(children)
  }
  let vnode, ns
  if (typeof tag === 'string') {
    let Ctor
    ns = (context.$vnode && context.$vnode.ns) || config.getTagNamespace(tag)
    if (config.isReservedTag(tag)) {
      // 创建虚拟 VNode
      vnode = new VNode(
        config.parsePlatformTagName(tag), data, children,
        undefined, undefined, context
      )
    } else if ((!data || !data.pre) && isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {
      // component
      vnode = createComponent(Ctor, data, context, children, tag)
    } else {
      vnode = new VNode(
        tag, data, children,
        undefined, undefined, context
      )
    }
  } else {
    vnode = createComponent(tag, data, context, children)
  }
  if (Array.isArray(vnode)) {
    return vnode
  } else if (isDef(vnode)) {
    if (isDef(ns)) applyNS(vnode, ns)
    if (isDef(data)) registerDeepBindings(data)
    return vnode
  } else {
    return createEmptyVNode()
  }
}


// 5、效果演示
var app = new Vue({
  el: '#app',
  render: function (createElement) {
    return createElement('div', {
      attrs: {
        id: 'app',
        class: "class_box"
      },
    }, this.message)
  },
  data: {
    message: 'Hello Vue!'
  }
})
```

<img src="/Image/Frame/Vue/28.png" style="zoom:50%;" align="left" />



##### 1-4-1-7-4、Diff Process

```js
// 1、change -> dep.notify -> updateComponent(视图更新)
export function mountComponent (
  vm: Component,
  el: ?Element,
  hydrating?: boolean
): Component {
  vm.$el = el
  // ...
  let updateComponent
  /* istanbul ignore if */
  if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
    updateComponent = () => {
      // 生成虚拟 VNode   
      const vnode = vm._render()
      // 更新 DOM
      vm._update(vnode, hydrating)
     
    }
  } else {
    updateComponent = () => {
      vm._update(vm._render(), hydrating)
    }
  }

  // 实例化一个渲染Watcher，在它的回调函数中会调用 updateComponent 方法  
  new Watcher(vm, updateComponent, noop, {
    before () {
      if (vm._isMounted && !vm._isDestroyed) {
        callHook(vm, 'beforeUpdate')
      }
    }
  }, true /* isRenderWatcher */)
  hydrating = false

  return vm
}

// 2、完成视图的更新工作事实上就是调用了 vm._update 方法，方法接收的第一个参数是刚生成的 Vnode
// 关键是 vm.__patch__ 方法，此亦整个 virtual-dom 中最为核心方法，主要完成了 prevVnode 和 vnode 的 diff 过程并根据需要操作的 vdom 节点打 patch，最后生成新的真实 dom 节点并完成视图的更新工作
Vue.prototype._update = function (vnode: VNode, hydrating?: boolean) {
  const vm: Component = this
  const prevEl = vm.$el
  const prevVnode = vm._vnode
  const restoreActiveInstance = setActiveInstance(vm)
  vm._vnode = vnode
  if (!prevVnode) {
    // 第一个参数为真实的 node 节点，则为初始化
    vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */)
  } else {
    // 若需要 diff 的 prevVnode 存在，则对 prevVnode 和 vnode 进行 diff
    vm.$el = vm.__patch__(prevVnode, vnode)
  }
  restoreActiveInstance()
  // update __vue__ reference
  if (prevEl) {
    prevEl.__vue__ = null
  }
  if (vm.$el) {
    vm.$el.__vue__ = vm
  }
  // if parent is an HOC, update its $el as well
  if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
    vm.$parent.$el = vm.$el
  }
}


// patch 过程中会调用 sameVnode 方法来对传入的2个 vnode 进行基本属性的比较，只有当基本属性相同的情况下才认为这个2个 vnode 只是局部发生了更新，然后才会对这 2 个 vnode 进行 diff，若 vnode 的基本属性存在不一致的情况，则直接跳过 diff 过程，进而依据 vnode 新建一个真实的 dom，同时删除老的 dom节点
function patch (oldVnode, vnode, hydrating, removeOnly) {
    // ......
    if (isUndef(oldVnode)) {
      // 当 oldVnode 不存在时，创建新的节点
      isInitialPatch = true
      createElm(vnode, insertedVnodeQueue)
    } else {
      // 对 oldVnode 和 vnode 进行 diff，并对 oldVnode 打 patch  
      const isRealElement = isDef(oldVnode.nodeType)
      if (!isRealElement && sameVnode(oldVnode, vnode)) {
        // patch existing root node
        patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly)
      } 
	// ......
  }
}
function sameVnode (a, b) {
  return (
    a.key === b.key &&
    a.tag === b.tag &&
    a.isComment === b.isComment &&
    isDef(a.data) === isDef(b.data) &&
    sameInputType(a, b)
  )
}

// 3、diff 过程中主要是通过调用 patchVnode 方法进行
// diff 过程中又分了好几种情况: oldCh 为 oldVnode 的子节点，ch 为 Vnode 的子节点：
// 首先, 进行文本节点的判断，若 oldVnode.text !== vnode.text，则直接进行文本节点的替换；
// 然后, 在 vnode 没有文本节点情况下，进入子节点的 diff；
// 	当 oldCh 和 ch 都存在且不相同的情况下，调用 updateChildren 对子节点进行 diff；
// 	若 oldCh 不存在，ch 存在，首先清空 oldVnode 的文本节点，同时调用 addVnodes 方法将 ch 添加到 elm 真实 dom 节点当中；
// 	若 oldCh 存在，ch不存在，则删除 elm 真实节点下的 oldCh 子节点；
// 	若 oldVnode 有文本节点，而 vnode 没有，那么就清空这个文本节点。
function patchVnode (oldVnode, vnode, insertedVnodeQueue, ownerArray, index, removeOnly) {
  // ...... 
  const elm = vnode.elm = oldVnode.elm
  const oldCh = oldVnode.children
  const ch = vnode.children
  // 若 vnode 没有文本节点
  if (isUndef(vnode.text)) {
    // 若 oldVnode 的 children 属性存在且 vnode 的 children 属性也存在  
    if (isDef(oldCh) && isDef(ch)) {
      // updateChildren，对子节点进行 diff  
      if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly)
    } else if (isDef(ch)) {
      if (process.env.NODE_ENV !== 'production') {
        checkDuplicateKeys(ch)
      }
      // 若 oldVnode 的 text 存在，则首先清空 text 内容, 然后将 vnode 的 children 添加进去  
      if (isDef(oldVnode.text)) nodeOps.setTextContent(elm, '')
      addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue)
    } else if (isDef(oldCh)) {
      // 删除 elm 下的 oldchildren
      removeVnodes(elm, oldCh, 0, oldCh.length - 1)
    } else if (isDef(oldVnode.text)) {
      // oldVnode 有子节点，而 vnode 没有，则清空这个节点  
      nodeOps.setTextContent(elm, '')
    }
  } else if (oldVnode.text !== vnode.text) {
    // 若 oldVnode 和 vnode 文本属性不同，则直接更新真实 dom 节点的文本元素
    nodeOps.setTextContent(elm, vnode.text)
  }
  // ......
}


function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
  // 为 oldCh 和 newCh 分别建立索引，为之后遍历的依据
  // 开始遍历 diff 前，首先给 oldCh 和 newCh 分别分配一个 startIndex 和 endIndex 来作为遍历的索引
  let oldStartIdx = 0
  let newStartIdx = 0
  let oldEndIdx = oldCh.length - 1
  let oldStartVnode = oldCh[0]
  let oldEndVnode = oldCh[oldEndIdx]
  let newEndIdx = newCh.length - 1
  let newStartVnode = newCh[0]
  let newEndVnode = newCh[newEndIdx]
  let oldKeyToIdx, idxInOld, vnodeToMove, refElm

  // 直到 oldCh 或 newCh 被遍历完后跳出循环
  // 当 oldCh 或 newCh 遍历完后(遍历完的条件就是 oldCh 或 newCh 的 startIndex >= endIndex)，就停止 oldCh 和 newCh 的 diff 过程
  while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
    if (isUndef(oldStartVnode)) {
      oldStartVnode = oldCh[++oldStartIdx] // Vnode has been moved left
    } else if (isUndef(oldEndVnode)) {
      oldEndVnode = oldCh[--oldEndIdx]
    } else if (sameVnode(oldStartVnode, newStartVnode)) {
      patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)
      oldStartVnode = oldCh[++oldStartIdx]
      newStartVnode = newCh[++newStartIdx]
    } else if (sameVnode(oldEndVnode, newEndVnode)) {
      patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)
      oldEndVnode = oldCh[--oldEndIdx]
      newEndVnode = newCh[--newEndIdx]
    } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right
      patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)
      canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))
      oldStartVnode = oldCh[++oldStartIdx]
      newEndVnode = newCh[--newEndIdx]
    } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left
      patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)
      canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)
      oldEndVnode = oldCh[--oldEndIdx]
      newStartVnode = newCh[++newStartIdx]
    } else {
      if (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)
      idxInOld = isDef(newStartVnode.key)
        ? oldKeyToIdx[newStartVnode.key]
      : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx)
      if (isUndef(idxInOld)) { // New element
        createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx)
      } else {
        vnodeToMove = oldCh[idxInOld]
        if (sameVnode(vnodeToMove, newStartVnode)) {
          patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)
          oldCh[idxInOld] = undefined
          canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)
        } else {
          // same key but different element. treat as new element
          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx)
        }
      }
      newStartVnode = newCh[++newStartIdx]
    }
  }
  if (oldStartIdx > oldEndIdx) {
    refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm
    addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)
  } else if (newStartIdx > newEndIdx) {
    removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)
  }
}
```

- 无 key Diff
- <img src="/Image/Frame/Vue/30.png" style="zoom:50%;" align="left"/>
- 有 key Diff
- <img src="/Image/Frame/Vue/31.png" style="zoom:50%;" align="left"/>



##### 1-4-1-7-5、Path Process

```js
// 观察上述代码知，通过 nodeOps 相关的方法对真实 DOM 结构进行操作
export function createElementNS (namespace: string, tagName: string): Element {
  return document.createElementNS(namespaceMap[namespace], tagName)
}

export function createTextNode (text: string): Text {
  return document.createTextNode(text)
}

export function createComment (text: string): Comment {
  return document.createComment(text)
}

export function insertBefore (parentNode: Node, newNode: Node, referenceNode: Node) {
  parentNode.insertBefore(newNode, referenceNode)
}

export function removeChild (node: Node, child: Node) {
  node.removeChild(child)
}

```



##### 1-4-1-7-X、总结

<img src="/Image/Frame/Vue/29.png" style="zoom:50%;" align="left" />

当数据发生改变时，set 方法会触发 Dep.notify 方法，通知所有订阅者 Watcher，订阅者就会调用 patch 给真实 DOM 打补丁，更新相应视图：

<img src="/Image/Frame/Vue/18.png" style="zoom:50%;" align="" />

**<u>*patch 过程：涉及 DOM Diff 过程*</u>**：DOM Diff 找到并只更新差异部分的 DOM，以减少更新量，提升效率；

- **<u>*同层比较：Diff 比较基础*</u>**。只有两个新旧节点是相同节点时，才会去比较各自子节点(另：最大的根节点一开始可直接比较)；
- 新旧节点：所有新旧节点均为 VNode 节点，使用此类型节点进行比较而不用 DOM 可无视平台限制，比较完成使用平台方法处理即可；
- 相同父级：只有相同父节点才能进行比较，没有则无法实现：
  - <img src="/Image/Frame/Vue/19.png" style="zoom:50%;" align="left" />
  - <img src="/Image/Frame/Vue/20.png" style="zoom:50%;" align="left" />
- **<u>*节点复用：Diff 比较内核*</u>**。建立在上述基础之上。Diff 比较是为了在新旧节点中找到相同节点，所以节点复用，找到相同节点而非无限递归查找；
  - 不同父节点无法复用：
    - <img src="/Image/Frame/Vue/21.png" style="zoom:50%;" align="left" />
    - <img src="/Image/Frame/Vue/22.png" style="zoom:50%;" align="left" />
  - 同级且父节点一致才可复用：
    - <img src="/Image/Frame/Vue/23.png" style="zoom:50%;" align="left" />

**<u>*DOM Diff 比较逻辑：*</u>**

- 比较处理流程：
  - 在新旧节点中
    1. 首先，找到 不需要移动的相同节点，消耗最小；
    2. 然后，再找相同但是需要移动的节点，消耗次小；
    3. 最后，找不到才会去新建/删除节点，保底处理；
- 比较是为修改 DOM 树：
  - 存在三种树：页面 DOM 树、旧 VNode 树、新 Vnode 树；
  - 页面 DOM 树与旧 VNode  树节点一一对应，而新 Vnode 树则是表示更新后页面 DOM 树 该有的样子
  - 注意：在旧 Vnode 树与新 Vnode 树 进行比较过程中：不会对此两棵 Vode 树进行修改，而是以比较的结果，直接对真实 DOM 进行修改
  - 比如：旧 Vnode 树同一层中，找到和新 Vnode 树 中一样但位置不一样节点，此时需要移动此节点，但不是移动旧 Vnode 树中节点，而是直接移动 DOM
  - 总之：新旧 Vnode 树是拿来比较，页面 DOM 树是拿来根据比较结果修改；

**<u>*DOM Diff 比较示例*</u>**：

<img src="/Image/Frame/Vue/24.png" style="zoom:50%;" align="left" />

首轮，父节点相同，符合规则，进行子节点比较，进行第一流程：先找无需移动的相同节点，找到节点 2，根据比较结果，无需修改 DOM，DOM 保留原位置；

<img src="/Image/Frame/Vue/25.png" style="zoom:50%;" align="left" />

二轮，再无<u>相同且无需移动的节点</u>，进行第二流程：找<u>相同但是需要移动的节点</u>，找到节点 5，根据比较结果，需要移动 DOM；

<img src="/Image/Frame/Vue/26.png" style="zoom:50%;" align="left" />

三轮，无相同节点，进行流程三，新建或删除节点，在旧 Vnode 中，若新 Vnode 不存在的节点要删除，在新 Vnode 中，旧 Vnode 不存在节点要新建；

<img src="/Image/Frame/Vue/27.png" style="zoom:50%;" align="left" />

最后，页面更新完毕；



**<u>*DOM Diff 总结：*</u>**

关键：一JS 模拟 DOM 树(虚拟DOM)、二比较虚拟DOM树差异，三将差异应用真正DOM上；

思想：Vue 虚拟DOM思想，初次渲染或更新都用 JSAST 将 DOM 化为虚拟 DOM 树，若为更新则按照一定规则(DIff)比对前后虚拟DOM树变化，随后将变化结果应用到真正DOM树上；

初次流程：vue.init 初始化、vm.$mounnt 挂载->return mountCompent(this, el, …)->实例化Watcher，然后再在里面调用 updateComponent -> vm.render 将实例渲染为 VNode(虚拟Node)(使用 createElement 创建 VNode)-> vm.update (vnode, …)->`vm.__patch__`(核心方法，完成 preVnode(旧VNode) 与 vnode (新VNode) 的 diff 过程并根据需要操作的 vdom 节点打 patch，最后生成新的真实DOM以完成视图更新操作)；

- `vm.__patch__`：先用 sameVnode 比对新旧Vnode的基本属性，若相同则认为发生局部更新，然后进行 diff，若不同则直接跳过 diff 过程，根据 vnode 新建一个真实 DOM，同时删除 旧 dom 节点；
- diff：主要通过调用 patchVNode 进行：
- 首先，进行文本节点的判断，若oldVnode.text !== vnode.text 则直接进行文本节点的替换==>nodeOps.setTextContent(elm, vnode.text)
- 然后，若非文本节点，则进入子节点 diff，
- 其他，若 oldVnode 子节点和 vnode 子节点均存在但不相同时，调用 updateChildren 对子节点进行 diff；
- 其他，若 oldVnode 子节点不存在但 vnode 子节点存在，则清空 oldVnode 文本节点，同时调用 addVnodes 将 vnode 子节点添加到 el 真实 dom 节点中；
- 其他，若 oldVnode 子节点存在，但 vnode 子节点不存在，则删除 elm 真实节点下的 oldVnode 子节点；
- 其他，若 oldVnode 有文本节点，但 vnode 没有，则清空此文本节点；

更新流程：调用响应式数据所维护的 dep，随后调用 dep.notify 方法，其中包含 updateComponent…此后流程同上；



补充：

diff算法过程：

- 先同级比较再比较子节点；
- 首先，判断一方有子节点和一方没有子节点的情况；如果新的一方有子节点，旧的一方没有，相当于新的子节点替代了原来没有的节点；同理，如果新的一方没有子节点，旧的一方有，相当于要把老的节点删除；
- 然后，比较都有子节点的情况，这里是`diff`的核心。首先会通过判断两个节点的`key、tag、isComment、data同时定义或不定义以及当标签类型为input的时候type相不相同`来确定两个节点是不是相同的节点，如果不是的话就将新节点替换旧节点。
- 如果是相同节点的话才会进入到`patchVNode`阶段。在这个阶段核心是采用双端比较的算法，同时从新旧节点的两端进行比较，在这个过程中，会用到模版编译时的静态标记配合`key`来跳过对比静态节点，如果不是的话再进行其它的比较。

`Vue3.x`借鉴了`ivi`算法和`inferno`算法。

它在创建`VNode`的时候就确定了其类型，以及在`mount/patch`的过程中采用`位运算`来判断一个`VNode`的类型，在这个基础之上再配合核心的Diff算法，使得性能上较Vue2.x有了提升。

diff算法缺点

因为采用的是同级比较，所以如果发现本级的节点不同的话就会将新节点之间替换旧节点，不会再去比较其下的子节点是否有相同





##### 1-4-1-X、总结

<img src="/Image/Frame/Vue/2.png" style="zoom:50%;" align="" />

**<u>*首先*</u>**，initData，获取 data 的 key，并获取 props，并确保 props 优先，不能与 data 重复，并判断是否保留字段，并将 data 属性代理到 vm 实例上(即 vm.key == vm._data.key)，随后进行 observer(data) 数据绑定操作；

然后，new Observer(data)(对数组方法及数组元素的处理，最终执行 walk 方法)、defineReactive(data, keys, values)、定义数据的 get 和 set 操作：

- `Object.defineProperty-get-(dep.depend->Dep.target.addDep->this.subs.push(watcher))`
- `Object.defineProperty-set-(dep.notify->subs[i].update-watcher.run)；`

**<u>*然后*</u>**，初次渲染时，DepTarget 不为 undefined，触发 Data 的 get 操作(保证只有视图中需要被用到的 data 才会触发 getter)，进行依赖收集：将组件 watcher (和 data 相关联的 watcher (存疑))添加到变量的 dep 的 subs 容器中；此时 Watcher 与 data 可看成是一种相互绑定状态；

**<u>*最后*</u>**，data 发生变化，set 被触发时，遍历执行 data.dep.subs 数组下的元素，即执行 watcher.run 方法、执行 render 函数的生成，进入 DOM diff 渲染流程；

**<u>*注意*</u>**：Vue 在初始化组件数据时，在生命周期 [beforeCreate](https://github.com/vuejs/vue/blob/dev/src/core/instance/init.js#L55)与[created ](https://github.com/vuejs/vue/blob/dev/src/core/instance/init.js#L59)钩子函数间实现了对 [data、props、computed、methods、events及watch](https://github.com/vuejs/vue/blob/dev/src/core/instance/state.js#L43) 的处理；

**<u>*补充*</u>**：依赖收集：

1. ObjectdefineProperty - get 时进行收集
2. data 中每个声明的属性，都会有一个 专属的依赖收集器 subs
3. 当页面使用到 某个属性时，页面的 watcher 就会被 放到 依赖收集器 subs 中
4. 总结即当 页面 A 读取了 name 时，会触发 name 的 get 函数，此时，name 就会保存 页面A 的 watcher；

**<u>*补充*</u>**：依赖更新：

1. Object.defineProperty - set触发依赖更新
2. 总结即当 name 改变时，name 会遍历自身的依赖收集器 subs，逐个通知其中的 watcher，让 watcher 完成更新；

**<u>*补充*</u>**：稍微总结：

1. Object.defineProperty - get ，用于 依赖收集
2. Object.defineProperty - set，用于 依赖更新
3. 每个 data 声明的属性，都拥有一个的专属依赖收集器 subs
4. 依赖收集器 subs 保存的依赖是 watcher
5. watcher 可用于 进行视图更新









##### 1-4-1-Y、补充

##### 1-4-1-Y-1、数据绑定补充

**<u>*前期数据处理*</u>**：new Vue -> this._init(options) -> 各种 init 包含 initState -> data属性的各种初始化，比如 initProps、initMethods、initData、initComputed、initWatch，此处重点在 initData，而 initData 中，组件 options 中的 data 会被赋给 vm._data，并进行代理操作，最后会执行 observe(data，true)

**<u>*依赖收集流程*</u>**

- defineReactive 接收整一个 data 对象，并每一个 key 与与之对应的 value
- <img src="/Image/Frame/Vue/3.png" style="zoom:50%;" align="left"/>
- Dep.target 在 Watcher 实例化时赋值：Vue实例化 initState 中调用，实例化时调用 this.get，随后调用 pushTarget，即可赋值：
- <img src="/Image/Frame/Vue/4.png" style="zoom:50%;" align="left"/>
- <img src="/Image/Frame/Vue/5.png" style="zoom:50%;" align="left"/>
- <img src="/Image/Frame/Vue/6.png" style="zoom:50%;" align="left"/>
- 回到 Dep.target.addDep(this)，由上述推导即 watcher.addDdep(dep)
- <img src="/Image/Frame/Vue/7.png" style="zoom:50%;" align="left"/>
- <img src="/Image/Frame/Vue/8.png" style="zoom:50%;" align="left"/>
- <img src="/Image/Frame/Vue/9.png" style="zoom:50%;" align="left"/>

依赖收集最终：

- 在 watcher.newDeps 中 push了闭包中传过来的 dep 对象；
- 在 dep.subs中push了初始化 Vue 是建立的 Watcher 对象；
- 即：watcher.newDeps.push(dep)、dep.subs.push(Watcher)；
- 而：后者中包含：this.getter = expOrFn，传过来的expOrFn是后期数据更新页面渲染的核心步骤；

**<u>*组件渲染流程*</u>**：

- 注意：初次依赖收集发生首次渲染时，依赖收集后试图更新时才会双绑响应
- <img src="/Image/Frame/Vue/10.png" style="zoom:50%;" align="left"/>

**<u>*视图更新流程*</u>**：

- <img src="/Image/Frame/Vue/11.png" style="zoom:50%;" align="left"/>
- <img src="/Image/Frame/Vue/12.png" style="zoom:50%;" align="left"/>
- <img src="/Image/Frame/Vue/13.png" style="zoom:50%;" align="left"/>
- <img src="/Image/Frame/Vue/14.png" style="zoom:50%;" align="left"/>
- <img src="/Image/Frame/Vue/15.png" style="zoom:50%;" align="left"/>
- <img src="/Image/Frame/Vue/16.png" style="zoom:50%;" align="left"/>
- 在上面 Watcher.get 方法中：
- 首先，会调用 `pushTarget` 函数将 `Watcher` 对象设为 `Dep.target`；
- 然后，会调用 getter 函数获取 value，即：调用 `updateCompent` 方法 —> `vm._update(vm._render(), hydrating)` —>  `compileToFunctions` 函数生成的 `render` 函数；
- 然后，上述 `render` 函数会返回一个 `VNode` 对象，同时会去获取模板中所使用到的数据，从而又触发数据 `Observer` 的 `getter` (即初次依赖收集通过 `mount`，后续依赖收集随 get 触发)；
- 最后，后面会调用 `vm.__patch__` 方法，进而执行虚拟 DOM 的 diff 过程实时的更新界面；
- <img src="/Image/Frame/Vue/17.png" style="zoom:50%;" align="left"/>

视图更新流程总结：

触发 getter 时，数据的 Dep 对象会将 Watcher 对象收集为依赖，这样就完成了渲染的依赖收集；而每当去修改响应式数据时，setter 就会通过 dep.notify 方法来调用 Watcher 的 update 方法。在 update 调用完 getter 函数后，会通过 popTarget 函数将 Dep.target 置空(途中没有展示)；





##### 1-4-1-Z、实现

```js
/**
 * Vue Minimalist implementation
 * By rjwx60
 */


const Observer = function(data) {
  // 遍历设置 getSet 方法
  for (let key in data) {
    defineReactive(data, key);
  }
};


const defineReactive = function(obj, key) {
  // 局部变量 dep，用于 getSet 内部调用, 发布者，用于管理观察者 watcher
  const dep = new Dep();
  // 获取当前值
  let val = obj[key];
  Object.defineProperty(obj, key, {
    // 设置可被循环
    enumerable: true,
    // 设置可被修改
    configurable: true,

    // 主体
    get() {
      console.log("in get");
      // 调用依赖收集器中的 addSub，用于收集当前属性与 Watcher 中的依赖关系
      dep.depend();
      return val;
    },
    set(newVal) {
      if (newVal === val) return;
      
      val = newVal;
      // 当值变更时，通知依赖收集器，更新每个需要更新的 Watcher，
      // 这里每个需要更新通过什么断定？dep.subs
      dep.notify();
    }
  });
};


const observe = function(data) {
  // 缺少对依赖重复收集的防御
  return new Observer(data);
};


const Vue = function(options) {
  const self = this;
  // 将 data 赋值给 this._data，源码此部分用的 Proxy 实现
  if (options && typeof options.data === "function") {
    this._data = options.data.apply(this);
  }
  // 挂载函数
  this.mount = function() {
    // 挂载后，Dep.target 才不为 undefined，才可以进行依赖收集
    new Watcher(self, self.render);
  };
  // 渲染函数
  this.render = function() {
    with (self) {
      _data.text;
      // _data.text2;
    }
  };
  // 监听 this._data
  observe(this._data);
};



// 观察者
const Watcher = function(vm, fn) {
  const self = this;
  this.vm = vm;
  // 将当前 Dep.target 指向自身，当 mount 时实例化
  Dep.target = this;
  
  this.addDep = function(dep) {
    // 闭包获取遍历 dep, 即调用 dep.addSub 方法，实现当前 Wathcer 的变量传递
    dep.addSub(self);
  };
  
  // 用于触发 vm._render
  this.update = function() {
    console.log("Watcher updated");
    fn();
  };

  // 此处负责首次调用 vm._render，从而触发 text 的 get 从而将当前的 Wathcer 与 Dep 相关联
  this.value = fn();

  // 清空 Dep.target，防止 notify 触发时，不停绑定 Watcher 与 Dep 造成死循环
  Dep.target = null;
};



// 发布者
const Dep = function() {
  const self = this;
  // 收集目标
  this.target = null;
  // 存储收集器中需要通知的 Watcher
  this.subs = [];
  // 当有目标时，绑定 Dep 与 Wathcer 关系
  this.depend = function() {
    if (Dep.target) {
      Dep.target.addDep(self);
    }
  };
  // 为当前收集器添加 Watcher
  this.addSub = function(watcher) {
    self.subs.push(watcher);
  };
  // 通知收集器中所的所有 Wathcer，调用其 update 方法
  this.notify = function() {
    for (let i = 0; i < self.subs.length; i += 1) {
      self.subs[i].update();
    }
  };
};





// 示例1:
const vue1 = new Vue({
  data() {
    return {
      text: "hello guys"
    };
  }
});

vue1.mount(); // in get
// new Vue -> Vue._data = data && observe(this._data)
// 初始化时，即 new Vue 时即进行了 data 的代理、data 下的每一属性的绑定 observer、此时的 DepTarget 为 undefined
// -> vue.mount -> new Watcher(Vue.this, Vue.render)
// 进行 mount 时，实例化 Watcher, 此时的 Watcher.DepTarget 不为 undefined，并进行首次的依赖收集(this.value = fn()(Vue.render()))
// -> this.value = Vue.render() = Vue._data.text, 即触发 get, 完成收集, 核心是 dep.depend(), (收集依赖, 未被依赖的属性值不会 get)
// dep.depend 通知 Dep.target(即 watcher).addDep(dep)，再折返给 Dep.dep.addSub(watcher)(来回传值是为了传递 watcher)，最终 dep.subs.push(watcher)
vue1._data.text = "123"; // Watcher updated /n in get
// 当发生变化时触发 set，即 dep.notify()，进行更新 subs[i].update()也即 watcher.update()，即 Vue.render




// 示例2:
const vue2 = new Vue({
  data() {
    return {
      text: 'hello guys',
      text2: 'hey'
    };
  }
})

vue2.mount(); // in get
// vue2._data.text = '456'; // Watcher updated /n in get
vue2._data.text2 = '123'; // nothing
// 流程与上述类似，但为何 text2 没有打印是因为没有进行依赖收集，render 中只进行了 Vue._data.text
// 并无 Vue._data.text2 所以没有触发 text2 的 Observer.get 也即没有收集和后续的相应改变
// 即核心关键在于 render 中没有它的身影
```





#### 1-4-2、Angular

Vue 为数据绑定，Angular 可称为变更检测：

##### 1-4-2-1、变更检测机制

**<u>*Angular 的变更检测*</u>**  要从一个错误说起 **<u>*ExpressionChangedAfterItHasBeenCheckedError*</u>**，一个按钮应用，当发生变化检测时将时间渲染到屏幕上。时间戳的精度是毫秒。点击按钮触发变化监测；组件类中有个名为`time`的getter，返回当前的时间戳；[地址](https://stackblitz.com/edit/angular-hqbenm?file=src/app/app.component.ts)

```ts
@Component({
    selector: 'my-app',
    template: `
        <h3>Change detection is triggered at: <span [textContent]="time | date:'hh:mm:ss:SSS'"></span></h3>
				<!-- Angular 不允许空的表达式，所以在 click 回调中放了一个 0 -->
        <button (click)="0">Trigger Change Detection</button>
    `
})
export class AppComponent {
    get time() {
        return Date.now();
    }
}
```

果然，报错 ExpressionChangedAfterItHasBeenCheckedError
原因：表达式在被 Angular 检查后发生了变化：之前的值："textContent: 1542375826274"，而现在的值："textContent: 1542375826275"；
所以，可发现 Angular 对表达式进行了两次计算，并将两次计算结果进行了比较，发现结果不一致，遂报错；

<img src="/Image/Frame/Angular/5.png" style="zoom:50%;" align="left" />

**<u>*Angular 的变更检测中有两个主要的构成元素：*</u>**

- 一个组件的视图
- 相关的数据绑定

Angular 中的每个组件都有一个由 HTML 元素构成的模板；

Angular 创建了 DOM 节点以便将模板中的内容渲染到屏幕上，它需要有一个地方存储这些 DOM 节点的引用；为此，在 Angular 内部有一个称为 **<u>*视图*</u>** 的数据结构。<u>*视图也被用来存储组件实例的引用，以及绑定表达式之前的值*</u>。组件和视图之间是一对一的关系：

<img src="/Image/Frame/Angular/6.png" style="zoom:50%;" align="" />



首先，当编译器在分析模板时，它会<u>识别</u>可能需要在变化检测期间被更新的DOM元素的属性；

然后，编译器会为每个这样的属性<u>创建</u>一个 **<u>*绑定*</u>**；数据绑定定义了：<u>*需要更新的属性名称*</u>、<u>*Angular 用于获取新值的表达式*</u>；

- 比如：此例中，`time` 属性被用在 `textContent` 属性的表达式中；所以 Angular 创建了绑定，并将它关联到 `span` 元素；

<img src="/Image/Frame/Angular/7.png" style="zoom:50%;" align="" />

- 注意：实际实现中，<u>*绑定不是一个有着所有必须信息的单独的对象*</u>；
  -  `viewDfinition` 为模板元素和需要更新的属性定义了绑定；
  - 而用于绑定的表达式则被置于 `updateRenderer` 函数中；

**<u>*Angular 变更检测流程：*</u>**Angular中，每个组件都会执行变更检测；而组件在 Angular 内部会被表达为视图，所以可以说每个视图都会执行变更检测；

- 首先，当 Angular 检查一个视图时，它只会运行所有的编译器为视图生成的绑定，对表达式求值并将它们的结果，存储在视图的 `oldValues` 数组中；此亦脏检查的由来；
- 然后，如果后续过程中，Angular 检测到了变化(Zone)，它就会更新与绑定相关的 DOM 属性，并将这个新的值放入视图的 `oldValues` 数组中；
- 然后，(进行渲染)，用户就得到了一个更新过的 UI (组件层级)；
- 最后，一旦 Angular 完成了当前组件的检测，它会递归地去检查子组件；
  - 比如：在本次示例中只有一个绑定：连接到 `App` 组件中的 `span` 元素的 `textContent` 属性；
  - 所以：在变化检测期间，Angular 读取了组件类的 `time` 属性的值，并将其应用到 `date` 管道上，然后将返回值与储存在视图中的旧值相比较；如果它检测到不同(也即表示发生值变更)，Angular 就会更新 `span` 的 `textContent` 属性和 `oldValues` 数组；

<img src="/Image/Frame/Angular/8.png" style="zoom:50%;" align="" />

- 注意：<u>*在开发模式下，每一次变更检测循环后(同步任务)，Angular 会同步地运行另一次检查(同步任务)，以确保表达式生成的值，与先前在变更检测中的值相同*</u>；这次检查并非是原始变更监测循环的一部分，它在整个组件树的变化检查结束后执行完全相同的步骤；但是在次次检查中，当 Angular 检测到了变更是不会更新DOM的；相反会抛出`ExpressionChangedAfterItHasBeenCheckedError` 错误；即：开发模式与生产模式不同，前者进行了两次检查，后者进行了一次；前者检查后若值不同则报错，后者值不同则更新UI；

- <u>原因：Ng 做此次检查的原因：确保表达式生成的值与先前在变更检测中的值相同，在开发模式中排查错误，以免在生产模式下，陷入变更检测循环；</u>

  - 比如：组件类中的某些属性在变化检测运行期间就已被更新，造成的结果是：表达式产生了与渲染到 UI 中的值不一致的新值；此时的 Angular 当然可以再运行一次变化检测以同步应用状态与UI；但如果在此过程中，某些属性再次被更新了呢？那么 Angular 就有可能会在无限的变化检测循环中崩溃；

- 所以，为避免这种情况，Angular 强制实行了被称为 **<u>*单项数据流*</u>** 的模式，并且在变化检测后运行的检查和由此产生错误`ExpressionChangedAfterItHasBeenCheckedError` 是强制的机制；一旦 Angular 处理完当前组件的绑定，就不能再更新绑定表达式中使用的属性；

- 解决：明白了变更检测原理，即可修复此错误，确保表达式在变化检测期间与随后的检查中返回的值是相同的：

  - 思路1：确保值始终不变；

  - 思路2：变更检测与二次检查均为同步任务(产生错误的检查在变化检测循环后立即同步运行)，遂可利用 EventLoop 机制，将值的变更操作封装在异步或微任务中执行，等检查后再去更新值，以避免错误发生；注意避免使用 setInterval 等异步操作，因为

  - 思路3：利用 zones 提供 API，在变更检测之外执行，见下方；

  - ```ts
    @Component({
        selector: 'my-app',
        template: `
            <h3>Change detection is triggered at: <span [textContent]="time | date:'hh:mm:ss:SSS'"></span></h3>
    				<!-- Angular 不允许空的表达式，所以在 click 回调中放了一个 0 -->
            <button (click)="0">Trigger Change Detection</button>
        `
    })
    export class AppComponent {
      	// ExpressionChangedAfterItHasBeenCheckedError
      	// 两次检查，所得的值均不同，报错
        get time() {
            return Date.now();
        }
      
      	// fix - 思路1
      	// 将值写死，time 返回值始终不变，不管如何前后两次检测的值均等，无报错，但没有实现需求，
        _time;
        get time() {  return this._time; }
        constructor() {
            this._time = Date.now();
        }
    
        // fix - 思路2
        _time;
        get time() {  return this._time; }
        constructor() {
            this._time = Date.now();
          	// 不断更新 _time 值，因为二次检查是同步任务，所以可利用 EventLoop 机制，用异步任务封装更新操作，等检查后再去更新；
          	// 异步操作被 Angular 做了劫持，都会触发新一轮的变更检测，若使用 setInterval 更是会无限次触发；
            setInterval(() => {
                this._time = Date.now();
            }, 1);
        }
    }
    ```

**<u>*Angular 变更检测之变更通知 Zone：*</u>**

与 React 相反，Angular 中的变更检测可完全自动地由浏览器中的任何一个异步事件触发；Angular 通过使用 `zone.js ` 库，以实现变更监测流程的触发( zone.js 检测到异步事件，事件通知 Angular，进入变更检测流程)；

此外 Angular 同时还引入了 zones 概念，注意 zones 并非 Angular 变更检测机制的一部分，而是独立于 Angular 之外的仅仅提供了一种拦截异步事件的方法的库，比如 `setInterval`，并通知 Angular 发生了异步事件，Angular 基于此通知来运行变更检测；一个网页应用可包含许多不同的 zones；其中一个是 `NgZone`，它在 Angular 启动时被创建；Angular 整一应用就运行在这个 zone 当中；只有在 zone 中发生的异步事件才会通知 Angular；

<img src="/Image/Frame/Angular/9.png" style="zoom:50%;" align="left" />

但是，`zone.js`也提供了一个API：`NgZone` 服务实现的 `runOutsideAngular`，以便在 Angular zone 之外的 zone 中运行某些代码；而在其他 zone 中发生异步事件时，Angular 并不会收到通知；没有通知就意味着没有变更检测；所以在本次示例中，可解决不断触发变更检测的问题：

**<u>注意：使用 NgZone 来在 Angular 之外运行某些代码以避免触发变化检测是一种常用的优化技巧；</u>**

```ts
@Component({
    selector: 'my-app',
    template: `
        <h3>Change detection is triggered at: <span [textContent]="time | date:'hh:mm:ss:SSS'"></span></h3>
				<!-- Angular 不允许空的表达式，所以在 click 回调中放了一个 0 -->
        <button (click)="0">Trigger Change Detection</button>
    `
})
export class AppComponent {
  	// ExpressionChangedAfterItHasBeenCheckedError
  	// 两次检查，所得的值均不同，报错
    get time() {
        return Date.now();
    }
  
  	// fix - 思路1
  	// 将值写死，time 返回值始终不变，不管如何前后两次检测的值均等，无报错，但没有实现需求，
    _time;
    get time() {  return this._time; }
    constructor() {
        this._time = Date.now();
    }

    // fix - 思路2
    _time;
    get time() {  return this._time; }
    constructor() {
        this._time = Date.now();
      	// 不断更新 _time 值，因为二次检查是同步任务，所以可利用 EventLoop 机制，用异步任务封装更新操作，等检查后再去更新；
      	// 异步操作被 Angular 做了劫持，都会触发新一轮的变更检测，若使用 setInterval 更是会无限次触发；
        setInterval(() => {
            this._time = Date.now();
        }, 1);
    }
  
  	// fix - 思路3
    _time;
    get time() {
        return this._time;
    }
    constructor(zone: NgZone) {
        this._time = Date.now();
				// 不断更新 _time 值，因为二次检查是同步任务，所以可利用 EventLoop 机制，用异步任务封装更新操作，等检查后再去更新；
      	// 异步操作被 Angular 做了劫持，都会触发新一轮的变更检测，若使用 setInterval 更是会无限次触发；
      	// 所以引入 NgZone 服务，使得异步任务在 NgZone 执行，绕开 NgZone 的变更检测，避免无限触发，又能确保检查后再更新值
      	// 1、异步 -> EventLoop 机制，异步绕开同步，避免值在检查前变化，保证检查后再变化，避免错误
      	// 2、Zone -> NgZone 原理，避免异步多次重复触发变更检测，避免死循环
        zone.runOutsideAngular(() => {
            setInterval(() => {
                this._time = Date.now()
            }, 1);
        });
    }

}
```

**<u>*Angular 变更检测之生命周期钩子的执行顺序：*</u>**

由于单项数据流的限制，在组件被检查后，不能在变化检测期间改变组件的某些属性；但绝大多数时候，当 Angular 对子组件进行变更检测时，数据的更新通过共享服务或同步事件进行广播、或直接将父组件注入到子组件中，然后通过生命周期钩子更新父组件的状态：[地址](https://stackblitz.com/edit/angular-zntusy)

```ts
// 父组件
@Component({
    selector: 'my-app',
    template: `
        <div [textContent]="text"></div>
        <child-comp></child-comp>
    `
})
export class AppComponent {
    text = 'Original text in parent component';
}


// 子组件
@Component({
    selector: 'child-comp',
    template: `<span>I am child component</span>`
})
export class ChildComponent {
  	// 获取到父组件
    constructor(private parent: AppComponent) {}
		// 通过父组件直接更新数据
    ngAfterViewChecked() {
        this.parent.text = 'Updated text in parent component';
    }
}
// 结果：ExpressionChangedAfterItHasBeenCheckedError
// 原因：当 Angular 在子组件中调用 ngAfterViewChecked 生命周期钩子时，父级 App 组件视图的数据绑定已被检查过，但这里在检查后更新了父组件中的 text 属性，导致前后两次绑定表达式的产生结果不一致，报错；
// 但是：若将 ngAfterViewChecked 改为 ngOnInit 等其他钩子函数(不含 AfterViewInit、AfterViewChecked)则不会报错
// 原因：Angular 在变更检测期间执行的操作顺序
```

在获悉 Angular 在变更检测期间执行的操作顺序前，需要搞明白 Angular 中的视图和绑定；在 `@angular/core` 模块中有一个名为 `checkAndUpdateView`的函数，它遍历组件树中的视图(组件)，并对每个视图执行检测；可通过 [此演示](https://angular-eobrrh.stackblitz.io/) 去进行调试：打开控制台，找到函数并打上断点，点击按钮触发变化监测，审查`view`变量

<video src="/Image/Frame/Angular/10.mov" style="zoom:50%;" align="left"></video>

结果：第一个 view 会成为宿主视图，其是 Angular 创建的一个根组件，用来托管 app 组件，继续执行，以获得它的子视图，此亦 AppComponent 的视图；

- component 属性存放了 App 组件的实例；
- node 属性存放了 DOM 节点的引用，这些 DOM 节点是为 App 组件的模板中的元素创建的；
- oldValues 数组存储了绑定表达式的结果；

关键：`checkAndUpdateView` 函数(**<u>*先别管上面的调试过程与结果，只须知道此函数即可*</u>**)，可以发现，Angular 会在变化检测期间触发生命周期钩子：当 Angular 处理绑定时，一些钩子在渲染前被调用，一些钩子则在渲染后才被调用

```js
function checkAndUpdateView(view, ...) {
    ...       
    // 更新子视图(组件)和指令中的绑定,
    // 如果有需要的话，调用 NgOnInit, NgDoCheck and ngOnChanges 钩子
    Services.updateDirectives(view, CheckType.CheckAndUpdate);
    
    // DOM 更新，为当前视图(组件)执行渲染
    Services.updateRenderer(view, CheckType.CheckAndUpdate);
    
    // 在子视图(组件)中执行变更检测
    execComponentViewsAction(view, ViewAction.CheckAndUpdate);
    
    // 调用 AfterViewChecked 和 AfterViewInit 钩子
    callLifecycleHooksChildrenFirst(…, NodeFlags.AfterViewChecked…);
    ...
}
```

<img src="/Image/Frame/Angular/11.png" style="zoom:50%;" align="" />

- 首先，Angular 为子组件更新输入绑定；
- 然后，Angular 调用了子组件上的 `OnInit`、`DoCheck`、`Onchanges` 钩子；
  - 意义：因子组件刚更新了输入绑定，所以 Angular 需要通知子组件输入绑定已被初始化；
- 然后，Angular 为子组件执行渲染；
- 此后，**<u>*Angular 为子组件运行变更检测 Run change detection，即意味着它会在子视图中重复这些操作；*</u>**
- 最后，Angular 调用了子组件上的 `AfterViewChecked`、`AfterViewInit` 钩子让子组件知道已被检查；

- 注意：Angular 在处理了父组件的绑定后，才调用子组件的 `AfterViewChecked` 生命周期钩子；
- 注意：`OnInit` 钩子在绑定被处理前调用，故即使在 `OnInit` 中改变 `text` 值，在随后的检查中它仍然是相同的，就解释了在 `ngOnInit`中不报错的行为；

##### 1-4-2-2、变更检测机制总结

Angular 中的所有组件，在内部均被表示为一种叫视图的数据结构；

Angular 的编译器解析模板并创建绑定，而每一绑定定义了：一个要更新的DOM元素的属性 & 用于求值的表达式；

视图中的 `oldValues `属性存储了在变更检测中被用于比较的旧值；

在变更检测期间，Angular 遍历所有绑定，并对表达式求值，将所得的结果与旧值比较，若有必要则更新DOM；

每个变更检测循环后，Angular 运行一次检查以确保组建的状态与用户界面同步；这次检查为同步运行并可能会报错`ExpressionChangedAfterItWasChecked`；

参考：https://blog.angularindepth.com/a-gentle-introduction-into-change-detection-in-angular-33f9ffff6f10



##### 1-4-2-3、变更检测触发器 Zone

##### 1-4-2-3-1、变化源于异步操作

**<u>*组件初始化后的 一切 数据变化均是由某个异步事件产生*</u>**；因为：初始化是一个同步过程，在 Angular 框架中，组件初始化对应的就是组件的构造方法被调用，此构造过程是一个同步的过程；而在构造过程后只有异步事件才会令组件中的数据发生变化，比如：点击，Ajax 请求，Promise，setTimeout 或 Websocket 等；

##### 1-4-2-3-2、Zone.js

为能在上述异步事件发生时及时检查变化，在 Angular 应用启动时会通过 Zone.js 库，为许多浏览器提供的 API 打补丁(可理解为劫持或封装处理)，使用代理方法来代理浏览器 API 的调用，代理方法不仅会调用监听事件时提供的回调函数，还会执行变更检查以及刷新界面；

Zone.js 是 Angular 团队在开发 Angular2 时实现的一个独立的库；Angular2 框架直接依赖 Zone.js 来实现变更检查；而 [Zone.js](https://www.cnblogs.com/whitewolf/p/zone-js.html) 实际上是一个异步操作的执行上下文，它为一组异步操作提供了一个统一的运行环境，并为这组异步过程的生命周期提供钩子方法，以方便在异步事件进行的不同阶段执行一些任务；

Zone.js 对浏览器中的 setTimeout、setInterval、setImmediate、以及事件、promise、地理信息geolocation都做了特殊处理；

<img src="/Image/Frame/Angular/21.png" style="zoom:50%;" align="left" />

<img src="/Image/Frame/Angular/22.png" style="zoom:50%;" align="left" />

首先，zone会将浏览器的原生方法保存在 setNative 中以便将会重用；

然后，zone 就开始其暴力行为，覆盖 window[setName] 和 window[clearName]；

然后，将对 setName 的调用转到自身的 zone[setName] 的调用(如此暴力的对浏览器原生对象实现了拦截转移)；

然后，zone 会在 Task 执行的前后调用自身的 addRepeatingTask、addTask 以及 wtf 事件来应用注册上的所有钩子函数；

补丁示例如下：addEventListener(Zone.js v0.6.0 版本)：是浏览器提供的用于监听事件的 API，在 Angular 启动的时候将它替换成了一个新的版本：

```js
function patchEventTargetMethods(obj, addFnName, removeFnName, metaCreator) {
    if (addFnName === void 0) { addFnName = ADD_EVENT_LISTENER; }
    if (removeFnName === void 0) { removeFnName = REMOVE_EVENT_LISTENER; }
    if (metaCreator === void 0) { metaCreator = defaultListenerMetaCreator; }
    if (obj && obj[addFnName]) {
        // 将 addEventListener 和 removeEventListener 分别替换为 makeZoneAwareAddListener 和 makeZoneAwareRemoveListener
        patchMethod(obj, addFnName, function () { return makeZoneAwareAddListener(addFnName, removeFnName, true, false, false, metaCreator); });
        patchMethod(obj, removeFnName, function () { return makeZoneAwareRemoveListener(removeFnName, true, metaCreator); });
        return true;
    }
    else {
        return false;
    }
}

// 实施替换的方法
function patchMethod(target, name, patchFn) {
    var proto = target;
    // ...
    // 获取带前缀的方法名
    var delegateName = zoneSymbol(name);
    var delegate;
    // 检查是否已经 patch 过
    if (proto && !(delegate = proto[delegateName])) {
        delegate = proto[delegateName] = proto[name];
        // 获取代理方法
        var patchDelegate_1 = patchFn(delegate, delegateName, name);
        // 将代理方法赋给对象的 addEventListener 属性
        proto[name] = function () {
            return patchDelegate_1(this, arguments);
        };
        // 将原来的方法实现作为属性添加到 proto[name] 上面
        attachOriginToPatched(proto[name], delegate);
    }
    // 返回原方法
    return delegate;
}

// 替换后的 "addEventListener"
function makeZoneAwareAddListener(addFnName, removeFnName, useCapturingParam, allowDuplicates, isPrepend, metaCreator) {
    // ...
    // 调度事件的方法
    function scheduleEventListener(eventTask) {
        var meta = eventTask.data;
        attachRegisteredEvent(meta.target, eventTask, isPrepend);
        return meta.invokeAddFunc(addFnSymbol, eventTask);
    }
    // 取消事件监听的方法
    function cancelEventListener(eventTask) {
        var meta = eventTask.data;
        findExistingRegisteredTask(meta.target, eventTask.invoke, meta.eventName, meta.useCapturing, true);
        return meta.invokeRemoveFunc(removeFnSymbol, eventTask);
    }
    // self 是被监听的对象， args 是监听的事件，包括事件名称和 callback
    return function zoneAwareAddListener(self, args) {
        // 根据事件的名称和回调方法创建封装 ZoneTask 的 data 对象
        var data = metaCreator(self, args);
        // ...
        // 获取当前的 Zone
        var zone = Zone.current;
        var source = data.target.constructor['name'] + '.' + addFnName + ':' + data.eventName;
        // 创建 ZoneTask 并开始调度这个 Task
        zone.scheduleEventTask(source, delegate, data, scheduleEventListener, cancelEventListener);
      	// 注意: 上述方法中又调用了 invokeAddFunc 方法，方法中有如下的语句:
      	// this.target[addFnSymbol](this.eventName, delegate.invoke, this.useCapturing);
      	// target 是被监听的对象
      	// target[addFnSymbol] 是浏览器提供的原始的 addEventListener 方法
      
      	// 这里，Zone.js 才真正地将 Task 的 invoke 方法与事件绑定在一起
      	// 当事件被触发时，便会调用 Task.invoke 在 invoke 中响应事件执行操作;
      	// 当事件发生时，便直接调用 invoke 方法来执行用户提供的 callback 以及其他的操作;
      	// 至此也就完成了给 addEventListener 打补丁的工作
      	// 总结: 层层封装，层层套娃

    };
}
```

<img src="/Image/Frame/Angular/12.png" style="zoom:50%;" align="" />

总结：Zone 为异步事件的处理提供了代理方法，在所有的异步事件被触发的时，都会先经过 Zone 的代理方法，此后，凡是在 Zone 内执行的异步事件的执行过程都在 Zone 的掌控之下，Zone 也就能知道这组异步事件在什么时候执行完成；而又因数据的变化是且仅可能是由于异步事件而产生，所以 Angular 也就可以通过监听 Zone 的生命周期事件，来得知什么时候应该进行变更检查；

##### 1-4-2-3-3、Zone.js 的 NG 应用

Zone.js 向外暴露了一个 Zone 对象，下面是其生命周期中各阶段的钩子方法，这些方法都会在 Zone 的各个生命周期钩子中被调用；

```js
// NgZone
NgZone.prototype.onEnter = function () {
    this._nesting++;
    if (this._isStable) {
        this._isStable = false;
        this._onUnstable.emit(null);
    }
};
NgZone.prototype.onLeave = function () {
    this._nesting--;
    this.checkStable();
};
NgZone.prototype.setHasMicrotask = function (hasMicrotasks) {
    this._hasPendingMicrotasks = hasMicrotasks;
    this.checkStable();
};
NgZone.prototype.setHasMacrotask = function (hasMacrotasks) { this._hasPendingMacrotasks = hasMacrotasks; };
NgZone.prototype.triggerError = function (error) { this._onErrorEvents.emit(error); };
```

当 NgZone run 之后，Angular 便会实例化一个叫做 `ApplicationRef` 的类，其中的 onMicrotaskEmpty 监听到后就会触发变更检测；

```js
// ...  
class ApplicationRef {
    _views:Array = [];
    constructor(private zone: NgZone) {
      	// onMicrotaskEmpty 事件会在当前 Zone 中的异步过程都已完成时触发
      	// 当监听到此事件后就去遍历 View 并且调用每个 view 的 detectChanges 方法来进行变更检查
        this.zone.onMicrotaskEmpty.subscribe(() => this.zone.run(() => this.tick());
    }
    tick() {
        this._runningTick = true;
        this._views.forEach(function (view) {
            return  view.ref.detectChanges();
        });
    }
}
```

注意：并非所有异步操作都有必要触发变更检查；比如某次异步操作，却没有数据发生变化，则应不必触发；而由于 Angular 应用运行在 NgZone 之中，所有在 NgZone 之中的异步操作都会通知框架进行变更检查；为此，NgZone 提供了一个 `runOutsideAngular` 方法，可供方法在 NgZone 之外运行，而不会触发 Angular 的变更检查，示例见前文，[或看此](http://plnkr.co/edit/j9W2op4lGezi8eexwHg6?p=preview)

##### 1-4-2-3-4、再述变更检测

以下内容<u>基于 Angular2.4.9</u>，补充 JIT 与 AOT 机制：

- JIT：吞吐量高，有运行时性能加成，可跑得更快，并可做到动态生成代码等，但相对启动速度较慢，并需一定时间和调用频率才能触发 JIT 的分层机制证；
- AOT：内存占用低启动速度快，无需 runtime 运行，直接将 runtime 静态链接至最终程序中，但无运行时性能加成，不能根据程序运行情况做进一步优化；

<img src="/Image/Frame/Angular/14.png" style="zoom:50%;" align="" />

非 AOT 模式下 Angular 将在运行时利用 JIT 机制，创建组件的包装类，框架将会为每个组件生成相应的包装类，也即对于每一个组件来讲，Angular 会为其生成至少两个类型 `View_ClassName_App` 和 `Wrapper_ClassName_App`，根组件还会生成一个 `View_ClassNameApp_Host`，来作为应用组件的入口，变更检查也是从这个地方开始；`Wrapper_ClassName_App` 类主要是提供了组件的生命周期钩子，`View_ClassName_App` 类主要做了下面5件事：

- 注入依赖；
- 创建组件中的 DOM 元素渲染页面；
- 响应绑定的事件；
- 利用类型为 `changeDetectorRef` 的变更检查器执行变更检查；
- 提供 debug 信息；

Angular 应用是由组件组成的树，每个组件又有自己的变更检查器，于是变更检查器们也组成了一颗变更检查器树；

无论哪一个组件的变更检查被触发时 Angular 都会采用 **<u>*深度优先遍历*</u>** 方式从根节点遍历整个变更检查器树；在 JIT 模式下，这些变更检查器会被编译成为 `View_ClassName_App` 中的`detectChangesInternal` 方法，在这个方法中组件会对自己内部的数据绑定进行检查，调用自己的 `ngOnChanges` 生命周期方法，若有子组件则还会调用子组件 `internalDetectChanges` 方法，如此不断，将检查沿着树枝的方向进行下去，如下图；此树也可描述 Angular 中组件的数据流是从上往下流动(原因是变更检查也是从上到下)；

<img src="/Image/Frame/Angular/13.png" style="zoom:50%;" align="" />

**<u>*比如*</u>**：在文本框中输入文字时，就会马上触发组件的变更检查，此时调用了 `View_InventoryApp0.detectChangesInternal` 方法：

**<u>*首先*</u>**，仔细留意末行，调用了 `jit_checkBinding25` 方法，其会比较新旧两个值是否相同，此方法是框架编译生成的方法，在运行时找到实际上调用的是 `view_utils.checkBinding` 方法，若`throwOnChange` 的值为 false，则使用 `looseIdentical` 来进行新旧值的比较，方法存在于 lang.js：

<img src="/Image/Frame/Angular/15.png" style="zoom:50%;" align="left" />

<img src="/Image/Frame/Angular/17.png" style="zoom:70%;" align="left" />

```js
export function looseIdentical(a, b) {
    return a === b || typeof a === 'number' && typeof b === 'number' && isNaN(a) && isNaN(b);
}
// 注意: 只是简单比较了引用或者值是否相同，并无做深度比较；所以数组或者对象等集合类型内部的值发生变化，Angular 并不能检查到
```

**<u>*然后*</u>**，Angular 在检查变更之后立即更新了视图：

<img src="/Image/Frame/Angular/18.png" style="zoom:80%;" align="left" />

```
if (jit_checkBinding24(throwOnChange,self._expr_32,currVal_32)) {
    self.renderer.setText(self._text_5,currVal_32);
    self._expr_32 = currVal_32;
}
```

当前组件所有的变更检查执行完成后，开始检查子组件的变更，然后变更检查器会按照深度优先的规则遍历整个组件树，直到所有节点的变更检查都完成为止；

由于单向数据流的原因，变更检查只需要执行一遍就可稳定下来，若在首次检查中产生副作用使得已检查过的节点发生了变化，Angular 会抛出异常(在开发模式开启二次检查机制，以避免上线发生此种情况)；抛出前面提到错误 ExpressionChangedAfterItHasBeenCheckedError；

**<u>*优化*</u>**：OnPush 策略

Default 模式下，每一组异步操作结束后，都会触发对整个组件树的变更检查，在某些场景下，某些组件是不需要每次都被检查，此时可将它们标记为不可变对象，Angular 将跳过对该组件的全部变化监测(含子组件)，直到有属性的引用发生变化为止；如果需要在 Angular 中使用不可变对象，则需要设置 `changeDetection: ChangeDetectionStrategy.OnPush`，启用 OnPush 模式，来避免不必要的变更检查以提升应用性能；

- 不可变对象：保证对象不会改变，即当其内部属性发生变化时，将会用新对象来替代旧对象；不可变对象仅仅依赖初始化时的属性，也即初始化时候属性没有改变，没有改变就不会产生一份新的引用；

```js
@Component({
  // ...
  changeDetection: ChangeDetectionStrategy.OnPush
}
export class InventoryApp {
	// ...
}
```

**<u>*示例*</u>**：

[示例地址](https://plnkr.co/edit/zGNlvnYsPSKbQPv7HxX3?p=preview&preview)；黄色部分是父组件，灰色的部分是子组件，子组件开启了 OnPush 模式； 

当点击黄色部分时，虽改变了 `this.person.name` 值，但是此变化并不能被框架检测到，也即反映在视图上；因为开启了 OnPush 模式的组件，它的变更检查器将会被关闭，它与它的子节点都无法再检查到父组件带来的变更；但注意：由节点内部产生的变化依然会触发变更检查；

<img src="/Image/Frame/Angular/20.png" style="zoom:50%;" align="left" />

点击灰色部分，也即被设置为 OnPush 模式的子组件，此时触发了子组件中的 onclick 方法，改变了 `this.person.name` 的值，由于此变更是由子组件内部事件导致，这时将会触发变更检查，视图上的文字也会被更新；





##### 1-4-2-3-5、变更检测机制再总结

<img src="/Image/Frame/Angular/19.png" style="zoom:50%;" align="left" />

1. Zone.js 为浏览器 API 打补丁
2. NgZone 初始化，监听当前 Zone 中的异步事件执行是否完成
3. 异步事件执行结束后出发 tick 方法开始变更检查
4. 变更检查由根组件开始按照深度优先遍历变更检查器树
5. 在每个数据绑定的检查结束之后，立即更新视图
6. 在继续检查子组件直到所有组件检查完成









参考：https://skyfly.xyz/2017/07/04/Front_End/Angular/AngularChangeDetection/















### 1-5、状态管理

#### 1-5-1、Vue

<img src="/Image/Frame/Vue/37.png" style="zoom:50%;" />

Vue 通过 [Vuex](https://vuex.vuejs.org/zh-cn/intro.html) 进行应用的状态管理，其借鉴了Flux、redux 基本思想，将共享数据抽离到全局，以单例形式存放，同时利用 Vue 的响应式机制来进行数据状态管理与更新；Vuex实现了一个单向数据流：

- 首先，在全局通过 State 存放数据，而所有修改 State 的操作，均须通过 Mutation 进行，同时其还提供订阅者模式以供外部插件调用获取 State 数据更新；
- 然后，所有异步接口均须通过 Action 操作(常见于调用后端接口异步获取更新数据)；
  - 注意 Action也是无法直接修改 State，仍需通过 Mutation 来修改 State 中数据；
- 最后，根据 State 变化，渲染到视图上；
  - 注意：Vuex 运行依赖于 Vue 内部数据双向绑定机制，故需 new一个Vue对象来实现"响应式化”；

安装：只需提供 store，然后执行下述代码即可完成 Vuex 的引入：

```js
Vue.use(Vuex);
// 将 store 放入 Vue 创建时的 option 中
new Vue({
    el: '#app',
    store
});
```

补充：Vue.use 原理 & Vuex.init

Vue 提供 [Vue.use ](https://cn.vuejs.org/v2/api/#Vue-use)方法来给 Vue 安装插件，其内部通过调用插件的 install 方法(当插件是一个对象时)来进行插件安装，从而将上述代码中的 store 注入到 Vue 实例中去；注意：因 Vue 版本不同；Vue.use 会有不同处理(applyMixin->VueInit)，若为版本1则将 VueInit 放入 init 方法中，若为版本2则将 VueInit 混淆进 beforeCreate 钩子中；

在 Vuex.init 中，根节点执行或使用 store，子组件则直接从父组件中获取 $store，保证所有组件都公用了全局的同一份 store

```js
// 一是防止 Vuex 被重复安装
// 二是执行 applyMixin，目的是执行 vuexInit 方法初始化 Vuex
export function install (_Vue) {
  if (Vue) {
    // 避免重复安装
    if (process.env.NODE_ENV !== 'production') {
      console.error(
        '[vuex] already installed. Vue.use(Vuex) should be called only once.'
      )
    }
    return
  }
  // 保存 Vue，同时用于检测是否重复安装
  Vue = _Vue
  // 将 vuexInit 混淆进 Vue 的 beforeCreate(Vue2.0) 或 _init方法(Vue1.0)
  applyMixin(Vue)
}

// ...

// Vuex 的 init 钩子，会存入每一个 Vue 实例等钩子列表
function vuexInit () {
  const options = this.$options
  // store injection
  if (options.store) {
    // 存在 store 其实代表的就是 Root 节点，直接执行 store(function时) 或使用 store(非function)
    this.$store = typeof options.store === 'function'
      ? options.store()
    : options.store
  } else if (options.parent && options.parent.$store) {
    // 子组件直接从父组件中获取 $store，以保证了所有组件都公用了全局的同一份 store
    // 如此便可以在每一个组件中通过 this.$store 访问全局的 Store 实例
    this.$store = options.parent.$store
  }
}
```



##### 1-5-1-1、Store

上述传入根组件的 store，即 Store 实例，其使用 Vuex 提供的 Store 方法构造：

Store 构造类初始化了些内部变量，并主要执行 installModule (初始化module) 以及 resetStoreVM (通过 VM 使 store "响应式")

```js
export default new Vuex.Store({
    strict: true,
    modules: {
        moduleA,
        moduleB
    }
});

// Store constructor
constructor (options = {}) {
    // Auto install if it is not done yet and `window` has `Vue`.
    // To allow users to avoid auto-installation in some cases,
    // this code should be placed here. See #731
  	// 在浏览器环境下，如果插件还未安装（!Vue即判断是否未安装），则它会自动安装。
  	// 允许用户在某些情况下避免自动安装;
    if (!Vue && typeof window !== 'undefined' && window.Vue) {
      install(window.Vue)
    }

    if (process.env.NODE_ENV !== 'production') {
      assert(Vue, `must call Vue.use(Vuex) before creating a store instance.`)
      assert(typeof Promise !== 'undefined', `vuex requires a Promise polyfill in this browser.`)
      assert(this instanceof Store, `Store must be called with the new operator.`)
    }

    const {
      // 包含应用在 store 上的插件方法
      // 这些插件直接接收 store 作为唯一参数
      // 可监听 mutation（用于外部地数据持久化、记录或调试）或提交 mutation （用于内部数据，例如 websocket 或 某些观察者）
      plugins = [],
      // 让 Vuex store 进入严格模式，此时的任何 mutation 处理函数以外修改 Vuex state 都会抛出错误
      strict = false
    } = options

    // 从 option 中取出 state，若为 function 则执行，最终得到一个对象
    let { state = {} } = options
    if (typeof state === 'function') { state = state() }

    // store internal state
    // 用来判断严格模式下是否是用 mutation 修改 state
    this._committing = false
    // 存放 action
    this._actions = Object.create(null)
    // 存放 mutation
    this._mutations = Object.create(null)
    // 存放 getter
    this._wrappedGetters = Object.create(null)
    // module 收集器
    this._modules = new ModuleCollection(options)
    // 根据 namespace 存放 module
    this._modulesNamespaceMap = Object.create(null)
    // 存放订阅者
    this._subscribers = []
    // 用以实现 Watch 的 Vue 实例
    this._watcherVM = new Vue()

    // bind commit and dispatch to self
    // 将 dispatch 与 commit 调用的 this 绑定为 store 对象本身，否则在组件内部 this.dispatch 时的 this 会指向组件的 vm
    const store = this
    const { dispatch, commit } = this
    // 为 dispatch 与 commit 绑定 this (Store实例本身)
    this.dispatch = function boundDispatch (type, payload) {
      return dispatch.call(store, type, payload)
    }
    this.commit = function boundCommit (type, payload, options) {
      return commit.call(store, type, payload, options)
    }

    // strict mode
    // 严格模式(使 Vuex store 进入严格模式，此时任何 mutation 处理函数以外修改 Vuex state 都会抛出错误)
    this.strict = strict

    // init root module.
    // this also recursively registers all sub-modules
    // and collects all module getters inside this._wrappedGetters
    // 初始化根 module，同时递归注册了所有子 modle，收集所有 module 的 getter 到 _wrappedGetters 中去
  	// this._modules.root 代表根 module才独有保存的 Module 对象
    installModule(this, state, [], this._modules.root)

    // initialize the store vm, which is responsible for the reactivity
    // (also registers _wrappedGetters as computed properties)
    // 通过 vm 重设 store，新建 Vue 对象使用 Vue 内部的响应式实现注册 state 及 computed
    resetStoreVM(this, state)

    // apply plugins
    // 调用插件
    plugins.forEach(plugin => plugin(this))

    // devtool 插件
    if (Vue.config.devtools) {
      devtoolPlugin(this)
    }
  }
```

##### 1-5-1-2、Store-installModule

作用是用为 module 加上 namespace名字空间后，注册 mutation、action 及 getter，同时递归安装所有子 module

```js
//  初始化 module
function installModule (store, rootState, path, module, hot) {
  //  是否是根 module 
  const isRoot = !path.length
  //  获取 module 的 namespace 
  const namespace = store._modules.getNamespace(path)

  // register in namespace map
  //  若有 namespace 则在 _modulesNamespaceMap 中注册 
  if (module.namespaced) {
    store._modulesNamespaceMap[namespace] = module
  }

  // set state
  if (!isRoot && !hot) {
    //  获取父级的 state 
    const parentState = getNestedState(rootState, path.slice(0, -1))
    //  module 的 name 
    const moduleName = path[path.length - 1]
    store.`_withCommit`(() => {
      //  将子 module 设置称响应式的 
      Vue.set(parentState, moduleName, module.state)
    })
  }

  const local = module.context = makeLocalContext(store, namespace, path)

  //  遍历注册 mutation 
  module.forEachMutation((mutation, key) => {
    const namespacedType = namespace + key
    registerMutation(store, namespacedType, mutation, local)
  })

  //  遍历注册 action 
  module.forEachAction((action, key) => {
    const namespacedType = namespace + key
    registerAction(store, namespacedType, action, local)
  })

  //  遍历注册 getter 
  module.forEachGetter((getter, key) => {
    const namespacedType = namespace + key
    registerGetter(store, namespacedType, getter, local)
  })

  //  递归安装 mudule 
  module.forEachChild((child, key) => {
    installModule(store, rootState, path.concat(key), child, hot)
  })
}
```



##### 1-5-1-3、Store-resetStoreVM-Core

```js
//  通过 vm 重设 store，新建 Vue 对象使用 Vue 内部的响应式实现注册 state 及 computed 
function resetStoreVM (store, state, hot) {
  //  存放之前的 vm 对象 
  const oldVm = store._vm 

  // bind store public getters
  store.getters = {}
  const wrappedGetters = store._wrappedGetters
  const computed = {}

  // 遍历 wrappedGetters，使用 Object.defineProperty 方法为每一个 getter 绑定上get方法
  // 如此在组件里访问 this.$store.getter.test 就等同于访问 store._vm.test，也即 Vue 对象的 computed 属性 
  forEachValue(wrappedGetters, (fn, key) => {
    // use computed to leverage its lazy-caching mechanism
    computed[key] = () => fn(store)
    Object.defineProperty(store.getters, key, {
      get: () => store._vm[key],
      enumerable: true // for local getters
    })
  })

  // use a Vue instance to store the state tree
  // suppress warnings just in case the user has added
  // some funky global mixins
  const silent = Vue.config.silent
  //  Vue.config.silent 暂时设置为 true，原因是 new 一个 Vue 实例过程中不会报出一切警告 
  Vue.config.silent = true
  // 关键: Vuex 采用了 new 一个 Vue对象来实现数据的"响应式化"，运用 Vue 内部提供的数据双向绑定功能来实现 store 的数据与视图的同步更新
  // 此时访问 store._vm.test 也即访问 Vue 实例中的属性
  store._vm = new Vue({
    data: {
      ?state: state
    },
    computed
  })
  Vue.config.silent = silent

  // enable strict mode for new vm
  //  使能严格模式，保证修改 store 只能通过 mutation 
  if (store.strict) {
    enableStrictMode(store)
  }

  if (oldVm) {
    //  解除旧 vm 的 state 的引用，及销毁旧 Vue 对象 
    if (hot) {
      // dispatch changes in all subscribed watchers
      // to force getter re-evaluation for hot reloading.
      store._withCommit(() => {
        oldVm._data.?state = null
      })
    }
    Vue.nextTick(() => oldVm.$destroy())
  }
}
  
// 上述两步完成后，即可通过 this.$store.getter.test 访问 vm 中的 test 属性
```



##### 1-5-1-4、VuexStrictMode

Vuex 的 Store 构造类的 option 有 strict 参数，可控制 Vuex 执行严格模式，严格模式下，所有修改 state 的操作须通过 mutation 实现，否则会抛出错误；

总的来说局势通过标志位判断；只有正确方法调用标志位才会放开，从而实现 Vuex 的严格模式；

```js
// 使能严格模式
function enableStrictMode (store) {
  // Vuex 利用 vm 的 $watch 方法来观察 ?state，也即 Store 的 state，在它被修改时进入回调
  // 回调中用 assert 断言来检测 store._committing，当 store._committing 为 false 时触发断言，抛出异常
  store._vm.$watch(function () { return this._data.?state }, () => {
    if (process.env.NODE_ENV !== 'production') {
      // 检测 store 中的 _committing 值，若是 true 代表不是通过 mutation 方法修改
      assert(store._committing, `Do not mutate vuex store state outside mutation handlers.`)
    }
  }, { deep: true, sync: true })
}

// Store 的 commit 方法中，执行 mutation 的语句是这样
this._withCommit(() => {
  entry.forEach(function commitIterator (handler) {
    handler(payload)
  })
})

_withCommit (fn) {
  // 调用 withCommit 修改 state 值时，会将 store 的 committing 值置为 true，内部会有断言检查该值
  // 在严格模式下只允许使用 mutation 来修改 store 中值，而不允许直接修改 store 的数值

  // 通过 commit（mutation）修改 state 数据时，会再调用 mutation 方法之前将 committing 置为 true，
  // 接下来再通过 mutation 函数修改 state 中的数据，此时触发 $watch 中的回调断言 committing 是不会抛出异常的（此时committing为true）
  // 而当直接修改 state 数据时，触发 $watch 的回调执行断言，此时 committing 为 false，则会抛出异常
  const committing = this._committing
  this._committing = true
  fn()
  this._committing = committing
}
```



##### 1-5-1-5、Commit-mutation

commit 方法会根据 type 找到并调用 _mutations 中的所有 type 对应的 mutation 方法，然后会执行 _subscribers 中的所有订阅者

```js
// 调用 mutation 的 commit 方法
commit (_type, _payload, _options) {
  // check object-style commit
  // 校验参数
  const {
    type,
    payload,
    options
  } = unifyObjectStyle(_type, _payload, _options)

  const mutation = { type, payload }
  // 取出 type 对应的 mutation 方法
  const entry = this._mutations[type]
  if (!entry) {
    if (process.env.NODE_ENV !== 'production') {
      console.error(`[vuex] unknown mutation type: ${type}`)
    }
    return
  }
  // 执行 mutation 中所有方法
  this._withCommit(() => {
    entry.forEach(function commitIterator (handler) {
      handler(payload)
    })
  })
  // 通知所有订阅者
  this._subscribers.forEach(sub => sub(mutation, this.state))

  if (
    process.env.NODE_ENV !== 'production' &&
    options && options.silent
  ) {
    console.warn(
      `[vuex] mutation type: ${type}. Silent option has been removed. ` +
      'Use the filter functionality in the vue-devtools'
    )
  }
}
// commit 方法会根据 type 找到并调用 _mutations 中的所有 type 对应的 mutation 方法
// 所以当没有 namespace 时，commit 方法会触发所有 module 中的 mutation 方法, 再执行完所有的 mutation 后会执行 _subscribers 中的所有订阅者


// Store 向外部提供了一个 subscribe 方法
// 用以注册一个订阅函数，会 push 到 Store 实例的 _subscribers 中，同时返回一个从 _subscribers 中注销该订阅者的方法。
// 注册一个订阅函数，返回取消订阅的函数
subscribe (fn) {
  const subs = this._subscribers
  if (subs.indexOf(fn) < 0) {
    subs.push(fn)
  }
  return () => {
    const i = subs.indexOf(fn)
    if (i > -1) {
      subs.splice(i, 1)
    }
  }
}

// 在 commit 结束后则会调用这些 _subscribers 中的订阅者，此订阅者模式提供给外部一个监视 state 变化的可能 state 通过 mutation改变时，可有效补获这些变化
```

##### 1-5-1-6、Dispatch-action

```js
// 调用 action 的 dispatch 方法
dispatch (_type, _payload) {
  // check object-style dispatch
  const {
    type,
    payload
  } = unifyObjectStyle(_type, _payload)

  // actions 中取出 type 对应的 ation
  const entry = this._actions[type]
  if (!entry) {
    if (process.env.NODE_ENV !== 'production') {
      console.error(`[vuex] unknown action type: ${type}`)
    }
    return
  }

  // 若是数组则包装 Promise 形成一个新 Promise，只有一个则直接返回第0个
  return entry.length > 1
    ? Promise.all(entry.map(handler => handler(payload)))
    : entry[0](payload)
}


// 遍历注册 action
function registerAction (store, type, handler, local) {
  // 取出 type 对应的 action
  const entry = store._actions[type] || (store._actions[type] = [])
  entry.push(function wrappedActionHandler (payload, cb) {
    let res = handler.call(store, {
      dispatch: local.dispatch,
      commit: local.commit,
      getters: local.getters,
      state: local.state,
      rootGetters: store.getters,
      rootState: store.state
    }, payload, cb)
    // 判断是否是 Promise
    if (!isPromise(res)) {
      // 不是 Promise 对象则转化 Promise 对象
      res = Promise.resolve(res)
    }
    if (store._devtoolHook) {
      // 存在 devtool 插件时触发 vuex 的 error 给 devtool
      return res.catch(err => {
        store._devtoolHook.emit('vuex:error', err)
        throw err
      })
    } else {
      return res
    }
  })
}


// 因 registerAction 时将 push 进 _actions 的 action 进行了一层封装（wrappedActionHandler）
// 所以在进行 dispatch 的第一个参数中获取 state、commit 等方法
// 之后，执行结果 res 会被进行判断是否是 Promise，不是则会进行一层封装，将其转化成 Promise 对象, 
// dispatch 时则从 _actions 中取出，只有一个的时候直接返回，否则用P romise.all 处理再返回。
```

##### 1-5-1-7、watch

```js
// 观察一个 getter 方法
// _watcherVM 是一个 Vue 实例，所以 watch 就可以直接采用 Vue 内部的 watch 特性提供了一种观察数据 getter 变动的方法
watch (getter, cb, options) {
  if (process.env.NODE_ENV !== 'production') {
    assert(typeof getter === 'function', `store.watch only accepts a function.`)
  }
  return this._watcherVM.$watch(() => getter(this.state, this.getters), cb, options)
}
```

##### 1-5-1-8、un/registerModule

```js
// registerModule 用以注册一个动态模块，也即在 store 创建后再注册模块的时候用该接口
// 注册一个动态 module，当业务进行异步加载的时候，可通过该接口进行注册动态 module
registerModule (path, rawModule) {
  // 转化称 Array
  if (typeof path === 'string') path = [path]

  if (process.env.NODE_ENV !== 'production') {
    assert(Array.isArray(path), `module path must be a string or an Array.`)
    assert(path.length > 0, 'cannot register the root module by using registerModule.')
  }

  // 注册
  this._modules.register(path, rawModule)
  // 初始化 module
  installModule(this, this.state, path, this._modules.get(path))
  // reset store to update getters...
  // 通过 vm 重设 store，新建 Vue 对象使用 Vue 内部的响应式实现注册 state 及 computed
  resetStoreVM(this, this.state)
}



//  注销一个动态 module
// 动态注销模块, 通过先从 state 中删除模块，然后用 resetStore 来重制 store
unregisterModule (path) {
  // 转化称 Array
  if (typeof path === 'string') path = [path]

  if (process.env.NODE_ENV !== 'production') {
    assert(Array.isArray(path), `module path must be a string or an Array.`)
  }

  // 注销
  this._modules.unregister(path)
  this._withCommit(() => {
    // 获取父级的 state
    const parentState = getNestedState(this.state, path.slice(0, -1))
    // 从父级中删除
    Vue.delete(parentState, path[path.length - 1])
  })
  // 重制 store
  resetStore(this)
}
```



##### 1-5-1-9、ResetStore

```js
// 重制 store
// 将 store 中的 _actions 等进行初始化以后，重新执行 installModule 与 resetStoreVM 来初始化 module 及用 Vue 特性使其"响应式化"
function resetStore (store, hot) {
  store._actions = Object.create(null)
  store._mutations = Object.create(null)
  store._wrappedGetters = Object.create(null)
  store._modulesNamespaceMap = Object.create(null)
  const state = store.state
  // init all modules
  installModule(store, state, [], store._modules.root, true)
  // reset vm
  resetStoreVM(store, state, hot)
}
```



### 1-6、组件化

#### 1-6-1、Vue

#### 1-6-2、Angular



### 1-7、依赖注入

#### 1-7-1、Vue

#### 1-7-2、Angular

##### 1-7-2-1、依赖注入

**<u>*依赖*</u>**：如果类 A 功能的实现需借助类 B，则称类 B 是类 A 的依赖；

**<u>*问题*</u>**：如果在类 A 内部实例化类 B，则两者间就会出现较高耦合，一旦类 B 出现问题，类 A 也需进行改造，若此类情况较多，且每个类之间都有很多依赖，那么就会出现牵一发而动全身的情况，程序会变得极难维护，且很容易出现问题；

**<u>*解决*</u>**：将 A 类对 B 类的控制权抽离，交给第三方去管理；而将控制权反转给第三方，就称为 **<u>*控制反转(IOC—InversionOf Control)*</u>**

- 比如：类 A 依赖类 B，但 A 不控制 B 的创建和销毁，仅使用 B，那么将 B 的控制权则交给 A 之外的第三方处理，叫控制反转(IOC)；

- **<u>*控制反转*</u>**：最早在 04年由 *Martin Fowler* 提出，它是针对面向对象设计不断复杂化而提出的一种设计原则，是一种利用面向对象编程法则来降低应用程序耦合的设计模式；
- **<u>*IOC 容器*</u>**：IOC 强调对代码引用的控制权，由调用方法方转移到外部容器，在运行时通过某种方式注入进来，实现控制的反转，以降低服务类间的耦合度；实现 IOC 的框架叫 IOC 容器；
- **<u>*依赖注入*</u>**：DI—Dependency Injection，是 IOC 最典型的实现方法，由IOC容器来控制依赖，通过使用构造函数、属性或工厂模式等方法，将依赖注入到所需类中，极大程度对双方进行了解耦；Angular实现控制反转的形式/手段就是依赖注入；
  - DI 有利于应用程序中各模块之间的解耦，使得代码更容易维护，这种优势会随着项目复杂度的增加而增加；
  - DI 让开发者可专注于所依赖对象的消费，而无需关注这些依赖对象的产生过程，大大提升开发效率，此外还可松耦合和可重用性、提高可测试性；
- **<u>*两者区别*</u>**：DI 与 IOC 基本是一个意思，但前者是后者的具体形式，后者是一种思想和设计原则；
- 比如：类 A 对类 B 的控制，起初由程序员人工添加，形式、传参均被敲代码的瞬间固定下来，即可说明类 A "控制" 了类 B；引入 IOC 后，注入行为还是由程序员管理，但改为 import 等的统一形式，控制权不再由类 A 管理，而是由 DI 统一控制、统一管理； 

```ts
// 不使用 DI
class Player {
  Weapon: weapon;

  Player() {
    // 与 Sord 类紧耦合
    this.weapon = new Sord()
  }

  public void attack() {
    weapon.attack();
  }
}
// 使用 DI 效果
class Player {
  Weapon: weapon;

  // weapon 被注入进来
  Player(Weapon weapon) {
    this.weapon = weapon;
  }
  
  public void attack() {
    weapon.attack();
  }
}

// DI EX1
// A 依赖于 B，因此在 A 中必然要使用 B 的 instance，这里通过 A 的构造函数将 B 的实例注入
class B {}
class A {
  constructor(b: B) {
    console.log('b: ', b);
  }
}
const b = new B();
// 将 b 实例注入 A 中
const a = new A(b);
```





##### 1-7-2-2、NG依赖注入

**<u>*基本*</u>**：Angular 的依赖注入一种创建依赖其他对象的方法，在创建一个新的对象实例时，依赖注入系统将会提供依赖对象(称为依赖关系) - **<u>*Angular Docs；*</u>**

Angular 的依赖注入是用来创建对象及其依赖的其它对象的一种方式，当依赖注入系统创建某个对象实例时，会负责提供该对象所依赖的对象(称为该对象的依赖)；在依赖注入模式中，应用组件无需关注所依赖对象的创建和初始化过程，可认为框架已初始化完毕，开发者只管调用即可；

**<u>*流程*</u>**：得到依赖项、查找依赖项所对应的对象、执行时注入；

**<u>*注入器*</u>**：Angular 依赖注入器，负责创建服务的实例，并把它们注入到你想要注入的类中；Angular 本身无法自动判断你是打算自行创建服务类的实例，亦或者是等注入器来创建它；若想通过注入器来创建，则须为每个服务指定服务提供商，<u>每个服务均需用 @xx 声明(以供 Angular 识别，方便统一管理)</u>





##### 1-7-2-2-1、旧注入方式NG6-

- 在预加载的模块的 @NgModule 装饰器中指定 providers:[]
- 在懒加载的模块的 @NgModule 装饰器中指定 providers:[]
- 在 @Component 和 @Directive 装饰器中指定 providers:[]

预加载：服务将是全局单例，即使它被多个模块的 providers: [] 重复申明，也不会重新创建实例；

- 注入器只会创建一个实例，因为它们最终都会注册到根级注入器；

懒加载：在应用程序运行初始化后一段时间，懒加载模块中提供的服务实例才会在子注入器(懒加载模块)上创建；

- 假若在预加载模块中注入这些服务，将会报 <u>*`No provider for MyService!`*</u> 错误；
- 补充：[上述两种 NG 的预加载懒加载策略](https://zhuanlan.zhihu.com/p/56596626)

第三种：服务是按组件实例化，且可在组件及其子树中的所有子组件中访问；

- 此时的服务非单例对象，每次在另1个组件模板中使用组件时，均会获得所提供服务的新实例，但也意味着服务实例将与组件一起销毁；
- 比如：`RandomService` 在 `RandomComponent` 中被注册，因此每当在模板中使用 `<random></random>` 组件时均将得到不同随机数；
- 但若：在模块级别提供 `RandomService`并且将被作为单例提供则不会出现这种情况；
- 因为：此时 `<random></random>` 组件的每次使用都会显示相同的随机数，因为该数字是在服务实例化期间生成的；



##### 1-7-2-2-2、新注入方式NG6+

通过使用 @Injectable 装饰器的新增的 provideIn 属性来使用，官方名称是“Tree-shakable providers”；

- 注意：其将 provideIn 视为以反向方式指定依赖关系，即非 "模块声明需要哪些服务”，而是“服务本身宣布它应该提供给哪些模块使用"；
- 注意：声明的模块可以是 root 或其他任何可用模块，此外，root 实际上是 AppModule 别名，使用 root 别名便可无需额外导入 AppModule；
- <img src="/Image/Frame/Angular/1.png" style="zoom:50%;" align="left"/>

**<u>*问题A：懒加载模块与正常模块的服务自动绑定行为不可预测：*</u>**

- 懒加载模块意义：可非常容易的将应用程序分成完全独立的逻辑块：
  - 更小的初始化代码，这意味着更快的加载和启动时间；
  - 懒惰加载的模块是真正隔离的，主机应用程序应该引用它们的唯一一点是某些路由的 `loadChildren` 属性；
  - 即若：懒加载使用正确，可将整个模块删除或外部化为独立的应用程序/库，可能有数百个组件和服务的模块可在不影响应用程序其余部分的情况下随意移动，而对懒惰模块的逻辑进行更改永远不会导致应用程序的其他部分出错；
- 解释：在懒加载中使用 `providerIn:'root'` 实现服务，就会发生如下行为，但问题在于在拥有大量模块和服务的大型应用中，其将变得不可预测；
  - 若服务仅被注入到懒加载模块中，则其将绑定在懒加载包中；
  - 若服务又被注入到正常模块中，则将捆绑在主包中；

解决A-1：使用 `providedIn: EagerlyImportedModule`

原因：可用于防止应用程序的其余部分注入服务而无需导入相应的模块，但这其实并非必需，应坚持使用 `provideIn：'root'`

解决A-2：使用 `providedIn: LazyLoadedModule`

**<u>*问题B：循环引用：*</u>**

<img src="/Image/Frame/Angular/2.png" style="zoom:50%;" align="left"/>

解决B：可通过创建 LazyServiceModule 来避免此问题，如下图；它将是 LazyModule 的一个子模块，并将被用作我们想要提供的所有懒加载服务的“锚”；

<img src="/Image/Frame/Angular/3.png" style="zoom:50%;" align="left"/>

注意：虽然有点不方便，但只需增加一个模块，这种方法结合了2者的优点:

- 其防止我们将懒加载的服务注入应用程序的正常加载模块；
- 只有当服务被"真正”注入其他惰性组件时，它才会打包到服务中；

注意：新注入方式不适用于@Component 和 @Directive，@Directive还需通过传统的使用 provider:[]来创建多个服务实例(每个组件)

<img src="/Image/Frame/Angular/4.png" style="zoom:50%;" align="left"/>



##### 1-7-2-2-3、总结

- 将 `providedIn: 'root'` 用于在整个应用程序中作为单例可用的服务；
- 永远不要使用 `providedIn:EagerLiymportedmodule`，若有一些非常特殊的用例，则使用 `providers: []` 来代替；
- 使用 `providedIn: LazyServiceModule` 可防止将懒加载的服务注入应用程序的正常加载模块；
- 若想使用 `LazyServiceModule`，则须先将其导入 `LazyModule`，以防止循环引用，然后 `LazyModule` 将以标准方式使用 NgRouter 为某些路由进行懒加载；
- 使用 `@Component 或 @Directive` 内部的 `providers: []`，为特定的组件子树提供服务，当然这将导致创建多个服务实例(每个组件使用一个服务实例)；
- 始终尝试保守地确定服务范围，以防止依赖蔓延和由此产生的巨大混乱；



##### 1-7-2-3、NG2依赖注入原理

在 JS 语境下，依赖注入实际就是：函数参数是函数而已(高阶函数，因为JS没有类)；

在 TS 语境下，依赖注入实际就是：在类的构造函数中传入另一个类，类实例化时包括其参数的类也会被实例化；

- 为什么 DI 只有在 Angular 中才会被探讨：因为其它框架并不是原生支持强类型，自然无法以DI为出发点进行框架设计；

**<u>*1、Angular 依赖注入是如何实现的：*</u>**

可以参考 express 与 vue (实际上就是中间件)，如下；但不同的是它们没有类，因此传递的是一个函数，然后只要约定返回值和参数即可进行依赖注入；

```
app.use(bodyParser.json());
Vue.use(Vuex);
```

但 **<u>Angular 传递的是类，需要进行类的实例化，实例化后还须绑定到当前 this 以供当前类使用；</u>**

注意：传统 OO 中的依赖注入是类，但这更灵活：值/工厂/类均可：`ValueProvider、FactoryProvider、ExistingProvider、StaticClassProvider、function`

```ts
// https://github.com/angular/angular/blob/master/packages/core/src/di/injector.ts 181
// 1、有参数的工厂模式依赖 如 RouterModule.forChild(), 分析其参数依赖并加载
if (USE_VALUE in provider) {
  // We need to use USE_VALUE in provider since provider.useValue could be defined as undefined.
  value = (provider as ValueProvider).useValue;
} else if ((provider as FactoryProvider).useFactory) {
  fn = (provider as FactoryProvider).useFactory;
} else if ((provider as ExistingProvider).useExisting) {
  // Just use IDENT
} else if ((provider as StaticClassProvider).useClass) {
  useNew = true;
  fn = resolveForwardRef((provider as StaticClassProvider).useClass);
} else if (typeof provide == 'function') {
  useNew = true;
  fn = provide;
} else {
  throw staticError(
    'StaticProvider does not have [useValue|useFactory|useExisting|useClass] or [provide] is not newable',
    provider);
}

// ...

// 2、然后 resolveToken 加载相关工厂参数，即依赖的依赖；
// 注意：一旦加载依赖的参数是另一个依赖，为避免出现环形依赖，Angular 会自行判断，每加载一个依赖就会进行记录
value = record.value;
if (value == CIRCULAR) {
  throw Error(NO_NEW_LINE + 'Circular dependency');
}

// ...

// 3、最后，将所有依赖实例化
static create(
  options: StaticProvider[]|{providers: StaticProvider[], parent?: Injector, name?: string},
  parent?: Injector): Injector {
  if (Array.isArray(options)) {
    return new StaticInjector(options, parent);
  } else {
    return new StaticInjector(options.providers, options.parent, options.name || null);
  }
}
```



**<u>*2、Angular Module装饰器(decorator)是如何装配相关依赖和组件的：*</u>**

所有的 Angular decorator 都继承自 makePropDecorator 方法，自动为目标函数添加方法属性：

因此，组件，指令，服务都会被添加到同一 module 下；

然后， Angular 在 app 实例化时会初始化一个 module，添加根 Injector，形成 <u>模块树</u>；

此外，惰性模块中的依赖还涉及延迟加载等内容，模块加载也是在 zone 中进行；

```ts
export function makePropDecorator(
    name: string, props?: (...args: any[]) => any, parentClass?: any): any {
  const metaCtor = makeMetadataCtor(props);

  function PropDecoratorFactory(...args: any[]): any {
    if (this instanceof PropDecoratorFactory) {
      metaCtor.apply(this, args);
      return this;
    }

    const decoratorInstance = new (<any>PropDecoratorFactory)(...args);

    return function PropDecorator(target: any, name: string) {
      const constructor = target.constructor;
      // Use of Object.defineProperty is important since it creates non-enumerable property which
      // prevents the property is copied during subclassing.
      const meta = constructor.hasOwnProperty(PROP_METADATA) ?
          (constructor as any)[PROP_METADATA] :
          Object.defineProperty(constructor, PROP_METADATA, {value: {}})[PROP_METADATA];
      meta[name] = meta.hasOwnProperty(name) && meta[name] || [];
      meta[name].unshift(decoratorInstance);
    };
  }

  if (parentClass) {
    PropDecoratorFactory.prototype = Object.create(parentClass.prototype);
  }

  PropDecoratorFactory.prototype.ngMetadataName = name;
  (<any>PropDecoratorFactory).annotationCls = PropDecoratorFactory;
  return PropDecoratorFactory;
}
```

参考：[Ng2 依赖注入是如何实现的](https://www.zhihu.com/question/265773703/answer/298969485)

##### 1-7-2-4、新版NG依赖注入原理

##### 1-7-2-5、依赖注入使用







### 1-8、模板解析

#### 1-8-1、Vue

总览：模板解析这种事，本质是将数据转化为一段html，最开始出现在后端，经过各种处理吐给前端；但随着各种 mv* 兴起，模板解析交由前端处理；Vue complier 将 template 转化成一个 render 函数字符串，编译过程如下：

- parse 函数：负责解析 template，利用正则生成 AST；
- optimize 函数：负责优化静态节点(标记不需要每次都更新的内容，diff 算法会直接跳过静态节点，从而减少比较过程，优化 patch 性能)；
- generate 函数：生成 render 函数字符串；

内容：parse，optimize，generate

作用：解析模板，生成渲染模板的 render

比如：`<div><span></span>{{num}}</div>`，经过 compile 之后，就会生成下面的 render，而 render 作用，也是为了生成跟模板节点一一对应的 Vnode：

<img src="/Image/Frame/Vue/300.png" style="zoom:50%;" align="left"/>

<img src="/Image/Frame/Vue/301.png" style="zoom:50%;" align="left"/>



##### 1-8-1-1、parse

作用：接收 template 原始模板，按照模板节点和数据 生成对应的 AST；

比如：`<div test=2><span name=1></span>{{num}}</div> `

<img src="/Image/Frame/Vue/302.png" style="zoom:50%;" align="left"/>



##### 1-8-1-2、optimize

作用：遍历递归每一AST节点，并标记静态节点(不会变化的、没有绑定任何动态数据的节点)，在页面更新时，减少比对此部分 DOM，从而达到性能优化的目的；

比如：`<div><span><b>1</b></span>{{a}}</div>` ，span 和 b 就是静态节点；在 optimize 处理中，就会给他们添加 static 判断是否是静态节点，用来标记某部分静态节点最大的祖宗节点，后面更新时，只要碰到这个属性，就知道其所有子孙节点都是静态节点，而不需每个子孙节点都要判断一次浪费时间；

<img src="/Image/Frame/Vue/303.png" style="zoom:50%;" align="left"/>



##### 1-8-1-3、generate

作用：将前两步生成完善的 AST 组装成 render 字符串 (这个 render 变成函数后是可执行的函数，不过现在是字符串的形态，后面会转成函数)

比如：`<div><span>{{b}}</span>{{a}}</div>` 经过前2步生成AST：

<img src="/Image/Frame/Vue/304.png" style="zoom:50%;" align="left"/>

然后，generate 接收 AST，先处理最外层 AST，然后开始递归遍历子节点，直到所有节点被处理完，这个过程中，字符串会被一点一点拼接完成，比如上面的 AST 拼接结果如下；注意：_c 是生成节点对应的 Vnode 的一个函数；

<img src="/Image/Frame/Vue/305.png" style="zoom:50%;" align="left"/>

简述拼接流程：

<img src="/Image/Frame/Vue/306.png" style="zoom:50%;" align="left"/>



##### 1-8-1-4、render

前面两步将 template 解析生成了 render 字符串，但仍需要转换成函数才可执行，`render = new Function(render)，vm.$options.render`

<img src="/Image/Frame/Vue/307.png" style="zoom:50%;" align="left"/>

参考：https://juejin.im/post/5d4cec74e51d4561bb33fb0d



#### 1-8-2、Angular







### 1-X、其他

#### 1-X-1、VueComputed

##### 1-X-1-1、概览

computed 计算就是调用设置的 get 函数，然后得到返回值；其能控制缓存的重要一点是它的属性：脏数据标志位 dirty；

- 当 dirty 为 true 时，读取 computed 会重新计算
- 当 dirty 为 false 时，读取 computed 会使用缓存

1、开始每个 computed 新建自己的 watcher 时，会设置 watcher.dirty = true，以便于 computed 被使用时，会计算得到值；

2、当依赖数据发生变化后，通知 computed 时，会设置 watcher.dirty = true，以便于其他地方重新渲染、重新读取 computed 时，computed 重新计算

3、当 computed 计算完成后，会设置 watcher.dirty = false，以便于其他地方再次读取时，使用缓存，免于计算； 

比如：下面的流程示意图：

<img src="/Image/Frame/Vue/308.png" style="zoom:50%;" align="left"/>

- data C 开始变化后.......

- 通知 computed B watcher 更新，并只重置脏数据标志位 dirty = true，而不会计算值；
- 通知 页面 A watcher 进行更新渲染，进而重新读取 computed B ，然后 computed B 开始重新计算；

为什么 data C 能通知 页面 A：因为 data C 的依赖收集器会同时收集到 computed B 和 页面 A 的 watcher

为什么 data C 能收集到 页面A 的watcher：因为 computed 在 页面 A 在读取 computed B 时，data C 就会收集到页面A watcher

为什么 computed 能够更新：因为被依赖通知更新后，computed 重置了脏数据标志位(放开权限)，允许页面读取 computed 时再更新值；

##### 1-X-1-1、源码分析

**<u>*首先*</u>**，在调用 Vue 创建实例过程中，会处理各种选项(初始化)，其中包括处理 computed(initComputed)；每个 computed 都创建一个 watcher，用来存储计算值，判断是否需要重新计算；initComputed 作用：

- 为每个 computed 配发 watcher；
- defineComputed 处理；
- 收集所有 computed 的 watcher；

```js
function initComputed(vm, computed) {
  var watchers = vm._computedWatchers = Object.create(null);
  for (var key in computed) {
    var userDef = computed[key];
    var getter = typeof userDef === 'function' ? userDef : userDef.get;
    // 1、为每个 computed 都创建一个 watcher
    // watcher 用来存储计算值，判断是否需要重新计算
    watchers[key] = new Watcher(vm, getter, { lazy: true });
    // 判断是否有重名的属性
    if (!(key in vm)) {
      defineComputed(vm, key, userDef);
    }
  }
}

// Watcher
// 总结: computed 即带有标志位的 watcher
function Watcher(vm, expOrFn, options) {   
  	// dirty 默认为 false 的，而 lazy 赋给 dirty 只相当于一个开启的作用(或初始化)，使其延后执行
    this.dirty = this.lazy = options.lazy;  
  	// 保存设置的 getter
    this.getter = expOrFn;   
  	// watcher.value 存放计算结果，但因受 lazy 条件的控制，不会新建实例并马上读取值，最初为 undefined
  	// 只有再读取 computed 时，才开始计算，而不是初始化就开始计算值，通过 watcher.get 计算 value 
    this.value = this.lazy ? undefined: this.get();
};

Watcher.prototype.get = function() {    
    // getter 就是 watcher 回调
    var value = this.getter.call(vm, vm);    
    return value
};


// defineComputed
// 总结: 使用 createComputedGetter 包装 get 函数
function defineComputed( target, key, userDef) {    
    // 设置 set 为默认值，避免 computed 并没有设置 set
  	// 1、set 函数默认是空函数，如果用户设置，则使用用户设置
    var set = function(){}      
    //  如果用户设置了set，就使用用户的set
    if (userDef.set) set = userDef.set   

  	// 2、使用 Object.defineProperty 在实例上 computed 属性，所以可以直接访问
    Object.defineProperty(target, key, {        
        // 3、使用 createComputedGetter 包装 get 函数，主要用于判断计算缓存结果是否有效
        get:createComputedGetter(key),        
        set:set
    });
}


// createComputedGetter
function createComputedGetter(key) {    
    return function() {        
        // 获取到相应 key 的 computed-watcher
        // 总结：即当 data 变化时，获取相应的 watcher，若 _computedWatchers 中包含所依赖的数据的 watcher，则返回 watcher；
        var watcher = this._computedWatchers[key];        
        // 若 computed 依赖的数据变化，dirty 会变成 true，从而重新计算，然后更新缓存值 watcher.value
      	// 总结: 
      	// 首先，watcher 初始化时，dirty 为默认值 true，遂进行首次执行；
 				// 然后，data 发生变化时，触发 watcher.prototype.update, 设置标志为 true；
      	// (data 会有一个 watcher 数组，其中有 computed类的 watcher，也有 watch类的watcher);
      	// 注意: 关键在于控制 watcher.dirty，这是执行的关键，首先要明白: computed 数据A 引用了 data 数据B，即 A 依赖 B，所以 B 会收集到 A 的 watcher，而当 B 改变时，会通知 A 进行更新，即调用 A-watcher.update, 而 update 中开启了 dirty，从而读取 comptued 时，会调用 evalute 重新计算
        if (watcher.dirty) {
            watcher.evaluate();
        }        
        // data 与 computed 双向绑定
      	// 总结: 之所以 data 能通知 computed 的 watcher，是因为初始化时就进行了双方关系绑定，绑定通过 watcher.depend 实现
      	// 即让 data 依赖收集器收集当前 watcher(computed_watcher)
      	// 举例说即: 页面-P、computed-C、data-D
      	// 1、P 引用了 C，C 引用了 D
				// 2、理论上 D 改变时，C 就会改变，C 则通知 P 更新
				// 3、实际上 C 让 D 和 P 建立联系，让 D 改变时直接通知 P
				// 而绑定的关键即下方代码 depend
        if (Dep.target) {
            watcher.depend();
        }        
        return watcher.value
    }
}

// evaluate
Watcher.prototype.evaluate = function() {    
    this.value = this.get();    
    // 执行完更新函数之后，立即重置标志位
    this.dirty = false;
};


// update 
Watcher.prototype.update = function() {    
    if (this.lazy)  this.dirty = true;
  	// ...
};


// depend
Watcher.prototype.depend = function() {    
    var i = this.deps.length;    
    while (i--) {        
        // this.deps[i].depend();
      	// Dep.target 即页面 watcher
        dep.addSub(Dep.target)
    }
};


Watcher.prototype.get = function() {    
    // 改变 Dep.target
    pushTarget()    
    // getter 就是 watcher 回调
    var value = this.getter.call(this.vm, this.vm);    
    // 恢复前一个 watcher
    popTarget()    
    return value
};
Dep.target = null;
var targetStack = [];
function pushTarget(_target) {    
    // 把上一个 Dep.target 缓存起来，便于后面恢复
    if (Dep.target) {
        targetStack.push(Dep.target);
    }
    Dep.target = _target;
}
function popTarget() {
    Dep.target = targetStack.pop();
}
// 1、页面 watcher.getter 保存 页面更新函数，computed watcher.getter 保存 计算 getter
// 2、watcher.get 用于执行 watcher.getter 并 设置 Dep.target
// 3、Dep.target 会有缓存
```

**<u>*Computed 机制总结：*</u>**

**<u>*首先，初始化时：*</u>**

- 初始化：init—>initComputed—>页面初次渲染，此时 Dep.target 为页面 Watcher—>触发用 createComputed包装的 get 函数 createComputedGetter，createComputedGetter 主要执行了：`if (watcher.dirty) { watcher.evaluate(); }`、`if (Dep.target) { watcher.depend(); }`   
  - 前者：执行前者；此时 watcher.dirty = true，因使用的是 lazy 的初始值 (initComputed 中 `new Watcher(vm, getter, { lazy: true });`)，所以 `watcher.evaluted` 可以被调用 (注意：调用完毕就要设置 dirty 为 false，此后除非与 computed 相关 data  发生变化，否则不会触发，即此值控制着缓存，是 computed 的核心实现)，随即 `computed.watcher.get` 被调用，进行 `pushTarget`，导致 `Dep.target` 被修改为 computed-watcher，而原来的值(页面 Watcher)会先被缓存到 targetStack 中；同时，computed 的计算会读取 data，因为双绑机制，此时 data 就能收集到 computed-watcher，即computed-watcher 也会保存到 data 的依赖收集器 dep.subs 中；随后，computed 计算完毕，执行 popTarget，释放 Dep.target，并将 Dep.target 恢复上一个 watcher(页面watcher)；
  - 后者，执行后者；即 `watcher.depend`，即执行 `dep.addSub(Dep.target)`，目的是让 data 再收集一次 Dep.target， 即收集页面 watcher；
- 此时，`data 的依赖收集器 = [ computed-watcher, 页面-watcher]`

**<u>*然后，数据更新时：*</u>**

- 即 computed 所依赖的 data 更新时，触发 `dep.nodify`，依次触发依赖数组下的每一watcher：
  - 先执行 computed-watcher 计算值(调用了 `watcher.update`，而其中包含了 `if (this.lazy)  this.dirty = true;`，但注意此时尚未计算结果，只是控制计算的阀门打开，计算行为由 `watcher.evaluate()` 负责，而此方法在 `get:createComputedGetter(key),`，注意 get，所以 get 时，也即页面渲染时，读取值时才做真正计算 )；
  - 再执行页面-watcher 渲染页面做真正计算；
  - 即 data 改变，正序遍历通知，computed 先更新，页面再更新，所以页面才能读取到最新的 computed 值；

**<u>*最后总结*</u>**：由双绑控制变化的触发，值相等则不触发，值不等才触发 watcher.update，而平时的刷新渲染不会触发 computed 的计算求值，因为 watcher.dirty 为 false，但 watcher 监听属性则会随着页面刷新而触发，即使它所绑定的值未发生值变化，因为它没有设置 watcher.dirty 变量去阻止；所以可以理解为 computed 计算属性是带有 dirty 标记的 watch，也正因为通过此标记，才能阻止不随页面刷新而计算；

<img src="/Image/Frame/Vue/510.png" style="zoom:50%;" align="left"/>

参考：https://juejin.im/post/6844903877699960846





#### 1-X-2、nextTick

##### 1-X-2-1、概览

官方描述：在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM；

```js
// 修改数据
vm.msg = 'Hello'
// DOM 还没有更新
Vue.nextTick(function () {
  // DOM 更新了
})

// 作为一个 Promise 使用 (2.1.0 起新增，详见接下来的提示)
Vue.nextTick()
 .then(function () {
  // DOM 更新了
})
// 2.1.0 起新增：若无提供回调且在支持 Promise 的环境中，则返回一个 Promise；
// 注意 Vue 不自带 Promise 的 polyfill，所以若目标浏览器不原生支持 Promise，得自己提供 polyfill... =。=
```

注意：Vue 异步执行 DOM 更新，只要观察到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据改变；若同一个 watcher 被多次触发，只会被推入到队列中一次；这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作上非常重要；然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部尝试对异步队列使用原生的 Promise.then 和 MessageChannel，如果执行环境不支持，会采用 setTimeout(fn, 0) 代替。

比如：当设置 vm.someData = 'new value' ，该组件不会立即重新渲染。当刷新队列时，组件会在事件循环队列清空时的下一个“tick”更新。多数情况我们不需要关心这个过程，但是如果你想在 DOM 状态更新后做点什么，这就可能会有些棘手。虽然 Vue.js 通常鼓励开发人员沿着“数据驱动”的方式思考，避免直接接触 DOM，但是有时我们确实要这么做。为了在数据变化之后等待 Vue 完成更新 DOM ，可以在数据变化之后立即使用 Vue.nextTick(callback) 。这样回调函数在 DOM 更新完成后就会调用；

Vue 在2.4版本、2.5版本和2.6版本中对于`nextTick`进行反复变动，原因是浏览器对于**微任务**的不兼容性影响、**微任务**和**宏任务**各自优缺点的权衡；

<img src="/Image/Frame/Vue/511.png" style="zoom:50%;" align="left"/>

若 Vue 使用`setTimeout`等**<u>宏任务函数</u>**，则势必要等待UI渲染完成后的下一个**<u>宏任务</u>**执行，而若 Vue 使用**<u>微任务函数</u>**，则无需等待UI渲染完成才进行`nextTick`的回调函数操作，可想象在 **JS引擎线程** 和 **GUI渲染线程** 间来回切换，及等待**GUI渲染线程**的过程中，浏览器势必要消耗性能，这是一个严谨的框架完全需要考虑的事情。

当然这里所说的只是`nextTick`执行用户回调之后的性能情况考虑，这中间当然不能忽略`flushBatcherQueue`更新Dom的操作，使用异步函数的另外一个作用当然是要确保同步代码执行完毕Dom更新性能优化（例如同步操作对响应式数据使用for循环更新一千次，那么这里只有一次DOM更新而不是一千次）。

到了这里，对于Vue中`nextTick`函数的命名应该是了然于心了，当然这个命名不知道和Node.js的`process.nextTick`还有没有什么必然联系



##### 1-X-2-2、源码分析

```js
// 2.5
/* @flow */
/* globals MessageChannel */

import { noop } from 'shared/util'
import { handleError } from './error'
import { isIOS, isNative } from './env'

const callbacks = []
let pending = false

function flushCallbacks () {
  pending = false
  const copies = callbacks.slice(0)
  callbacks.length = 0
  for (let i = 0; i < copies.length; i++) {
    copies[i]()
  }
}

// 在2.4中使用了microtasks ，但是还是存在问题，
// 在2.5版本中组合使用macrotasks和microtasks，组合使用的方式是对外暴露withMacroTask函数
// Here we have async deferring wrappers using both microtasks and (macro) tasks.
// In < 2.4 we used microtasks everywhere, but there are some scenarios where
// microtasks have too high a priority and fire in between supposedly
// sequential events (e.g. #4521, #6690) or even between bubbling of the same
// event (#6566). However, using (macro) tasks everywhere also has subtle problems
// when state is changed right before repaint (e.g. #6813, out-in transitions).
// Here we use microtask by default, but expose a way to force (macro) task when
// needed (e.g. in event handlers attached by v-on).

// 2.5版本在nextTick中对于调用microtask（微任务）还是macrotask（宏任务）声明了两个不同的变量
let microTimerFunc
let macroTimerFunc

// 默认使用microtask（微任务）
let useMacroTask = false


// 这里主要定义macrotask（宏任务）函数
// macrotask（宏任务）的执行优先级
// setImmediate -> MessageChannel -> setTimeout
// setImmediate是最理想的选择
// 最Low的状况是降级执行setTimeout

// Determine (macro) task defer implementation.
// Technically setImmediate should be the ideal choice, but it's only available
// in IE. The only polyfill that consistently queues the callback after all DOM
// events triggered in the same loop is by using MessageChannel.
/* istanbul ignore if */
if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {
  macroTimerFunc = () => {
    setImmediate(flushCallbacks)
  }
} else if (typeof MessageChannel !== 'undefined' && (
  isNative(MessageChannel) ||
  // PhantomJS
  MessageChannel.toString() === '[object MessageChannelConstructor]'
)) {
  const channel = new MessageChannel()
  const port = channel.port2
  channel.port1.onmessage = flushCallbacks
  macroTimerFunc = () => {
    port.postMessage(1)
  }
} else {
  /* istanbul ignore next */
  macroTimerFunc = () => {
    setTimeout(flushCallbacks, 0)
  }
}


// 这里主要定义microtask（微任务）函数
// microtask（微任务）的执行优先级
// Promise -> macroTimerFunc
// 如果原生不支持Promise，那么执行macrotask（宏任务）函数

// Determine microtask defer implementation.
/* istanbul ignore next, $flow-disable-line */
if (typeof Promise !== 'undefined' && isNative(Promise)) {
  const p = Promise.resolve()
  microTimerFunc = () => {
    p.then(flushCallbacks)
    // in problematic UIWebViews, Promise.then doesn't completely break, but
    // it can get stuck in a weird state where callbacks are pushed into the
    // microtask queue but the queue isn't being flushed, until the browser
    // needs to do some other work, e.g. handle a timer. Therefore we can
    // "force" the microtask queue to be flushed by adding an empty timer.
    if (isIOS) setTimeout(noop)
  }
} else {
  // fallback to macro
  microTimerFunc = macroTimerFunc
}


// 对外暴露withMacroTask 函数
// 触发变化执行nextTick时强制执行macrotask（宏任务）函数

/**
 * Wrap a function so that if any code inside triggers state change,
 * the changes are queued using a (macro) task instead of a microtask.
 */
export function withMacroTask (fn: Function): Function {
  return fn._withTask || (fn._withTask = function () {
    useMacroTask = true
    try {
      return fn.apply(null, arguments)
    } finally {
      useMacroTask = false    
    }
  })
}

// 这里需要注意pending
export function nextTick (cb?: Function, ctx?: Object) {
  let _resolve
  callbacks.push(() => {
    if (cb) {
      try {
        cb.call(ctx)
      } catch (e) {
        handleError(e, ctx, 'nextTick')
      }
    } else if (_resolve) {
      _resolve(ctx)
    }
  })
  if (!pending) {
    pending = true
    if (useMacroTask) {
      macroTimerFunc()
    } else {
      microTimerFunc()
    }
  }
  // $flow-disable-line
  if (!cb && typeof Promise !== 'undefined') {
    return new Promise(resolve => {
      _resolve = resolve
    })
  }
}









// 2.6
/* @flow */
/* globals MutationObserver */

import { noop } from 'shared/util'
import { handleError } from './error'
import { isIE, isIOS, isNative } from './env'

export let isUsingMicroTask = false

const callbacks = []
let pending = false

function flushCallbacks () {
  pending = false
  const copies = callbacks.slice(0)
  callbacks.length = 0
  for (let i = 0; i < copies.length; i++) {
    copies[i]()
  }
}

// 在2.5版本中组合使用microtasks 和macrotasks，但是重绘的时候还是存在一些小问题，而且使用macrotasks在任务队列中会有几个特别奇怪的行为没办法避免，So又回到了之前的状态，在任何地方优先使用microtasks 。
// Here we have async deferring wrappers using microtasks.
// In 2.5 we used (macro) tasks (in combination with microtasks).
// However, it has subtle problems when state is changed right before repaint
// (e.g. #6813, out-in transitions).
// Also, using (macro) tasks in event handler would cause some weird behaviors
// that cannot be circumvented (e.g. #7109, #7153, #7546, #7834, #8109).
// So we now use microtasks everywhere, again.
// A major drawback of this tradeoff is that there are some scenarios
// where microtasks have too high a priority and fire in between supposedly
// sequential events (e.g. #4521, #6690, which have workarounds)
// or even between bubbling of the same event (#6566).
let timerFunc

// The nextTick behavior leverages the microtask queue, which can be accessed
// via either native Promise.then or MutationObserver.
// MutationObserver has wider support, however it is seriously bugged in
// UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It
// completely stops working after triggering a few times... so, if native
// Promise is available, we will use it:
/* istanbul ignore next, $flow-disable-line */


// task的执行优先级
// Promise -> MutationObserver -> setImmediate -> setTimeout

if (typeof Promise !== 'undefined' && isNative(Promise)) {
  const p = Promise.resolve()
  timerFunc = () => {
    p.then(flushCallbacks)
    // In problematic UIWebViews, Promise.then doesn't completely break, but
    // it can get stuck in a weird state where callbacks are pushed into the
    // microtask queue but the queue isn't being flushed, until the browser
    // needs to do some other work, e.g. handle a timer. Therefore we can
    // "force" the microtask queue to be flushed by adding an empty timer.
    if (isIOS) setTimeout(noop)
  }
  isUsingMicroTask = true
} else if (!isIE && typeof MutationObserver !== 'undefined' && (
  isNative(MutationObserver) ||
  // PhantomJS and iOS 7.x
  MutationObserver.toString() === '[object MutationObserverConstructor]'
)) {
  // Use MutationObserver where native Promise is not available,
  // e.g. PhantomJS, iOS7, Android 4.4
  // (#6466 MutationObserver is unreliable in IE11)
  let counter = 1
  const observer = new MutationObserver(flushCallbacks)
  const textNode = document.createTextNode(String(counter))
  observer.observe(textNode, {
    characterData: true
  })
  timerFunc = () => {
    counter = (counter + 1) % 2
    textNode.data = String(counter)
  }
  isUsingMicroTask = true
} else if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {
  // Fallback to setImmediate.
  // Techinically it leverages the (macro) task queue,
  // but it is still a better choice than setTimeout.
  timerFunc = () => {
    setImmediate(flushCallbacks)
  }
} else {
  // Fallback to setTimeout.
  timerFunc = () => {
    setTimeout(flushCallbacks, 0)
  }
}

export function nextTick (cb?: Function, ctx?: Object) {
  let _resolve
  callbacks.push(() => {
    if (cb) {
      try {
        cb.call(ctx)
      } catch (e) {
        handleError(e, ctx, 'nextTick')
      }
    } else if (_resolve) {
      _resolve(ctx)
    }
  })
  if (!pending) {
    pending = true
    timerFunc()
  }
  // $flow-disable-line
  if (!cb && typeof Promise !== 'undefined') {
    return new Promise(resolve => {
      _resolve = resolve
    })
  }
}
```

参考：https://juejin.im/post/6844903843197616136#heading-2





