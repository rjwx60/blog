---
typora-root-url: ../../Source
---



<img src="/Image/Basics/Special/Async/1.png" style="zoom:60%;" />



### 一、总结

#### 1-1、异步编程发展历程简述

- 阶段一：回调函数
  - 问题1：缺乏顺序性：其导致调试困难，并与大脑线性思维方式不符；
  - 问题2：缺乏可信任性： 控制反转导致系列信任问题；
- 阶段二：Promise 基于 PromiseA+ 规范的实现
  - 解决：上述问题2，重掌代码执行主动权；
- 阶段三：Generator(生成器函数) 用同步方式来书写代码
  - 解决：上述问题1，但需手动调用 next 方法，将回调成功返回的数据送回 JS 主流程中；
- 阶段四：Async/Await (结合 Promise & Generator)，在 await 后面跟 Promise，自动等待 Promise 决议值
  - 解决：Generator需要手动控制next(...)执行的问题、真正实现了用同步的方式书写异步代码；



#### 1-2、总结

<img src="/Image/Basics/Special/Async/31.png" style="zoom:50%;" align="left" />

- 回调函数
  - 优点：解决同步问题；
  - 缺点：地狱缺乏顺序性，调试困难，与大脑思维方式不符、函数间存在耦合性牵一发动全身(控制反转)、难以处理错误；

<img src="/Image/Basics/Special/Async/28.png" style="zoom:50%;" align="left" />

- Promise
  - 优点：解决回调地狱问题，可链式调用，自动执行，符合大脑线性思维模式；
  - 缺点：一旦新建即立即执行则无法停止、错误需通过回调函数来捕获、处于 pending 态时无法得知具体状态(刚开始/即将完成 )；

<img src="/Image/Basics/Special/Async/29.png" style="zoom:50%;" align="left" />

- Generator
  - 优点：执行可控；(利用协程完成 Generator 函数，用 co 库让代码依次执行完，同时以同步方式书写，也让异步操作按顺序执行)；
  - 缺点：执行需手动触发

<img src="/Image/Basics/Special/Async/30.png" style="zoom:50%;" align="left" />

- Async/await
  - 优点：代码结构清晰(无需 then 链)；以同步的方式来书写，且无需借助第三方库的支持；
  - 缺点：将异步改为同步，多个无依赖的异步操作将导致性能降低；







### 二、传统回调

<img src="/Image/Basics/Special/Async/2.png" style="zoom:50%;" align="left" />

<img src="/Image/Basics/Special/Async/3.png" style="zoom:50%;" align="left" />

问题1：回调地狱：充满回调嵌套，代码横向纵向扩展、难以调试和维护、bug 追踪难度大、不符人脑线性处理；

问题2：控制反转：即把程序一部分的执行控制交给某个第三方，而代码和第三方之间没有一份明确表达的契约；

比如：C 先传出接收数据，后异步传回，此时数据是不被 C 可控的，且在第三方的控制下；







### 三、Promise

**<u>意义：解决因控制反转导致的信任问题(此外还一定程度上解决了回调函数的书写结构问题，逻辑性、可读性增强，依赖层级清晰)</u>**



#### 3-1、Promise/A+规范

##### 3-1-1、基本内容

- 不变性：某个 Promise 必处于3态之一且不变(一旦决议，状态不再改变)：
  - 激发态——pending —> fulfilled 稳定态；
  - 激发态——pending —> rejected 稳定态；
- 可信任性
  - then 总能返回一个Promise：其中涉及 Promise 解析过程的抽象过程 [[Resolve]](promise, x)，可将某些非标准的：类Promise接口、对象、函数或值规范为标准 Promise；
- 注意：若 then  函数的2个参数不是函数，会导致 then 函数 返回一个与之前 promise 状态相同的 promise
- 核心1：Promise 本质是状态机，且状态只能为以下三种：Pending-等待态、Fulfilled-执行态、Rejected-拒绝态，状态变更单向；
- 核心2：then 接收 2 个可选参数，分别对应状态改变时触发的回调，then 返回 promise，then 可被同一个 promise 调用多次；



##### 3-1-2、基本原则

原则1：当通过 ***new Promise*(*function* (*resolve*, *reject*)*{}*)** 形式定义 *Promise* 时，构造用到函数就已在被执行，见下图；

原则*2*：函数在没有返回值时，会默认返回 *undefined*；

<img src="/Image/Basics/Special/Async/8.png" style="zoom:50%;" align="left" />



##### 3-1-3、解决的问题

- 解决了回调，调用过早问题：
  - Promise 调用 then 时，即使 Promise 已决议，也总会在当前 Js 事件处理完后再调用提供给 then 的回调
- 解决了回调，调用过晚问题：
  - Promise 对象调用 resolve 或 reject 时，通过 then 注册的回调会在下一个异步时间点上被触发；而若多个通过 then 注册的回调，都会在下一个异步时间点上被依次调用，这些注册回调中的异步回调均无法影响或延误对其他 then 上回调的调用；

<img src="/Image/Basics/Special/Async/9.png" style="zoom:50%;" align="left" />

- 解决了回调，调用次数太多或太少问题：
  - Promise 的定义方式使得它只能被决议一次，且会默默忽略任何后续调用，因此任何通过 then 注册的回调就只会被调用一次；
- 解决了回调，无法成功接收所传参数的问题：
  - resolve 或 reject，默认传值 undefined
  - resolve 或 reject，中的值不管是什么，都会被传给所有注册在 then 中的回调函数
  - resolve 或 reject，中传递多个参数时，第一个参数后的所有参数都会被忽略；故多参数传递需通过对象传递；
- 解决了吞掉可能出现的错误或异常问题：

<img src="/Image/Basics/Special/Async/10.png" style="zoom:50%;" align="left" />



##### 3-1-4、返回值

Promise 只是改变了传递回调的位置，只是将 callback 放到可信任的中间机构，并由这个机构去连接代码与接口，故本质上并没有完全摆脱回调；但是就是这样比单纯使用回调更值得信任，因为 Promise.resolve：

- 若向 Promise.resolve 传递1个真 Promise，则得到传递过去的同1个 Promise：
- <img src="/Image/Basics/Special/Async/11.png" style="zoom:50%;" align="left" />
- 若向 Promise.resolve 传递1个非 Promise、非 thenable 的立即值，则得到1个用这个值填充的 Promise：
- <img src="/Image/Basics/Special/Async/12.png" style="zoom:50%;" align="left" />
- 若向 Promise.resolve 传递1个非 Promise、真 thenable 的立即值，Promise.resolve 则会试图展开此值 ，且展开过程中会持续到提取出一个具体的非类 Promise 的规范后的最终值：
- <img src="/Image/Basics/Special/Async/13.png" style="zoom:50%;" align="left" />



##### 3-1-5、总结

无论传递什么值，从 Promise.resolve 得到的都是一个真正的  Promise，是一个可信任的值，所以通过Promise.resolve 过滤，以获取可信任性；故有跟传统回调相比，Promise 更值得信任的说法；



#### 3-2、Promise 解决

##### 3-2-1、回调地狱问题

回调地狱：存在两问题：<u>多层嵌套的问题</u>，且<u>每种任务的处理结果存在两种可能性(成或败)，则就需要在每种任务执行结束后分别处理这两种可能性</u>。

Promise 的诞生就是为了解决这两个问题，Promise 利用了三大技术手段来解决：

- **回调函数延迟绑定**；

```js
// 回调函数非直接声明，而是通过后面的 then 方法传入的，即延迟传入，此乃 回调函数延迟绑定
let readFilePromise = (filename) => {
  fs.readFile(filename, (err, data) => {
    if(err) {
      reject(err);
    }else {
      resolve(data);
    }
  })
}
readFilePromise('1.json').then(data => {
  return readFilePromise('2.json')
});
```

- **返回值穿透**；

```js
// 首先，根据 then 中回调函数的传入值创建不同类型的Promise
// 然后，把返回的 Promise 穿透到外层, 以供后续的调用；x 即内部返回的 Promise
// 最后，在 x 后面可以依次完成链式调用；此乃 返回值穿透的效果

let x = readFilePromise('1.json').then(data => {
  return readFilePromise('2.json')//这是返回的Promise
});
x.then(/* 内部逻辑省略 */)

// 链式调用，解决了多层嵌套的问题
readFilePromise('1.json').then(data => {
    return readFilePromise('2.json');
}).then(data => {
    return readFilePromise('3.json');
}).then(data => {
    return readFilePromise('4.json');
});
```

- **错误冒泡**；

```js
// 使用错误冒泡，以应对每次任务执行结束后分别处理成功和失败的情况
readFilePromise('1.json').then(data => {
    return readFilePromise('2.json');
}).then(data => {
    return readFilePromise('3.json');
}).then(data => {
    return readFilePromise('4.json');
}).catch(err => {
  // xxx
})
```



##### 3-2-2、作为微任务引入

Promise 中的执行函数是同步进行，但其中可能存在着异步操作，在异步操作结束后，会调用 resolve 方法或中途遇到错误调用 reject 方法，而两者均作为微任务进入到 EventLoop 中；其实就是如何处理回调的问题，总结起来有三种方式:

- 使用同步回调，直到异步任务进行完，再进行后面的任务；
  - 同步问题明显，阻塞整个脚本；
- 使用异步回调，将回调函数放在进行 **<u>宏任务队列的队尾</u>**；
  - 若宏任务队列非常长，那么回调迟迟得不到执行，造成应用卡顿；
- 使用异步回调，将回调函数放到  **<u>当前宏任务中的最后面</u>**；
  - 为解决上述方案问题，Promise 采取第三种方式， 即作为微任务引入：把 resolve(reject) 回调的执行放在当前宏任务的末尾；
  - 采用**异步回调**替代同步回调解决了浪费 CPU 性能的问题。
  - 放到**当前宏任务最后**执行，解决了回调执行的实时性问题。





#### 3-3、Promise 实现

##### 3-3-1、低配版

```javascript
/**
 * 1、低配版 Promise
 */
class MyPromise1 {
  // 构造方法接收一个回调
  constructor(executor) {
    // then 收集的执行成功的回调队列
    this._resolveQueue = [];
    // then 收集的执行失败的回调队列
    this._rejectQueue = [];

    // 实现 resolve
    let _resolve = val => {
      // 从成功队列里取出回调依次执行
      while (this._resolveQueue.length) {
        const callback = this._resolveQueue.shift();
        callback(val);
      }
    };
    
    // reject 实现同 resolve
    let _reject = val => {
      // 从失败队列里取出回调依次执行
      while (this._rejectQueue.length) {
        const callback = this._rejectQueue.shift();
        callback(val);
      }
    };
    // new Promise()时立即执行 executor,并传入 resolve 和 reject
    executor(_resolve, _reject);
  }

  // then 方法,接收一个成功的回调和一个失败的回调，并 push 进对应队列
  then(resolveFn, rejectFn) {
    this._resolveQueue.push(resolveFn);
    this._rejectQueue.push(rejectFn);
  }
}

// 测试用例
const p1 = new MyPromise1((resolve, reject) => {
  setTimeout(() => {
    resolve("result");
  }, 1000);
});
// 1秒后输出 result
p1.then(res => console.log(res));
```



##### 3-3-2、高配版

即结合 Promise/A 规范实现版本；

##### 3-3-2-1、基本骨架的实现

- 核心1：Promise 本质是状态机，且状态只能为以下三种：Pending-等待态、Fulfilled-执行态、Rejected-拒绝态，状态变更单向；
  核心2：then 接收 2 个可选参数，分别对应状态改变时触发的回调，then 返回 promise，then 可被同一个 promise 调用多次；

```javascript
function P2() {
  //Promise/A+规范的三种状态
  const PENDING = "pending";
  const FULFILLED = "fulfilled";
  const REJECTED = "rejected";

  class MyPromise2 {
    // 构造方法接收一个回调
    constructor(executor) {
      // Promise 状态
      this._status = PENDING;
      // 成功队列, resolve 时触发
      this._resolveQueue = [];
      // 失败队列, reject 时触发
      this._rejectQueue = [];

      // 实现同 reject
      let _resolve = val => {
        // 实现规范要求的 "状态只能由 pending 到 fulfilled 或 rejected"
        if (this._status !== PENDING) return;
        // 变更状态
        this._status = FULFILLED;

        // 使用一个队列来储存回调，实现规范要求的 "then 方法可以被同一个 promise 调用多次"
        // 若使用一个变量而非队列来储存回调,那么即使多次 p1.then() 也只会执行一次回调
        while (this._resolveQueue.length) {
          const callback = this._resolveQueue.shift();
          callback(val);
        }
      };
      // 实现同 resolve
      let _reject = val => {
        // 实现规范要求的 "状态只能由 pending 到 fulfilled 或 rejected"
        if (this._status !== PENDING) return;
        // 变更状态
        this._status = REJECTED;

        // 使用一个队列来储存回调，实现规范要求的 "then 方法可以被同一个 promise 调用多次"
        // 若使用一个变量而非队列来储存回调,那么即使多次 p1.then() 也只会执行一次回调
        while (this._rejectQueue.length) {
          const callback = this._rejectQueue.shift();
          callback(val);
        }
      };
      // new Promise()时立即执行 executor, 并传入 resolve 和 reject
      executor(_resolve, _reject);
    }
    // then 方法,接收一个成功的回调和一个失败的回调
    then(resolveFn, rejectFn) {
      this._resolveQueue.push(resolveFn);
      this._rejectQueue.push(rejectFn);
    }
  }
}
```

<img src="/Image/Basics/Special/Async/14.png" style="zoom:50%;" align="left" />

##### 3-3-2-2、在前面基础上，实现链式调用

- 将 then 方法的返回值包装成 promise 
- then 的回调需要顺序执行，需要等待当前 Promise 状态变更后，才执行下一 then 收集的回调

```javascript
function P3() {
  // Promise/A+规范的三种状态
  const PENDING = "pending";
  const FULFILLED = "fulfilled";
  const REJECTED = "rejected";

  class MyPromise3 {
    // 构造方法接收一个回调
    constructor(executor) {
      // Promise 状态
      this._status = PENDING;
      // 成功队列, resolve 时触发
      this._resolveQueue = [];
      // 失败队列, reject 时触发
      this._rejectQueue = [];

      // 实现同 reject
      let _resolve = val => {
        // 实现规范要求的 "状态只能由 pending 到 fulfilled 或 rejected"
        if (this._status !== PENDING) return;
        // 变更状态
        this._status = FULFILLED;
        // 使用一个队列来储存回调，实现规范要求的 "then 方法可以被同一个 promise 调用多次"
        // 若使用一个变量而非队列来储存回调,那么即使多次 p1.then() 也只会执行一次回调
        while (this._resolveQueue.length) {
          const callback = this._resolveQueue.shift();
          callback(val);
        }
      };
      // 实现同 resolve
      let _reject = val => {
        // 实现规范要求的 "状态只能由 pending 到 fulfilled 或 rejected"
        if (this._status !== PENDING) return;
        // 变更状态
        this._status = REJECTED;

        // 使用一个队列来储存回调，实现规范要求的 "then 方法可以被同一个 promise 调用多次"
        // 若使用一个变量而非队列来储存回调,那么即使多次 p1.then() 也只会执行一次回调
        while (this._rejectQueue.length) {
          const callback = this._rejectQueue.shift();
          callback(val);
        }
      };
      // new Promise()时立即执行 executor, 并传入 resolve 和 reject
      executor(_resolve, _reject);
    }

    // then 方法
    then(resolveFn, rejectFn) {
      // return 一个新的 promise
      return new MyPromise((resolve, reject) => {
        // 把 resolveFn 重新包装一下, 再 push 进 resolve 执行队列, 这是为了能够获取回调的返回值进行分类讨论
        const fulfilledFn = value => {
          try {
            // 执行第一个(当前的) Promise 的成功回调,并获取返回值
            let x = resolveFn(value);
            // 分类讨论返回值,如果是 Promise, 那么等待 Promise 状态变更,否则直接 resolve
            x instanceof MyPromise3 ? x.then(resolve, reject) : resolve(x);
          } catch (error) {
            reject(error);
          }
        };
        // 把后续 then 收集的依赖都 push 进当前 Promise 的成功回调队列中(_rejectQueue), 这是为了保证顺序调用
        this._resolveQueue.push(fulfilledFn);

        // reject 同理
        const rejectedFn = error => {
          try {
            let x = rejectFn(error);
            x instanceof MyPromise3 ? x.then(resolve, reject) : resolve(x);
          } catch (error) {
            reject(error);
          }
        };
        this._rejectQueue.push(rejectedFn);
      });
    }
  }
}

// 测试用例
const p3 = new MyPromise3((resolve, reject) => {
  setTimeout(() => {
    resolve(1);
  }, 500);
});

p3.then(res => {
  console.log(res);
  return 2;
})
.then(res => {
  console.log(res);
  return 3;
})
.then(res => {
  console.log(res);
});
// 1
// 2
// 3
```

<img src="/Image/Basics/Special/Async/15.png" style="zoom:50%;" align="left" />

##### 3-3-2-3、在前面基础上，实现值穿透、状态变更处理

- **<u>值穿透</u>**：即若 then 接收的参数类型不是 function 则应当忽略，让链式调用继续往下执行；
- **<u>处理状态为 resolve/reject 的情况</u>**：一般情况下 then 对应状态 pending，但特殊情况比如 Promise.resolve()/reject().then() 则此时状态为 resolve/reject，此时若还按照 pending 态时的做法：将 then 中回调 push 进 resolve/reject 队列中的话，回调将不会正确执行，故需对上述特殊情况进行处理，即对 fulfilled 状态和 rejected 情况进行处理：直接执行回调；

```javascript
function P4() {
  //Promise/A+规范的三种状态
  const PENDING = "pending";
  const FULFILLED = "fulfilled";
  const REJECTED = "rejected";

  class MyPromise4 {
    // 构造方法接收一个回调
    constructor(executor) {
      // Promise 状态
      this._status = PENDING;
      // 成功队列, resolve 时触发
      this._resolveQueue = [];
      // 失败队列, reject 时触发
      this._rejectQueue = [];

      // 实现同 reject
      let _resolve = val => {
        // 实现规范要求的 "状态只能由 pending 到 fulfilled 或 rejected"
        if (this._status !== PENDING) return;
        // 变更状态
        this._status = FULFILLED;

        // 使用一个队列来储存回调，实现规范要求的 "then 方法可以被同一个 promise 调用多次"
        // 若使用一个变量而非队列来储存回调,那么即使多次 p1.then() 也只会执行一次回调
        while (this._resolveQueue.length) {
          const callback = this._resolveQueue.shift();
          callback(val);
        }
      };
      // 实现同 resolve
      let _reject = val => {
        // 实现规范要求的 "状态只能由 pending 到 fulfilled 或 rejected"
        if (this._status !== PENDING) return;
        // 变更状态
        this._status = REJECTED;

        // 使用一个队列来储存回调，实现规范要求的 "then 方法可以被同一个 promise 调用多次"
        // 若使用一个变量而非队列来储存回调,那么即使多次 p1.then() 也只会执行一次回调
        while (this._rejectQueue.length) {
          const callback = this._rejectQueue.shift();
          callback(val);
        }
      };
      // new Promise()时立即执行 executor, 并传入 resolve 和 reject
      executor(_resolve, _reject);
    }

    // then 方法,接收一个成功的回调和一个失败的回调
    then(resolveFn, rejectFn) {
      // 根据规范，若 then 参数不是 function，则需要忽略它, 让链式调用继续往下执行
      typeof resolveFn !== "function" ? (resolveFn = value => value) : null;
      typeof rejectFn !== "function"
        ? (rejectFn = reason => {
            throw new Error(reason instanceof Error ? reason.message : reason);
          })
        : null;

      // return 一个新的 promise
      return new MyPromise4((resolve, reject) => {
        // 把 resolveFn 重新包装一下, 再 push 进 resolve 执行队列,这是为了能够获取回调的返回值进行分类讨论
        const fulfilledFn = value => {
          try {
            // 执行第一个(当前的) Promise 的成功回调,并获取返回值
            let x = resolveFn(value);
            // 分类讨论返回值,如果是 Promise, 那么等待 Promise 状态变更, 否则直接 resolve
            x instanceof MyPromise4 ? x.then(resolve, reject) : resolve(x);
          } catch (error) {
            reject(error);
          }
        };

        // reject 同理
        const rejectedFn = error => {
          try {
            let x = rejectFn(error);
            x instanceof MyPromise ? x.then(resolve, reject) : resolve(x);
          } catch (error) {
            reject(error);
          }
        };

        switch (this._status) {
          // 当状态为 pending 时, 把 then 回调 push 进 resolve/reject 执行队列,等待执行
          case PENDING:
            this._resolveQueue.push(fulfilledFn);
            this._rejectQueue.push(rejectedFn);
            break;
          // 当状态已经变为 resolve/reject 时,直接执行 then 回调
          case FULFILLED:
            fulfilledFn(this._value);
            // this._value 是上一个 then 回调 return 的值(见完整版代码)
            break;
          case REJECTED:
            rejectedFn(this._value);
            break;
        }
      });
    }
  }
}
```

<img src="/Image/Basics/Special/Async/16.png" style="zoom:50%;" align="left" />

##### 3-3-2-4、在前面基础上，实现同步任务的兼容

目前 Promise 执行顺序是 new Promise -> then()收集回调 -> resolve/reject执行回调，但前提是异步任务；

若为同步则会变为：new Promise -> resolve/reject执行回调 -> then() 收集回调，解决方式是为同步任务包裹 setTimeout 强行变为异步任务

```javascript
function P5() {
  //Promise/A+规定的三种状态
  const PENDING = "pending";
  const FULFILLED = "fulfilled";
  const REJECTED = "rejected";

  class MyPromise5 {
    // 构造方法接收一个回调
    constructor(executor) {
      // Promise 状态
      this._status = PENDING;
      // 储存 then 回调 return 的值
      this._value = undefined;
      // 成功队列, resolve 时触发
      this._resolveQueue = [];
      // 失败队列, reject 时触发
      this._rejectQueue = [];

      // 由于 resolve/reject 是在 executor 内部被调用, 因此需要使用箭头函数固定 this 指向, 否则找不到 this._resolveQueue
      let _resolve = val => {
        // 把 resolve 执行回调的操作封装成一个函数, 放进 setTimeout 里, 以兼容 executor 是同步代码的情况
        const run = () => {
          // 对应规范中的" 状态只能由 pending 到 fulfilled 或 rejected"
          if (this._status !== PENDING) return;
          this._status = FULFILLED; // 变更状态
          this._value = val; // 储存当前 value

          // 这里之所以使用一个队列来储存回调,是为了实现规范要求的 "then 方法可以被同一个 promise 调用多次"
          // 如果使用一个变量而非队列来储存回调,那么即使多次 p1.then() 也只会执行一次回调
          while (this._resolveQueue.length) {
            const callback = this._resolveQueue.shift();
            callback(val);
          }
        };
        setTimeout(run);
      };
      // 实现同 resolve
      let _reject = val => {
        const run = () => {
          if (this._status !== PENDING) return;
          // 对应规范中的"状态只能由 pending 到 fulfilled 或 rejected"
          this._status = REJECTED; // 变更状态
          this._value = val; // 储存当前 value
          while (this._rejectQueue.length) {
            const callback = this._rejectQueue.shift();
            callback(val);
          }
        };
        setTimeout(run);
      };
      // new Promise() 时立即执行 executor, 并传入 resolve 和 reject
      executor(_resolve, _reject);
    }

    // then 方法,接收一个成功的回调和一个失败的回调
    then(resolveFn, rejectFn) {
      // 根据规范，如果 then 的参数不是 function，则我们需要忽略它, 让链式调用继续往下执行
      typeof resolveFn !== "function" ? (resolveFn = value => value) : null;
      typeof rejectFn !== "function"
        ? (rejectFn = reason => {
            throw new Error(reason instanceof Error ? reason.message : reason);
          })
        : null;

      // return 一个新的 promise
      return new MyPromise5((resolve, reject) => {
        // 把 resolveFn 重新包装一下, 再 push 进 resolve 执行队列,这是为了能够获取回调的返回值进行分类讨论
        const fulfilledFn = value => {
          try {
            // 执行第一个(当前的)Promise 的成功回调,并获取返回值
            let x = resolveFn(value);
            // 分类讨论返回值, 如果是 Promise,那么等待 Promise 状态变更,否则直接 resolve
            x instanceof MyPromise5 ? x.then(resolve, reject) : resolve(x);
          } catch (error) {
            reject(error);
          }
        };

        // reject 同理
        const rejectedFn = error => {
          try {
            let x = rejectFn(error);
            x instanceof MyPromise5 ? x.then(resolve, reject) : resolve(x);
          } catch (error) {
            reject(error);
          }
        };

        switch (this._status) {
          // 当状态为 pending 时,把 then 回调 push 进 resolve/reject 执行队列,等待执行
          case PENDING:
            this._resolveQueue.push(fulfilledFn);
            this._rejectQueue.push(rejectedFn);
            break;
          // 当状态已经变为 resolve/reject 时,直接执行 then 回调
          case FULFILLED:
            fulfilledFn(this._value); // this._value 是上一个 then 回调 return 的值(见完整版代码)
            break;
          case REJECTED:
            rejectedFn(this._value);
            break;
        }
      });
    }
  }
}

// 测试用例
const p5 = new MyPromise5((resolve, reject) => {
  resolve(1); // 同步 executor 测试
});

p5.then(res => {
  console.log(res);
  return 2; // 链式调用测试
})
.then() // 值穿透测试
.then(res => {
  console.log(res);
  return new MyPromise5((resolve, reject) => {
    resolve(3); //返回 Promise 测试
  });
})
.then(res => {
  console.log(res);
  throw new Error("reject 测试"); //reject 测试
})
.then(
  () => {},
  err => {
    console.log(err);
  }
);
```

<img src="/Image/Basics/Special/Async/17.png" style="zoom:50%;" align="left" />

##### 3-3-2-5、在前面基础上，实现静态方法

诸如 race/all/catch/resolve/reject/finally

```javascript
function P6() {
  //Promise/A+规定的三种状态
  const PENDING = "pending";
  const FULFILLED = "fulfilled";
  const REJECTED = "rejected";

  class MyPromise6 {
    // 构造方法接收一个回调
    constructor(executor) {
      // Promise 状态
      this._status = PENDING; 
      // 储存 then 回调 return 的值
      this._value = undefined; 
      // 成功队列, resolve 时触发
      this._resolveQueue = []; 
      // 失败队列, reject 时触发
      this._rejectQueue = []; 

      // 由于 resolve/reject 是在 executor 内部被调用, 因此需要使用箭头函数固定 this 指向, 否则找不到 this._resolveQueue
      let _resolve = val => {
        //把 resolve 执行回调的操作封装成一个函数,放进 setTimeout 里,以兼容 executor 是同步代码的情况
        const run = () => {
          if (this._status !== PENDING) return; // 对应规范中的"状态只能由 pending 到 fulfilled 或 rejected"
          this._status = FULFILLED; // 变更状态
          this._value = val; // 储存当前 value

          // 这里之所以使用一个队列来储存回调,是为了实现规范要求的 "then 方法可以被同一个 promise 调用多次"
          // 如果使用一个变量而非队列来储存回调,那么即使多次 p1.then()也只会执行一次回调
          while (this._resolveQueue.length) {
            const callback = this._resolveQueue.shift();
            callback(val);
          }
        };
        setTimeout(run);
      };
      // 实现同 resolve
      let _reject = val => {
        const run = () => {
          if (this._status !== PENDING) return; // 对应规范中的"状态只能由 pending 到 fulfilled 或 rejected"
          this._status = REJECTED; // 变更状态
          this._value = val; // 储存当前 value
          while (this._rejectQueue.length) {
            const callback = this._rejectQueue.shift();
            callback(val);
          }
        };
        setTimeout(run);
      };
      // new Promise()时立即执行 executor,并传入 resolve 和 reject
      executor(_resolve, _reject);
    }

    // then 方法,接收一个成功的回调和一个失败的回调
    then(resolveFn, rejectFn) {
      // 根据规范，如果 then 的参数不是 function，则我们需要忽略它, 让链式调用继续往下执行
      typeof resolveFn !== "function" ? (resolveFn = value => value) : null;
      typeof rejectFn !== "function"
        ? (rejectFn = reason => {
            throw new Error(reason instanceof Error ? reason.message : reason);
          })
        : null;

      // return 一个新的 promise
      return new MyPromise6((resolve, reject) => {
        // 把 resolveFn 重新包装一下,再 push 进 resolve 执行队列,这是为了能够获取回调的返回值进行分类讨论
        const fulfilledFn = value => {
          try {
            // 执行第一个(当前的)Promise 的成功回调,并获取返回值
            let x = resolveFn(value);
            // 分类讨论返回值,如果是 Promise,那么等待 Promise 状态变更,否则直接 resolve
            x instanceof MyPromise6 ? x.then(resolve, reject) : resolve(x);
          } catch (error) {
            reject(error);
          }
        };

        // reject 同理
        const rejectedFn = error => {
          try {
            let x = rejectFn(error);
            x instanceof MyPromise6 ? x.then(resolve, reject) : resolve(x);
          } catch (error) {
            reject(error);
          }
        };

        switch (this._status) {
          // 当状态为 pending 时,把 then 回调 push 进 resolve/reject 执行队列,等待执行
          case PENDING:
            this._resolveQueue.push(fulfilledFn);
            this._rejectQueue.push(rejectedFn);
            break;
          // 当状态已经变为 resolve/reject 时,直接执行 then 回调
          case FULFILLED:
            fulfilledFn(this._value); // this._value 是上一个 then 回调 return 的值(见完整版代码)
            break;
          case REJECTED:
            rejectedFn(this._value);
            break;
        }
      });
    }

    //catch 方法其实就是执行一下 then 的第二个回调
    catch(rejectFn) {
      return this.then(undefined, rejectFn);
    }

    //finally 方法
    finally(callback) {
      return this.then(
        value => MyPromise.resolve(callback()).then(() => value), //执行回调,并 returnvalue 传递给后面的 then
        reason =>
          MyPromise.resolve(callback()).then(() => {
            throw reason;
          }) //reject 同理
      );
    }

    // 静态的 resolve 方法
    static resolve(value) {
      if (value instanceof MyPromise6) return value; //根据规范, 如果参数是 Promise 实例, 直接 return 这个实例
      return new MyPromise6(resolve => resolve(value));
    }

    // 静态的 reject 方法
    static reject(reason) {
      return new MyPromise6((resolve, reject) => reject(reason));
    }

    // 静态的 all 方法
    static all(promiseArr) {
      let index = 0;
      let result = [];
      return new MyPromise6((resolve, reject) => {
        promiseArr.forEach((p, i) => {
          //Promise.resolve(p)用于处理传入值不为 Promise 的情况
          MyPromise.resolve(p).then(
            val => {
              index++;
              result[i] = val;
              if (index === promiseArr.length) {
                resolve(result);
              }
            },
            err => {
              reject(err);
            }
          );
        });
      });
    }

    // 静态的 race 方法
    static race(promiseArr) {
      return new MyPromise6((resolve, reject) => {
        // 同时执行 Promise,如果有一个 Promise 的状态发生改变,就变更新 MyPromise 的状态
        for (let p of promiseArr) {
          MyPromise.resolve(p).then(
            //Promise.resolve(p)用于处理传入值不为 Promise 的情况
            value => {
              resolve(value); //注意这个 resolve 是上边 new MyPromise 的
            },
            err => {
              reject(err);
            }
          );
        }
      });
    }
  }
  
  // 测试用例
  const p6 = new MyPromise6((resolve, reject) => {
    resolve(1); // 同步 executor 测试
  });
  
  p6.then(res => {
    console.log('res1', res);
    return 2; // 链式调用测试
  })
  .then() // 值穿透测试
  .then(res => {
    console.log('res2', res);
    return new MyPromise6((resolve, reject) => {
      resolve(3); //返回 Promise 测试
    });
  })
  .then(res => {
    return new MyPromise6((resolve, reject) => {
      setTimeout(() => {
        console.log('timer1');
        resolve();
      }, 1000);
    });
  })
  .then(res => {
    return new MyPromise6((resolve, reject) => {
      setTimeout(() => {
        console.log('timer2');
        resolve();
      }, 10000);
    });
  })
  .then(res => {
    console.log(res);
    throw new Error("reject 测试"); //reject 测试
  })
  .then(
    () => {},
    err => {
      console.log(err);
    }
  );

  const p7 = new MyPromise6((resolve, reject) => {
    setTimeout(() => {
      resolve('success')
    },1000)
  })
  
  const p8 = new MyPromise6((resolve, reject) => {
    setTimeout(() => {
      reject('failed..')
    }, 5000)
  })
  
  MyPromise6.race([p7, p8]).then((result) => {
    console.log(result)
  }).catch((error) => {
    console.log(error)  // 打开的是 'failed'
  })

    
  MyPromise6.all([p7, p8]).then((result) => {
    console.log(result)
  }).catch((error) => {
    console.log(error)  // 打开的是 'failed'
  })
}
```





### 四、Generator

**<u>意义：解决顺序性问题</u>**

优点：解决不符合大脑顺序、线性的思维方式问题；缺点：需要手动控制next()执行；



#### 4-1、ES6 新增协议

##### 4-1、可迭代协议

协议允许 Js 对象去定义或定制它们的迭代行为；比如：定义在一个 for...of 结构中，什么值可被循环得到；其中：内置可迭代对象且有默认迭代行为如下 (注意：Object不符合可迭代协议，[但可实现](https://www.imooc.com/qadetail/265962?lastmedia=1))：

- Array
- Map
- Set
- String
- TypeArray
- 函数的 Arguments 对象
- NodeList 对象

注意：为了变成可迭代对象，1个对象必须实现@@iterator方法；即此对象须有一名为 [Symbol.iterator] 的属性，其值为返回一个对象(须符合迭代器协议)的无参函数 (或对象原型链 prototype chain上的某个对象含有)；而当一个对象需要被迭代的时候 (比如开始用于一个for...of循环中) ，其 @@iterator 方法被调用，且无参数，最后返回一个用于在迭代中获得值的迭代器，



##### 4-2、迭代器协议

协议定义一种标准方式，来产生一个有限或无限序列的值；比如：当1个对象被认为是1个迭代器时，其实现了1个next 方法，方法是返回一个对象的无参函数，被返回对象拥有2个属性；

- **done：boolean**
  - 若迭代器已经过了被迭代序列时，则为 true，此时 value 可能描述了该迭代器的返回值；
  - 若迭代器可产生序列中的下1个值，则为 false，这等效于连同 done 属性也不指定；
- **value：any**
  - 迭代器返回的任何 JS 值，done 为 true 时可忽略；

<img src="/Image/Basics/Special/Async/4.png" style="zoom:50%;" align="" />

<img src="/Image/Basics/Special/Async/5.png" style="zoom:50%;" align="" />



#### 4-2、Generator

##### 4-2-1、基本

**<u>生成器</u>** 是一个带 <u>星号</u> 的 "函数"(注意：但并非真正函数)，可通过  `yield` 关键字  <u>暂停执行</u> 和 <u>恢复执行</u>；其执行有这样几个关键点:

- 调用 gen() 后，程序会阻塞住，不会执行任何语句；
- 调用 g.next() 后，程序继续执行，直到遇到 yield 程序暂停；
- next 方法 <u>返回有两个属性的对象</u>：`value` 和 `done`；
  - 前者为`当前 yield 后面的结果`；
  - 后者表示`是否执行完`，遇到`return` 后，`done` 会由`false`变为`true`；

```js
function* gen() {
  console.log("gen enter");
  let a = yield 1;
  let b = yield (function () {return 2})();
  return 3;
}
// 生成迭代器实例
// 阻塞住，不会执行任何语句
var g = gen() 

console.log(typeof g)  
// object 注意不是 "function"
// gen enter
console.log(g.next())  
// { value: 1, done: false }
console.log(g.next())  
// { value: 2, done: false }
console.log(g.next())  
// { value: 3, done: true }
console.log(g.next()) 
// { value: undefined, done: true }
```



##### 4-2-2、实现机制—协程 

**<u>协程</u>**：是一种比线程更加轻量级的存在，协程处在线程的环境中，<u>一个线程可存在多个协程</u>，可将协程理解为线程中的一个个任务；不像进程和线程，<u>协程并不受操作系统的管理，而是被具体的应用程序代码所控制</u>；

- 注意：JS 是单线程执行，**<u>多协程无法同时执行，一个线程一次只能执行一个协程</u>**；
- 比如：当前执行 A 协程，另外尚有 B 协程，若想执行 B 任务，则须在 A 协程中，<u>将 JS 线程控制权转交给 B协程</u>，而在 B 执行时，A 就会处于暂停状态；

```js
function* A() {
  console.log("我是A");
  yield B(); // A停住，在这里转交线程执行权给B
  console.log("结束了");
}
function B() {
  console.log("我是B");
  return 100;// 返回，并且将线程执行权还给A
}
let gen = A();
gen.next();
gen.next();

// 我是A
// 我是B
// 结束了

// A 将执行权交给 B，也就是 A 启动 B，我们也称 A 是 B 的父协程。因此 B 当中最后return 100其实是将 100 传给了父协程。
// 注意：对于协程来说，其并不受操作系统控制，完全由用户自定义切换，因此并没有进程/线程上下文切换的开销，此乃高性能的重要原因
```



##### 4-2-3、生成器的自动化实现

生成器执行方式为暂停-恢复、暂停-恢复…且每次执行都要手动调用 next，无法自动执行；且与异步无关联，但可用 thunk(偏函数) 和 promise 实现异步关联

##### 4-2-3-1、thunk 自动化实现

```js
let isString = (obj) => {
  return Object.prototype.toString.call(obj) === '[object String]';
};
let isFunction = (obj) => {
  return Object.prototype.toString.call(obj) === '[object Function]';
};
let isArray = (obj) => {
  return Object.prototype.toString.call(obj) === '[object Array]';
};
let isSet = (obj) => {
  return Object.prototype.toString.call(obj) === '[object Set]';
};
// ...
// 对上述进行合并
let isType = (type) => {
  return (obj) => {
    return Object.prototype.toString.call(obj) === `[object ${type}]`;
  }
}
// isString 和 isFunction 是由 isType 生产出来的函数，可以实现相同功能且代码简洁化
let isString = isType('String');
let isFunction = isType('Function');
// ...

isString("123");
isFunction(val => val);

// isType 这样的函数即称为 thunk 函数: 其核心逻辑是接收一定的参数，生产出定制化的函数，然后使用定制化的函数去完成功能
// thunk 函数的实现会比单个的判断函数复杂一点点，但就是这一点点的复杂，大大方便了后续的操作；
```

**<u>thunk 函数</u>**: 其核心逻辑是：**<u>接收一定的参数，生产出定制化的函数，然后使用定制化的函数去完成功能</u>**；虽然其实现会比单个的判断函数复杂一点点，但就是这一点点的复杂，大大方便了后续的操作；

**<u>即将 thunk 是返回可传参函数的函数；此点可结合生成器，既然 thunk 返回函数，那传入回调，即可实现异步、一次执行等</u>**

**<u>thunk 关联 generator</u>**：

```js
// readFileThunk 就是一个 thunk 函数
// 异步操作核心的一环就是绑定回调函数，而 thunk 函数可以辅助实现；
// 首先传入文件名(参数)，然后生成一个针对某个文件的定制化函数，若在这个函数中传入回调参数，则此回调就会成为异步操作的回调；
// 即将其想象为 isType 函数 返回值是一个可传参的函数；
const readFileThunk = (filename) => {
  return (callback) => {
    fs.readFile(filename, callback);
  }
}

const gen = function* () {
  const data1 = yield readFileThunk('001.txt')
  console.log(data1.toString())
  const data2 = yield readFileThunk('002.txt')
  console.log(data2.toString)
}

let g = gen();
// 第一步: 由于进场是暂停的，我们调用next，让它开始执行。
// next 返回值中有一个 value 值，value 即 yield 后的结果，放在这里也就是是 thunk 函数生成的定制化函数，里面需要传一个回调函数作为参数
g.next().value((err, data1) => {
  // 第二步: 拿到上一次得到的结果，调用 next, 将结果作为参数传入，程序继续执行。
  // 同理，value 传入回调
  g.next(data1).value((err, data2) => {
    g.next(data2);
  })
})
```

```js
// 上述封装结果如下
function run(gen){
  const next = (err, data) => {
    let res = gen.next(data);
    if(res.done) return;
    res.value(next);
  }
  next();
}
run(g);
```



##### 4-2-3-2、promise 自动化实现

```js
const readFilePromise = (filename) => {
  return new Promise((resolve, reject) => {
    fs.readFile(filename, (err, data) => {
      if(err) {
        reject(err);
      }else {
        resolve(data);
      }
    })
  }).then(res => res);
}
const gen = function* () {
  const data1 = yield readFilePromise('001.txt')
  console.log(data1.toString())
  const data2 = yield readFilePromise('002.txt')
  console.log(data2.toString)
}

let g = gen();
function getGenPromise(gen, data) { 
  return gen.next(data).value;
}
getGenPromise(g).then(data1 => {
  return getGenPromise(g, data1);
}).then(data2 => {
  return getGenPromise(g, data2)
})
```

```js
// 上述封装结果如下
function run(g) {
  const next = (data) => {
    let res = g.next();
    if(res.done) return;
    res.value.then(data => {
      next(data);
    })
  }
  next();
}
```



##### 4-2-3-3、co 库自动化实现

```js
const co = require('co');
let g = gen();
co(g).then(res =>{
  console.log(res);
})
```



##### 4-2-X、注意事项

##### 4-2-X-1、生成器调用另生成器

```js
function* gen1() {
    yield 1;
    yield 4;
}
function* gen2() {
    yield 2;
    yield 3;
}

// 输出 1 2 3 4
function* gen1() {
    yield 1;
    yield* gen2();
    yield 4;
}
```





### 五、Async/Await

**<u>意义：解决 Generator 需手动控制 next 执行的问题(真正实现用同步方式书写异步代码)</u>**



#### 5-1、基本

**<u>Async</u>**：是一个通过异步执行并隐式 **<u>返回 Promise 作为结果</u>** 的函数；<u>是 协程 和 Promise 的组合体</u>，完全解决了基于传统回调的异步流程存在的两个问题(见上方)，能够像 co + Generator 一样用同步的方式来书写异步代码，又得到底层的语法支持，无需借助任何第三方库；

Await：暂停异步函数的执行；注意 await 只能与 Promise 共用，无法与传统回调共用，await 等待 Promise 完成并返回其结果；

- 优点：解决了 Generator 需要手动控制 next 执行的问题；
- 优点：真正实现用同步的方式书写异步代码，逻辑和数据依赖清晰；
- 优点：无需写 .then、无需写匿名函数处理 Promise 的 resolve 值、无需定义多余变量、避免代码嵌套、提高可读性；
- 缺点：错误处理过于安静，往往需要用 try-catch 来捕获；

```js
async function func() {
  return 100;
}
console.log(func());
// Promise {<resolved>: 100}
```

```js
async function test() {
  console.log(100)
  let x = await 200
  // let promise = new Promise((resolve,reject) => {
  //	resolve(200);
  //  // 调用 resolve, 进入微任务队列
  //	// JS 引擎将暂停当前协程的运行，把线程的执行权交给父协程
  // })
  // 回到父协程中，父协程的第一件事情就是对 await 返回的 Promise 调用 then, 来监听这个 Promise 的状态改变
  // promise.then(value => {
  //  // 相关逻辑，在resolve 执行之后来调用
  //  // 1. 将线程的执行权交给test协程
  //  // 2. 把 value 值传递给 test 协程
	// })
  console.log(x)
  console.log(200)
}
// 首先, 代码同步执行，打印出 0，然后将 test 压入执行栈, 打印 100
console.log(0)
// 然后，遇到 await，被 JS 引擎转换成一个 Promise
test()
// 然后往下执行，打印出300。
// 根据 EvLoop 机制，当前主线程的宏任务完成，现在检查微任务队列, 发现还有一个Promise的 resolve，执行，现在父协程在then中传入的回调执
console.log(300)

// 0 100 300 200 200
```

Async/Await 利用 `协程` 和 `Promise ` 实现同步方式编写异步代码的效果，其中 `Generator` 是对 `协程` 的一种实现，虽然语法简单，但引擎在背后做了大量的工作，用 `async/await` 写出的代码也更加优雅、美观，相比于之前的 `Promise` 不断调用then的方式，语义化更加明显；相比于`co + Generator`性能更高，上手成本也更低；




#### 5-2、实现

​	Promise 一旦新建即立即执行则无法停止，错误需通过回调函数来捕获，而 async/await 可进行更细粒度的操作，比如下图，而 async/await 实际上是对 Generator(生成器) 的封装，即语法糖，为何前者盛行是因为后者刚出现不久就被前者取代；

```javascript
// Promise 立即执行则无法停止
Promise.resolve(a).then(b => {}).then(c => {})
// Async/await
async function test() { 
	const a = await Promise.resolve(a);
  // do something else ..
  const b = await Promise.resolve(b);
  // do something else ..
  const c = await Promise.resolve(c);
  // do something else ..
}
```



##### 5-2-1、Generator 的简介

ES6 的 Generator 函数，可通过 yield 关键字，将函数执行挂起，并通过 next 方法切换到下一状态，以改变执行流程；

```javascript
// testGenerator1
function* testG1() {
  yield 'hello'
  yield 'guys'
  return '!'
}

const gen1 = testG1();
console.log(gen1.next()); // {value: "hello", done: false}
console.log(gen1.next()); // {value: "guys", done: false}
console.log(gen1.next()); // {value: "!", done: true}

// testGenerator2
function* testG2() {
  console.log(yield 'hello');
  console.log(yield 'guys');
  return '!'
}

const gen2 = testG2();
gen2.next();
// value: "hello", done: false}
gen2.next('anybody');
// anybody
// {value: "guys", done: false}
gen2.next('here');
// here
// {value: "!", done: true}
gen2.next('!!!');
// {value: undefined, done: true}
```



##### 5-2-2、Generator 与 Async/Await 区别

- async/await 自带执行器，无需手动调用 next 方法即可自动执行下一步；
- async 函数返回值为 Promise 对象，Generator 则是生成器对象；
- await 能返回 Promise 的 resolve/reject 值；



##### 5-2-3、基于 Generator 实现 Async/Await

```javascript
// 1、让 Generator 类似 Async 行为第1步：让 yield(await) 能返回 resolve 值
function* myGenerator() {
  yield Promise.resolve(1);
  yield Promise.resolve(2);
  yield Promise.resolve(3);
}
// 手动执行迭代器
const gen = myGenerator()
gen.next().value.then(val => {
  gen.next(val).value.then(val => {
    gen.next(val).value.then(val => {
      gen.next(val)
    })
  })
})


// 2、让 Generator 类似 Async 行为第2步：自动调用并输出(通过封装递归执行函数实现)
function run(gen) {
  var g = gen()   
  function _next(val) {             // 通过内部函数递归执行 g.next()
    var res = g.next(val)           // 获取迭代器对象 res，并传入上轮 resolve 出的值
    if(res.done) return res.value   // 根据 Generator 迭代器对象的值来作为递归终止判断
    res.value.then(val => {         // 通过 Promise 的 then 方法实现自动迭代
      _next(val)                    // 等待 Promise 完成就自动执行下一个 next，并传入 resolve 的值
    })
  };
  _next();
}
run(myGenerator)




// 3、让 Generator 类似 Async 行为第3步：返回 Promise、增加错误处理、基本类型值也能实现
function run(gen) {
  // 将返回值包装成 Promise
  return new Promise((resolve, reject) => {
    var g = gen()
    function _next(val) {
      // 用 tryCatch 实现错误处理
      try {
        var res = g.next(val) 
      } catch(err) {
        return reject(err); 
      }
      // 递归结束
      if(res.done) {
        return resolve(res.value);
      }
      // 利用 Promise 特性处理基本类型值，以兼容 yield 后面跟基本类型的情况
      // 将 res.value 包装为 Promise
      Promise.resolve(res.value).then(
        val => {
          _next(val);
        }, 
        err => {
          // 抛出错误
          g.throw(err)
        });
    }
    _next();
  });
}




// 4、测试
function* myGenerator() {
  try {
    console.log(yield Promise.resolve(1)) 
    console.log(yield 2)   //2
    console.log(yield Promise.reject('error'))
  } catch (error) {
    console.log(error)
  }
}
const result = run(myGenerator) // result是一个Promise
// 输出 1 2 error
```



##### 5-2-4、Babel 对 Async/Await 的转译

```javascript
// 相当于 run()
function _asyncToGenerator(fn) {
  // return 一个 function，和 async 保持一致，而 run 直接执行了 Generator，略不符规范
  return function() {
    var self = this
    var args = arguments
    return new Promise(function(resolve, reject) {
      var gen = fn.apply(self, args);
      // 相当于 _next()
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'next', value);
      }
      // 处理异常
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'throw', err);
      }
      _next(undefined);
    });
  };
}

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}


// 测试
const foo = _asyncToGenerator(function* () {
  try {
    console.log(yield Promise.resolve(1))   //1
    console.log(yield 2)                    //2
    return '3'
  } catch (error) {
    console.log(error)
  }
})
foo().then(res => {
  console.log(res)                          //3
})
```





#### 5-3、注意事项

##### 5-3-1、forEach + await

```js
// 问题: 对于异步代码，forEach 并不能保证按顺序执行
async function test() {
	let arr = [4, 2, 1]
	arr.forEach(async item => {
		const res = await handle(item)
		console.log(res)
	})
	console.log('结束')
}
function handle(x) {
	return new Promise((resolve, reject) => {
		setTimeout(() => {
			resolve(x)
		}, 1000 * x)
	})
}
test()
// 结束 1 2 4


// 原因:
// forEach 核心逻辑
// forEach 直接执行，无法保证异步任务的执行顺序
for (var i = 0; i < length; i++) {
  if (i in array) {
    var element = array[i];
    callback(element, i, array);
  }
}


// 解决: 使用 for...of
async function test() {
  let arr = [4, 2, 1]
  for(const item of arr) {
	const res = await handle(item)
	console.log(res)
  }
	console.log('结束')
}
// 4 2 1 结束


// 原理: for of 采用一种特别的手段——迭代器去遍历
// 且数组是一种可迭代数据类型: 原生具有[Symbol.iterator]属性数据类型为可迭代数据类型。如数组、类数组（如arguments、NodeList）、Set和Map
// 可迭代对象可以通过迭代器进行遍历:
let arr = [4, 2, 1];
// iterator 即迭代器
let iterator = arr[Symbol.iterator]();
console.log(iterator.next());
// {value: 4, done: false}
console.log(iterator.next());
// {value: 2, done: false}
console.log(iterator.next());
// {value: 1, done: false}
console.log(iterator.next());
// {value: undefined, done: true}


// 所以: 最初版本可通过以下实现
async function test() {
  let arr = [4, 2, 1]
  let iterator = arr[Symbol.iterator]();
  let res = iterator.next();
  while(!res.done) {
    let value = res.value;
    console.log(value);
    await handle(value);
    res = iterater.next();
  }
	console.log('结束')
}
// 4
// 2
// 1
// 结束
```

**<u>注意：生成器本身就是一个 迭代器</u>**，所以可以用 for...of 遍历；

```js
function* fibonacci(){
  // 1
  let [prev, cur] = [0, 1];
  console.log(cur);
  // 死循环
  while(true) {
    [prev, cur] = [cur, prev + cur];
    // 输出
    yield cur;
  }
}
// 用 for of 代替人工执行
for(let item of fibonacci()) {
  if(item > 50) break;
  console.log(item);
}
// 1
// 1
// 2
// 3
// 5
// 8
// 13
// 21
// 34
```



#### 5-x、示例与

##### 5-x-1、示例1

<img src="/Image/Basics/Special/Async/18.png" style="zoom:50%;" align="left" />

<img src="/Image/Basics/Special/Async/19.png" style="zoom:50%;" align="left" />

##### 5-x-2、示例2

<img src="/Image/Basics/Special/Async/20.png" style="zoom:50%;" align="left" />

##### 5-x-3、注意1

- 若不使用await，异步函数会被同步执行

<img src="/Image/Basics/Special/Async/21.png" style="zoom:50%;" align="left" />



##### 5-x-4、注意2

- async-await 主要解决的就是将异步问题同步化，降低异步编程的认知负担；
- async-await 是 promise 和 generator 的语法糖，故无法取代 Promsie 地位，如并行执行需要结合 Promise.all；
- async 函数执行后，总是返回一个 promise 对象，可调用 then 等方法，而里面 await 所在的行的语句是同步的；
- async 函数即将 Generator 函数的星号（*）替换成 async，将 yield 替换成 await；
- async 函数的实现，即将 Generator 函数和自动执行器，包装在一个函数中；

<img src="/Image/Basics/Special/Async/22.png" style="zoom:50%;" align="left" />



##### 5-x-5、注意3

- 同 Generator 函数一样，async 函数返回一个 Promise 对象，可以使用 then 方法添加回调函数

<img src="/Image/Basics/Special/Async/23.png" style="zoom:50%;" align="left" />



##### 5-x-6、注意4

- await 命令后面的 Promise 对象，运行结果可能是 rejected，故最好将 await 命令放在 try...catch 中，try..catch 错误处理也比较符合我们平常编写同步代码时候处理的逻辑
- await 调用，是让其后的语句做一个递归执行，直到获取到结果并使其状态变更，才会 resolve 掉，而只有 resolve 掉，await 那行代码才算执行完，才继续往下一行执行
- awaiit 后面跟 promsie 才能有线程效果，且 promise 内必须加 resolve

<img src="/Image/Basics/Special/Async/24.png" style="zoom:50%;" align="left" />



##### 5-x-7、注意5

- async + 函数 的原型是一个 [AsyncFunction](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/AsyncFunction)，而紧跟 async 后的函数最终返回的是 Promise，

<img src="/Image/Basics/Special/Async/25.png" style="zoom:50%;" align="left" />

<img src="/Image/Basics/Special/Async/26.png" style="zoom:50%;" align="left" />

- 即便函数 return 某些值，但最终都会封装成 Promsie

<img src="/Image/Basics/Special/Async/27.png" style="zoom:50%;" align="left" />







### 六、前端请求相关

#### 6-1、Ajax

##### 6-1-1、基本

**<u>*Ajax—Asynchronous JS And XML*</u>** (异步的 JS 和 XML)

Ajax 是一种用于创建快速动态网页的技术；通过在后台与服务器进行少量数据交换，Ajax 可使网页实现异步更新；其最大特点也即实现局部刷新；

- 核心：**<u>*XMLHttpRequest*</u>** 对象 (老版本是ActiveXObject)，其并非单一技术实现，而是有机利用一系列交互式网页应用相关的技术所形成的结合体；

- 前身：过去使用 JS 向服务器发出 [HTTP](https://link.juejin.im/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen%2FHTTP) 请求，故需要负责此功能的类实例，此亦 <u>**XMLHttpRequest**</u> 的由来，此类最初是在 IE 中作为一个名为 **<u>XMLHTTP</u>** 的**<u>ActiveX</u>** 对象引入；然后，Mozilla、Safari、其他浏览器，实现一个 **<u>XMLHttpRequest</u>** 类，支持 Microsoft 的原始 <u>**ActiveX**</u> 对象的方法和属性，同时微软也实现了 **<u>XMLHttpRequest</u>**；浏览器实现对象：XMLHttpRequest、IE6-ActiveXObject；
- 注意：虽名称包含 XML，但实际上数据格式可由 [JSON](https://link.juejin.im/?target=https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2FJSON) 代替，以进一步减少数据量，形成所谓的 Ajaj；

Ajax 优点：

- 无刷新更新数据，用户体验好；
- 异步通信，更加快的响应能力；
- 基于标准化的并被广泛支持的技术，无需下载插件或小程序；
- 减少冗余请求，减少了带宽占用，减轻了服务器负担、场地租用成本；
- 数据与呈现分离，有利于分工合作、减少非技术人员对页面的修改造成的 WEB 应用程序错误、提高效率；

Ajax 缺点：

- 不支持浏览器回退功能和加入收藏书签功能，即破坏了浏览器后退机制；
  - 现象：在动态更新页面情况下，用户无法回到上一页面状态；
  - 解决：
    - [HTML5](https://link.juejin.im/?target=https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2FHTML5)  前可使用 [URL](https://link.juejin.im/?target=https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2FURL) 片断标识符 ([锚点](https://link.juejin.im/?target=https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2F%E9%94%9A%E7%82%B9)，即URL中#后面的部分)来保持追踪，允许用户回到指定的某个应用程序状态；
    - [HTML5](https://link.juejin.im/?target=https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2FHTML5)  后可直接操作浏览历史，并以字符串形式存储网页状态，将网页加入网页收藏夹或书签时状态会被隐形地保留；
- 存在一定的安全问题，因其暴露了与服务器交互的细节；容易受攻击：跨站点脚步攻击、SQL注入攻击和基于Credentials的安全漏洞等；
- 对搜索引擎的支持比较弱；
- 无法用URL直接访问，不易调试；

##### 6-1-2、系列对比

##### 6-1-2-1、Ajax 与 Flash

- Ajax：对 CSS、文本支持很好，支持搜索，易用易于开发，但多媒体、矢量图形、机器访问不足；
- Flash：适合处理多媒体、矢量图形、机器访问好、兼容性好，但对 CSS、处理文本上不足，不容易被搜索，格式私有，体积大，有性能问题；
- 相同点：与服务器的无刷新传递消息、可检测用户离线和在线状态、可操作 DOM；

##### 6-1-2-2、Ajax 与 Fetch

前者本质是使用 ***<u>XMLHttpRequest</u>*** 对象来请求数据；

后者则是全局对象 window 的一个方法：`window.fetch(URL，控制不同配置的 init 对象(可选))`，使用 Promises 来处理结果/回调:

- 从 fetch 返回的 *<u>Promise</u>* 将不会拒绝 HTTP 错误状态
  - 即使：响应是一个 HTTP 404 或 500；且仅在网络故障时或任何阻止请求完成时，它才会拒绝；

- 默认情况下，fetch 在服务端不会发送/接收任何 cookies

  - 若站点依赖于维护一个用户会话，则导致未经认证的请求(要发送 cookies，必须发送凭据头). 

  - 若想在同域中自动发送 cookie，则须使用 credentials 的 same-origin 值，其使得 fetch 处理 Cookie 与 *XMLHttpRequest* 类似；

  - 否则，Cookie 将不会被发送，导致这些请求不保留认证会话

  - ```js
    window.fetch(url, {
    	credentials: 'same-origin'
    })
    ```

- 对于 CORS 请求，使用 credentials 的 include 值，允许将凭据发送到其他域：

  - ```js
    window.fetch(url, {
       credentials: 'include'
    })
    ```

    

##### 6-1-3、使用

```js
/**
 * Ajax 基本使用
 */

// 创建核心 Ajax 对象实例
const xhr = new XMLHttpRequest();

// 规定请求方式、请求对象、是否异步请求
// 格式：open(method, url, async) 常用：POST/GET/DELETE，不常用：COPY/HEAD/LINK 等
// async：请求为true则是异步请求，为false则是同步请求，默认是true。
// 异步：非阻塞，前面的代码不会影响后面代码的执行。 
// 同步：阻塞，前面的代码影响后面代码的执行。
xhr.open("POST", "URL", true);

// 请求参数示例
postData = { name1: "value1", name2: "value2" };

// 请求参数处理
postData = (function(value) {
  var dataString = "";
  for (var key in value) {
    dataString += key + "=" + value[key] + "&";
  }
  return dataString;
})(postData);

// 请求头设置 - 必须在 open 和 send 之间调用 - 规定发送信息至服务器时内容编码类型
xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded");

// 是否允许携带跨域 Cookie - ajax 请求默认携带同源请求 cookie，跨域请求不携带
xhr.withCredentials = true;

// 发出请求 - postData: http 请求的参数，可为string、Blob等类型
// 若使用get发送请求，该参数可不填或null 
// 若使用post发送请求，则需要填写
xhr.send(postData);

// 请求发送前触发 - readyState == 1后, readyState == 2前
xhr.onloadstart = function() {};

// 请求发送状态 readyState 属性改变时触发 - 接受服务器响应数据
xhr.onreadystatechange = function() {
  if (xhr.readyState === 4) {
    // readyState - XMLHttpRequest 对象所处的状态
    //      0     UNSENT                代理被创建，但尚未调用 open
    //      1     OPENED                open 方法已被调用
    //      2     HEADERS_RECEIVED      send 方法已被调用，且头部和状态已可获得(接收到头信息)
    //      3     LOADING               下载进行中、responseText 属性已包含部分数据(接收到响应主体)
    //      4     DONE                  下载已完成(响应完成)
    if ((xhr.status >= 200 && xhr.status < 300) || xhr.status === 304) {
      // status - http 请求状态, 初始0, 若服务器无显式地指定则为默认 200
      // 1字头：消息 
      // 2字头：成功 
      // 3字头：重定向 
      // 4字头：请求错误 
      // 5字头：服务器错误
      console.log(xhr.responseText);
    }
  }
};

// 请求完成时触发 - 资源及其依赖资源已完成加载时刻，常用于处理返回值
xhr.onload = function() {};

// 接收返回头 - 若返回头中有多个相同名称，则用逗号 & 空格将值分隔的字符串
var responseHeader = xhr.getResponseHeader(name);

// 异常处理
xhr.onerror = function() {
  console.log("Network request failed");
};

// 超时处理
xhr.ontimeout = function() {
  console.log("Timeout Request failed");
};

// 进度处理
xhr.onprogress = function(event){
  console.log(event.loaded / event.total);
}

// 终止请求 - 调用后 readyState 将被设置为 0
xhr.abort();
```



##### 6-1-4、$.ajax 

是 jQuery 对 Ajax 的封装，还支持 JSONP，前期叱咤风云，后期随着各式框架出现，为使用 Ajax 引入 jQuery 不实际，故有 fetch 方案；

- `load()`、`$.get()` 和 `$.post()` 方法基本即可满足日常需求，复杂场景可用 `$.ajax()` ；
- `load()` 方法通常用来从 web 服务器上获取静态的数据文件；

```js
$.ajax({
  // 请求方式
  type: 'GET',
  // 返回值类型
  dataType: "json", 
  //    "json":   返回 JSON 数据；
  //    "text":   返回 纯文本字符串；
  //    "xml":    返回 XML 文档，可用 jQuery 处理；
  //    "html":   返回 纯文本 HTML 信息；包含的 script 标签会在插入 dom 时执行；
  //    "script": 返回 纯文本 JS 代码、不自动缓存结果 (除非设置了 "cache" 参数) 
  //              注意 在远程请求时(不在同一个域下)，所有 POST 请求都将转为 GET 请求 (因将使用 DOM 的 script标签来加载);
  //    "jsonp":  JSONP 格式。使用 JSONP 形式调用函数时，如 "myurl?callback=?" jQuery 将自动替换 ? 为正确的函数名，以执行回调函数
  // 请求超时时间(毫秒)
  timeout: 10000,
  // 请求为异步或同步
  async: true,
  // 请求发送信息至服务器时内容编码类型
  contentType: "application/json", 
  // 请求头
  headers: { "Content-Type": "application/json" }, 
  // 跨域携带 - cookie
  xhrFields: { withCredentials: true }, 
  // 参数传递 - 使用 JSON.stringify 转码
  data: JSON.stringify({ a: [{ b: 1, a: 1 }] }), 
  // 成功处理
  success: function(data, status) {
    console.log(data, status);
  },
  // 失败处理
  error: function(xhr, status) {
    console.log(xhr, status);
  },
  // 请求动作完成后调用(无论成功或失败)
  complete: function(xhr, status){
    console.log(xhr, status);
  }
});
```



#### 6-2、Fetch

##### 6-2-1、基本

可理解为 Ajax 的 Promise 化，在 Ajax 基础上增加更多扩展，比如 CORS、HTTP、流程化、回调地狱等，源码结构如下：



##### 6-2-2、源码实现

<img src="/Image/Basics/Special/Async/34.png" style="zoom:50%;" align="left" />

##### 6-2-2-1、基本骨架

- 构造 Promise 对象并返回
- 创建 Request 对象
- 创建 XMLHttpRequest 对象
- 取出 Request 对象中参数
- 打开 XHR 请求，并将 Request 对象中存储的 headers 取出赋给 XHR
- onload 后取出 response 的 status、headers、body 封装 Response 对象，调用 resolve

<img src="/Image/Basics/Special/Async/35.png" style="zoom:50%;" align="left" />



##### 6-2-2-2、Errors 处理及封装

注意：使用 fetch 接收到异常状态码均会进入 then 而不是 catch，故需手动处理；

<img src="/Image/Basics/Special/Async/36.png" style="zoom:50%;" align="left" />



##### 6-2-2-3、Headers 封装

注意：通过 map 维护传入的头部参数；

<img src="/Image/Basics/Special/Async/37.png" style="zoom:50%;" align="left" />

<img src="/Image/Basics/Special/Async/38.png" style="zoom:50%;" align="left" />



##### 6-2-2-4、Request 封装

<img src="/Image/Basics/Special/Async/39.png" style="zoom:50%;" align="left" />



##### 6-2-2-5、Response 封装

注意：fetch 执行完毕后，不能直接在 response 中获取到返回值而必须调用 text()、json() 等函数才能获取到返回值；

<img src="/Image/Basics/Special/Async/40.png" style="zoom:50%;" align="left" />

<img src="/Image/Basics/Special/Async/41.png" style="zoom:50%;" align="left" />

<img src="/Image/Basics/Special/Async/42.png" style="zoom:50%;" align="left" />



##### 6-2-3、使用注意

问题：因 fetch 为底层 API，故没有太多封装

- 需要自己判断返回值类型，并执行响应获取返回值的方法；

- 获取返回值方法只能调用一次，不能多次调用；

- 老版浏览器不会默认携带 cookie；

- 不能直接传递 JS 对象作为参数；

  - ```js
    // jquery ajax
    $.post(url, {name: 'test'})
    // fetch
    fetch(url, {
        method: 'POST',
        body: Object.keys({name: 'test'}).map((key) => {
            return encodeURIComponent(key) + '=' + encodeURIComponent(params[key]);
        }).join('&')
    })
    ```

- 无法正常的捕获异常；

- 不支持超时控制；

- 不支持 jsonp；

解决：自实现 fetch 功能封装

- <u>请求参数的处理</u>，使其支持传入不同的参数类型：

  - ```js
    function stringify(url, data) {
      var dataString = url.indexOf('?') == -1 ? '?' : '&';
      for (var key in data) {
        dataString += key + '=' + data[key] + '&';
      };
      return dataString;
    }
    
    if (request.formData) {
      request.body = request.data;
    } else if (/^get$/i.test(request.method)) {
      request.url = `${request.url}${stringify(request.url, request.data)}`;
    } else if (request.form) {
      request.headers.set('Content-Type', 'application/x-www-form-urlencoded;charset=UTF-8');
      request.body = stringify(request.data);
    } else {
      request.headers.set('Content-Type', 'application/json;charset=UTF-8');
      request.body = JSON.stringify(request.data);
    }
    ```

- <u>Cookie 携带</u>：新版浏览器已开始默认携带同源 cookie，但老版浏览器中不会默认携带，<u>故需要统一处理</u>：

  - ```js
    request.credentials =  'same-origin'; // 同源携带
    request.credentials =  'include'; // 可跨域携带
    ```

- <u>错误处理</u>：当接收到一个代表错误的 HTTP 状态码时，fetch 返回的 Promise 不会被标记为 reject， 即使为 404 或 500，相反会将 Promise 状态标记为 resolve (但会将 resolve 的返回值的 ok 属性设置为 false)，而仅当网络故障时或请求被阻止时，才会标记为 reject；<u>故须对异常进行统一处理</u>：

  - ```js
    .then(response => {
      if (response.ok) {
        return Promise.resolve(response);
      }else{
        const error = new Error(`请求失败! 状态码: ${response.status}, 失败信息: ${response.statusText}`);
        error.response = response;
        return Promise.reject(error);
      }
    });
    ```

- <u>返回值处理</u>：对不同的返回值类型调用不同的函数接收，故必须提前判断好类型，不能多次调用获取返回值的方法

  - ```js
    .then(response => {
      let contentType = response.headers.get('content-type');
      if (contentType.includes('application/json')) {
        return response.json();
      } else {
        return response.text();
      }
    });
    ```

- JSONP支持：没有提供对 JSONP 的支持；跨域推荐使用 CORS 或 Nginx 解决跨域





#### 6-3、Axios

##### 6-3-1、基本

基本：Axios 也是对原生 XHR 的封装，是基于 promise 的 HTTP 库，它有以下几大特性，[文档](https://www.kancloud.cn/yunye/axios/234845)：

- 提供了并发请求的接口；
- 可在 Node 与浏览器中使用；
- 支持 Promise API，客户端支持防御 XSRF；
- 可拦截请求和响应、转换请求数据&响应数据、取消请求、自动转换 JSON 数据；

```js
// 1、简单使用1
axios({
    method: 'GET',
    url: url,
})
.then(res => {console.log(res)})
.catch(err => {console.log(err)})


// 2、简单使用2
axios.post('/user', {
    name: 'zxm',
    age: 18,
  })
  .then(function (response) {
    console.log(response);
  })


// 3、并发请求
function getUserAccount() {
  return axios.get('/user/12345');
}
function getUserPermissions() {
  return axios.get('/user/12345/permissions');
}
axios.all([getUserAccount(), getUserPermissions()])
  .then(axios.spread(function (acct, perms) {
    // Both requests are now complete
  }));
```



##### 6-3-2、使用





##### 6-3-3、源码解析

##### 6-3-3-1、源码结构

<img src="/Image/Basics/Special/Async/43.png" style="zoom:50%;" align="left" />



##### 6-3-3-2、Instance 实例构建

**<u>*利用 createInstance 构建实例、继承 utils 方法，随后为实例增加各个函数方法*</u>**，lib/axios.js

<img src="/Image/Basics/Special/Async/44.png" style="zoom:50%;" align="left" />

- 补充 utils 工具方法：
  - <img src="/Image/Basics/Special/Async/45.png" style="zoom:50%;" align="left" />
  - utils 中的 merge 方法：合并对象的属性，相同属性后面的替换前的
  - <img src="/Image/Basics/Special/Async/50.png" style="zoom:50%;" align="left" />
  - <img src="/Image/Basics/Special/Async/51.png" style="zoom:50%;" align="left" />
  - utils 中的 extend 方法：将 b 里面的属性和方法继承给 a , 并且将 b 里面的方法的执行上个下文都绑定到 thisArg
  - <img src="/Image/Basics/Special/Async/46.png" style="zoom:50%;" align="left" />
  - <img src="/Image/Basics/Special/Async/47.png" style="zoom:50%;" align="left" />
  - extend  中的 forEach 能遍历基本数据，数组，对象：
  - <img src="/Image/Basics/Special/Async/48.png" style="zoom:50%;" align="left" />
  - extend 中的  bind 返回一个函数，并且传入的方法执行上下文绑定到 thisArg上
  - <img src="/Image/Basics/Special/Async/49.png" style="zoom:50%;" align="left" />



##### 6-3-3-3、createInstance 详解

<img src="/Image/Basics/Special/Async/52.png" style="zoom:50%;" align="left" />

函数返回了一个函数 instance：

- instance 是一个函数 Axios.prototype.request 且执行上下文绑定到 context；
- instance 中含有 Axios.prototype 上面的所有方法，且这些方法的执行上下文也绑定到 context；
- instance 中含有 context 上的方法；



##### 6-3-3-4、Axios 类

<img src="/Image/Basics/Special/Async/53.png" style="zoom:50%;" align="left" />

- Axios 核心即 request 方法，上面所有方法都通过调用了 `this.request` 方法(包含 Promise 的链式调用与中间件思想)

  - <img src="/Image/Basics/Special/Async/54.png" style="zoom:50%;" align="left" />

  - 补充：拦截器用于将请求或响应在 then 或 catch 处理前拦截

  - <img src="/Image/Basics/Special/Async/55.png" style="zoom:50%;" align="left" />

  - 所以：此段代码作用是为 chain 的头尾添加请求拦截器和相应拦截器 

  - <img src="/Image/Basics/Special/Async/56.png" style="zoom:50%;" align="left" />

  - **<u>*最终 chain 是如此结构(重点)*</u>**：

  - ```js
    chain = [ 请求拦截器的成功方法，请求拦截器的失败方法，dispatchRequest， undefined, 响应拦截器的成功方法，响应拦截器的失败方法 ]
    ```

  - 所以，会看此 request 方法，意即将 chain 内的方法两两拿出来执行：

  - <img src="/Image/Basics/Special/Async/57.png" style="zoom:50%;" align="left" />

  - ```js
    promise
    	.then(请求拦截器的成功方法, 请求拦截器的失败方法)           
    	.then(dispatchRequest, undefined)           
    	.then(响应拦截器的成功方法, 响应拦截器的失败方法)
    ```

  - 此外，Axios 实例中，request、response均为拦截器interceptorManager实例，观察知，其作用如字面意义

  - <img src="/Image/Basics/Special/Async/58.png" style="zoom:50%;" align="left" />



##### 6-3-3-5、dispatchRequest 

 chain 数组 dispatchRequest 是发送请求的方法(真正核心)，作用如下：

- 数据转换，转换请求体/响应体，可理解为数据层面的适配；
- 调用适配器

```js
'use strict';
var utils = require('./../utils');
var transformData = require('./transformData');
var isCancel = require('../cancel/isCancel');
var defaults = require('../defaults');
var isAbsoluteURL = require('./../helpers/isAbsoluteURL');
var combineURLs = require('./../helpers/combineURLs');

// 请求取消时候的方法，暂不看
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
}

module.exports = function dispatchRequest(config) {
  throwIfCancellationRequested(config);
  // 请求没有取消 执行下面的请求
  if (config.baseURL && !isAbsoluteURL(config.url)) {
    config.url = combineURLs(config.baseURL, config.url);
  }
  config.headers = config.headers || {};
	// 转换数据
  config.data = transformData(
    config.data,
    config.headers,
    config.transformRequest
  );
  // 合并配置
  config.headers = utils.merge(
    config.headers.common || {},
    config.headers[config.method] || {},
    config.headers || {}
  );
	// 请求方法
  utils.forEach(
    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
    function cleanHeaderConfig(method) {
      delete config.headers[method];
    }
  );
  
  
  // 重点: adapter 获取请求的方式
  var adapter = config.adapter || defaults.adapter;
  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);
		// 拦截到了请求的数据，并转换 data
    response.data = transformData(
      response.data,
      response.headers,
      config.transformResponse
    );
    return response;
  }, function onAdapterRejection(reason) {
      // 失败处理
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = transformData(
          reason.response.data,
          reason.response.headers,
          config.transformResponse
        );
      }
    }

    return Promise.reject(reason);
  });
};
```

留意到 dispatchRequest 返回了 adapter 方法以供 Promise.then 执行，关键：var adapter = config.adapter || defaults.adapter;

```js
// defaults.js
'use strict';

var utils = require('./utils');
var normalizeHeaderName = require('./helpers/normalizeHeaderName');

var DEFAULT_CONTENT_TYPE = {
  'Content-Type': 'application/x-www-form-urlencoded'
};

function setContentTypeIfUnset(headers, value) {
  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
    headers['Content-Type'] = value;
  }
}
// getDefaultAdapter 方法是来获取请求的方式
function getDefaultAdapter() {
  var adapter;
  // process 是 node 环境的全局变量
  if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {
    // 若是 node 环境则通过 node http 的请求方法
    adapter = require('./adapters/http');
  } else if (typeof XMLHttpRequest !== 'undefined') {
   	// 若是浏览器则用 XMLHttpRequest
    adapter = require('./adapters/xhr');
  }
  return adapter;
}

var defaults = {
  // adapter 就是请求的方法
  adapter: getDefaultAdapter(),
	// 下面一些请求头，转换数据，请求，详情的数据
  // 所以直接拿到请求的数据是一个对象，若用 ajax 则拿到的都是 jSON 格式的字符串
  // 然后每次都通过 JSON.stringify（data）来处理结果。
  transformRequest: [function transformRequest(data, headers) {
    normalizeHeaderName(headers, 'Accept');
    normalizeHeaderName(headers, 'Content-Type');
    if (utils.isFormData(data) ||
      utils.isArrayBuffer(data) ||
      utils.isBuffer(data) ||
      utils.isStream(data) ||
      utils.isFile(data) ||
      utils.isBlob(data)
    ) {
      return data;
    }
    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils.isURLSearchParams(data)) {
      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
      return data.toString();
    }
    if (utils.isObject(data)) {
      setContentTypeIfUnset(headers, 'application/json;charset=utf-8');
      return JSON.stringify(data);
    }
    return data;
  }],

  transformResponse: [function transformResponse(data) {
    /*eslint no-param-reassign:0*/
    if (typeof data === 'string') {
      try {
        data = JSON.parse(data);
      } catch (e) { /* Ignore */ }
    }
    return data;
  }],

  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,

  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',

  maxContentLength: -1,

  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  }
};

defaults.headers = {
  common: {
    'Accept': 'application/json, text/plain, */*'
  }
};

utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});

module.exports = defaults;
```

- Axios 还有一些功能：请求的取消，请求超时的处理。这里我没有全部说明；
- Axios 通过在请求中添加 toke 并验证方法，让客户端支持防御 XSRF、[Django CSRF 原理分析](https://blog.csdn.net/u011715678/article/details/48752873)



#### 6-X、Restful 设计理念

基本：Restful 即有意义的URL + 合适的 HTTP 动词；

本质：基于 HTTP 协议对资源的增删改查操作做出定义；

特点：

- 看 Url 即知操作资源是什么；
- 看 Http Method 即知操作动作是什么；
- 看 Http Status Code 即知操作结果是什么；

特征：

<img src="/Image/Basics/Special/Async/59.png" style="zoom:50%;" align="left" />

注意：RESTful 和语言、传输格式无关，设计风格无对错之分，Restful 设计风格亦如此；

注意：RESTful 风格仅规定了 URL 和 HTTP Method 的使用，并无定义 body 中数据格式；

注意：JSON API 开源规范文档描述了如何传递数据的格式；

详看：[细说API – 重新认识RESTful](https://www.toutiao.com/a6646933417105555976/?tt_from=weixin&utm_campaign=client_share&wxshare_count=1&timestamp=1575764720&app=news_article&utm_source=weixin&utm_medium=toutiao_ios&req_id=201912080825200100260772081CBF5063&group_id=6646933417105555976)