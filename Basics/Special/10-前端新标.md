---
typora-root-url: ../../Source
---



### 一、ES6

- `let const`
- `Proxy`
- Set/Map 新数据结构；
- 对象属性同名简写

- `Class&Extend`

- 模块`import`和`export`

- 箭头函数

- 函数默认参数

- `...`扩展运输符允许展开数组(解构赋值)

- 字符串模版

- Promise

- Generator：yield 暂停代码，next 继续执行

  - ```ts
    function* helloWorld() {
      yield 'hello';
      yield 'world';
      return 'ending';
    }
    const generator = helloWorld();
    generator.next()  // { value: 'hello', done: false }
    generator.next()  // { value: 'world', done: false }
    generator.next()  // { value: 'ending', done: true }
    generator.next()  // { value: undefined, done: true }
    ```

- 等等



### 二、ES7

#### 2-1、Array.prototype.includes()

- ES6，String.prototype.includes() 可查询给定字符串是否包含一个字符；
- ES7，Array.prototype.includes() 判断数组是否包含一个指定值，包含返回 true，否则 false；

```js
const arr = [1, 3, 5, 2, '8', NaN, -0]
arr.includes(1) 		// true
arr.includes(1, 2) 	// false 该方法的第二个参数表示搜索的起始位置，默认为0
arr.includes('1') 	// false
arr.includes(NaN) 	// true
arr.includes(+0) 		// true
```

而在此之前，是通过 indexOf 或 find/findIndex 方法来间接判断：

- 前者不够语义化，表达不直观，且内部使用严格相等，对 NaN 会造成误判；

- 后者则可细粒度操作，配合 Object.is 判断 NaN；

```js
// indexOf
if (arr.indexOf(el) !== -1) { // ... }
[NaN].indexOf(NaN)// -1

// find/findIndex
[1, 4, -5, 10].find((n) => n < 0) // -5
[1, 5, 10, 15].findIndex(function(value) { return value > 9; }) // 2
[NaN].findIndex(y => Object.is(NaN, y)) // 0
```



#### 2-2、求幂运算符**

ES7 的指数运算符效果等同于 Math.pow()

```js
console.log(2**10);						// 1024
console.log(Math.pow(2, 10)) 	// 1024
```



### 三、ES8

#### 3-1、Async/Await

Promise 能很好地解决回调地狱问题，但若处理流程复杂，则整段代码将充斥着 then，语义化不明显，代码无法很好地表示执行流程；为此，ES8 引入了async/await，以提供在不阻塞主线程的情况下，使用同步代码实现异步访问资源的能力，使代码逻辑更加清晰；

- await 不可以脱离 async 单独使用；
- await 后面一定是 Promise 对象，否则会自动包装成 Promise；
- async 是一个通过异步执行并隐式返回 Promise 作为结果的函数；

```js
// Ex1
// 使用同步代码的方式来实现, 支持 try-catch 捕获异常
async function foo () {
  try {
    let response1 = await fetch('https://blog.csdn.net/')
    console.log(response1)
    let response2 = await fetch('https://juejin.im/')
    console.log(response2)
  } catch (err) {
    console.error(err)
  }
}
foo()

// Ex2
async function foo () {
  return 'TLP'
}
foo().then(val => {
  console.log(val) // TLP
})
// 等价于
async function foo () {
  return Promise.resolve('浪里行舟')
}
foo().then(val => {
  console.log(val) // 浪里行舟
})
```



#### 3-2、Object.values/Object.entries

- ES5 引入 Object.keys，方法返回一个数组，成员是参数对象自身的(不含继承的)所有可遍历(enumerable)属性的键名；
- ES8 引入跟 Object.keys 配套的 Object.values 和 Object.entries，作为遍历一个对象的补充手段，供for...of循环使用；
  - Object.entries 方法返回一个数组，成员是参数对象自身的(不含继承的)所有可遍历(enumerable)属性的键值对数组；

```js
// Object.keys
const obj = { foo: 'bar', baz: 42 }; Object.keys(obj) 					// ["foo", "baz"]
const obj = { 100: 'a', 2: 'b', 7: 'c' }; Object.keys(obj) 			// ["2", "7", "100"]
// 注意: 若属性名为数值的属性，是按照数值大小，从小到大遍历

// Object.values
const obj = { foo: 'bar', baz: 42 }; Object.values(obj) 				// ["bar", 42]
const obj = { 100: 'a', 2: 'b', 7: 'c' }; Object.values(obj) 		// ["b", "c", "a"]
// 注意: 若属性名为数值的属性，是按照数值大小，从小到大遍历

// Object.entries
const obj = { foo: 'bar', baz: 42 }; Object.entries(obj) 						// [ ["foo", "bar"], ["baz", 42] ]
const obj = { 10: 'xxx', 1: 'yyy', 3: 'zzz' }; Object.entries(obj); // [['1', 'yyy'], ['3', 'zzz'], ['10': 'xxx']]
```



#### 3-3、String padding

ES8 String 新增了两个实例函数 String.prototype.padStart 和 String.prototype.padEnd，允许将空字符串或其他字符串添加到原始字符串的开头或结尾；

- targetLength(必填)：当前字符串需要填充到的目标长度；若此数值小于当前字符串的长度，则返回当前字符串本身；
- padString(可选)：填充字符串；若字符串太长，使填充后的字符串长度超过了目标长度，则只保留最左侧部分，其他部分会被截断，参数缺省值为 ""

```
String.padStart(targetLength,[padString])
'x'.padStart(4, 'ab') // 'abax'
'x'.padEnd(5, 'ab') 	// 'xabab'

// 常用于日期、金额的格式化
'12'.padStart(10, 'YYYY-MM-DD') // "YYYY-MM-12"
'09-12'.padStart(10, 'YYYY-MM-DD') // "YYYY-09-12"
```



#### 3-4、Object.getOwnPropertyDescriptors()

- ES5 的 Object.getOwnPropertyDescriptor()，方法会返回某个对象属性的描述对象(descriptor)；
- ES8 引入 Object.getOwnPropertyDescriptors()，方法返回指定对象所有自身属性(非继承属性)的描述对象；
  - 引入目的：解决 Object.assign() 无法正确拷贝 get/set 属性问题；

```js
const obj = {
  name: "TLP",
  get bar () {
    return 'TLPPP'
  }
}
console.log(Object.getOwnPropertyDescriptor(obj, 'name'))
result = { value: 'TLP',
  writable: true,
  enumerable: true,
  configurable: true }

console.log(Object.getOwnPropertyDescriptors(obj))
result = { name:
  { value: 'TLP',
    writable: true,
    enumerable: true,
    configurable: true },
 bar:
  { get: [Function: get bar],
    set: undefined,
    enumerable: true,
    configurable: true } }

// Object.assign 无法正确拷贝 get/set 方法，其总是拷贝一个属性的值，而不会拷贝它背后的赋值方法或取值方法
const source = {
  set foo(value) {
    console.log(value);
  },
  get bar() {
    return "TLPPP";
  },
};
const target = {};
Object.assign(target, source);
console.log(Object.getOwnPropertyDescriptor(target, "foo"));
result = {
  value: undefined,
  writable: true,
  enumerable: true,
  configurable: true,
};

// 使用 Object.getOwnPropertyDescriptors() 方法配合 Object.defineProperties()方法，实现正确拷贝
const source = {
  set foo(value) {
    console.log(value);
  },
  get bar() {
    return "TLPPP";
  },
};
const target = {};
Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
console.log(Object.getOwnPropertyDescriptor(target, "foo"));
result = { get: undefined,
  set: [Function: set foo],
  enumerable: true,
  configurable: true 
}
```





### 四、ES9

#### 4-1、for await of

ES6 for of 方法能遍历具有 Symbol.iterator 接口的同步迭代器数据，但不能遍历异步迭代器；

ES9 for await of 方法能遍历具有 Symbol.asyncIterator 方法的数据结构，也即异步迭代器，且会等待前一成员状态改变后才会遍历到下一个成员，相当于 async函数内部的 await；

```js
// for of 遍历不能遍历异步迭代器
function Gen(time) {
  return new Promise(function (resolve, reject) {
    setTimeout(function () {
      resolve(time);
    }, time);
  });
}
async function test() {
  let arr = [Gen(2000), Gen(100), Gen(3000)];
  for (let item of arr) {
    console.log(Date.now(), item.then(console.log));
  }
}
test();
// 1598407617108 Promise { <pending> }
// 1598407617117 Promise { <pending> }
// 1598407617118 Promise { <pending> }
// 100
// 2000
// 3000

// for await of 会等待前一个Promise对象的状态改变后，再遍历到下一个成员
function Gen(time) {
  return new Promise(function (resolve, reject) {
    setTimeout(function () {
      resolve(time);
    }, time);
  });
}
async function test() {
  let arr = [Gen(2000), Gen(100), Gen(3000)];
  for await (let item of arr) {
    console.log(Date.now(), item);
  }
}
test();
// 1598407667359 2000
// 1598407667362 100
// 1598407668357 3000
```



#### 4-2、Object Rest Spread

- ES6 spread 操作符，可用它替换 cancat 和 slice 方法，使数组操作(复制/合并/作为函数参数)更简单；
- ES9 通过向对象文本添加扩展属性进一步扩展此种语法，使得可将一对象属性拷贝到另一对象上；
  - 注意：相同属性名，则只有最后一个生效；
  - 注意：这种拷贝属于浅拷贝；
  - 注意：rest 属性必须始终出现在对象的末尾，否则报错；

```js
// Array 解构赋值
const arr1 = [10, 20, 30];
const copy = [...arr1]; 
console.log(copy); // [10, 20, 30] 复制
const arr2 = [40, 50];
const merge = [...arr1, ...arr2]; 
console.log(merge); // [10, 20, 30, 40, 50] 合并
console.log(Math.max(...arr)); // 30 拆解

// Object 解构赋值
const input = {
  a: 1,
  b: 2,
  c: 1,
};
const output = {
  ...input,
  c: 3,
};
console.log(output); // {a: 1, b: 2, c: 3}

// Object 解构赋值
const input = {
  a: 1,
  b: 2,
  c: 3,
};
let { a, ...rest } = input;
console.log(a, rest); // 1 {b: 2, c: 3}
```



#### 4-3、Promise.prototype.finally()

Promise.prototype.finally 方法返回一 Promise，在 promise 执行结束时，无论结果状态如何，在执行then 和 catch 后，都会执行 finally 指定的回调；

- 常用无论结果如何均需执行某些操作的场景，避免同样语句需要在 then 和 catch 中各写一次的情况；

```js
fetch("https://www.google.com")
  .then((response) => {
    console.log(response.status);
  })
  .catch((error) => {
    console.log(error);
  })
  .finally(() => {
    document.querySelector("#spinner").style.display = "none";
  });
```



#### 4-4、新的正则表达式特性

ES9 为正则表达式添加了四个新特性，进一步提高 JS 的字符串处理能力：

##### 4-4-1、s(dotAll)flag

正则表达式中，点（.）是一个特殊字符，代表任意的单个字符，但是有两个例外。一个是四个字节的 UTF-16 字符，这个可以用u修饰符解决；另一个是行终止符,如换行符(\n)或回车符(\r),这个可以通过ES9的s(dotAll)flag，在原正则表达式基础上添加s表示:

```js
console.log(/foo.bar/.test('foo\nbar')) // false
console.log(/foo.bar/s.test('foo\nbar')) // true
```

那如何判断当前正则是否使用了 dotAll 模式呢？

```js
const re = /foo.bar/s // Or, `const re = new RegExp('foo.bar', 's');`.
console.log(re.test('foo\nbar')) // true
console.log(re.dotAll) // true
console.log(re.flags) // 's'
```

##### 4-4-2、命名捕获组

- ES5 在某些场合的纯数字匹配会产生歧义(比如日期匹配)；
- ES9 引入命名捕获组，允许为每一组匹配指定一个名字，既便于阅读代码，又便于引用；
  - 模式的头部添加 "问号 + 尖括号 + 组名"

```js
// ES5
const re = /(\d{4})-(\d{2})-(\d{2})/;
const match= re.exec('2019-01-01');
console.log(match[0]);    // → 2019-01-01
console.log(match[1]);    // → 2019
console.log(match[2]);    // → 01
console.log(match[3]);    // → 01

// ES9
const re = /(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})/;
const match = re.exec('2019-01-01');
console.log(match.groups);          // → {year: "2019", month: "01", day: "01"}
console.log(match.groups.year);     // → 2019
console.log(match.groups.month);    // → 01
console.log(match.groups.day);      // → 01

// + replace 使用
const re = /(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})/
const usDate = '2018-04-30'.replace(re, '$<month>-$<day>-$<year>')
console.log(usDate) // 04-30-2018
```



##### 4-4-3、Lookbehind 后行断言

- ES5 只支持先行断言("先遇到一个条件，再判断后面是否满足")，不支持后行断言；
- ES9 开始支持("先遇到一个条件，再判断前面是否满足")；
  - **<u>*(?<…)是后行断言的符号，(?..)是先行断言的符号*</u>**

```js
// 先行断言
let test = 'hello world'
console.log(test.match(/hello(?=\sworld)/))
// ["hello", index: 0, input: "hello world", groups: undefined]

// 后行断言 - 判断 world 前面是 hello
let test = 'world hello'
console.log(test.match(/(?<=world\s)hello/))
// ["hello", index: 6, input: "world hello", groups: undefined]
```



##### 4-4-4、Unicode属性转义

ES9 引入一种新的类的写法：\p{...} 和 \P{...}，允许正则表达式匹配符合 Unicode 某种属性的所有字符；比如可使用 \p{Number} 来匹配所有 Unicode 数字；

```js
// 匹配的 Unicode 字符㉛字符串
const str = '㉛';
console.log(/\d/u.test(str));    // → false
console.log(/\p{Number}/u.test(str));     // → true

// 使用 \p{Alphabetic} 来匹配所有的 Unicode 单词字符
const str = 'ض';
console.log(/\p{Alphabetic}/u.test(str));     // → true
// the \w shorthand cannot match ض
console.log(/\w/u.test(str));    // → false

// 负向的 Unicode 属性转义模板 \P{...}
console.log(/\P{Number}/u.test('㉛'));    // → false
console.log(/\P{Number}/u.test('ض'));    // → true
console.log(/\P{Alphabetic}/u.test('㉛'));    // → true
console.log(/\P{Alphabetic}/u.test('ض'));    // → false
```



#### 4-5、String.prototype.matchAll

如果一个正则表达式在字符串里面有多个匹配，现在一般使用。

```js
// 过去匹配字符串中的多个匹配项，需要使用 g 修饰符或 y 修饰符，然后在循环里面逐一取出，否则只返回第一个匹配
function collectGroup1 (regExp, str) {
  const matches = []
  while (true) {
    const match = regExp.exec(str)
    if (match === null) break
    matches.push(match[1])
  }
  return matches
}
console.log(collectGroup1(/"([^"]*)"/g, `"foo" and "bar" and "baz"`))
// [ 'foo', 'bar', 'baz' ]

// 通过 ES9 的 String.prototype.matchAll 方法，可一次性取出所有匹配，且由于 string.matchAll(regex) 返回的是遍历器，所以可用 for..of 循环取出
function collectGroup1 (regExp, str) {
  let results = []
  for (const match of str.matchAll(regExp)) {
    results.push(match[1])
  }
  return results
}
console.log(collectGroup1(/"([^"]*)"/g, `"foo" and "bar" and "baz"`))
// ["foo", "bar", "baz"]
```



### 五、ES10

#### 5-1、Array.prototype.flat&flatMap()

ES10 flat() 方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回，多用于打平多维数组；

- newArray = arr.flat(depth) depth是指定要提取嵌套数组的结构深度，默认值为 1	

ES10 flatMap() 方法首先使用映射函数映射每个元素，然后将结果压缩成一个新数组；

- 注意：flatMap 实际上是综合了 map 和 flat 操作，它只能打平一层；

```js
// flat
const numbers1 = [1, 2, [3, 4, [5, 6]]]
console.log(numbers1.flat())	// [1, 2, 3, 4, [5, 6]]
const numbers2 = [1, 2, [3, 4, [5, 6]]]
console.log(numbers2.flat(2))	// [1, 2, 3, 4, 5, 6]

// flatMap
let arr = [1, 2, 3]
console.log(arr.map(item => [item * 2]).flat()) // [2, 4, 6]
console.log(arr.flatMap(item => [item * 2])) 		// [2, 4, 6]
```





#### 5-2、Object.fromEntries()

ES8 Object.entries 方法可将对象转换为数组，从而使用数组原型诸多内置方法；

ES10 Object.fromEntries 实现了与 Object.entries 相反的操作：根据对象的 entries 得到 object；

```js
const object = { x: 23, y:24 };
const entries = Object.entries(object); // [['x', 23], ['y', 24]]
const result = Object.fromEntries(entries); // { x: 23, y: 24 }

// 要求: 提取 obj 中所有 value 大于 21 的键值对
// ES10之前
const obj = {
  a: 21,
  b: 22,
  c: 23,
};
console.log(Object.entries(obj)); // [['a',21],["b", 22],["c", 23]]
let arr = Object.entries(obj).filter(([a, b]) => b > 21); // [["b", 22],["c", 23]]
let obj1 = {};
for (let [name, age] of arr) {
  obj1[name] = age;
}
console.log(obj1); // {b: 22, c: 23}


// Object.fromEntries() 实现
const obj = {
  a: 21,
  b: 22,
  c: 23
}
let res = Object.fromEntries(Object.entries(obj).filter(([a, b]) => b > 21))
console.log(111, res) // {b: 22, c: 23}
```



#### 5-3、String.trimStart 和 String.trimEnd

ES10 新增，便于移除开头和结尾的空格；

```js
// trimStart() 方法从字符串的开头删除空格
var str = " TLP ";
console.log(str.length); // 5
str = str.trimStart();
console.log(str.length); // 4
var str1 = str.trim(); // 清除前后的空格
console.log(str1.length); // 3
str.replace(/^\s+/g, ""); // 也可用正则实现开头删除空格

// trimEnd() 方法从一个字符串的右端移除空白字符
var str = " TLP ";
console.log(str.length); // 5
str = str.trimEnd();
console.log(str.length); // 4
var str1 = str.trim(); // 清除前后的空格
console.log(str1.length); // 3
str.replace(/\s+$/g, ""); // 也可用正则实现右端移除空白字符
```



#### 5-4、try…catch

ES10中，try-catch 语句中的参数变为一可选项，过去是必须传递此异常参数的；

```js
// ES10 之前
try {
  // tryCode
} catch (err) {
  // catchCode
}

// ES10
try {
  console.log('Foobar')
} catch {
  console.error('Bar')
}
```



#### 5-5、BigInt

JS所有数字都保存成 64 位浮点数，给数值表示带来两大限制：

- 数值的精度只能到 53 个二进制位(相当于 16 个十进制位)，大于此范围的整数，JS 无法精确表示，使其不适合进行科学和金融方面的精确计算；
- 大于或等于 2 的 1024 次方的数值，JS 无法表示，会返回 Infinity；

```js
// 超过 53 个二进制位的数值，无法保持精度
Math.pow(2, 53) === Math.pow(2, 53) + 1 // true
// 超过 2 的 1024 次方的数值，无法表示
Math.pow(2, 1024) // Infinity
```

ES10 引入新型数据类型 BigInt 来解决这个问题，BigInt 只用来表示整数，没有位数限制，任何位数的整数都可精确表示；

- 只需要在数字后面加上 n 即可创建 BigInt 类型的值、也可使用全局方法 BigInt(value) 转化，入参 value 为数字/数字字符串；

```js
const aNumber = 111;
const aBigInt = BigInt(aNumber);
aBigInt === 111n // true
typeof aBigInt === 'bigint' // true
typeof 111 // "number"
typeof 111n // "bigint"
```

算上 BigInt，JS 中原始类型就从 6 个变为了 7 个：

- Boolean、Null、Undefined、Number、String、Symbol (new in ECMAScript 2015)、BigInt (new in ECMAScript 2019)



#### 5-6、Symbol.prototype.description

Symbol 描述只被存储在内部的 [[Description]]，无直接对外暴露，只有调用 Symbol 的 toString() 时才可读取这个属性：

```js
Symbol('desc').description;  // "desc"
Symbol('').description;      // ""
Symbol().description;        // undefined
```



#### 5-7、Function.prototype.toString()

ES10，Function.toString() 获取的字符串呈现出原本源码的样子，过去是得到空白符；

```js
function sum(a, b) {
  return a + b;
}
console.log(sum.toString());
// function sum(a, b) {
//  return a + b;
// }
```




参考：[浪里行舟](https://juejin.im/post/6844904018834096142)