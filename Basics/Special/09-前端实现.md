---
typora-root-url: ../../Source
---



### 一、数组相关

右移操作，将前面的空位用0填充，可用于保证某变量为数字且为整数

```js
null >>> 0  //0

undefined >>> 0  //0

void(0) >>> 0  //0

function a (){};  a >>> 0  //0

[] >>> 0  //0

var a = {}; a >>> 0  //0

123123 >>> 0  //123123

45.2 >>> 0  //45

0 >>> 0  //0

-0 >>> 0  //0

-1 >>> 0  //4294967295

-1212 >>> 0  //4294966084
```



#### 1-1、map

<img src="/Image/Basics/Special/API/1.png" style="zoom:50%;" align="left" />

```js
// 关键：使用 in 来进行原型链查找。同时，如果没有找到就不处理，能有效处理稀疏数组的情况
Array.prototype.map = function(callbackFn, thisArg) {
  // 处理数组类型异常
  if (this === null || this === undefined) {
    throw new TypeError("Cannot read property 'map' of null or undefined");
  }
  // 处理回调类型异常
  if (Object.prototype.toString.call(callbackfn) != "[object Function]") {
    throw new TypeError(callbackfn + ' is not a function')
  }
  // 草案中提到要先转换为对象
  let O = Object(this);
  let T = thisArg;

  
  let len = O.length >>> 0;
  let A = new Array(len);
  for(let k = 0; k < len; k++) {
    // 还记得原型链那一节提到的 in 吗？in 表示在原型链查找
    // 如果用 hasOwnProperty 是有问题的，它只能找私有属性
    if (k in O) {
      let kValue = O[k];
      // 依次传入this, 当前项，当前索引，整个数组
      let mappedValue = callbackfn.call(T, KValue, k, O);
      A[k] = mappedValue;
    }
  }
  return A;
}


// V8 实现
function ArrayMap(f, receiver) {
  CHECK_OBJECT_COERCIBLE(this, "Array.prototype.map");

  // Pull out the length so that modifications to the length in the
  // loop will not affect the looping and side effects are visible.
  var array = TO_OBJECT(this);
  var length = TO_LENGTH(array.length);
  if (!IS_CALLABLE(f)) throw %make_type_error(kCalledNonCallable, f);
  var result = ArraySpeciesCreate(array, length);
  for (var i = 0; i < length; i++) {
    if (i in array) {
      var element = array[i];
      %CreateDataProperty(result, i, %_Call(f, receiver, element, i, array));
    }
  }
  return result;
}
```



#### 1-2、reduce

<img src="/Image/Basics/Special/API/2.png" style="zoom:50%;" align="left" />

```js
// 关键：初始值不传怎么处理、回调函数的参数有哪些，返回值如何处理；
// 关键：从最后一项开始遍历，通过原型链查找跳过空项
Array.prototype.reduce  = function(callbackfn, initialValue) {
  // 异常处理，和 map 一样
  // 处理数组类型异常
  if (this === null || this === undefined) {
    throw new TypeError("Cannot read property 'reduce' of null or undefined");
  }
  // 处理回调类型异常
  if (Object.prototype.toString.call(callbackfn) != "[object Function]") {
    throw new TypeError(callbackfn + ' is not a function')
  }
  let O = Object(this);
  let len = O.length >>> 0;
  let k = 0;
  let accumulator = initialValue;
  if (accumulator === undefined) {
    for(; k < len ; k++) {
      // 查找原型链
      if (k in O) {
        accumulator = O[k];
        k++;
        break;
      }
    }
  }
  // 表示数组全为空
  if(k === len && accumulator === undefined) 
    throw new Error('Each element of the array is empty');
  for(;k < len; k++) {
    if (k in O) {
      // 注意，核心！
      accumulator = callbackfn.call(undefined, accumulator, O[k], k, O);
    }
  }
  return accumulator;
}

// 实现2
Array.prototype.myreduce = function reduce(callbackfn) {
  // 拿到数组
  const O = this,
    len = O.length;
  // 下标值
  let k = 0,
    // 累加器
    accumulator = undefined,
    // k下标对应的值是否存在
    kPresent = false,
    // 初始值
    initialValue = arguments.length > 1 ? arguments[1] : undefined;

  if (typeof callbackfn !== 'function') {
    throw new TypeError(callbackfn + ' is not a function');
  }

  // 数组为空，并且有初始值，报错
  if (len === 0 && arguments.length < 2) {
    throw new TypeError('Reduce of empty array with no initial value');
  }
  // 如果初始值存在
  if (arguments.length > 1) {
    // 设置累加器为初始值
    accumulator = initialValue;
    // 初始值不存在
  } else {
    accumulator = O[k];
    ++k;
  }

  while (k < len) {
    // 判断是否为 empty [,,,]
    kPresent = O.hasOwnProperty(k);

    if (kPresent) {
      const kValue = O[k];
      // 调用 callbackfn
      accumulator = callbackfn.apply(undefined, [accumulator, kValue, k, O]);
    }
    ++k;
  }
  return accumulator;
};



// 测试
const rReduce = ['1', null, undefined, , 3, 4].reduce((a, b) => a + b, 3);
const mReduce = ['1', null, undefined, , 3, 4].myreduce((a, b) => a + b, 3);
console.log(rReduce, mReduce);
// 31nullundefined34 31nullundefined34



// V8 实现
function ArrayReduce(callback, current) {
  CHECK_OBJECT_COERCIBLE(this, "Array.prototype.reduce");

  // Pull out the length so that modifications to the length in the
  // loop will not affect the looping and side effects are visible.
  var array = TO_OBJECT(this);
  var length = TO_LENGTH(array.length);
  return InnerArrayReduce(callback, current, array, length,
                          arguments.length);
}

function InnerArrayReduce(callback, current, array, length, argumentsLength) {
  if (!IS_CALLABLE(callback)) {
    throw %make_type_error(kCalledNonCallable, callback);
  }

  var i = 0;
  find_initial：if (argumentsLength < 2) {
    for (; i < length; i++) {
      if (i in array) {
        current = array[i++];
        break find_initial;
      }
    }
    throw %make_type_error(kReduceNoInitial);
  }

  for (; i < length; i++) {
    if (i in array) {
      var element = array[i];
      current = callback(current, element, i, array);
    }
  }
  return current;
}
```



#### 1-3、push/pop

<img src="/Image/Basics/Special/API/3.png" style="zoom:50%;" align="left" />

```js
// push
Array.prototype.push = function(...items) {
  let O = Object(this);
  let len = this.length >>> 0;
  let argCount = items.length >>> 0;
  // 2 ** 53 - 1 为JS能表示的最大正整数
  if (len + argCount > 2 ** 53 - 1) {
    throw new TypeError("The number of array is over the max value restricted!")
  }
  for(let i = 0; i < argCount; i++) {
    O[len + i] = items[i];
  }
  let newLength = len + argCount;
  O.length = newLength;
  return newLength;
}

// pop
Array.prototype.pop = function() {
  let O = Object(this);
  let len = this.length >>> 0;
  if (len === 0) {
    O.length = 0;
    return undefined;
  }
  len --;
  let value = O[len];
  delete O[len];
  O.length = len;
  return value;
}
```



#### 1-4、filter

<img src="/Image/Basics/Special/API/4.png" style="zoom:50%;" align="left" />

```js
Array.prototype.filter = function(callbackfn, thisArg) {
  // 处理数组类型异常
  if (this === null || this === undefined) {
    throw new TypeError("Cannot read property 'filter' of null or undefined");
  }
  // 处理回调类型异常
  if (Object.prototype.toString.call(callbackfn) != "[object Function]") {
    throw new TypeError(callbackfn + ' is not a function')
  }
  let O = Object(this);
  let len = O.length >>> 0;
  let resLen = 0;
  let res = [];
  for(let i = 0; i < len; i++) {
    if (i in O) {
      let element = O[i];
      if (callbackfn.call(thisArg, O[i], i, O)) {
        res[resLen++] = element;
      }
    }
  }
  return res;
}
```



#### 1-5、splice

- splice(position, count) 表示从 position 索引的位置开始，删除count个元素
- splice(position, 0, ele1, ele2, ...) 表示从 position 索引的元素后面插入一系列的元素
- splice(postion, count, ele1, ele2, ...) 表示从 position 索引的位置开始，删除 count 个元素，然后再插入一系列的元素
- 返回值为`被删除元素`组成的`数组`。

<img src="/Image/Basics/Special/API/5.png" style="zoom:50%;" align="left" />

##### 1-5-1、基本骨架

```js
Array.prototype.splice = function(startIndex, deleteCount, ...addElements)  {
  let argumentsLen = arguments.length;
  let array = Object(this);
  let len = array.length;
  let deleteArr = new Array(deleteCount);
   
  // 1-2、拷贝删除的元素
  sliceDeleteElements(array, startIndex, deleteCount, deleteArr);
  // 1-3、移动删除元素后面的元素
  movePostElements(array, startIndex, len, deleteCount, addElements);
  // 插入新元素
  for (let i = 0; i < addElements.length; i++) {
    array[startIndex + i] = addElements[i];
  }
  array.length = len - deleteCount + addElements.length;
  return deleteArr;
}

// 1-2、拷贝删除的元素实现
const sliceDeleteElements = (array, startIndex, deleteCount, deleteArr) => {
  for (let i = 0; i < deleteCount; i++) {
    let index = startIndex + i;
    if (index in array) {
      let current = array[index];
      deleteArr[i] = current;
    }
  }
};
```

##### 1-5-2、移动删除元素后的元素

对删除元素后面的元素进行挪动, 挪动分为三种情况:

- 添加的元素和删除的元素个数相等

  - ```js
    // 1-3、移动删除元素后面的元素
    const movePostElements = (array, startIndex, len, deleteCount, addElements) => {
      // 1-3-1、添加的元素和删除的元素个数相等
      if (deleteCount === addElements.length) return;
    }
    ```

- 添加的元素个数小于删除的元素

  - <img src="/Image/Basics/Special/API/6.png" style="zoom:35%;" align="left" />

  - ```js
    // 1-3、移动删除元素后面的元素
    const movePostElements = (array, startIndex, len, deleteCount, addElements) => {
      //...
      // 1-3-1、添加的元素和删除的元素个数相等
      // 1-3-2、添加的元素个数小于删除的元素
      // 添加的元素和删除的元素个数不相等，则移动后面的元素
      if(deleteCount > addElements.length) {
        // 删除的元素比新增的元素多，那么后面的元素整体向前挪动
        // 一共需要挪动 len - startIndex - deleteCount 个元素
        for (let i = startIndex + deleteCount; i < len; i++) {
          let fromIndex = i;
          // 将要挪动到的目标位置
          let toIndex = i - (deleteCount - addElements.length);
          if (fromIndex in array) {
            array[toIndex] = array[fromIndex];
          } else {
            delete array[toIndex];
          }
        }
        // 注意注意！这里我们把后面的元素向前挪，相当于数组长度减小了，需要删除冗余元素
        // 目前长度为 len + addElements - deleteCount
        for (let i = len - 1; i >= len + addElements.length - deleteCount; i --) {
          delete array[i];
        }
      } 
    };
    ```

- 添加的元素个数大于删除的元素

  - <img src="/Image/Basics/Special/API/7.png" style="zoom:35%;" align="left" />

  - ```js
    // 1-3、移动删除元素后面的元素
    const movePostElements = (array, startIndex, len, deleteCount, addElements) => {
      //...
      // 1-3-1、添加的元素和删除的元素个数相等
      // 1-3-2、添加的元素个数小于删除的元素
      // 1-3-3、添加的元素个数大于删除的元素
      if(deleteCount < addElements.length) {
        // 删除的元素比新增的元素少，那么后面的元素整体向后挪动
        // 思考一下: 这里为什么要从后往前遍历？从前往后会产生什么问题？
        for (let i = len - 1; i >= startIndex + deleteCount; i--) {
          let fromIndex = i;
          // 将要挪动到的目标位置
          let toIndex = i + (addElements.length - deleteCount);
          if (fromIndex in array) {
            array[toIndex] = array[fromIndex];
          } else {
            delete array[toIndex];
          }
        }
      }
    };
    ```

##### 1-5-3、优化参数边界情况

当用户传来非法的 startIndex 和 deleteCount 或者负索引的时候，需要我们做出特殊的处理。

```js
const computeStartIndex = (startIndex, len) => {
  // 处理索引负数的情况
  if (startIndex < 0) {
    return startIndex + len > 0 ? startIndex + len: 0;
  } 
  return startIndex >= len ? len: startIndex;
}

const computeDeleteCount = (startIndex, len, deleteCount, argumentsLen) => {
  // 删除数目没有传，默认删除startIndex及后面所有的
  if (argumentsLen === 1) 
    return len - startIndex;
  // 删除数目过小
  if (deleteCount < 0) 
    return 0;
  // 删除数目过大
  if (deleteCount > len - startIndex) 
    return len - startIndex;
  return deleteCount;
}

Array.prototype.splice = function (startIndex, deleteCount, ...addElements) {
  //,...
  let deleteArr = new Array(deleteCount);
  
  // 下面参数的清洗工作
  startIndex = computeStartIndex(startIndex, len);
  deleteCount = computeDeleteCount(startIndex, len, deleteCount, argumentsLen);
   
  // 拷贝删除的元素
  sliceDeleteElements(array, startIndex, deleteCount, deleteArr);
  //...
}
```

##### 1-5-4、优化密封对象/冻结对象情况

- 密封对象：不可扩展对象，且已有成员的 [[Configurable]] 属性被设置 false，意味着无法添加、删除方法和属性；但属性值可修改；
- 冻结对象：最严格的防篡改级别，除了包含密封对象的限制外，还不能修改属性值；

```js
// 判断 sealed 对象和 frozen 对象, 即 密封对象 和 冻结对象
if (Object.isSealed(array) && deleteCount !== addElements.length) {
  throw new TypeError('the object is a sealed object!')
} else if(Object.isFrozen(array) && (deleteCount > 0 || addElements.length > 0)) {
  throw new TypeError('the object is a frozen object!')
}
```

##### 1-5-5、完整实现

```js
const sliceDeleteElements = (array, startIndex, deleteCount, deleteArr) => {
  for (let i = 0; i < deleteCount; i++) {
    let index = startIndex + i;
    if (index in array) {
      let current = array[index];
      deleteArr[i] = current;
    }
  }
};

const movePostElements = (array, startIndex, len, deleteCount, addElements) => {
  // 如果添加的元素和删除的元素个数相等，相当于元素的替换，数组长度不变，被删除元素后面的元素不需要挪动
  if (deleteCount === addElements.length) return;
  // 如果添加的元素和删除的元素个数不相等，则移动后面的元素
  else if(deleteCount > addElements.length) {
    // 删除的元素比新增的元素多，那么后面的元素整体向前挪动
    // 一共需要挪动 len - startIndex - deleteCount 个元素
    for (let i = startIndex + deleteCount; i < len; i++) {
      let fromIndex = i;
      // 将要挪动到的目标位置
      let toIndex = i - (deleteCount - addElements.length);
      if (fromIndex in array) {
        array[toIndex] = array[fromIndex];
      } else {
        delete array[toIndex];
      }
    }
    // 注意注意！这里我们把后面的元素向前挪，相当于数组长度减小了，需要删除冗余元素
    // 目前长度为 len + addElements - deleteCount
    for (let i = len - 1; i >= len + addElements.length - deleteCount; i --) {
      delete array[i];
    }
  } else if(deleteCount < addElements.length) {
    // 删除的元素比新增的元素少，那么后面的元素整体向后挪动
    // 思考一下: 这里为什么要从后往前遍历？从前往后会产生什么问题？
    for (let i = len - 1; i >= startIndex + deleteCount; i--) {
      let fromIndex = i;
      // 将要挪动到的目标位置
      let toIndex = i + (addElements.length - deleteCount);
      if (fromIndex in array) {
        array[toIndex] = array[fromIndex];
      } else {
        delete array[toIndex];
      }
    }
  }
};

const computeStartIndex = (startIndex, len) => {
  // 处理索引负数的情况
  if (startIndex < 0) {
    return startIndex + len > 0 ? startIndex + len: 0;
  } 
  return startIndex >= len ? len: startIndex;
}

const computeDeleteCount = (startIndex, len, deleteCount, argumentsLen) => {
  // 删除数目没有传，默认删除startIndex及后面所有的
  if (argumentsLen === 1) 
    return len - startIndex;
  // 删除数目过小
  if (deleteCount < 0) 
    return 0;
  // 删除数目过大
  if (deleteCount > len - startIndex) 
    return len - startIndex;
  return deleteCount;
}

Array.prototype.splice = function(startIndex, deleteCount, ...addElements)  {
  let argumentsLen = arguments.length;
  let array = Object(this);
  let len = array.length >>> 0;
  let deleteArr = new Array(deleteCount);

  startIndex = computeStartIndex(startIndex, len);
  deleteCount = computeDeleteCount(startIndex, len, deleteCount, argumentsLen);

  // 判断 sealed 对象和 frozen 对象, 即 密封对象 和 冻结对象
  if (Object.isSealed(array) && deleteCount !== addElements.length) {
    throw new TypeError('the object is a sealed object!')
  } else if(Object.isFrozen(array) && (deleteCount > 0 || addElements.length > 0)) {
    throw new TypeError('the object is a frozen object!')
  }
   
  // 拷贝删除的元素
  sliceDeleteElements(array, startIndex, deleteCount, deleteArr);
  // 移动删除元素后面的元素
  movePostElements(array, startIndex, len, deleteCount, addElements);

  // 插入新元素
  for (let i = 0; i < addElements.length; i++) {
    array[startIndex + i] = addElements[i];
  }

  array.length = len - deleteCount + addElements.length;

  return deleteArr;
}
```



#### 1-6、sort

##### 1-6-1、V8 实现思路

V8 源码中排序的思路：假设要排序的元素个数是 n：

- 当 n <= 10 时，采用 **<u>插入排序</u>**；
- 当 n > 10 时，采用 **<u>三路快速排序</u>**：
  - 10 < n <= 1000，<u>采用中位数作为哨兵元素</u>；
  - n > 1000，每隔 200~215 个元素挑出一个元素，放到一个新数组，然后对它排序，找到中间位置的数，以此作为中位数

- 注意：虽 <u>插入排序</u> 理论上是 O(n^2) 算法，<u>快速排序</u> 是 O(nlogn) 级算法；但实际情况中，当 n 越小，快排优势会越来越小，若 n 足够小，插入甚至会比快排高效；因此，对于很小的数据量，V8 应用的是 插入排序；
- 注意：费力选择哨兵元素的原因是避免快排效率退化：快排性能瓶颈在于递归的深度，最坏的情况是每次的哨兵都是最小元素或最大元素，此时进行 partition时(一边是小于哨兵的元素，另一边是大于哨兵的元素)，就会有一边是空的，如此下去，递归层数就达到 n 次，而每一层的复杂度是 O(n)，因此快排此时会退化成 O(n^2) 级别；
- 所以：让哨兵元素尽可能地处于数组中间位置，让最大或最小的情况尽可能减少；所以 V8 才做了如此多的优化；

##### 1-6-2、插入排序及优化

```js
// 插入排序
const insertSort = (arr, start = 0, end) => {
  end = end || arr.length;
  for(let i = start; i < end; i++) {
    let j;
    for(j = i; j > start && arr[j - 1] > arr[j]; j --) {
      let temp = arr[j];
      arr[j] = arr[j - 1];
      arr[j - 1] = temp;
    }
  }
  return;
}

// 交换元素会有相当大的性能消耗，可用变量覆盖的方式代替

// 排序优化
const insertSort = (arr, start = 0, end) => {
  end = end || arr.length;
  for(let i = start; i < end; i++) {
    let e = arr[i];
    let j;
    for(j = i; j > start && arr[j - 1] > e; j --)
      arr[j] = arr[j-1];
    arr[j] = e;
  }
  return;
}
```



##### 1-6-3、哨兵元素

```js
// sort 基本骨架
Array.prototype.sort = (comparefn) => {
  let array = Object(this);
  let length = array.length >>> 0;
  return InnerArraySort(array, length, comparefn);
}

const InnerArraySort = (array, length, comparefn) => {
  // 比较函数未传入
  if (Object.prototype.toString.call(callbackfn) !== "[object Function]") {
    comparefn = function (x, y) {
      if (x === y) return 0;
      x = x.toString();
      y = y.toString();
      if (x == y) return 0;
      else return x < y ? -1 : 1;
    };
  }
  const insertSort = () => {
    //...
  }
  const getThirdIndex = (a, from, to) => {
    // 元素个数大于1000时寻找哨兵元素
  }
  const quickSort = (a, from, to) => {
    //哨兵位置
    let thirdIndex = 0;
    while(true) {
      if(to - from <= 10) {
        insertSort(a, from, to);
        return;
      }
      if(to - from > 1000) {
        thirdIndex = getThirdIndex(a, from , to);
      }else {
        // 小于1000 直接取中点
        thirdIndex = from + ((to - from) >> 2);
      }
    }
    //下面开始快排
  }
}

// 哨兵位置寻找实现
const getThirdIndex = (a, from, to) => {
  let tmpArr = [];
  // 递增量，200~215 之间，因为任何正数和15做与操作，不会超过15，当然是大于0的
  let increment = 200 + ((to - from) & 15);
  let j = 0;
  from += 1;
  to -= 1;
  for (let i = from; i < to; i += increment) {
    tmpArr[j] = [i, a[i]];
    j++;
  }
  // 把临时数组排序，取中间的值，确保哨兵的值接近平均位置
  tmpArr.sort(function(a, b) {
    return comparefn(a[1], b[1]);
  });
  let thirdIndex = tmpArr[tmpArr.length >> 1][0];
  return thirdIndex;
}
```



##### 1-6-4、快速排序

```js
const _sort = (a, b, c) => {
  let arr = [a, b, c];
  insertSort(arr, 0, 3);
  return arr;
}

const quickSort = (a, from, to) => {
  //...
  // 上面我们拿到了thirdIndex
  // 现在我们拥有三个元素，from, thirdIndex, to
  // 为了再次确保 thirdIndex 不是最值，把这三个值排序
  [a[from], a[thirdIndex], a[to - 1]] = _sort(a[from], a[thirdIndex], a[to - 1]);
  // 现在正式把 thirdIndex 作为哨兵
  let pivot = a[thirdIndex];
  // 正式进入快排
  let lowEnd = from + 1;
  let highStart = to - 1;
  // 现在正式把 thirdIndex 作为哨兵, 并且lowEnd和thirdIndex交换
  let pivot = a[thirdIndex];
  a[thirdIndex] = a[lowEnd];
  a[lowEnd] = pivot;
  
  // [lowEnd, i)的元素是和pivot相等的
  // [i, highStart) 的元素是需要处理的
  for(let i = lowEnd + 1; i < highStart; i++) {
    let element = a[i];
    let order = comparefn(element, pivot);
    if (order < 0) {
      a[i] = a[lowEnd];
      a[lowEnd] = element;
      lowEnd++;
    } else if(order > 0) {
      do{
        highStart--;
        if(highStart === i) break;
        order = comparefn(a[highStart], pivot);
      }while(order > 0)
      // 现在 a[highStart] <= pivot
      // a[i] > pivot
      // 两者交换
      a[i] = a[highStart];
      a[highStart] = element;
      if(order < 0) {
        // a[i] 和 a[lowEnd] 交换
        element = a[i];
        a[i] = a[lowEnd];
        a[lowEnd] = element;
        lowEnd++;
      }
    }
  }
  // 永远切分大区间
  if (lowEnd - from > to - highStart) {
    // 继续切分lowEnd ~ from 这个区间
    to = lowEnd;
    // 单独处理小区间
    quickSort(a, highStart, to);
  } else if(lowEnd - from <= to - highStart) {
    from = highStart;
    quickSort(a, from, lowEnd);
  }
}
```



##### 1-6-5、完整实现

```js
const sort = (arr, comparefn) => {
  let array = Object(arr);
  let length = array.length >>> 0;
  return InnerArraySort(array, length, comparefn);
}

const InnerArraySort = (array, length, comparefn) => {
  // 比较函数未传入
  if (Object.prototype.toString.call(comparefn) !== "[object Function]") {
    comparefn = function (x, y) {
      if (x === y) return 0;
      x = x.toString();
      y = y.toString();
      if (x == y) return 0;
      else return x < y ? -1 : 1;
    };
  }
  const insertSort = (arr, start = 0, end) => {
    end = end || arr.length;
    for (let i = start; i < end; i++) {
      let e = arr[i];
      let j;
      for (j = i; j > start && comparefn(arr[j - 1], e) > 0; j--)
        arr[j] = arr[j - 1];
      arr[j] = e;
    }
    return;
  }
  const getThirdIndex = (a, from, to) => {
    let tmpArr = [];
    // 递增量，200~215 之间，因为任何正数和15做与操作，不会超过15，当然是大于0的
    let increment = 200 + ((to - from) & 15);
    let j = 0;
    from += 1;
    to -= 1;
    for (let i = from; i < to; i += increment) {
      tmpArr[j] = [i, a[i]];
      j++;
    }
    // 把临时数组排序，取中间的值，确保哨兵的值接近平均位置
    tmpArr.sort(function (a, b) {
      return comparefn(a[1], b[1]);
    });
    let thirdIndex = tmpArr[tmpArr.length >> 1][0];
    return thirdIndex;
  };

  const _sort = (a, b, c) => {
    let arr = [];
    arr.push(a, b, c);
    insertSort(arr, 0, 3);
    return arr;
  }

  const quickSort = (a, from, to) => {
    //哨兵位置
    let thirdIndex = 0;
    while (true) {
      if (to - from <= 10) {
        insertSort(a, from, to);
        return;
      }
      if (to - from > 1000) {
        thirdIndex = getThirdIndex(a, from, to);
      } else {
        // 小于1000 直接取中点
        thirdIndex = from + ((to - from) >> 2);
      }
      let tmpArr = _sort(a[from], a[thirdIndex], a[to - 1]);
      a[from] = tmpArr[0]; a[thirdIndex] = tmpArr[1]; a[to - 1] = tmpArr[2];
      // 现在正式把 thirdIndex 作为哨兵
      let pivot = a[thirdIndex];
      [a[from], a[thirdIndex]] = [a[thirdIndex], a[from]];
      // 正式进入快排
      let lowEnd = from + 1;
      let highStart = to - 1;
      a[thirdIndex] = a[lowEnd];
      a[lowEnd] = pivot;
      // [lowEnd, i)的元素是和pivot相等的
      // [i, highStart) 的元素是需要处理的
      for (let i = lowEnd + 1; i < highStart; i++) {
        let element = a[i];
        let order = comparefn(element, pivot);
        if (order < 0) {
          a[i] = a[lowEnd];
          a[lowEnd] = element;
          lowEnd++;
        } else if (order > 0) {
          do{
            highStart--;
            if (highStart === i) break;
            order = comparefn(a[highStart], pivot);
          }while (order > 0) ;
          // 现在 a[highStart] <= pivot
          // a[i] > pivot
          // 两者交换
          a[i] = a[highStart];
          a[highStart] = element;
          if (order < 0) {
            // a[i] 和 a[lowEnd] 交换
            element = a[i];
            a[i] = a[lowEnd];
            a[lowEnd] = element;
            lowEnd++;
          }
        }
      }
      // 永远切分大区间
      if (lowEnd - from > to - highStart) {
        // 单独处理小区间
        quickSort(a, highStart, to);
        // 继续切分lowEnd ~ from 这个区间
        to = lowEnd;
      } else if (lowEnd - from <= to - highStart) {
        quickSort(a, from, lowEnd);
        from = highStart;
      }
    }
  }
  quickSort(array, 0, length);
}
```

<img src="/Image/Basics/Special/API/8.png" style="zoom:50%;" align="left"/>

<img src="/Image/Basics/Special/API/9.png" style="zoom:50%;" align="left"/>

<img src="/Image/Basics/Special/API/10.png" style="zoom:50%;" align="left"/>

<img src="/Image/Basics/Special/API/11.png" style="zoom:50%;" align="left"/>



#### 1-7、findIndex

1. `findIndex`方法对数组中的每个数组索引`0..length-1`（包括）执行一次`callback`函数，直到找到一个`callback`函数返回真实值（强制为`true`）的值。
2. 如果找到这样的元素，`findIndex`会立即返回该元素的索引。
3. 如果回调从不返回真值，或者数组的`length`为0，则`findIndex`返回-1。
4. 回调函数调用时有三个参数：元素的值，元素的索引，以及被遍历的数组。
5. 如果一个 `thisArg` 参数被提供给 `findIndex`, 它将会被当作`this`使用在每次回调函数被调用的时候。如果没有被提供，将会使用[`undefined`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined)。
6. `findIndex`不会修改所调用的数组。

```js
Array.prototype.myFindIndex = function (cb, context = undefined) {
  if (typeof cb !== 'function') {
    throw new TypeError('cb must be a function');
  }
  var arr = [].slice.call(this);
  var len = arr.length >>> 0;
  let i = 0;
  while (i < len) {
    if (cb.call(context, arr[i], i, arr)) {
      return i;
    }
    i++;
  }
  return -1;
}
function isEven (num) {
  return num % 2 === 0;
}
console.log([3, 4, 5].myFindIndex(isEven)) // 1

// Else
// https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex
```











### 二、常用 API 相关

#### 2-1、instance of

原理：`L` 的 `__proto__`  是不是等于 `R.prototype` ，不等于再找 `L.__proto__.__proto__` 直到 `__proto__` 为 `null`

- 在 `left` 的原型链中层层查找，是否有原型等于 `prototype；`
- 确定边界条件，如果 `left === null`，即找到头没找到返回 `false`，`right === left`，即找到返回 `true；`
- `left = left.__proto__`，不停的向上查找；

```js
// 实现1
function myInstanceof(left, right) {
    // 基本数据类型直接返回 false
    if(typeof left !== 'object' || left === null) return false;
    // getProtypeOf 是 Object 对象自带的一个方法，能够拿到参数的原型对象
    let proto = Object.getPrototypeOf(left);
    while(true) {
        // 查找到尽头，还没找到
        if(proto == null) return false;
        // 找到相同的原型对象
        if(proto == right.prototype) return true;
        proto = Object.getPrototypeOf(proto);
    }
}

// 实现2
const myInstanceof = function (left, right) {
  if(typeof left !== 'object' || left === null) return false;
  right = right.prototype;
  left = left.__proto__;
  while (true) {
    if (left === null) return false;
    if (right === left) return true;
    left = left.__proto__;
  }
};

// 实现3
// L 表示左表达式，R 表示右表达式
function instance_of(L, R) {
  var O = R.prototype;
  L = L.__proto__;
  while (true) {
    if (L === null) return false;
    // 这里重点：当 O 严格等于 L 时，返回 true
    if (O === L) return true;
    L = L.__proto__;
  }
}
```

#### 2-2、Object

##### 2-2-1、Object.is

```js
function is(x, y) {
  if (x === y) {
    // 运行到 1/x === 1/y 时 x 和 y 都为 0，但是 1/+0 = +Infinity， 1/-0 = -Infinity, 是不一样的
    return x !== 0 || y !== 0 || 1 / x === 1 / y;
  } else {
    // NaN===NaN 是 false, 这是不对的，在这里做一个拦截，x !== x，那么一定是 NaN, y 同理
    // 两个都是 NaN 时返回 true
    return x !== x && y !== y;
  }
}
```

##### 2-2-2、Object.create

```js
// 新建一个空的构造函数 F ，然后让 F.prototype 指向 obj，最后返回 F 的实例
const myCreate = function (obj) {
  function F() {};
  F.prototype = obj;
  return new F();
}

// 实现2
if (typeof Object.create !== "function") {
  Object.create = function (prototype, properties) {
    if (typeof prototype !== "object") { throw TypeError(); }
    function Ctor() {}
    Ctor.prototype = prototype;
    var o = new Ctor();
    if (prototype) { o.constructor = Ctor; }
    if (properties !== undefined) {
      if (properties !== Object(properties)) { throw TypeError(); }
      Object.defineProperties(o, properties);
    }
    return o;
  };
}
```



##### 2-2-3、getOwnPropertyNames

注意：不能拿到不可枚举的属性

```js
if (typeof Object.getOwnPropertyNames !== 'function') {
  Object.getOwnPropertyNames = function(o) {
    if (o !== Object(o)) {
      throw TypeError('Object.getOwnPropertyNames called on non-object');
    }
    var props = [],
      p;
    for (p in o) {
      if (Object.prototype.hasOwnProperty.call(o, p)) {
        props.push(p);
      }
    }
    return props;
  };
}
```





#### 2-3、Array

##### 2-3-1、Array.isArray

```js
Array.myIsArray = function(o) {
  return Object.prototype.toString.call(Object(o)) === '[object Array]';
};

console.log(Array.myIsArray([])); // true
```





#### 2-4、绑定

##### 2-4-1、new

new 被调用后做了如下事情：

- 让实例可以访问到私有属性
- 让实例可以访问构造函数原型(constructor.prototype)所在原型链上的属性
- 若构造函数返回的结果不是引用数据类型

```js
// 实现1
function newOperator(ctor, ...args) {
    if(typeof ctor !== 'function') throw 'newOperator function the first param must be a function';

    let obj = Object.create(ctor.prototype);
    let res = ctor.apply(obj, args);
    
    let isObject = typeof res === 'object' && res !== null;
    let isFunction = typoof res === 'function';
    return isObect || isFunction ? res ：obj;
};
```

- 它创建了一个全新的对象
- 它会被执行[[Prototype]]（也就是__proto__）链接
- 它使this指向新创建的对象
- 通过new创建的每个对象将最终被[[Prototype]]链接到这个函数的prototype对象上
- 如果函数没有返回对象类型Object(包含Functoin, Array, Date, RegExg, Error)，那么new表达式中的函数调用将返回该对象引用



- `Constructor` 就是 `new` 时传入的第一个参数，剩余的 `arguments` 是其他的参数
- 使用`obj.__proto__ = Constructor.prototype` 继承原型上的方法
- 将剩余的 `arguments` 传给 `Contructor` ，绑定 `this` 指向为 `obj`，并执行
- 如果构造函数返回的是引用类型，直接返回该引用类型，否则返回 `obj`

```js
const myNew = function () {
  let Constructor = Array.prototype.shift.call(arguments);
  let obj = {};
  obj.__proto__ = Constructor.prototype;
  let res = Constructor.apply(obj, arguments);
  return res instanceof Object ? res : obj;
};
```

- 创建一个新对象；
- 将构造函数的作用域赋给新对象 (因此 this 就指向了这个新对象)；
- 执行构造函数中的代码 (为这个新对象添加属性)；
- 返回新对象；

```js
function myNew() {
  // 创建一个实例对象
  var obj = new Object();
  // 取得外部传入的构造器
  var Constructor = Array.prototype.shift.call(arguments);
  // 实现继承，实例可以访问构造器的属性
  obj.__proto__ = Constructor.prototype;
  // 调用构造器，并改变其 this 指向到实例
  var ret = Constructor.apply(obj, arguments);
  // 如果构造函数返回值是对象则返回这个对象，如果不是对象则返回新的实例对象
  return typeof ret === 'object' && ret !== null ? ret : obj;
}
// 测试
// ========= 无返回值 =============
const testNewFun = function(name) {
  this.name = name;
};
const newObj = myNew(testNewFun, 'foo');
console.log(newObj); // { name: "foo" }
console.log(newObj instanceof testNewFun); // true
// ========= 有返回值 =============
const testNewFun = function(name) {
  this.name = name;
  return {};
};
const newObj = myNew(testNewFun, 'foo');
console.log(newObj); // {}
console.log(newObj instanceof testNewFun); // false



// 实现2
function create () {
  // 1. 获取构造函数，并且删除 arguments 中的第一项
  var Con = [].shift.call(arguments);
  // 2. 创建一个空的对象并链接到构造函数的原型，使它能访问原型中的属性
  var obj = Object.create(Con.prototype);
  // 3. 使用apply改变构造函数中this的指向实现继承，使obj能访问到构造函数中的属性
  var ret = Con.apply(obj, arguments);
  // 4. 优先返回构造函数返回的对象
  return ret instanceof Object ? ret : obj;
}
// 构造函数中有返回值且为对象，那么创建的实例就只能访问到返回对象中的属性，所以要判断一下ret的类型，如果是对象的话，则返回这个对象。
// 构造函数中没有返回值，那么创建的实例就能访问到这个构造函数中的所有属性了，此时ret就会为undefined，所以返回obj。
// 构造函数中有返回值但是返回值是undefined以外的其它基本类型(比如字符串)，这种情况当成第二种情况(没有返回值)来处理。
```





##### 2-4-2、bind

总体：call、apply、bind 本质都是改变 `this` 的指向，不同点 call、apply 是直接调用函数，bind 是返回一个新的函数；而 call 跟 apply 就只有参数上不同；

原理：bind 方法会创建一个新的函数，在 bind 被调用时，此新函数的 this 被指定为 bind 的第一个参数，而其余参数将作为新函数的参数，供调用时使用；

语法：`function.bind(thisArg, arg1, arg2, ...)` ，从用法上看，似乎给 call/apply 包一层 function 即可实现，但：

- <u>参数接收</u>：bind 除了 this 还接收其他参数，bind 返回的函数也接收参数，这两部分的参数都要传给返回的函数；
- <u>改变指向</u>：new 会改变 this 指向：若 bind 绑定后的函数被 new 构造调用，则 this 指向也会发生改变，指向当前函数的实例；即`new绑定` 的优先级高于 `显式绑定` 和 `硬绑定`，而函数作为构造函数用 `new` 关键字调用时，不应该改变其 `this` 指向；
- <u>箭头函数</u>：箭头函数的 `this` 永远指向它所在的作用域；
- 没有保留原函数在原型链上的属性和方法；

所以要确保 bind 被调用后做如下事情：

- 对于普通函数，绑定 this 指向
- 对于构造函数，要保证原函数的原型对象上的属性不能丢失

```js
// 简易版
Function.prototype.myBind = function (thisArg, ...args) {
    var self = this
    // new 优先级
    var fbound = function () {
        self.apply(this instanceof self ? 
                   this : 
                   thisArg, args.concat(Array.prototype.slice.call(arguments)));
    }
    // 继承原型上的属性和方法
    fbound.prototype = Object.create(self.prototype);
    return fbound;
}

// 完整版
Function.prototype.bind = function (context, ...args) {
    // 异常处理
    if (typeof this !== "function") {
      throw new Error("Function.prototype.bind - what is trying to be bound is not callable");
    }
    // 保存this的值，它代表调用 bind 的函数
    var self = this;
  
  	// 处理实现1:
    var fNOP = function () {};
    var fbound = function () {
        self.apply(this instanceof self ? 
            this :
            context, args.concat(Array.prototype.slice.call(arguments)));
    }
    fNOP.prototype = this.prototype;
    fbound.prototype = new fNOP();
  
  	// 处理实现2:
  	var fbound = function () {
        self.apply(this instanceof self ? 
            this :
            context, args.concat(Array.prototype.slice.call(arguments)));
    }
    fbound.prototype = Object.create(self.prototype);
  
    return fbound;
}

// 完整版2
Function.prototype.mybind = function(thisArg) {
  if (typeof this !== 'function') {
    throw TypeError("Bind must be called on a function");
  }
  // 拿到参数，为了传给调用者
  const args = Array.prototype.slice.call(arguments, 1),
        // 保存 this
        self = this,
        // 构建一个干净的函数，用于保存原函数的原型
        nop = function() {},
        // 绑定的函数
        bound = function() {
          // this instanceof nop, 判断是否使用 new 来调用 bound
          // 如果是 new 来调用的话，this的指向就是其实例，
          // 如果不是 new 调用的话，就改变 this 指向到指定的对象 o
          return self.apply(
            this instanceof nop ? this : thisArg,
            args.concat(Array.prototype.slice.call(arguments))
          );
        };

  // 箭头函数没有 prototype，箭头函数this永远指向它所在的作用域
  if (this.prototype) {
    nop.prototype = this.prototype;
  }
  // 修改绑定函数的原型指向
  bound.prototype = new nop();
  return bound;
}
// 测试：
const bar = function() {
  console.log(this.name, arguments);
};
bar.prototype.name = 'bar';
const foo = {
  name: 'foo'
};
const bound = bar.mybind(foo, 22, 33, 44);
new bound(); // bar, [22, 33, 44]
bound(); // foo, [22, 33, 44]
```

- `bind` 的参数可以在绑定和调用的时候分两次传入
- `bindArgs` 是绑定时除了第一个参数以外传入的参数，`args` 是调用时候传入的参数，将二者拼接后一起传入
- 如果使用 `new` 运算符构造绑定函数，则会改变 `this` 指向，`this` 指向当前的实例
- 通过 `Fn` 链接原型，这样 `fBound` 就可以通过原型链访问父类 `Fn` 的属性

```js
Function.prototype.mybind = function (context) {
  let that = this;
  let bindArgs = Array.prototype.slice.call(arguments, 1);
  function Fn() {}
  function fBound(params) {
    let args = Array.prototype.slice.call(arguments);
    return that.apply(
      this instanceof fBound ? this : context,
      bindArgs.concat(args)
    );
  }
  Fn.prototype = this.prototype;
  fBound.prototype = new Fn();
  return fBound;
};
```



- 函数内的`this`表示的就是调用的函数
- 可以将上下文传递进去, 并修改`this`的指向
- 返回一个函数
- 可以传入参数
- 柯里化
- 一个绑定的函数也能使用`new`操作法创建对象, 且提供的`this`会被忽略

```js
Function.prototype.bind2 = function(context) {
  // 1. 判断调用bind的是不是一个函数
  if (typeof this !== "function") {
    throw new Error(
      "Function.prototype.bind - what is trying to be bound is not callable"
    );
  }
  // 2. 外层的this指向调用者(也就是调用的函数)
  var self = this;
  // 3. 收集调用bind时的其它参数
  var args = Array.prototype.slice.call(arguments, 1);

  // 4. 创建一个返回的函数
  var fBound = function() {
    // 6. 收集调用新的函数时传入的其它参数
    var innerArgs = Array.prototype.slice.call(arguments);
    // 7. 使用apply改变调用函数时this的指向
    // 作为构造函数调用时this表示的是新产生的对象, 不作为构造函数用的时候传递context
    return self.apply(
      this instanceof fNOP ? this : context,
      args.concat(innerArgs)
    );
  };
  // 5. 创建一个空的函数, 且将原型指向调用者的原型(为了能用调用者原型中的属性)
  // 下面三步的作用有点类似于 fBoun.prototype = this.prototype 但有区别
  var fNOP = function() {};
  fNOP.prototype = this.prototype;
  fBound.prototype = new fNOP();
  // 8. 返回最后的结果
  return fBound;
};
```





##### 2-4-3、call/apply

总体：call、apply、bind 本质都是改变 `this` 的指向，不同点 call、apply 是直接调用函数，bind 是返回一个新的函数；而 call 跟 apply 就只有参数上不同；总结是：`bind` 是封装了 `call` 方法改变了 `this` 的指向并返回一个新的函数；

原理：在方法调用模式下，`this` 总是指向调用它所在方法的对象，`this` 的指向与所在方法的调用位置有关，而与方法的声明位置无关 (箭头函数特殊)；而 call 方法使用一个指定的 this 值和单独给出的一个或多个参数来调用一个函数；

语法：`function.call(thisArg, arg1, arg2, ...)`，而由于函数 this 指向其直接调用者，故变更调用者即完成 this 指向的变更

```js
// 最简版
Function.prototype.myCall = function(thisArg, ...args) {
    thisArg.fn = this              // this 指向调用 call 的对象, 即要改变 this 指向的函数
    return thisArg.fn(...args)     // 执行函数并 return 其执行结果
}

// 完整版1
Function.prototype.myCall = function(thisArg, ...args) {
    const fn = Symbol('fn')        // 声明一个独有的 Symbol 属性, 防止 fn 覆盖已有属性
    thisArg = thisArg || window    // 若没有传入 this, 则默认绑定 window 对象
    thisArg[fn] = this              // this 指向调用 call 的对象, 即要改变 this 指向的函数
    const result = thisArg[fn](...args)  // 执行当前函数
    delete thisArg[fn]              // 删除声明的 fn 属性
    return result                  // 返回函数执行结果
}

// 完整版2
const foo = { name: 'foo' };
foo.fn = function() {
  // 这里的 this 指向了 foo
  // 因为 foo 调用了 fn，
  // fn 的 this 就指向了调用它所在方法的对象 foo 上
  console.log(this.name); // foo
};
// 利用 this 机制实现 call
Function.prototype.mycall = function(thisArg) {
  // this 指向调用 call 的对象
  if (typeof this !== 'function') {
    // 调用 call 的若不是函数则报错
    throw new TypeError('Error');
  }
  // 声明一个 Symbol 属性，防止 fn 被占用
  const fn = Symbol('fn')
  const args = [...arguments].slice(1);
  thisArg = thisArg || window;
  // 将调用 call 函数的对象添加到 thisArg 的属性中
  thisArg[fn] = this;
  // 执行该属性
  const result = thisArg[fn](...args);
  // 删除该属性
  delete thisArg[fn];
  // 返回函数执行结果
  return result;
}
// 测试
const bar = function() {
  console.log(this.name, arguments);
};
bar.prototype.name = 'bar';
const foo = {
  name: 'foo'
};
bar.mycall(foo, 1, 2, 3); // foo [1, 2, 3]
bar.myapply(foo, [1, 2, 3]); // foo [1, 2, 3]



// 完整版3
Function.prototype.call = function (context) {
    let context = context || window;
    let fn = Symbol('fn');
    context.fn = this;
    let args = [];
    for(let i = 1, len = arguments.length; i < len; i++) {
        args.push('arguments[' + i + ']');
    }
    let result = eval('context.fn(' + args +')');
    delete context.fn
    return result;
}

// ES6 版本
Function.prototype.call = function (context, ...args) {
  let context = context || window;
  let fn = Symbol('fn');
  context.fn = this;
  let result = eval('context.fn(...args)');
  delete context.fn
  return result;
}
```

- `context` 存在就使用 `context`，否则是 `window`
- 使用 `Object(context)` 将 `context` 转换成对象，并通过 `context.fn` 将 `this` 指向 `context`
- 循环参数，注意从 `1` 开始，第 `0` 个是上下文，后面才是我们需要的参数
- 将参数字符串 `push` 进 `args`
- 字符串和数组拼接时，数组会调用 `toString` 方法，这样可以实现将参数一个个传入，并通过 `eval` 执行
- 拿到结果返回前，删除掉 `fn`

```js
Function.prototype.call = function (context) {
  context = context ? Object(context) : window;
  context.fn = this;
  let args = [];
  for (let i = 1; i < arguments.length; i++) {
    args.push("arguments[" + i + "]");
  }
  let res = eval("context.fn(" + args + ")");
  delete context.fn;
  return res;
};
```



apply 方法调用一个具有给定 this 值的函数，以及作为一个数组(或类似数组对象)提供的参数；
语法：`func.apply(thisArg, [argsArray])`，实际上 apply 与 call 类似，区别在于 call 接收参数列表，而 apply 接收一个参数数组，所以在 call 的实现上简单改一下入参形式即可：

```js
// 完整版1
Function.prototype.myApply = function(thisArg, args) {
    const fn = Symbol('fn')        // 声明一独有的 Symbol 属性, 防止 fn 覆盖已有属性
    thisArg = thisArg || window    // 若无传入 this, 则默认绑定 window对象
    thisArg[fn] = this              // this 指向调用 call 的对象, 即要改变 this 指向的函数
    const result = thisArg[fn](...args)  // 执行当前函数
    // 说明: 虽 apply 接收的是一个数组，但在调用原函数时，依然要展开参数数组, 可对照原生 apply，原函数接收到展开的参数数组;
    delete thisArg[fn]              // 删除声明的 fn 属性
    return result                  // 返回函数执行结果
}

// 完整版2
Function.prototype.myapply = function(thisArg) {
  if (typeof this !== 'function') {
    throw this + ' is not a function';
  }
  const args = arguments[1];
  const fn = Symbol('fn')
  thisArg[fn] = this;

  const result = thisArg[fn](...arg);
  delete thisArg[fn];
  return result;
};
// 测试
const bar = function() {
  console.log(this.name, arguments);
};
bar.prototype.name = 'bar';
const foo = {
  name: 'foo'
};
bar.mycall(foo, 1, 2, 3); // foo [1, 2, 3]
bar.myapply(foo, [1, 2, 3]); // foo [1, 2, 3]


// ES6 版本
Function.prototype.apply = function (context, args) {
  let context = context || window;
  context.fn = this;
  let result = eval('context.fn(...args)');

  delete context.fn
  return result;
}
```

- `apply` 无需循环参数列表，传入的 `args` 就是数组
- 但是 `args` 是可选参数，如果不传入的话，直接执行

```js
Function.prototype.apply = function (context, args) {
  context = context ? Object(context) : window;
  context.fn = this;
  if (!args) {
    return context.fn();
  }
  let res = eval("context.fn(" + args + ")");
  delete context.fn;
  return res;
};
```



- call、apply 实现

- 考点：在于 this 上下文怎么绑定到目标函数，即 this 的指向性问题；

  - 将函数设为对象的属性
  - 执行 & 删除这个函数
  - 指定 this 到函数并传入给定参数执行函数
  - 若不传入参数，默认指向为 window

  - 注意：eval 固然性能不好，但兼容性好且能达到实现本题效果；

  - ```js
    Function.prototype.call2 = function(context) {
        var context = context || window; // 因传进来的 context 有可能是 null
        context.fn = this;
        var args = [];
        for (var i = 1; i < arguments.length; i++) {
            args.push("arguments[" + i + "]"); // 否则字符串的引号会被自动去掉 变成了变量 导致报错
        }
        args = args.join(",");
    
        var result = eval("context.fn(" + args + ")"); // 相当于执行 context.fn(arguments[1], arguments[2]);
    
        delete context.fn;
        return result; // 因有可能 this 函数会有返回值 return
    }
    
    // 2
    Function.prototype.call2 = function(context, ...args) {
      // 因为传进来的 context 有可能是 null
      context = context || window;
      // Function.prototype this 为当前运行的函数
      // 让 fn 的上下文为 context
      context.fn = this;
      const result = context.fn(...args);
      delete context.fn;
      return result;
    };
    
    function test(a, b, c) {
      console.log(this, a, b, c);
      return this;
    }
    test.call2({ test: 22 }, 1, 2, 3);
    
    // 3
    Function.prototype.call2 = function (context) {
        var context = context || window;
        context.fn = this;
    
        var args = [];
        for(var i = 1, len = arguments.length; i < len; i++) {
            args.push('arguments[' + i + ']');
        }
    
        var result = eval('context.fn(' + args +')');
    
        delete context.fn
        return result;
    }
    
    
    // ES5 实现 call
    function fnFactory(context) {
      var unique_fn = "fn";
      while (context.hasOwnProperty(unique_fn)) {
        unique_fn = "fn" + Math.random();
      }
      return unique_fn;
    }
    Function.prototype.call2 = function(context) {
      // 1. 若是传入的context是null或者undefined时指向window;
      // 2. 若是传入的是原始数据类型, 原生的call会调用 Object() 转换
      context = context ? Object(context) : window;
      // 3. 创建一个独一无二的fn函数的命名
      var fn = fnFactory(context);
      // 4. 这里的this就是指调用call的那个函数
      // 5. 将调用的这个函数赋值到context中, 这样之后执行context.fn的时候, fn里的this就是指向context了
      context[fn] = this;
      // 6. 定义一个数组用于放arguments的每一项的字符串: ['agruments[1]', 'arguments[2]']
      var args = [];
      // 7. 要从第1项开始, 第0项是context
      for (var i = 1, l = arguments.length; i < l; i++) {
        args.push("arguments[" + i + "]");
      }
      // 8. 使用eval()来执行fn并将args一个个传递进去
      var result = eval("context[fn](" + args + ")");
      // 9. 给context额外附件了一个属性fn, 所以用完之后需要删除
      delete context[fn];
      // 10. 函数fn可能会有返回值, 需要将其返回
      return result;
    };
    // ES6 实现 call
    Function.prototype.call3 = function(context) {
      context = context ? Object(context) : window;
      var fn = Symbol();
      context[fn] = this;
    
      let args = [...arguments].slice(1);
      let result = context[fn](...args);
    
      delete context[fn];
      return result;
    };
    ```

  - ```js
    Function.prototype.apply2 = function(context, arr) {
        var context = context || window; // 因传进来的 context 有可能是 null
        context.fn = this;
        var args = [];
        var params = arr || [];
        for (var i = 0; i < params.length; i++) {
            args.push("params[" + i + "]"); // 否则字符串的引号会被自动去掉 变成了变量 导致报错
        }
        args = args.join(",");
    
        var result = eval("context.fn(" + args + ")"); // 相当于执行 context.fn(arguments[1], arguments[2]);
    
        delete context.fn;
        return result; // 因有可能 this 函数会有返回值 return
    }
    // 2
    Function.prototype.apply2 = function(context, arr) {
        let context = context || window; 
        context.fn = this;
        arr = arr || [];
        const result = context.fn(...arr); 
        delete context.fn;
        return result; // 因有可能 this 函数会有返回值 return
    }
    // 3
    Function.prototype.apply = function (context, arr) {
        var context = Object(context) || window;
        context.fn = this;
        var result;
        if (!arr) {
            result = context.fn();
        }
        else {
            var args = [];
            for (var i = 0, len = arr.length; i < len; i++) {
                args.push('arr[' + i + ']');
            }
            result = eval('context.fn(' + args + ')')
        }
        delete context.fn
        return result;
    }
    
    // ES5 实现 apply
    function fnFactory(context) {
      var unique_fn = "fn";
      while (context.hasOwnProperty(unique_fn)) {
        unique_fn = "fn" + Math.random();
      }
      return unique_fn;
    }
    Function.prototype.apply2 = function(context, arr) {
      // 1. 若是传入的context是null或者undefined时指向window;
      // 2. 若是传入的是原始数据类型, 原生的call会调用 Object() 转换
      context = context ? Object(context) : window;
      // 3. 创建一个独一无二的fn函数的命名
      var fn = fnFactory(context);
      // 4. 这里的this就是指调用call的那个函数
      // 5. 将调用的这个函数赋值到context中, 这样之后执行context.fn的时候, fn里的this就是指向context了
      context[fn] = this;
    
      var result;
      // 6. 判断有没有第二个参数
      if (!arr) {
        result = context[fn]();
      } else {
        // 7. 有的话则用args放每一项的字符串: ['arr[0]', 'arr[1]']
        var args = [];
        for (var i = 0, len = arr.length; i < len; i++) {
          args.push("arr[" + i + "]");
        }
        // 8. 使用eval()来执行fn并将args一个个传递进去
        result = eval("context[fn](" + args + ")");
      }
      // 9. 给context额外附件了一个属性fn, 所以用完之后需要删除
      delete context[fn];
      // 10. 函数fn可能会有返回值, 需要将其返回
      return result;
    };
    // ES6 实现 apply
    Function.prototype.apply3 = function(context, arr) {
      context = context ? Object(context) : window;
      let fn = Symbol();
      context[fn] = this;
    
      let result = arr ? context[fn](...arr) : context[fn]();
      delete context[fn];
      return result;
    };
    ```

  - call、apply 对比

    - Function.prototype.apply 和 Function.prototype.call 作用一样，区别在于传入参数的不同；
    - 第一个参数均为，指定函数体内this的指向；
    - 第二个参数则不同：
      - 前者传入带下标的集合，数组或类数组，并将其作为参数传给函数；
      - 前者从第二个开始传入的参数是不固定的，都会传给函数作为参数；
    - call 比 apply 的性能要好，平常可多用 call，call 传入参数的格式正是内部所需要的格式；
    - 注意：平时开发中不必过分关注 call 和 apply 的性能问题，但可尽量使用 call，而因为 ES6 的 reset 解构支持，call 基本可代替 apply；
    - 补充：lodash 源码中并无直接用 Function.prototype.apply，而是在参数较少时(1-3)采用 call 方式调用，也因 lodash 中没有超过 4 个参数方法；
    - 此外：若一函数设计超过4个入参，则需要考虑重构了；







#### 2-5、继承

##### 2-5-1、class

##### 2-5-1-1、ES6 实现

```js
class B {
  constructor(opt) {
    this.BName = opt.name;
  }
}
class A extends B {
  constructor() {
    // 向父类传参
    super({ name: 'B' });
    // this 必须在 super() 下面使用
    console.log(this);
  }
}
```

##### 2-5-1-2、ES5 实现

使用寄生组合继承的方式

1. 原型链继承，使子类可以调用父类原型上的方法和属性
2. 借用构造函数继承，可以实现向父类传参
3. 寄生继承，创造干净的没有构造方法的函数，用来寄生父类的 prototype

```js
// 实现继承，通过继承父类 prototype
function __extends(child, parent) {
  // 修改对象原型
  Object.setPrototypeOf(child, parent);
  // 寄生继承，创建一个干净的构造函数，用于继承父类的 prototype
  // 这样做的好处是，修改子类的 prototype 不会影响父类的 prototype
  function __() {
    // 修正 constructor 指向子类
    this.constructor = child;
  }
  // 原型继承，继承父类原型属性，但是无法向父类构造函数传参
  child.prototype =
    parent === null
      ? Object.create(parent)
      : ((__.prototype = parent.prototype), new __());
}

var B = (function() {
  function B(opt) {
    this.name = opt.name;
  }
  return B;
})();

var A = (function(_super) {
  __extends(A, _super);
  function A() {
    // 借用继承，可以实现向父类传参, 使用 super 可以向父类传参
    return (_super !== null && _super.apply(this, { name: 'B' })) || this;
  }
  return A;
})(B);

// 测试
const a = new A();
console.log(a.BName, a.constructor); // B ,ƒ A() {}
```



#### 2-6、异步

##### 2-6-1、Promise

原理：发布订阅模式

- 构造函数接收一个 `executor` 函数，并会在 `new Promise()` 时立即执行该函数
- then 时收集依赖，将回调函数收集到成功/失败队列
- `executor` 函数中调用 `resolve/reject` 函数
- `resolve/reject` 函数被调用时会通知触发队列中的回调

```js
const isFunction = variable => typeof variable === 'function';

// 定义Promise的三种状态常量
const PENDING = 'pending';
const FULFILLED = 'fulfilled';
const REJECTED = 'rejected';

class MyPromise {
  // 构造函数，new 时触发
  constructor(handle: Function) {
    try {
      handle(this._resolve, this._reject);
    } catch (err) {
      this._reject(err);
    }
  }
  // 状态 pending fulfilled rejected
  private _status: string = PENDING;
  // 储存 value，用于 then 返回
  private _value: string | undefined = undefined;
  // 失败队列，在 then 时注入，resolve 时触发
  private _rejectedQueues: any = [];
  // 成功队列，在 then 时注入，resolve 时触发
  private _fulfilledQueues: any = [];
  // resovle 时执行的函数
  private _resolve = val => {
    const run = () => {
      if (this._status !== PENDING) return;
      this._status = FULFILLED;
      // 依次执行成功队列中的函数，并清空队列
      const runFulfilled = value => {
        let cb;
        while ((cb = this._fulfilledQueues.shift())) {
          cb(value);
        }
      };
      // 依次执行失败队列中的函数，并清空队列
      const runRejected = error => {
        let cb;
        while ((cb = this._rejectedQueues.shift())) {
          cb(error);
        }
      };
      /*
       * 如果resolve的参数为Promise对象，
       * 则必须等待该Promise对象状态改变后当前Promsie的状态才会改变
       * 且状态取决于参数Promsie对象的状态
       */
      if (val instanceof MyPromise) {
        val.then(
          value => {
            this._value = value;
            runFulfilled(value);
          },
          err => {
            this._value = err;
            runRejected(err);
          }
        );
      } else {
        this._value = val;
        runFulfilled(val);
      }
    };
    // 异步调用
    setTimeout(run);
  };
  // reject 时执行的函数
  private _reject = err => {
    if (this._status !== PENDING) return;
    // 依次执行失败队列中的函数，并清空队列
    const run = () => {
      this._status = REJECTED;
      this._value = err;
      let cb;
      while ((cb = this._rejectedQueues.shift())) {
        cb(err);
      }
    };
    // 为了支持同步的Promise，这里采用异步调用
    setTimeout(run);
  };
  // then 方法
  then(onFulfilled?, onRejected?) {
    const { _value, _status } = this;
    // 返回一个新的Promise对象
    return new MyPromise((onFulfilledNext, onRejectedNext) => {
      // 封装一个成功时执行的函数
      const fulfilled = value => {
        try {
          if (!isFunction(onFulfilled)) {
            onFulfilledNext(value);
          } else {
            const res = onFulfilled(value);
            if (res instanceof MyPromise) {
              // 如果当前回调函数返回MyPromise对象，必须等待其状态改变后在执行下一个回调
              res.then(onFulfilledNext, onRejectedNext);
            } else {
              //否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数
              onFulfilledNext(res);
            }
          }
        } catch (err) {
          // 如果函数执行出错，新的Promise对象的状态为失败
          onRejectedNext(err);
        }
      };

      // 封装一个失败时执行的函数
      const rejected = error => {
        try {
          if (!isFunction(onRejected)) {
            onRejectedNext(error);
          } else {
            const res = onRejected(error);
            if (res instanceof MyPromise) {
              // 如果当前回调函数返回MyPromise对象，必须等待其状态改变后在执行下一个回调
              res.then(onFulfilledNext, onRejectedNext);
            } else {
              //否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数
              onFulfilledNext(res);
            }
          }
        } catch (err) {
          // 如果函数执行出错，新的Promise对象的状态为失败
          onRejectedNext(err);
        }
      };

      switch (_status) {
        // 当状态为pending时，将then方法回调函数加入执行队列等待执行
        case PENDING:
          this._fulfilledQueues.push(fulfilled);
          this._rejectedQueues.push(rejected);
          break;
        // 当状态已经改变时，立即执行对应的回调函数
        case FULFILLED:
          fulfilled(_value);
          break;
        case REJECTED:
          rejected(_value);
          break;
      }
    });
  }
  // catch 方法
  catch(onRejected) {
    return this.then(undefined, onRejected);
  }
  // finally 方法
  finally(cb) {
    return this.then(
      value => MyPromise.resolve(cb()).then(() => value),
      reason =>
        MyPromise.resolve(cb()).then(() => {
          throw reason;
        })
    );
  }
  // 静态 resolve 方法
  static resolve(value) {
    // 如果参数是MyPromise实例，直接返回这个实例
    if (value instanceof MyPromise) return value;
    return new MyPromise(resolve => resolve(value));
  }
  // 静态 reject 方法
  static reject(value) {
    return new MyPromise((resolve, reject) => reject(value));
  }
  // 静态 all 方法
  static all(list) {
    return new MyPromise((resolve, reject) => {
      // 返回值的集合
      let values = [];
      let count = 0;
      for (let [i, p] of list.entries()) {
        // 数组参数如果不是MyPromise实例，先调用MyPromise.resolve
        this.resolve(p).then(
          res => {
            values[i] = res;
            count++;
            // 所有状态都变成fulfilled时返回的MyPromise状态就变成fulfilled
            if (count === list.length) resolve(values);
          },
          err => {
            // 有一个被rejected时返回的MyPromise状态就变成rejected
            reject(err);
          }
        );
      }
    });
  }
  // 添加静态race方法
  static race(list) {
    return new MyPromise((resolve, reject) => {
      for (let p of list) {
        // 只要有一个实例率先改变状态，新的MyPromise的状态就跟着改变
        this.resolve(p).then(
          res => {
            resolve(res);
          },
          err => {
            reject(err);
          }
        );
      }
    });
  }
}
```

##### 2-6-2、Async/Await

原理：利用 `generator` (生成器)分割代码片段，然后我们使用一个函数让其自迭代，每一个`yield` 用 `promise` 包裹起来，执行下一步的时机由 `promise` 来控制；

```js
// 异步迭代，模拟异步函数
function _asyncToGenerator(fn) {
  return function() {
    var self = this,
      args = arguments;
    // 将返回值promise化
    return new Promise(function(resolve, reject) {
      // 获取迭代器实例
      var gen = fn.apply(self, args);
      // 执行下一步
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'next', value);
      }
      // 抛出异常
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'throw', err);
      }
      // 第一次触发
      _next(undefined);
    });
  };
}
// 执行迭代步骤，处理下次迭代结果
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    // 迭代器完成
    resolve(value);
  } else {
    // -- 这行代码就是精髓 --
    // 将所有值promise化
    // 比如 yield 1
    // const a = Promise.resolve(1) a 是一个 promise
    // const b = Promise.resolve(a) b 是一个 promise
    // 可以做到统一 promise 输出
    // 当 promise 执行完之后再执行下一步
    // 递归调用 next 函数，直到 done == true
    Promise.resolve(value).then(_next, _throw);
  }
}
// 测试
const asyncFunc = _asyncToGenerator(function*() {
  const e = yield new Promise(resolve => {
    setTimeout(() => {
      resolve('e');
    }, 1000);
  });
  const a = yield Promise.resolve('a');
  const d = yield 'd';
  const b = yield Promise.resolve('b');
  const c = yield Promise.resolve('c');
  return [a, b, c, d, e];
});

asyncFunc().then(res => {
  console.log(res); // ['a', 'b', 'c', 'd', 'e']
});
```



### 三、常用实现

#### 3-1、arguments 转换

arguments 本身无法调用数组方法，因其是类数组：属性从 0 开始排序，并有 callee、length属性；常见的类数组还有：

- 用 getElementsByTagName/ClassName() 获得的 HTMLCollection；
- 用 querySelector 获得的 nodeList；

类数组无法使用数组方法，但必要时可将它们转换成数组：

##### 3-1-1、Array.prototype.slice.call

```js
function sum(a, b) {
  let args = Array.prototype.slice.call(arguments);
  console.log(args.reduce((sum, cur) => sum + cur));// args可以调用数组原生的方法啦
}
sum(1, 2);// 3
```

##### 3-1-2、Array.from

```js
function sum(a, b) {
  let args = Array.from(arguments);
  console.log(args.reduce((sum, cur) => sum + cur));// args可以调用数组原生的方法啦
}
sum(1, 2);// 3
```

这种方法也可以用来转换Set和Map哦！

##### 3-1-3、ES6 展开运算符

```js
function sum(a, b) {
  let args = [...arguments];
  console.log(args.reduce((sum, cur) => sum + cur));// args可以调用数组原生的方法啦
}
sum(1, 2);// 3
```

##### 3-1-4、利用 concat + apply

```js
function sum(a, b) {
  let args = Array.prototype.concat.apply([], arguments);// apply方法会把第二个参数展开
  console.log(args.reduce((sum, cur) => sum + cur));// args可以调用数组原生的方法啦
}
sum(1, 2);// 3
```



#### 3-2、深浅拷贝

##### 3-2-1、浅拷贝

以赋值的形式拷贝引用对象，仍指向同一个地址，**修改时原对象也会受到影响**

##### 3-2-1-1、手动实现

```js
const shallowClone = (target) => {
  if (typeof target === 'object' && target !== null) {
    const cloneTarget = Array.isArray(target) ? []：{};
    for (let prop in target) {
      if (target.hasOwnProperty(prop)) {
          cloneTarget[prop] = target[prop];
      }
    }
    return cloneTarget;
  } else {
    return target;
  }
}
```

##### 3-2-1-2、Object.assign

```js
let obj = { name：'sy', age：18 };
const obj2 = Object.assign({}, obj, {name：'sss'});
console.log(obj2); // { name：'sss', age：18 }
// 注意：Object.assgin() 拷贝的是对象的属性的引用，而非对象本身；
```

##### 3-2-1-3、concat 浅拷贝数组

```js
let arr = [1, 2, 3];
let newArr = arr.concat();
newArr[1] = 100;
console.log(arr); // [ 1, 2, 3 ]
```

##### 3-2-1-4、slice 浅拷贝

```js
let arr = [1, 2, 3];
let newArr = arr.slice();
newArr[0] = 100;
console.log(arr); // [1, 2, 3]
```

##### 3-2-1-5、ES6 展开运算符

```js
let arr = [1, 2, 3];
let newArr = [...arr]; // 跟 arr.slice() 一样效果
```




##### 3-2-2、深拷贝

完全拷贝一个新对象，**修改时原对象不再受到任何影响**；

区别：深拷贝和浅拷贝是针对复杂数据类型来说的，浅拷贝只拷贝一层，而深拷贝是层层拷贝

- 浅拷贝：是会将对象的每个属性进行依次复制，但是当对象的属性值是引用类型时，实质复制的是其引用，当引用指向的值改变时也会跟着变化；
- 深拷贝：复制变量值，对于非基本类型的变量，则递归至基本类型变量后，再复制。 深拷贝的结果与原来对象完全隔离、互不影响；



##### 3-2-2-1、简易版

```js
JSON.parse(JSON.stringify()); // 性能最快
```

- 无法解决 <u>循环引用</u> 的问题：`const a = {val:2};  a.target = a;`，会出现无限递归，导致系统栈溢出，并报错；
- 无法拷贝某些特殊对象，诸如 RegExp、Date、Set、Map 等 与特殊值 undefined 等；
- 无法拷贝原型链上的属性；
- 无法拷贝函数；

```js
const deepClone = (target) => {
  // 引用类型判断
  if (typeof target === 'object' && target !== null) {
    // 初始值选取
    const cloneTarget = Array.isArray(target) ? []：{};
    // 迭代操作
    for (let prop in target) {
      if (target.hasOwnProperty(prop)) {
          cloneTarget[prop] = deepClone(target[prop]);
      }
    }
    return cloneTarget;
  } else {
    return target;
  }
}
```



##### 3-2-2-2、解决循环引用

关键：创建 Map，记录已拷贝过的对象，若已拷贝过则直接返回；

```js
// 判断
const isObject = (target) => (typeof target === 'object' || typeof target === 'function') && target !== null;
const deepClone = (target, map = new Map()) => { 
  // 若已拷贝过则直接返回
  if(map.get(target)) return target; 
  if (isObject(target)) { 
    // 记录已拷贝过的对象
    map.set(target, true); 
    // 迭代操作
    const cloneTarget = Array.isArray(target) ? []：{}; 
    for (let prop in target) { 
      if (target.hasOwnProperty(prop)) { 
          cloneTarget[prop] = deepClone(target[prop],map); 
      } 
    } 
    return cloneTarget; 
  } else { 
    return target; 
  } 
}

// 测试
const a = {val:2};
a.target = a;
let newA = deepClone(a);
console.log(newA) // { val：2, target：{ val：2, target：[Circular] } }
```

##### 3-2-2-2-1、强引用与 WeakMap

上面 map 上的 key 与 map 构成了 <u>强引用关系</u>：

- 在计算机程序设计中，<u>弱引用与强引用相对</u>， 是指不能确保其引用的对象不会被垃圾回收器回收的引用； <u>一个对象若只被弱引用所引用，则被认为是不可访问（或弱可访问）的，并因此可能在任何时刻被回收</u>；
- 即**<u>被弱引用的对象可在任何时候被回收</u>**，**<u>但对于强引用来说，只要这个强引用还在，那么对象无法被回收</u>**；比如 map 和 a 一直是强引用的关系， 在程序结束之前，a 所占的内存空间一直不会被释放；

所以，使 map 上的 key 与 map 构成弱引用关系即可，可利用 ES6 WeakMap 实现，WeakMap 是一种特殊的Map, 其中的键是`弱引用`的；<u>其键必须是对象，而值可以是任意的</u>；

```js
// 判断
const isObject = (target) => (typeof target === 'object' || typeof target === 'function') && target !== null;
const deepClone = (target, map = new WeakMap()) => { 
  // 若已拷贝过则直接返回
  if(map.get(target)) return target; 
  if (isObject(target)) { 
    // 记录已拷贝过的对象
    map.set(target, true); 
    // 迭代操作
    const cloneTarget = Array.isArray(target) ? []：{}; 
    for (let prop in target) { 
      if (target.hasOwnProperty(prop)) { 
          cloneTarget[prop] = deepClone(target[prop],map); 
      } 
    } 
    return cloneTarget; 
  } else { 
    return target; 
  } 
}
```



##### 3-2-2-4、实现特殊对象拷贝

##### 3-2-2-4-1、可继续遍历对象

关键：鉴别对象并进行分类处理；

```js
const getType = Object.prototype.toString.call(obj);
const isObject = (target) => (typeof target === 'object' || typeof target === 'function') && target !== null;

// 可继续遍历
const canTraverse = {
  '[object Map]'：true,
  '[object Set]'：true,
  '[object Array]'：true,
  '[object Object]'：true,
  '[object Arguments]'：true,
};

const deepClone = (target, map = new Map()) => {
  if(!isObject(target)) return target;
  let type = getType(target);
  let cloneTarget;
  if(!canTraverse[type]) {
    // 处理不能遍历的对象
    return;
  } else {
    // 这波操作相当关键，可以保证对象的原型不丢失！
    let ctor = target.prototype;
    cloneTarget = new ctor();
  }

  if(map.get(target)) return target;
  map.put(target, true);

  // 处理Map
  if(type === mapTag) {
    target.forEach((item, key) => {
      cloneTarget.set(deepClone(key), deepClone(item));
    })
  }
  
  // 处理Set
  if(type === setTag) {
    target.forEach(item => {
      target.add(deepClone(item));
    })
  }

  // 处理数组和对象
  for (let prop in target) {
    if (target.hasOwnProperty(prop)) {
        cloneTarget[prop] = deepClone(target[prop]);
    }
  }
  return cloneTarget;
}
```



##### 3-2-2-4-2、不可继续遍历对象

```js
const boolTag = '[object Boolean]';
const numberTag = '[object Number]';
const stringTag = '[object String]';
const dateTag = '[object Date]';
const errorTag = '[object Error]';
const regexpTag = '[object RegExp]';
const funcTag = '[object Function]';

const handleRegExp = (target) => {
  const { source, flags } = target;
  return new target.constructor(source, flags);
}

const handleFunc = (target) => {
  // 待会的重点部分
}

const handleNotTraverse = (target, tag) => {
  const Ctor = targe.constructor;
  switch(tag) {
    case boolTag:
    case numberTag:
    case stringTag:
    case errorTag：
    case dateTag:
      return new Ctor(target);
    case regexpTag:
      return handleRegExp(target);
    case funcTag:
      return handleFunc(target);
    default:
      return new Ctor(target);
  }
}
```



##### 3-2-2-5、实现函数拷贝

函数也是对象，但因过于特殊，故单独拆解，JS 有两种函数：一种是普通函数，另一种是箭头函数；每个普通函数都是 Function 的实例，而箭头函数不是任何类的实例，每次调用都是不一样的引用；所以**<u>只需处理普通函数的情况，箭头函数直接返回它本身即可；可利用原型，判断箭头函数，因其是不存在原型的；</u>**

```js
const handleFunc = (func) => {
  // 箭头函数直接返回自身
  if(!func.prototype) return func;
  const bodyReg = /(?<={)(.|\n)+(?=})/m;
  const paramReg = /(?<=\().+(?=\)\s+{)/;
  const funcString = func.toString();
  // 分别匹配 函数参数 和 函数体
  const param = paramReg.exec(funcString);
  const body = bodyReg.exec(funcString);
  if(!body) return null;
  if (param) {
    const paramArr = param[0].split(',');
    return new Function(...paramArr, body[0]);
  } else {
    return new Function(body[0]);
  }
}
```

注意：修复bug：

```js
const target = new Boolean(false);
const Ctor = target.constructor;
new Ctor(target); // 结果为 Boolean {true} 而应该是 false；
// 解决：调用valueOf：new target.constructor(target.valueOf())。
// 但实际上，这种写法是不推荐的。因为在ES6后不推荐使用 [new 基本类型()] 这样的语法，所以 es6 中的新类型 Symbol 是不能直接 new 的，只能通过 new Object(SymbelType)
```



##### 3-2-2-5、完成版

```js
const getType = obj => Object.prototype.toString.call(obj);
const isObject = (target) => (typeof target === 'object' || typeof target === 'function') && target !== null;

const canTraverse = {
  '[object Map]'：true,
  '[object Set]'：true,
  '[object Array]'：true,
  '[object Object]'：true,
  '[object Arguments]'：true,
};
const mapTag = '[object Map]';
const setTag = '[object Set]';
const boolTag = '[object Boolean]';
const numberTag = '[object Number]';
const stringTag = '[object String]';
const symbolTag = '[object Symbol]';
const dateTag = '[object Date]';
const errorTag = '[object Error]';
const regexpTag = '[object RegExp]';
const funcTag = '[object Function]';

const handleRegExp = (target) => {
  const { source, flags } = target;
  return new target.constructor(source, flags);
}

const handleFunc = (func) => {
  // 箭头函数直接返回自身
  if(!func.prototype) return func;
  const bodyReg = /(?<={)(.|\n)+(?=})/m;
  const paramReg = /(?<=\().+(?=\)\s+{)/;
  const funcString = func.toString();
  // 分别匹配 函数参数 和 函数体
  const param = paramReg.exec(funcString);
  const body = bodyReg.exec(funcString);
  if(!body) return null;
  if (param) {
    const paramArr = param[0].split(',');
    return new Function(...paramArr, body[0]);
  } else {
    return new Function(body[0]);
  }
}

const handleNotTraverse = (target, tag) => {
  // 关键：保证对象的原型不丢失！
  const Ctor = target.constructor;
  switch(tag) {
    case boolTag:
      return new Object(Boolean.prototype.valueOf.call(target));
    case numberTag:
      return new Object(Number.prototype.valueOf.call(target));
    case stringTag:
      return new Object(String.prototype.valueOf.call(target));
    case symbolTag:
      return new Object(Symbol.prototype.valueOf.call(target));
    case errorTag：
    case dateTag:
      return new Ctor(target);
    case regexpTag:
      return handleRegExp(target);
    case funcTag:
      return handleFunc(target);
    default:
      return new Ctor(target);
  }
}

const deepClone = (target, map = new WeakMap()) => {
  if(!isObject(target)) 
    return target;
  let type = getType(target);
  let cloneTarget;
  if(!canTraverse[type]) {
    // 处理不能遍历的对象
    return handleNotTraverse(target, type);
  } else {
    // 关键：保证对象的原型不丢失！
    let ctor = target.constructor;
    cloneTarget = new ctor();
  }

  if(map.get(target)) 
    return target;
  map.set(target, true);

  // 处理Map
  if(type === mapTag) {
    target.forEach((item, key) => {
      cloneTarget.set(deepClone(key, map), deepClone(item, map));
    })
  }
  
  // 处理Set
  if(type === setTag) {
    target.forEach(item => {
      cloneTarget.add(deepClone(item, map));
    })
  }

  // 处理数组和对象
  for (let prop in target) {
    if (target.hasOwnProperty(prop)) {
        cloneTarget[prop] = deepClone(target[prop], map);
    }
  }
  return cloneTarget;
}
```



#### 3-3、数组相关

- map：遍历数组，返回回调返回值组成的新数组；
- forEach：无法 break，可用 try/catch 中 throw new Error 来停止；
- filter：过滤；
- some：有一项返回true，则整体为true；
  every：有一项返回false，则整体为false；
- join：通过指定连接符生成字符串；
- push / pop：末尾推入和弹出，改变原数组， `push` 返回数组长度, `pop` 返回原数组最后一项；
- unshift / shift：头部推入和弹出，改变原数组，`unshift` 返回数组长度，`shift` 返回原数组第一项 ；
- sort(fn) / reverse：排序与反转，改变原数组；
- concat：连接数组，不影响原数组， 浅拷贝；
- slice(start, end)：返回截断后的新数组，不改变原数组；
- splice(start, number, value...)：返回删除元素组成的数组，value 为插入项，改变原数组；
- indexOf / lastIndexOf(value, fromIndex)：查找数组项，返回对应的下标；
- reduce / reduceRight(fn(prev, cur)， defaultPrev)：两两执行，prev 为上次化简函数的`return`值，cur 为当前值；
  - 当传入 `defaultPrev` 时，从第一项开始；
  - 当未传入时，则为第二项；



##### 3-3-1、数组扁平化

扁平化即多维数组转为一维数组：`[1, [2, [3, [4, 5]]], 6];// -> [1, 2, 3, 4, 5, 6]`

##### 3-3-1-1、ES6 flat

```js
const arr = [1, [1,2], [1,2,3]]
arr.flat(Infinity)  // [1, 1, 2, 1, 2, 3]
```

##### 3-3-1-2、replace + split

```js
ary = str.replace(/(\[|\])/g, '').split(',')
```

##### 3-3-1-3、replace + JSON.parse

```js
str = str.replace(/(\[|\])/g, '');
str = '[' + str + ']';
ary = JSON.parse(str);
```

##### 3-3-1-4、普通递归

```js
let result = [];
let fn = function(ary) {
  for(let i = 0; i < ary.length; i++) {
    let item = ary[i];
    if (Array.isArray(ary[i])){
      fn(item);
    } else {
      result.push(item);
    }
  }
}

// 实现2
const arr = [1, [1,2], [1,2,3]]
function flat(arr) {
  let result = []
  for (const item of arr) {
    item instanceof Array ? result = result.concat(flat(item)) : result.push(item)
  }
  return result
}
flat(arr) // [1, 1, 2, 1, 2, 3]
```

##### 3-3-1-5、利用 reduce 函数迭代

```js
const ary = [1, [1,2], [1,2,3]]
function flatten(ary) {
    return ary.reduce((pre, cur) => {
        return pre.concat(Array.isArray(cur) ? flatten(cur) ：cur);
    }, []);
}
console.log(flatten(ary)) // [1, 1, 2, 1, 2, 3]
```

##### 3-3-1-6、ES6 展开运算符

```js
// 每次 while 都会合并一层的元素，这里第一次合并结果为 [1, 1, 2, 1, 2, 3, [4,4,4]]
// 然后 arr.some 判定数组中是否存在数组，因为存在 [4,4,4]，继续进入第二次循环进行合并
let arr = [1, [1,2], [1,2,3,[4,4,4]]]
while (arr.some(Array.isArray)) {
  arr = [].concat(...arr);
}
console.log(arr)  // [1, 1, 2, 1, 2, 3, 4, 4, 4]
```

##### 3-3-1-7、序列化 + 正则

```js
const arr = [1, [1,2], [1,2,3]]
const str = `[${JSON.stringify(arr).replace(/(\[|\])/g, '')}]`
JSON.parse(str)   // [1, 1, 2, 1, 2, 3]
```



##### 3-3-2、数组寻值

##### 3-3-2-1、indexOf(ele)

```js
// 判断数组中是否存在某个值，如果存在，则返回数组元素的下标，否则返回-1
var arr=[1,2,3,4];
var index=arr.indexOf(3);
console.log(index);
```

##### 3-3-2-2、includes(ele [,fromIndex])

```js
// 判断数组中是否存在某个值，如果存在返回 true，否则返回 false
var arr=[1,2,3,4];
if(arr.includes(3))
    console.log("存在");
else
    console.log("不存在");
```

##### 3-3-2-4、find(cb [,thisArg])

```js
// 数组中满足条件的第一个元素的值，如果没有，返回 undefined
var arr=[1,2,3,4];
var result = arr.find(item =>{
    return item > 3
});
console.log(result);
```

##### 3-3-2-5、findeIndex(cb [,thisArg])

```js
// 返回数组中满足条件的第一个元素的下标，如果没有找到，返回 -1
var arr=[1,2,3,4];
var result = arr.findIndex(item =>{
    return item > 3
});
console.log(result);
```



##### 3-3-3、数组乱序

##### 3-3-3-1、sort + random

```js
var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
arr.sort(function () {
    return Math.random() - 0.5;
});
```





##### 3-3-4、数组去重

- `Array.from(new Set(arr))`

  - ```js
    var arr = [1,1,2,5,6,3,5,5,6,8,9,8];
    console.log(Array.from(new Set(arr)))
    // console.log([...new Set(arr)])
    ```

- `[...new Set(arr)]`

- `for `循环嵌套，利用 `splice` 去重

  - ```js
    function unique (origin) {
      let arr = [].concat(origin);
      for (let i = 0; i < arr.length; i++) {
        for (let j = i + 1; j < arr.length; j++) {
          if (arr[i] == arr[j]) {
            arr.splice(j, 1);
            j--;
          }
        }
      }
      return arr;
    }
    var arr = [1,1,2,5,6,3,5,5,6,8,9,8];
    console.log(unique(arr))
    ```

- 新建数组，利用 `indexOf` 或 `includes` 去重

  - ```js
    function unique (arr) {
      let res = []
      for (let i = 0; i < arr.length; i++) {
        if (!res.includes(arr[i])) {
          res.push(arr[i])
        }
      }
      return res;
    }
    var arr = [1,1,2,5,6,3,5,5,6,8,9,8];
    console.log(unique(arr))
    ```

- 先用 `sort `排序，然后用一个指针从第`0`位开始，配合 `while` 循环去重

  - ```js
    function unique (arr) {
      arr = arr.sort(); // 排序之后的数组
      let pointer = 0;
      while (arr[pointer]) {
        if (arr[pointer] != arr[pointer + 1]) { // 若这一项和下一项不相等则指针往下移
          pointer++;
        } else { // 否则删除下一项
          arr.splice(pointer + 1, 1);
        }
      }
      return arr;
    }
    var arr = [1,1,2,5,6,3,5,5,6,8,9,8];
    console.log(unique(arr))
    ```

    











#### 3-4、双向绑定

##### 3-4-1、defineProperty 实现

```js
// 数据
const data = {
  text: 'default'
};
const input = document.getElementById('input');
const span = document.getElementById('span');
// 数据劫持
Object.defineProperty(data, 'text', {
  // 数据变化 --> 修改视图
  set(newVal) {
    input.value = newVal;
    span.innerHTML = newVal;
  }
});
// 视图更改 --> 数据变化
input.addEventListener('keyup', function(e) {
  data.text = e.target.value;
});
```



##### 3-4-2、proxy 实现

```js
// 数据
const data = {
  text: 'default'
};
const input = document.getElementById('input');
const span = document.getElementById('span');
// 数据劫持
const handler = {
  set(target, key, value) {
    target[key] = value;
    // 数据变化 --> 修改视图
    input.value = value;
    span.innerHTML = value;
    return value;
  }
};
const proxy = new Proxy(data, handler);

// 视图更改 --> 数据变化
input.addEventListener('keyup', function(e) {
  proxy.text = e.target.value;
});
```



#### 3-5、函数相关

##### 3-5-1、柯里化

无时无刻不在使用柯里化函数，只是没有将它总结出来而已；其本质就是将一个参数很多的函数分解成单一参数的多个函数。

- 延迟计算 （用闭包把传入参数保存起来，当传入参数的数量足够执行函数时，开始执行函数）
- 动态创建函数 （参数不够时会返回接受剩下参数的函数）
- 参数复用（每个参数可以多次复用）

```
const curry = fn =>
  (judge = (...args) =>
    args.length >= fn.length
      ? fn(...args)
      : (...arg) => judge(...args, ...arg));

const sum = (a, b, c, d) => a + b + c + d;
const currySum = curry(sum);

currySum(1)(2)(3)(4); // 10
currySum(1, 2)(3)(4); // 10
currySum(1)(2, 3)(4); // 10
```



##### 3-5-X、Sleep 函数

实现一个 sleep 函数，比如 sleep(1000) 意味着等待1000毫秒，可从 Promise、Generator、Async/Await 等角度实现：

```js
// Promise
const sleep = time => {
  return new Promise(resolve => setTimeout(resolve,time))
}
sleep(1000).then(()=>{
  // ...
})

// Generator
function* sleepGenerator(time) {
  yield new Promise(function(resolve,reject){
    setTimeout(resolve,time);
  })
}
sleepGenerator(1000).next().value.then(()=>{console.log(1)})

// async
function sleep(time) {
  return new Promise(resolve => setTimeout(resolve,time))
}
async function output() {
  let out = await sleep(1000);
  // ...
  return out;
}
output();

// ES5
function sleep(callback,time) {
  if(typeof callback === 'function')
    setTimeout(callback,time)
}

function output(){
  // ...
}
sleep(output,1000);
```



##### 3-5-Y、LazyMan 函数 

```
LazyMan('Tony');
// Hi I am Tony

LazyMan('Tony').sleep(10).eat('lunch');
// Hi I am Tony
// 等待了10秒...
// I am eating lunch

LazyMan('Tony').eat('lunch').sleep(10).eat('dinner');
// Hi I am Tony
// I am eating lunch
// 等待了10秒...
// I am eating diner

LazyMan('Tony').eat('lunch').eat('dinner').sleepFirst(5).sleep(10).eat('junk food');
// Hi I am Tony
// 等待了5秒...
// I am eating lunch
// I am eating dinner
// 等待了10秒...
// I am eating junk food
```

```js
class LazyManClass {
    constructor(name) {
        this.taskList = [];
        this.name = name;
        console.log(`Hi I am ${this.name}`);
        setTimeout(() => {
            this.next();
        }, 0);
    }
    eat (name) {
        var that = this;
        var fn = (function (n) {
            return function () {
                console.log(`I am eating ${n}`)
                that.next();
            }
        })(name);
        this.taskList.push(fn);
        return this;
    }
    sleepFirst (time) {
        var that = this;
        var fn = (function (t) {
            return function () {
                setTimeout(() => {
                    console.log(`等待了${t}秒...`)
                    that.next();
                }, t * 1000);  
            }
        })(time);
        this.taskList.unshift(fn);
        return this;
    }
    sleep (time) {
        var that = this
        var fn = (function (t) {
            return function () {
                setTimeout(() => {
                    console.log(`等待了${t}秒...`)
                    that.next();
                }, t * 1000); 
            }
        })(time);
        this.taskList.push(fn);
        return this;
    }
    next () {
        var fn = this.taskList.shift();
        fn && fn();
    }
}
function LazyMan(name) {
    return new LazyManClass(name);
}
LazyMan('Tony').eat('lunch').eat('dinner').sleepFirst(5).sleep(4).eat('junk food');



// 1、简易版
class LazyManClass {
  constructor(name) {
    this.name = name
    this.queue = []
    console.log(`Hi I am ${name}`)
    setTimeout(() => {
      this.next()
    },0)
  }

  sleepFirst(time) {
    const fn = () => {
      setTimeout(() => {
        console.log(`等待了${time}秒...`)
        this.next()
      }, time)
    }
    this.queue.unshift(fn)
    return this
  }

  sleep(time) {
    const fn = () => {
      setTimeout(() => {
        console.log(`等待了${time}秒...`)
        this.next()
      },time)
    }
    this.queue.push(fn)
    return this
  }

  eat(food) {
    const fn = () => {
      console.log(`I am eating ${food}`)
      this.next()
    }
    this.queue.push(fn)
    return this
  }

  next() {
    const fn = this.queue.shift()
    fn && fn()
  }
}
function LazyMan(name) {
  return new LazyManClass(name)
}



// 2、Proxy 实现
function LazyMan(username) {
  console.log(' Hi I am ' + username);

  var temp = {
    taskList: [],
    sleepFirst(timeout) {
      return () => {
        setTimeout(() => {
          console.log(`等待了${timeout}秒...`);
          this.next();
        }, timeout * 1000);
      };
    },
    sleep(timeout) {
      return () => {
        setTimeout(() => {
          console.log(`等待了${timeout}秒...`);
          this.next();
        }, timeout * 1000);
      };
    },
    eat(type) {
      return () => {
        console.log(`I am eating ${type}`);
        this.next();
      };
    },
    next() {
      var fn = this.taskList.shift();
      fn && fn();
    }
  };

  var proxy = new Proxy(temp, {
    get(target, key, receiver) {
      return function(...rest) {
        if (key === 'sleepFirst') {
          target.taskList.unshift(target[key](rest));
        } else {
          target.taskList.push(target[key](rest));
        }
        return receiver;
      };
    }
  });

  setTimeout(() => {
    temp.next();
  }, 0);
  return proxy;
}
LazyMan('Tony').eat('lunch').eat('dinner').sleepFirst(5).sleep(10).eat('junk food');
// Hi I am Tony
// 等待了5秒...
// I am eating lunch
// I am eating dinner
// 等待了10秒...
// I am eating junk food



// 3、链表实现
class Node {
  constructor(func = null) {
    this.func = func;
    this.next = null;
  }

  async exec() {
    if (this.func) {
      await this.func();
    }
    if (this.next && this.next.func) {
      this.next.exec();
    }
  }
}

function delayFunc(delay) {
  return new Promise(resolve => {
    setTimeout(() => {
      console.log(`等待了${delay}秒...`);
      resolve();
    }, delay * 1000);
  });
}

class Lazy {
  constructor(name) {
    this.name = name;
    this.head = new Node();
    this.current = this.head;
    Promise.resolve().then(() => this.head.exec());
  }

  eat(sth) {
    const log = () => {
      console.log("I am eating " + sth);
    };
    this.current.next = new Node(log);
    this.current = this.current.next;
    return this;
  }

  sleep(delay) {
    this.current.next = new Node(() => delayFunc(delay));
    this.current = this.current.next;
    return this;
  }

  sleepFirst(delay) {
    let head = new Node(() => delayFunc(delay));
    if (!this.head.func) {
      head.next = this.head.next;
    } else {
      head.next = this.head;
    }
    this.head = head;
    return this;
  }
}

function LazyMan(name) {
  console.log("I am " + name);
  return new Lazy(name);
}
LazyMan('Tony').eat('lunch').eat('dinner').sleepFirst(5).sleep(10).eat('junk food');
```



#### 3-6、字符串相关

##### 3-6-1、逆序输出

```js
function reverse(str) {
  let res = str.split('');
  return res.reverse().join('');
}
reverse('hello world!'); // output: '!dlrow olleh'
```





#### 3-X、其他实现

##### 3-X-1、Cookie

```js
// 创建 cookie
var CookieUtil = {
	get: function (name) { 
    var cookieName = encodeURIComponent(name) + '=',
        cookieStart = document.cookie.indexOf(cookieName),
    		cookieValue = null;
    
    if (cookieStart > -1) { 
        var cookieEnd = document.cookie.indexOf(';', cookieStart); 
        if (cookieEnd == -1) { 
            cookieEnd = document.cookie.length;
        }
        cookieValue = decodeURIComponent(document.cookie.substring(cookieStart + cookieName.length, cookieEnd)); 
    }
    return cookieValue;
	},
	set: function (name, value, expires, path, domain, secure) { 
    var cookieText = encodeURIComponent(name) + '=' + encodeURIComponent(value); 
    if (expires instanceof Date) { 
        cookieText += '; expires=' + expires; 
    }
    if (path) { 
        cookieText += '; expires=' + expires; 
    }
    if (domain) { 
        cookieText += '; domain=' + domain; 
    }
    if (secure) { 
        cookieText += '; secure'; 
    }
    document.cookie = cookieText;
	},
  unset: function (name, path, domain, secure) { 
    this.set(name, "", new Date(0), path, domain, secure)
	}
}
```



##### 3-X-2、异步请求顺序执行

- 利用 `reduce`，初始值传入一个`Promise.resolve()`，之后往里面不停的叠加`.then()`

  - ```js
    const arr = [1, 2, 3]
    arr.reduce((p, x) => {
      return p.then(() => {
        return new Promise(r => {
          setTimeout(() => r(console.log(x)), 1000)
        })
      })
    }, Promise.resolve())
    
    // Way - 2
    const arr = [1, 2, 3]
    arr.reduce((p, x) => p.then(() => new Promise(r => setTimeout(() => r(console.log(x)), 1000))), Promise.resolve())
    // 每隔1秒输出1,2,3
    ```

- 利用 `forEach`，本质和 `reduce` 原理相同；

  - ```js
    const time = (timer) => {
      return new Promise(resolve => {
        setTimeout(() => {
          resolve()
        }, timer)
      })
    }
    const ajax1 = () => time(2000).then(() => {
      console.log(1);
      return 1
    })
    const ajax2 = () => time(1000).then(() => {
      console.log(2);
      return 2
    })
    const ajax3 = () => time(1000).then(() => {
      console.log(3);
      return 3
    })
    
    function mergePromise () {
      // 存放每个 ajax 的结果
      const data = [];
      let promise = Promise.resolve();
      ajaxArray.forEach(ajax => {
      	// 第一次的 then 为了用来调用 ajax
      	// 第二次的 then 是为了获取 ajax 的结果
        promise = promise.then(ajax).then(res => {
          data.push(res);
          return data; // 把每次的结果返回
        })
      })
      // 最后得到的 promise 它的值就是 data
      return promise;
    }
    
    mergePromise([ajax1, ajax2, ajax3]).then(data => {
      console.log("done");
      console.log(data); // data 为 [1, 2, 3]
    });
    
    // 1
    // 2
    // 3
    // done
    // [1, 2, 3]
    ```

- 用`ES9`中的`for...await...of`来实现

- Rxjs 实现；







### 四、ES6 实现

#### 4-1、let、const

##### 4-1-1、利用 IIFE 实现 let

```js
(function(){
  for(var i = 0; i < 5; i ++){
    console.log(i)  // 0 1 2 3 4
  }
})();
console.log(i)      // Uncaught ReferenceError: i is not defined
```

- var 声明的变量会挂到 window 上，而 let 和 const 不会；
- var 声明的变量存在变量提升，而 let 和 const 不会；
- let 和 const 声明形成块作用域，只能在块作用域里访问，不能跨块访问，也不能跨函数访问；
- 同一作用域下 let 和 const 不能声明同名变量，而 var 可以；
- 暂时性死区，let 和 const 声明的变量不能在声明前被使用；



##### 4-1-2、利用 defineProperty 实现 const

实现 const 的关键在于 `Object.defineProperty()` ，此API用于在一个对象上增加或修改属性；

通过配置属性描述符，可精确地控制属性行为；`Object.defineProperty(obj, prop, desc)` 其接收三个参数：

- obj：要在其上定义属性的对象；
- prop：要定义或修改的属性的名称；
- descriptor：将被定义或修改的属性描述符；
  - value：该属性对应的值；可以是任何有效的 JS 值(数值，对象，函数等)；
    - 默认为 undefined；
  - get：一个给属性提供 getter 的方法，若没有 getter 则为 undefined；
  - set：一个给属性提供 setter 的方法，若没有 setter 则为 undefined；
    - 当属性值修改时，触发执行该方法；
  - writable：当且仅当该属性的 writable 为 true 时，value 才能被赋值运算符改变；
    - 默认为 false；
  - enumerable：定义对象的属性是否可在 for...in 循环和 Object.keys() 中被枚举；
    - 默认为 false；
  - Configurable：表示对象属性是否可以被删除，以及除 value 和 writable 特性外的其他特性是否可被修改；
    - 默认为 false；

```js
function _const(key, value) {    
    const desc = {        
        value,        
        writable: false    
    }    
    Object.defineProperty(window, key, desc)
}
    
_const('obj', {a: 1})   // 定义obj
obj.b = 2               // 可以正常给obj的属性赋值
obj = {}                // 无法赋值新对象
```





### X、综合实现

#### X-1、完善 sum 并须调用 asyncAdd

完善sum函数，使得 sum(1,2,3,4,5,6) 函数返回值为 21 ,需要在 sum 函数中调用 asyncAdd 函数进行数值运算，且不能修改asyncAdd函数

```js
/**
 * 请在 sum函数中调用此函数，完成数值计算
 * @param {*} a 要相加的第一个值
 * @param {*} b 要相加的第二个值
 * @param {*} callback 相加之后的回调函数
 */
function asyncAdd(a,b,callback) {
  setTimeout(function(){
   callback(null, a+b)
  },1000)
}

/**
 * 请在此方法中调用asyncAdd方法，完成数值计算
 * @param  {...any} rest 传入的参数
 */
async function sum(...rest) {
  // 请在此处完善代码
}

let start = window.performance.now()
sum(1, 2, 3, 4, 5, 6).then(res => {
  // 请保证在调用sum方法之后，返回结果21
  console.log(res)
  console.log(`程序执行共耗时: ${window.performance.now() - start}`)
})
```

```js
// 输出大于 6秒
async function sum(...rest) {
  // 取出来第一个作为初始值
  let result = rest.shift()
  // 通过for of 遍历 rest, 依次相加
  for(let num of rest) {
    // 使用promise 获取相加结果
    result = await new Promise(resolve => {
      asyncAdd(result, num, (_,res) => {
        resolve(res)
      })
    })
  }
  // 返回执行结果
  return result
}

// 执行成功，执行时长大于6秒
sum1(1, 2, 3, 4, 5,6).then(res => {
  console.log(`计算结果为:${res}`)
})

// 输出大于 3 秒
// 原理: 并发执行多个，比如 sum(1,2,3,4,5,6)，可以同时执行 1+2,3+4,5+6
async function sum(...rest) {
  // 如果传的值少于2个，则直接返回
  if (rest.length <= 1) {
    return rest[0] || 0
  }
  const promises = []
  // 遍历将数组里面的值两个两个的执行
  for (let i = 0; i < rest.length; i += 2) {
    promises.push(
      new Promise(resolve => {
        // 如果 rest[i+1] 是 undefined, 说明数组长度是奇数，这个是最后一个
        if (rest[i + 1] === undefined) {
          resolve(rest[i])
        } else {
          // 调用asyncAdd 进行计算
          asyncAdd(rest[i], rest[i + 1], (_, result) => {
            resolve(result)
          })
        }
      })
    )
  }
  // 获取第一次计算结果
  const result = await Promise.all(promises)
  // 然后将第一次获取到的结果即 [3,7,11] 再次调用 sum执行
  return await sum(...result)
}

// 执行成功，执行时长大于3秒小于4秒
sum1(1, 2, 3, 4, 5,6).then(res => {
  console.log(`计算结果为:${res}`)
})


// 输出大于 1秒
// 原理: 利用 Promise.all 并发执行 + Obj.toString 隐式转换
async function sum(...rest) {
  let result = 0
  // 隐氏类型转换， 对象 + 数字，会先调用对象的toString 方法
  const obj = {}
  obj.toString = function() {
    return result
  }
  const promises = []
  for(let num of rest) {
    promises.push(new Promise((resolve) => {
      asyncAdd(obj, num, (_, res) => {
        resolve(res)
      })
    }).then(res => {
      // 在这里将 result的值改变之后，obj.toString 的返回值就变了，这时候下一个setTimeout调用时就使用了新值
      result = res
    }))
  }
  await Promise.all(promises)
  return result
}

// 执行成功，执行时长大于1秒小于2秒
sum1(1, 2, 3, 4, 5,6).then(res => {
  console.log(`计算结果为:${res}`)
})
```

