---
typora-root-url: ../../Source
---



### 一、数组相关

右移操作，将前面的空位用0填充，可用于保证某变量为数字且为整数

```js
null >>> 0  //0

undefined >>> 0  //0

void(0) >>> 0  //0

function a (){};  a >>> 0  //0

[] >>> 0  //0

var a = {}; a >>> 0  //0

123123 >>> 0  //123123

45.2 >>> 0  //45

0 >>> 0  //0

-0 >>> 0  //0

-1 >>> 0  //4294967295

-1212 >>> 0  //4294966084
```



#### 1-1、map

<img src="/Image/Basics/Special/API/1.png" style="zoom:50%;" align="left" />

```js
// 关键: 使用 in 来进行原型链查找。同时，如果没有找到就不处理，能有效处理稀疏数组的情况
Array.prototype.map = function(callbackFn, thisArg) {
  // 处理数组类型异常
  if (this === null || this === undefined) {
    throw new TypeError("Cannot read property 'map' of null or undefined");
  }
  // 处理回调类型异常
  if (Object.prototype.toString.call(callbackfn) != "[object Function]") {
    throw new TypeError(callbackfn + ' is not a function')
  }
  // 草案中提到要先转换为对象
  let O = Object(this);
  let T = thisArg;

  
  let len = O.length >>> 0;
  let A = new Array(len);
  for(let k = 0; k < len; k++) {
    // 还记得原型链那一节提到的 in 吗？in 表示在原型链查找
    // 如果用 hasOwnProperty 是有问题的，它只能找私有属性
    if (k in O) {
      let kValue = O[k];
      // 依次传入this, 当前项，当前索引，整个数组
      let mappedValue = callbackfn.call(T, KValue, k, O);
      A[k] = mappedValue;
    }
  }
  return A;
}


// V8 实现
function ArrayMap(f, receiver) {
  CHECK_OBJECT_COERCIBLE(this, "Array.prototype.map");

  // Pull out the length so that modifications to the length in the
  // loop will not affect the looping and side effects are visible.
  var array = TO_OBJECT(this);
  var length = TO_LENGTH(array.length);
  if (!IS_CALLABLE(f)) throw %make_type_error(kCalledNonCallable, f);
  var result = ArraySpeciesCreate(array, length);
  for (var i = 0; i < length; i++) {
    if (i in array) {
      var element = array[i];
      %CreateDataProperty(result, i, %_Call(f, receiver, element, i, array));
    }
  }
  return result;
}
```



#### 1-2、reduce

<img src="/Image/Basics/Special/API/2.png" style="zoom:50%;" align="left" />

```js
// 关键: 初始值不传怎么处理、回调函数的参数有哪些，返回值如何处理；
// 关键: 从最后一项开始遍历，通过原型链查找跳过空项
Array.prototype.reduce  = function(callbackfn, initialValue) {
  // 异常处理，和 map 一样
  // 处理数组类型异常
  if (this === null || this === undefined) {
    throw new TypeError("Cannot read property 'reduce' of null or undefined");
  }
  // 处理回调类型异常
  if (Object.prototype.toString.call(callbackfn) != "[object Function]") {
    throw new TypeError(callbackfn + ' is not a function')
  }
  let O = Object(this);
  let len = O.length >>> 0;
  let k = 0;
  let accumulator = initialValue;
  if (accumulator === undefined) {
    for(; k < len ; k++) {
      // 查找原型链
      if (k in O) {
        accumulator = O[k];
        k++;
        break;
      }
    }
  }
  // 表示数组全为空
  if(k === len && accumulator === undefined) 
    throw new Error('Each element of the array is empty');
  for(;k < len; k++) {
    if (k in O) {
      // 注意，核心！
      accumulator = callbackfn.call(undefined, accumulator, O[k], k, O);
    }
  }
  return accumulator;
}


// V8 实现
function ArrayReduce(callback, current) {
  CHECK_OBJECT_COERCIBLE(this, "Array.prototype.reduce");

  // Pull out the length so that modifications to the length in the
  // loop will not affect the looping and side effects are visible.
  var array = TO_OBJECT(this);
  var length = TO_LENGTH(array.length);
  return InnerArrayReduce(callback, current, array, length,
                          arguments.length);
}

function InnerArrayReduce(callback, current, array, length, argumentsLength) {
  if (!IS_CALLABLE(callback)) {
    throw %make_type_error(kCalledNonCallable, callback);
  }

  var i = 0;
  find_initial: if (argumentsLength < 2) {
    for (; i < length; i++) {
      if (i in array) {
        current = array[i++];
        break find_initial;
      }
    }
    throw %make_type_error(kReduceNoInitial);
  }

  for (; i < length; i++) {
    if (i in array) {
      var element = array[i];
      current = callback(current, element, i, array);
    }
  }
  return current;
}
```



#### 1-3、push/pop

<img src="/Image/Basics/Special/API/3.png" style="zoom:50%;" align="left" />

```js
// push
Array.prototype.push = function(...items) {
  let O = Object(this);
  let len = this.length >>> 0;
  let argCount = items.length >>> 0;
  // 2 ** 53 - 1 为JS能表示的最大正整数
  if (len + argCount > 2 ** 53 - 1) {
    throw new TypeError("The number of array is over the max value restricted!")
  }
  for(let i = 0; i < argCount; i++) {
    O[len + i] = items[i];
  }
  let newLength = len + argCount;
  O.length = newLength;
  return newLength;
}

// pop
Array.prototype.pop = function() {
  let O = Object(this);
  let len = this.length >>> 0;
  if (len === 0) {
    O.length = 0;
    return undefined;
  }
  len --;
  let value = O[len];
  delete O[len];
  O.length = len;
  return value;
}
```



#### 1-4、filter

<img src="/Image/Basics/Special/API/4.png" style="zoom:50%;" align="left" />

```js
Array.prototype.filter = function(callbackfn, thisArg) {
  // 处理数组类型异常
  if (this === null || this === undefined) {
    throw new TypeError("Cannot read property 'filter' of null or undefined");
  }
  // 处理回调类型异常
  if (Object.prototype.toString.call(callbackfn) != "[object Function]") {
    throw new TypeError(callbackfn + ' is not a function')
  }
  let O = Object(this);
  let len = O.length >>> 0;
  let resLen = 0;
  let res = [];
  for(let i = 0; i < len; i++) {
    if (i in O) {
      let element = O[i];
      if (callbackfn.call(thisArg, O[i], i, O)) {
        res[resLen++] = element;
      }
    }
  }
  return res;
}
```



### 二、常用 API 相关

#### 2-1、instance of

```js
function myInstanceof(left, right) {
    // 基本数据类型直接返回 false
    if(typeof left !== 'object' || left === null) return false;
    // getProtypeOf是 Object 对象自带的一个方法，能够拿到参数的原型对象
    let proto = Object.getPrototypeOf(left);
    while(true) {
        // 查找到尽头，还没找到
        if(proto == null) return false;
        // 找到相同的原型对象
        if(proto == right.prototype) return true;
        proto = Object.getPrototypeOf(proto);
    }
}
```

#### 2-2、Object

##### 2-2-1、Object.is

```js
function is(x, y) {
  if (x === y) {
    // 运行到 1/x === 1/y 时 x 和 y 都为 0，但是 1/+0 = +Infinity， 1/-0 = -Infinity, 是不一样的
    return x !== 0 || y !== 0 || 1 / x === 1 / y;
  } else {
    // NaN===NaN 是 false, 这是不对的，在这里做一个拦截，x !== x，那么一定是 NaN, y 同理
    // 两个都是 NaN 时返回 true
    return x !== x && y !== y;
  }
}
```



#### 2-3、绑定

##### 2-3-1、new

new 被调用后做了如下事情：

- 让实例可以访问到私有属性
- 让实例可以访问构造函数原型(constructor.prototype)所在原型链上的属性
- 若构造函数返回的结果不是引用数据类型

```js
function newOperator(ctor, ...args) {
    if(typeof ctor !== 'function'){
      throw 'newOperator function the first param must be a function';
    }
    let obj = Object.create(ctor.prototype);
    let res = ctor.apply(obj, args);
    
    let isObject = typeof res === 'object' && res !== null;
    let isFunction = typoof res === 'function';
    return isObect || isFunction ? res : obj;
};
```



##### 2-3-2、bind

bind 被调用后做了如下事情：

- 对于普通函数，绑定this指向
- 对于构造函数，要保证原函数的原型对象上的属性不能丢失

```js
Function.prototype.bind = function (context, ...args) {
    // 异常处理
    if (typeof this !== "function") {
      throw new Error("Function.prototype.bind - what is trying to be bound is not callable");
    }
    // 保存this的值，它代表调用 bind 的函数
    var self = this;
  
  	// 处理实现1:
    var fNOP = function () {};
    var fbound = function () {
        self.apply(this instanceof self ? 
            this : 
            context, args.concat(Array.prototype.slice.call(arguments)));
    }
    fNOP.prototype = this.prototype;
    fbound.prototype = new fNOP();
  
  	// 处理实现2:
  	var fbound = function () {
        self.apply(this instanceof self ? 
            this : 
            context, args.concat(Array.prototype.slice.call(arguments)));
    }
    fbound.prototype = Object.create(self.prototype);
  
    return fbound;
}
```



##### 2-3-3、call/apply

```js
Function.prototype.call = function (context) {
    let context = context || window;
    let fn = Symbol('fn');
    context.fn = this;

    let args = [];
    for(let i = 1, len = arguments.length; i < len; i++) {
        args.push('arguments[' + i + ']');
    }

    let result = eval('context.fn(' + args +')');

    delete context.fn
    return result;
}

// ES6 版本
Function.prototype.call = function (context, ...args) {
  let context = context || window;
  let fn = Symbol('fn');
  context.fn = this;

  let result = eval('context.fn(...args)');

  delete context.fn
  return result;
}
```



```js
Function.prototype.apply = function (context, args) {
  let context = context || window;
  context.fn = this;
  let result = eval('context.fn(...args)');

  delete context.fn
  return result;
}
```





### 三、常用实现

#### 3-1、arguments 转换

arguments 本身无法调用数组方法，因其是类数组：属性从 0 开始排序，并有 callee、length属性；常见的类数组还有：

- 用 getElementsByTagName/ClassName() 获得的 HTMLCollection；
- 用 querySelector 获得的 nodeList；

类数组无法使用数组方法，但必要时可将它们转换成数组：

##### 3-1-1、Array.prototype.slice.call

```js
function sum(a, b) {
  let args = Array.prototype.slice.call(arguments);
  console.log(args.reduce((sum, cur) => sum + cur));// args可以调用数组原生的方法啦
}
sum(1, 2);// 3
```

##### 3-1-2、Array.from

```js
function sum(a, b) {
  let args = Array.from(arguments);
  console.log(args.reduce((sum, cur) => sum + cur));// args可以调用数组原生的方法啦
}
sum(1, 2);// 3
```

这种方法也可以用来转换Set和Map哦！

##### 3-1-3、ES6 展开运算符

```js
function sum(a, b) {
  let args = [...arguments];
  console.log(args.reduce((sum, cur) => sum + cur));// args可以调用数组原生的方法啦
}
sum(1, 2);// 3
```

##### 3-1-4、利用 concat + apply

```js
function sum(a, b) {
  let args = Array.prototype.concat.apply([], arguments);// apply方法会把第二个参数展开
  console.log(args.reduce((sum, cur) => sum + cur));// args可以调用数组原生的方法啦
}
sum(1, 2);// 3
```



#### 3-2、深浅拷贝

##### 3-2-1、浅拷贝

##### 3-2-1-1、手动实现

```js
const shallowClone = (target) => {
  if (typeof target === 'object' && target !== null) {
    const cloneTarget = Array.isArray(target) ? []: {};
    for (let prop in target) {
      if (target.hasOwnProperty(prop)) {
          cloneTarget[prop] = target[prop];
      }
    }
    return cloneTarget;
  } else {
    return target;
  }
}
```

##### 3-2-1-2、Object.assign

```js
let obj = { name: 'sy', age: 18 };
const obj2 = Object.assign({}, obj, {name: 'sss'});
console.log(obj2); // { name: 'sss', age: 18 }
// 注意：Object.assgin() 拷贝的是对象的属性的引用，而非对象本身；
```

##### 3-2-1-3、concat 浅拷贝数组

```js
let arr = [1, 2, 3];
let newArr = arr.concat();
newArr[1] = 100;
console.log(arr); // [ 1, 2, 3 ]
```

##### 3-2-1-4、slice 浅拷贝

```js
let arr = [1, 2, 3];
let newArr = arr.slice();
newArr[0] = 100;
console.log(arr); // [1, 2, 3]
```



##### 3-2-1-5、ES6 展开运算符

```js
let arr = [1, 2, 3];
let newArr = [...arr]; // 跟 arr.slice() 一样效果
```




##### 3-2-2、深拷贝

##### 3-2-2-1、简易版

```js
JSON.parse(JSON.stringify());
```

- 无法解决 <u>循环引用</u> 的问题：`const a = {val:2};  a.target = a;`，会出现无限递归，导致系统栈溢出；
- 无法拷贝某些特殊对象，诸如 RegExp, Date, Set, Map 等；
- 无法拷贝函数；

```js
const deepClone = (target) => {
  // 引用类型判断
  if (typeof target === 'object' && target !== null) {
    // 初始值选取
    const cloneTarget = Array.isArray(target) ? []: {};
    // 迭代操作
    for (let prop in target) {
      if (target.hasOwnProperty(prop)) {
          cloneTarget[prop] = deepClone(target[prop]);
      }
    }
    return cloneTarget;
  } else {
    return target;
  }
}
```



##### 3-2-2-2、解决循环引用

关键：创建 Map，记录已拷贝过的对象，若已拷贝过则直接返回；

```js
// 判断
const isObject = (target) => (typeof target === 'object' || typeof target === 'function') && target !== null;
const deepClone = (target, map = new Map()) => { 
  // 若已拷贝过则直接返回
  if(map.get(target)) return target; 
  if (isObject(target)) { 
    // 记录已拷贝过的对象
    map.set(target, true); 
    // 迭代操作
    const cloneTarget = Array.isArray(target) ? []: {}; 
    for (let prop in target) { 
      if (target.hasOwnProperty(prop)) { 
          cloneTarget[prop] = deepClone(target[prop],map); 
      } 
    } 
    return cloneTarget; 
  } else { 
    return target; 
  } 
}

// 测试
const a = {val:2};
a.target = a;
let newA = deepClone(a);
console.log(newA) // { val: 2, target: { val: 2, target: [Circular] } }
```

##### 3-2-2-2-1、强引用与 WeakMap

上面 map 上的 key 与 map 构成了 <u>强引用关系</u>：

- 在计算机程序设计中，<u>弱引用与强引用相对</u>， 是指不能确保其引用的对象不会被垃圾回收器回收的引用； <u>一个对象若只被弱引用所引用，则被认为是不可访问（或弱可访问）的，并因此可能在任何时刻被回收</u>；
- 即**<u>被弱引用的对象可在任何时候被回收</u>**，**<u>但对于强引用来说，只要这个强引用还在，那么对象无法被回收</u>**；比如 map 和 a 一直是强引用的关系， 在程序结束之前，a 所占的内存空间一直不会被释放；

所以，使 map 上的 key 与 map 构成弱引用关系即可，可利用 ES6 WeakMap 实现，WeakMap 是一种特殊的Map, 其中的键是`弱引用`的；<u>其键必须是对象，而值可以是任意的</u>；

```js
// 判断
const isObject = (target) => (typeof target === 'object' || typeof target === 'function') && target !== null;
const deepClone = (target, map = new WeakMap()) => { 
  // 若已拷贝过则直接返回
  if(map.get(target)) return target; 
  if (isObject(target)) { 
    // 记录已拷贝过的对象
    map.set(target, true); 
    // 迭代操作
    const cloneTarget = Array.isArray(target) ? []: {}; 
    for (let prop in target) { 
      if (target.hasOwnProperty(prop)) { 
          cloneTarget[prop] = deepClone(target[prop],map); 
      } 
    } 
    return cloneTarget; 
  } else { 
    return target; 
  } 
}
```



##### 3-2-2-3、实现特殊对象拷贝

##### 3-2-2-3-1、可继续遍历对象

关键：鉴别对象并进行分类处理；

```js
const getType = Object.prototype.toString.call(obj);
const isObject = (target) => (typeof target === 'object' || typeof target === 'function') && target !== null;

// 可继续遍历
const canTraverse = {
  '[object Map]': true,
  '[object Set]': true,
  '[object Array]': true,
  '[object Object]': true,
  '[object Arguments]': true,
};

const deepClone = (target, map = new Map()) => {
  if(!isObject(target)) return target;
  let type = getType(target);
  let cloneTarget;
  if(!canTraverse[type]) {
    // 处理不能遍历的对象
    return;
  } else {
    // 这波操作相当关键，可以保证对象的原型不丢失！
    let ctor = target.prototype;
    cloneTarget = new ctor();
  }

  if(map.get(target)) return target;
  map.put(target, true);

  // 处理Map
  if(type === mapTag) {
    target.forEach((item, key) => {
      cloneTarget.set(deepClone(key), deepClone(item));
    })
  }
  
  // 处理Set
  if(type === setTag) {
    target.forEach(item => {
      target.add(deepClone(item));
    })
  }

  // 处理数组和对象
  for (let prop in target) {
    if (target.hasOwnProperty(prop)) {
        cloneTarget[prop] = deepClone(target[prop]);
    }
  }
  return cloneTarget;
}
```



##### 3-2-2-3-2、不可继续遍历对象

```js
const boolTag = '[object Boolean]';
const numberTag = '[object Number]';
const stringTag = '[object String]';
const dateTag = '[object Date]';
const errorTag = '[object Error]';
const regexpTag = '[object RegExp]';
const funcTag = '[object Function]';

const handleRegExp = (target) => {
  const { source, flags } = target;
  return new target.constructor(source, flags);
}

const handleFunc = (target) => {
  // 待会的重点部分
}

const handleNotTraverse = (target, tag) => {
  const Ctor = targe.constructor;
  switch(tag) {
    case boolTag:
    case numberTag:
    case stringTag:
    case errorTag: 
    case dateTag:
      return new Ctor(target);
    case regexpTag:
      return handleRegExp(target);
    case funcTag:
      return handleFunc(target);
    default:
      return new Ctor(target);
  }
}
```



##### 3-2-2-4、实现函数拷贝

函数也是对象，但因过于特殊，故单独拆解，JS 有两种函数：一种是普通函数，另一种是箭头函数；每个普通函数都是 Function 的实例，而箭头函数不是任何类的实例，每次调用都是不一样的引用；所以**<u>只需处理普通函数的情况，箭头函数直接返回它本身即可；可利用原型，判断箭头函数，因其是不存在原型的；</u>**

```js
const handleFunc = (func) => {
  // 箭头函数直接返回自身
  if(!func.prototype) return func;
  const bodyReg = /(?<={)(.|\n)+(?=})/m;
  const paramReg = /(?<=\().+(?=\)\s+{)/;
  const funcString = func.toString();
  // 分别匹配 函数参数 和 函数体
  const param = paramReg.exec(funcString);
  const body = bodyReg.exec(funcString);
  if(!body) return null;
  if (param) {
    const paramArr = param[0].split(',');
    return new Function(...paramArr, body[0]);
  } else {
    return new Function(body[0]);
  }
}
```

注意：修复bug：

```js
const target = new Boolean(false);
const Ctor = target.constructor;
new Ctor(target); // 结果为 Boolean {true} 而应该是 false；
// 解决：调用valueOf: new target.constructor(target.valueOf())。
// 但实际上，这种写法是不推荐的。因为在ES6后不推荐使用 [new 基本类型()] 这样的语法，所以 es6 中的新类型 Symbol 是不能直接 new 的，只能通过 new Object(SymbelType)
```



##### 3-2-2-5、完成版

```js
const getType = obj => Object.prototype.toString.call(obj);
const isObject = (target) => (typeof target === 'object' || typeof target === 'function') && target !== null;

const canTraverse = {
  '[object Map]': true,
  '[object Set]': true,
  '[object Array]': true,
  '[object Object]': true,
  '[object Arguments]': true,
};
const mapTag = '[object Map]';
const setTag = '[object Set]';
const boolTag = '[object Boolean]';
const numberTag = '[object Number]';
const stringTag = '[object String]';
const symbolTag = '[object Symbol]';
const dateTag = '[object Date]';
const errorTag = '[object Error]';
const regexpTag = '[object RegExp]';
const funcTag = '[object Function]';

const handleRegExp = (target) => {
  const { source, flags } = target;
  return new target.constructor(source, flags);
}

const handleFunc = (func) => {
  // 箭头函数直接返回自身
  if(!func.prototype) return func;
  const bodyReg = /(?<={)(.|\n)+(?=})/m;
  const paramReg = /(?<=\().+(?=\)\s+{)/;
  const funcString = func.toString();
  // 分别匹配 函数参数 和 函数体
  const param = paramReg.exec(funcString);
  const body = bodyReg.exec(funcString);
  if(!body) return null;
  if (param) {
    const paramArr = param[0].split(',');
    return new Function(...paramArr, body[0]);
  } else {
    return new Function(body[0]);
  }
}

const handleNotTraverse = (target, tag) => {
  // 关键: 保证对象的原型不丢失！
  const Ctor = target.constructor;
  switch(tag) {
    case boolTag:
      return new Object(Boolean.prototype.valueOf.call(target));
    case numberTag:
      return new Object(Number.prototype.valueOf.call(target));
    case stringTag:
      return new Object(String.prototype.valueOf.call(target));
    case symbolTag:
      return new Object(Symbol.prototype.valueOf.call(target));
    case errorTag: 
    case dateTag:
      return new Ctor(target);
    case regexpTag:
      return handleRegExp(target);
    case funcTag:
      return handleFunc(target);
    default:
      return new Ctor(target);
  }
}

const deepClone = (target, map = new WeakMap()) => {
  if(!isObject(target)) 
    return target;
  let type = getType(target);
  let cloneTarget;
  if(!canTraverse[type]) {
    // 处理不能遍历的对象
    return handleNotTraverse(target, type);
  } else {
    // 关键: 保证对象的原型不丢失！
    let ctor = target.constructor;
    cloneTarget = new ctor();
  }

  if(map.get(target)) 
    return target;
  map.set(target, true);

  // 处理Map
  if(type === mapTag) {
    target.forEach((item, key) => {
      cloneTarget.set(deepClone(key, map), deepClone(item, map));
    })
  }
  
  // 处理Set
  if(type === setTag) {
    target.forEach(item => {
      cloneTarget.add(deepClone(item, map));
    })
  }

  // 处理数组和对象
  for (let prop in target) {
    if (target.hasOwnProperty(prop)) {
        cloneTarget[prop] = deepClone(target[prop], map);
    }
  }
  return cloneTarget;
}
```





#### 3-3、数组扁平化

扁平化即多维数组转为一维数组：`[1, [2, [3, [4, 5]]], 6];// -> [1, 2, 3, 4, 5, 6]`

##### 3-3-1、ES6 flat

```js
ary = ary.flat(Infinity);
```

##### 3-3-2、replace + split

```js
ary = str.replace(/(\[|\])/g, '').split(',')
```

##### 3-3-3、replace + JSON.parse

```js
str = str.replace(/(\[|\])/g, '');
str = '[' + str + ']';
ary = JSON.parse(str);
```

##### 3-3-4、普通递归

```js
let result = [];
let fn = function(ary) {
  for(let i = 0; i < ary.length; i++) {
    let item = ary[i];
    if (Array.isArray(ary[i])){
      fn(item);
    } else {
      result.push(item);
    }
  }
}
```

##### 3-3-5、利用 reduce 函数迭代

```js
function flatten(ary) {
    return ary.reduce((pre, cur) => {
        return pre.concat(Array.isArray(cur) ? flatten(cur) : cur);
    }, []);
}
let ary = [1, 2, [3, 4], [5, [6, 7]]]
console.log(flatten(ary))
```

##### 3-3-6、ES6 展开运算符

```js
//只要有一个元素有数组，那么循环继续
while (ary.some(Array.isArray)) {
  ary = [].concat(...ary);
}
```





#### 3-4、数组寻值

##### 3-4-1、indexOf(ele)

```js
// 判断数组中是否存在某个值，如果存在，则返回数组元素的下标，否则返回-1
var arr=[1,2,3,4];
var index=arr.indexOf(3);
console.log(index);
```

##### 3-4-2、includes(ele [,fromIndex])

```js
// 判断数组中是否存在某个值，如果存在返回 true，否则返回 false
var arr=[1,2,3,4];
if(arr.includes(3))
    console.log("存在");
else
    console.log("不存在");
```

##### 3-4-3、find(cb [,thisArg])

```js
// 数组中满足条件的第一个元素的值，如果没有，返回 undefined
var arr=[1,2,3,4];
var result = arr.find(item =>{
    return item > 3
});
console.log(result);
```

##### 3-4-4、findeIndex(cb [,thisArg])

```js
// 返回数组中满足条件的第一个元素的下标，如果没有找到，返回 -1
var arr=[1,2,3,4];
var result = arr.findIndex(item =>{
    return item > 3
});
console.log(result);
```


