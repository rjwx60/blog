---
typora-root-url: ../../Source
---



### 一、基本

#### 1-1、数据类型

基本数据类型

- boolean
- null
- undefined
- number
- string
- symbol
- bigint

引用数据类型：对象 Object，包含

- 普通对象-Object；
- 数组对象-Array；
- 正则对象-RegExp；
- 日期对象-Date；
- 数学函数-Math；
- 函数对象-Function；



#### 1-X、注意事项

##### 1-X-1、null

虽然 typeof null 会输出 object，但这只是 JS 存在的一个悠久 Bug：

JS 的最初版本中使用是 32 位系统，为性能考虑使用低位存储变量的类型信息，000 开头代表是对象然而 null 表示为全零，故将它错误的判断为 object；



##### 1-X-2、基本包装类型

```js
// '1'.toString() 之所以能执行
// 是因为语句运行的过程中做了这样几件事情:

// 1、创建 Object 类实例
// 注意: 目前 ES6 规范不建议用 new 来创建基本类型的包装类；而由于 Symbol 和 BigInt 的出现，对它们调用 new 都会报错
var s = new Object('1');
// 2、调用实例方法
s.toString();
// 3、执行完方法立即销毁这个实例
s = null;
```

整个过程体现 **<u>基本包装类型</u>** 的性质，而基本包装类型恰恰属于基本数据类型，包括 Boolean、Number、String；



##### 1-X-3、精度问题

0.1和0.2在转换成二进制后会无限循环，由于标准位数的限制后面多余的位数会被截掉，此时就已经出现了精度的损失，相加后因浮点数小数位的限制而截断的二进制数字在转换为十进制就会变成0.30000000000000004；



##### 1-X-3-1、精度现状

在JS中，所有的数字都以双精度 64 位浮点格式表示，这导致 JS 中的 Number 无法精确表示非常大的整数，还会将非常大的整数四舍五入；确切地说：JS 中的Number 类型只能安全地表示 `-9007199254740991 (-(2^53-1)) 和  9007199254740991 ((2^53-1))间的数`，任何超出此范围的整数值都可能失去精度；

```js
console.log(999999999999999);  //=>10000000000000000
```

同时也会有一定的安全性问题:

```js
9007199254740992 === 9007199254740993;    // → true
```



##### 1-X-3-1、精度解决—BigInt

BigInt 是一种新的数据类型，用于当整数值大于 Number 数据类型支持的范围时；这种数据类型允许安全地对 `大整数`  执行算术操作，表示高分辨率的时间戳，使用大整数 id 等等，而不需要使用库；

##### 1-X-3-1-1、创建

```js
// 1、在数字末尾追加 n 创建 BigInt
console.log( 9007199254740995n );    // → 9007199254740995n	
console.log( 9007199254740995 );     // → 9007199254740996
// 2、使用 BigInt() 构造函数创建 BigInt
BigInt("9007199254740995");    // → 9007199254740995n
```

##### 1-X-3-1-2、使用

```js
10n + 20n;    // → 30n	
10n - 20n;    // → -10n	
+10n;         // → TypeError: Cannot convert a BigInt value to a number	
-10n;         // → -10n	
10n * 20n;    // → 200n	
20n / 10n;    // → 2n	
23n % 10n;    // → 3n	
10n ** 3n;    // → 1000n	

const x = 10n;	
++x;          // → 11n	
--x;          // → 9n
console.log(typeof x);   //"bigint"
```

##### 1-X-3-1-3、注意事项

- BigInt 不支持一元加号运算符，可能是某些程序可能依赖于 + 始终生成 Number 的不变量，或抛出异常；另外，更改 + 的行为也会破坏 asm.js 代码；
- 因隐式类型转换可能丢失信息，故不允许在 bigint 和 Number 间进行混合操作；
  - 当混合使用大整数和浮点数时，结果值可能无法由 BigInt 或 Number 精确表示；

```
10 + 10n;    // → TypeError
```

- 不能将 BigInt 传递给 Web api 和内置的 JS 函数，这些函数需要一个 Number 类型的数字；尝试这样做会报 TypeError 错误；

```
Math.max(2n, 4n, 6n);    // → TypeError
```

- 当 Boolean 类型与 BigInt 类型相遇时，BigInt 的处理方式与 Number 类似，即只要不是 0n，BigInt 即会被视为 truthy 值；

```
if(0n){ // 条件判断为false
}
if(3n){ // 条件为true
}
```

- 元素均为 BigInt 的数组可进行 sort；
- BigInt 可正常地进行位运算，如|、&、<<、>>、^；



##### 1-X-3-1-4、兼容性

<img src="/Image/Basics/Special/Mode/3.png" style="zoom:50%;" align="left" />



### 二、检测

#### 2-1、type of

**<u>对于原始类型，除 null 外，均可显示正确类型；</u>**

```js
typeof 1 // 'number'
typeof '1' // 'string'
typeof undefined // 'undefined'
typeof true // 'boolean'
typeof Symbol() // 'symbol'
```

**<u>对于引用数据类型，除函数外，均显示 `"object"`</u>**

```js
typeof [] // 'object'
typeof {} // 'object'
typeof console.log // 'function'
```

**<u>使用 instance of 判断基本类型值</u>** [MDN上关于hasInstance的解释](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/hasInstance)

```js
class PrimitiveNumber {
  static [Symbol.hasInstance](x) {
    return typeof x === 'number'
  }
}
console.log(111 instanceof PrimitiveNumber) // true
// 原理是使用 instanceof 方法重定义，换成 typeof
```



#### 2-2、instance of



#### 2-3、万能法

- 基本类型 `null`：使用 `String(null)`
- 基本类型 (`string / number / boolean / undefined`) + `function`：直接使用 `typeof`；
- 其余引用类型(`Array / Date / RegExp Error`)：调用 `toString` 后根据 `[object XXX]` 进行判断；

```js
let class2type = {}
'Array Date RegExp Object Error'.split(' ').forEach(e => class2type[ '[object ' + e + ']' ] = e.toLowerCase()) 

function type(obj) {
    if (obj == null) return String(obj)
    return typeof obj === 'object' ? class2type[ Object.prototype.toString.call(obj) ] || 'object' : typeof obj
}
```



### 三、转换

#### 3-1、基本

##### 3-1-1、基本

JS中，类型转换只有三种：

- 转换成数字
- 转换成布尔值
- 转换成字符串

<img src="/Image/Basics/Special/Data/1.png" style="zoom:50%;" align="left" />



##### 3-1-2、运算符转换

JS 中在使用运算符号或者对比符时，会自带隐式转换，规则如下:

- -、*、/、% ：一律转换成数值后计算
- +：
  - 数字 + 字符串 = 字符串， 运算顺序是从左到右
  - 数字 + 对象， 优先调用对象的`valueOf` -> `toString`
  - 数字 + `boolean/null` -> 数字
  - 数字 + `undefined` -> `NaN`
- `[1].toString() === '1'`
- `{}.toString() === '[object object]'`
- `NaN` !== `NaN` 、`+undefined 为 NaN`





#### 3-X、注意事项

##### 3-X、Object.is 与 === 区别

Object 在严格等于的基础上修复了一些特殊情况下的失误，具体来说就是 +0 和 -0，NaN 和 NaN；



##### 3-X、=== 与 == 区别

===：严格相等，左右两边不仅值要相等，类型也要相等；例如'1'===1的结果是false，因为一边是string，另一边是number。

==：值相等，但涉及一些类型转换，**<u>== 的转换规则</u>** 如下：

- 两边的类型是否相同，相同则比较值大小；比如 1 == 2，返回 false
- 判断对象是否是 null 和 undefined，是则返回 true；
- 判断对象的类型是否是 String 和 Number，是则将 String 类型转换成 Number，再进行比较；
- 判断其中一方是否是 Boolean，是则将 Boolean 转换成 Number，再进行比较；
- 若其中一方为 Object，且另一方为 String、Number 或 Symbol，则将 Object 转换成字符串，再进行比较；
  - **<u>对象转原始类型</u>**：会调用内置的 [ToPrimitive] 函数，函数操作逻辑如下：
    - 若存在 Symbol.toPrimitive() 方法，则优先调用并返回；
    - 调用 valueOf()，若转换为原始类型，则返回；
    - 调用 toString()，若转换为原始类型，则返回；
    - 若均无返回原始类型，会报错；

```js
// example1:
console.log({a: 1} == true);//false
console.log({a: 1} == "[object Object]");//true

// example2:
var obj = {
  value: 3,
  valueOf() {
    return 4;
  },
  toString() {
    return '5'
  },
  [Symbol.toPrimitive]() {
    return 6
  }
}
console.log(obj + 1); // 输出7


// example3:
var a = {
  value: 0,
  valueOf: function() {
    this.value++;
    return this.value;
  }
};
console.log(a == 1 && a == 2); // true
```

```js
[] == ![] // true
// == 中，左右两边都需要转换为数字然后进行比较。
// [] 转换为数字为0。
// ![] 首先是转换为布尔值，由于 [] 作为一个引用类型转换为布尔值为 true, 因此 ![] 为 false，进而在转换成数字，变为0
// 0 == 0 ， 结果为true
```

