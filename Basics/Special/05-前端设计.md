---
typora-root-url: ../../Source
---



### 一、基本

#### 1-1、基本

- **<u>原型 prototype</u>**： 创建的每一个函数，都有一个prototype属性，该属性指向一个对象，这个对象就是原型

  - 定B：一个简单的对象，用于实现对象的 **属性继承**；可简单的理解成对象的爹；

  - 比如：在火狐、谷歌中，每个 JS 对象中都包含一`__proto__`    属性(非标)指向它爹(该对象原型)，即 `obj.__proto__` 进行访问；

  - 定C：原型是构造调用时，也即在实例创建过程中，系统自动创建出来的、与构造函数相关联的一个空的对象，可由 `构造函数.prototype` 访问到；

  - 注意：`实例.__proto__`，指向函数原型，于是在原型上增加属性或方法，便可成为实例的共有属性和方法；

  - 补充：原型对象是一个内部对象，官方没有给出能直接访问的方法，浏览器提供了一个 __proto__ 属性，通过它来访问对象原型：

    原型对象在 JS 标准中用 [[prototype]] 表示 (参见 [ECMAScript](https://developer.mozilla.org/en-US/docs/Glossary/ECMAScript))；

- **<u>构造函数</u>**：可通过 `new` 来 **新建一个对象** 的函数；

  - 本质：即函数、专用于同 new 操作符一起实例化对象、new 调用的时候称为构造调用；
  - 约定：大写字母开头、应仅作为构造调用使用；

- **<u>实例</u>**：通过构造函数和 `new` 创建出来的对象(或中间对象，或函数在中间对象环境下调用产生的结果)，即实例； 

  - **实例通过`__proto__`指向原型，通过`constructor`指向构造函数**；




##### 1-1-1、注意事项

<img src="/Image/Basics/Special/Mode/21.png" style="zoom:50%;" align="left" />

<img src="/Image/Basics/Special/Mode/22.png" style="zoom:50%;" align="left" />

- 注意：每个对象的 `__proto__` 属性，指向对象的构造函数的 prototype；
- 所以：上面图中，对象为 Foo.prototype(原型)，对象的构造函数为 Object，对象指向对象的构造函数的原型即 Object.prototype；
- 所以：此处对象乃原型，是故原型的构造函数为 Object；
- 那么：若对象为 Object.prototype(原型)，则又指向谁呢？null；

<img src="/Image/Basics/Special/Mode/23.png" style="zoom:50%;" align="left" />





#### 1-2、关系

在 JS 中，每当定义一个函数数据类型(普通函数、类)时候，都会天生自带一个 prototype 属性，这个属性指向函数的 **<u>原型对象</u>**；

当函数经过 new 调用时，此函数便作为 **<u>构造函数</u>**，返回一全新的 **<u>实例</u>** 对象，此实例对象有一个__proto__属性，指向构造函数的原型对象；

```js
// 实例为 instance, 构造函数为 Object, 构造函数拥有一个 prototype 属性指向原型
const instance = new Object()
const prototype = Object.prototype
```

##### 1-2-1、构造与实例

构造函数、实例之间关系：

创建和被创建的关系，实例需通过 `__proto__` 找原型，再通过原型的 constructor 找构造其的函数；

<img src="/Image/Basics/Special/Mode/30.png" style="zoom:50%;" align="left"/>



##### 1-2-2、构造与原型

构造函数、原型之间关系：

函数的原型对象即：`构造函数的原型对象.constructor === 函数`；

<img src="/Image/Basics/Special/Mode/31.png" style="zoom:50%;" align="left"/>



##### 1-2-3、实例与原型

某某实例、原型之间关系**：**

实例的原型 === 构造实例的函数的原型对象，即：`实例.__proto__ === 构造实例的函数.prototype`；

<img src="/Image/Basics/Special/Mode/32.png" style="zoom:50%;" align="left"/>



##### 1-2-4、prototype 与 proto

显式原型：prototype：

- 含义：每一个函数，在创建之后都会拥有一个名为 prototype 的属性，属性指向函数的原型对象；
- 作用：用以实现基于原型的继承与属性共享；
  - 注意：通过 Function.prototype.bind 构造出的函数是例外，其没有 prototype 属性；

隐式原型：`__proto__`：

- 含义：任意 JS 对象，都有内置属性 [[prototype]]，指向创建此对象的函数的显式原型 prototype；
- 作用：用以构成原型链，同样可用以实现基于原型的继承与属性共享，当找寻某对象属性或方法时，便会沿此进行搜索；
  - 注意：ES5 前，没有标准方法访问此属性(prototype)，但大多数浏览器均支持通过 `__proto__` 访问；
  - 注意：ES5 后，有标准方法可访问：Object.getPrototypeOf()：`Object.getPrototypeOf(fn) == test.prototype // true`
  - 注意：Object.prototype 是唯一的，没有原型的对象：

两者关系：

- 对象的隐式原型 `__proto__` 指向，创建这个对象的函数(constructor)，的显式原型 prototype；
- <img src="/Image/Basics/Special/Mode/38.png" style="zoom:50%;" align="left"/>

两者区别：

- prototype：对象且函数才有属性；
- `__proto__`：对象皆有的属性，但并非规范属性 (部分浏览器实现，标准属性为 [[Prototype]]
- <img src="/Image/Basics/Special/Mode/39.png" style="zoom:50%;" align="left"/>

注意事项：

- `__proto__` 为 构造器原型；

  - ```js
    __proto__ == constructor.prototype // true
    ```

- `__proto__` 实际上是 getter setter，源于 Object.prototype，使用时可理解成返回 Object.getPrototypeOf(obj)；

  - ```js
    Object.getPrototypeOf(fn) == fn__proto__ // true
    ```

- `__proto__` 指向取决于对象创建的实现方式，图3-5；

<img src="/Image/Basics/Special/Mode/40.png" style="zoom:50%;" align="left"/>

<img src="/Image/Basics/Special/Mode/41.png" style="zoom:50%;" align="left"/>

<img src="/Image/Basics/Special/Mode/42.png" style="zoom:50%;" align="left"/>



##### 1-2-5、constructor

constructor 属性是原型对象的属性，指向这个原型对象所对应的构造函数；

每个对象实例都具有 [constructor](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/constructor) 属性，它指向创建该实例的构造器函数

- 比如：person2.constructor，返回 Person() 构造器
- 比如：new person2.constructor()，返回 Person() 构造器 创建的新实例



##### 1-2-6、关系综述

构造函数、原型和实例之间的关系：每个 <u>构造函数</u> 都有一个 <u>原型</u> 对象，<u>原型</u> 对象都包含一个指向 <u>构造函数</u> 的指针，而 <u>实例</u> 都包含一个 <u>原型对象</u> 的指针；

```js
// 三者的关系(再述):
实例.__proto__ === 原型

原型.constructor === 构造函数

构造函数.prototype === 原型

实例.constructor === 构造函数
// 注意: 其实实例上并不是真正有 constructor 这个指针，它其实是从原型链上获取的: 
// instance.hasOwnProperty('constructor') === false 

// 例如: 
// const o = new Object()
// o.constructor === Object   --> true
// o.__proto__ = null;
// o.constructor === Object   --> false 

// 对象原型 prototype 属性 与 构造函数 prototype 属性间区别：
// 前者可通过 Object.getPrototypeOf(obj) 或，已被弃用的 __proto__ 属性获得
// 前者是每个实例上都有的属性，后者是构造函数的属性
// 也就是说，Object.getPrototypeOf(new Foobar())和 Foobar.prototype 指向着同一个对象
// function Foobar(){} -> undefined
// foobar = new Foobar() -> Foobar {}
// Object.getPrototypeOf(foobar) == Foobar.prototype -> true
```

<img src="/Image/Basics/Special/Mode/4.png" style="zoom:35%;" />

<img src="/Image/Basics/Special/Mode/43.png" style="zoom:50%;" />

##### 1-2-6-1、大图解说

再叙：实例对象的原型([[Prototype]] 或 `__proto__`) === 构造实例的函数的原型对象，即构造实例的函数的 prototype 属性；

再叙：构造函数的 prototype 属性，即原型对象，又可作为新的实例对象，实例对象的原型又指向下一轮；

再叙：一直到达 Object.prototype，其原型，即 `Object.prototype.__proto__ === null`；

再叙：`对象.__proto__…..__proto__`为 Object.prototype，随即 `Object.prototype. __proto__` 指向 Null；

<img src="/Image/Basics/Special/Mode/14.png" style="zoom:50%;" align="left" />

- 分析：`__proto__` 即实例对象的原型 `[[Prototype]]`;
- 注意：`__proto__` 是私有属性，现代浏览器将其暴露给用户，修改此值会改变继承关系；

- 分析：函数构建出的实例对象的原型 `__proto__`，指向函数的原型 `Foo.prototype`，图左上角；
- 分析：函数的属性 prototype，指向函数原型，即 `Foo.prototype`，图中上方；

- 分析：函数原型的原型，即 `Foo.prototype.__proto__` ，指向 Object 原型 `Object.prototype`，图右上角；

- 注意：唯一例外：Function 构造函数，可用 `Function.__proto__` 来访问 `Function.prototype` 
  - 一般情况是：实例的__proto__指向实例构造函数的 prototype ;
- 因为：Function 构造函数即其自身，故作为实例化对象来访问；
  - `Function.__proto__(作为实例) == Function.prototype(作为构造函数)`；

- 注意：唯一例外：`Function.prototype` 并非普通对象，而是函数对象 (特殊匿名函数，此函数的 `__proto__` 指向 Object.prototype)；
- 而且：所有构造函数中，只有 Function 的 prototype 属性为函数

<img src="/Image/Basics/Special/Mode/35.png" style="zoom:50%;" align="left" />

<img src="/Image/Basics/Special/Mode/34.png" style="zoom:50%;" align="left" />



##### 1-2-6-2、大图解说

<img src="/Image/Basics/Special/Mode/36.png" style="zoom:50%;" align="left" />

注意：任何对象均函数，均继承 Function 所有属性和方法，而 Function 是内置的构造函数也是对象，均继承 Object 的所有属性方法；

注意：各种 function、Object、Function 等实际上均为 new Function() 后的实例，而这些实例原型 `__proto__` 均指向 Function.prototype；

同理：Object、Number、String、Array、Function、Date 等均为函数，而所有函数均由 Function 创建，故其原型 `__proto__` 指向 Function.prototype：

<img src="/Image/Basics/Special/Mode/37.png" style="zoom:50%;" align="left" />







#### 1-3、new 

##### 1-3-1、new 过程

<img src="/Image/Basics/Special/Mode/19.png" style="zoom:55%;" align="left"/>

构造调用过程即 new 过程：

- 首先，创建全新的对象 (中间对象) obj；
- 然后，新对象会被执行 [[ 原型 ]] 连接 (将中间对象的原型，指向函数原型，此后便可使用函数原型上的方法和属性)； 
  - `obj.__proto__ = Target.prototype`
- 然后，新对象会绑定到函数调用的 this (即将函数内部 this 指向中间对象)；
- 最后，若函数返回基本类型，则返回中间对象；若返回对象，则代替中间对象，返回函数返回的对象；

再说：new 调用过程：

- 它创建了一个全新的对象
- 它会被执行[[Prototype]](也即 `__proto__`)链接
- 它使 this 指向新创建的对象
- 通过 new 创建的每个对象将最终被[[Prototype]]链接到这个函数的prototype对象上
- 如果函数没有返回对象类型 Object(包含Functoin, Array, Date, RegExg, Error)，那么new表达式中的函数调用将返回该对象引用

再说：new 调用过程：

- 创建(或者说构造)一个全新对象；
- 这个新对象会被执行 [[ Prototype ]] 连接；
- 这个新对象会绑定到函数调用的 this；
- 若函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象；

<img src="/Image/Basics/Special/Mode/20.png" style="zoom:50%;" align="left" />

再说：new 调用过程：

- **创建一个新对象，并继承其构造函数的`prototype`**；此步是为了继承构造函数原型上的属性和方法；
- **执行构造函数，方法内的`this`被指定为该新实例**；此步是为了执行构造函数内的赋值操作；
- **返回新实例** (规范规定，若构造方法返回了一个对象，则返回该对象，否则返回第一步创建的新对象)；

```js
// new 是关键字, 这里用函数来模拟, new Foo(args) <=> myNew(Foo, args)
function myNew(foo, ...args) {
  // 创建新对象, 并继承构造方法的 prototype 属性
  // 此步是为了把 obj 挂原型链上, 相当于 obj.__proto__ = Foo.prototype
  let obj = Object.create(foo.prototype)  
  
  // 执行构造方法, 并为其绑定新 this
  // 此步是为了让构造方法能进行 this.name = name 类似操作, args 是构造方法的入参, 因为此处用 myNew 模拟, 故入参从 myNew 传入
  let result = foo.apply(obj, args)

  // 若构造方法已 return 了一个对象，则就返回该对象，否则返回 myNew 创建的新对象
  // 一般情况下，构造方法不会返回新实例，但使用者可以选择返回新实例来覆盖 new 创建的对象
  return Object.prototype.toString.call(result) === '[object Object]' ? result : obj
}

// 测试：
function Foo(name) {
  this.name = name
}
const newObj = myNew(Foo, 'zhangsan')
console.log(newObj)                 // Foo {name: "zhangsan"}
console.log(newObj instanceof Foo)  // true
```



##### 1-3-2、创建对象方式

创建对象的三种方式：字面量、new、Object.create()，但本质的只有1种：new；

- 字面量是方便创建对象的语法糖，本质是 new Object()
- new Object 内部还是通过 new 创建

```js
// Object.create
function object(o) {
	function F(){};
	F.prototype = o;
	return new F();
}
```





#### 1-4、原型链

**<u>原型链</u>**：即 JS 对象通过 `__proto__`  指向父类对象，直到指向 Object 对象为止，形成的一个原型指向的链条；

**<u>原型链</u>**：当访问一对象的属性/方法时，首先在该对象上查找，然后查找该对象原型，以及该对象原型的原型，逐层上找，直到匹配属性/方法或达原型链尾-null；

**<u>原型链</u>**：即相互关联的原型组成的链条结构；

[[Prototype]] 内置属性，其实就是对其他对象的引用，几乎所有对象在创建时 [[Prototype]] 属性都会被赋予一非空值；

- 查找操作：
  - 如果，在对象上没有找到需要的属性或者方法引用，引擎就会继续在 [[Prototype]] 关联的对象上进行查找；
  - 如果，在后者中也没有找到需要的引用就会继续查找它的 [[Prototype]]，以此类推；
  - 这一系列对象的链接即 **<u>原型链</u>**；

- Get 操作：试图引用对象的属性时会触发[[Get]] 操作，比如 myObject.a：
  - 首先，检查对象本身是否有这个 [[Prototype]] 内置属性，若有则使用它，若没有，则需使用对象的 [[Prototype]] 链；
  - 但若，anotherObject 中也找不到 a 且 [[Prototype]] 链不为空，则继续查找下去，此过程会持续到找到匹配属性名或查找完整条 [[Prototype]] 链；
  - 最后，若还是找不到那个值，[[Get]] 操作返回 undefined；
- Set 操作：试图给一个 对象设置属性 或 修改已有的属性值会触发 [[Set]] 操作，myObject.foo = "bar”：
  - 首先，若 myObject 对象中包含名为 foo 的普通数据访问属性，则只修改已有属性值；
    - 若 myObject 的 [[Prototype]] 链上层也有 foo，此时发生屏蔽，因 myObject.foo 总是会选择原型链中最底层的 foo 属性；
  - 然后，若 foo 非直接存在于 myObject 中，[[Prototype]] 链就会被遍历，类似 [[Get]] 操作：
    - 若原型链上找不到 foo，foo 就会被直接添加到 myObject 上。
    - 若原型链上存在 foo (在 [[Prototype]] 链上层存在名为 foo)： 
      - 情况1：其为没有被标记为只读(writable:false)，则会直接在 myObject 中添加一个名为 foo 的新属性，它是屏蔽属性；
      - 情况2：其为被标记为只读(writable:false)，则无法修改已有属性或者在 myObject 上创建屏蔽属性；
        - 如果，运行在严格模式下会抛出一个错误，否则，这条赋值语句会被忽略，总之，不会发生屏蔽；
      - 情况3：其为一个 setter ，则一定会调用这个 setter；
        - foo 不会被添加到(或说屏蔽于)myObject，也不会重新定义 foo 这个 setter；

<img src="/Image/Basics/Special/Mode/24.png" style="zoom:50%;" align=""/>

- 注意：使用 for..in ，遍历对象时原理和查找 [[Prototype]] 链类似，任何可通过原型链访问到且是 enumerable的属性都会被枚举；
- 注意：使用 in 操作符，检查属性在对象中是否存在时，同样会查找对象的整条原型链(此时无论属性是否可枚举)；
- 注意：所有普通 [[Prototype]] 链，最终均指向内置的 Object.prototype：
  - 由于所有普通内置对象都“源于”(将 [[Prototype]] 链的顶端设置为)此 Object.prototype 对象，故包含 JS 中许多通用的功能：
  - 比如： .toString() 和 .valueOf()， .hasOwnProperty(..) 和 .isPrototypeOf(..)；



**<u>原型链</u>**：每一对象都有自己的原型对象：实例对象有原型，原型对象也是对象(此处原型对象相当于上一级原型的实例)，故也有其原型(上一级原型对象)，如此形成的一个链式结构；

比如：下图：`实例.__proto__`指向其原型，`原型.__proto__`又指向其原型，然后指向 Object.prototype，最终指向 null；

<img src="/Image/Basics/Special/Mode/25.png" style="zoom:50%;" align="left"/>

<img src="/Image/Basics/Special/Mode/26.png" style="zoom:50%;" align="left"/>

<img src="/Image/Basics/Special/Mode/27.png" style="zoom:50%;" align="left" />



**<u>原型链</u>**：Js 是一种基于原型的语言：每个对象，拥有一个原型对象，对象以其原型为模板，从原型继承方法和属性原型对象也可能拥有原型，并从中继承方法和属性，一层一层、以此类推，此种关系被称为原型链；

- 意义：它解释了为何一个对象会拥有，“定义在其他对象中的属性和方法”。更准确说，它解释了为何一个对象会拥有，定义在 Object的，构造器函数(constructor functions)上的，prototype属性上的属性和方法，而非定义在对象实例上；
- 注意：Js 中并不是复制，而是建立链接：传统的 OOP 中，定义类后，创建对象实例时，类中定义的所有属性和方法都被，复制到实例中，但在 JS 中，并不是复制在 JS 中，是在对象实例，和它的构造器间，建立一个链接(它是 `__proto__` 属性，是从构造函数的prototype 属性派生的)之后通过上溯原型链，在构造器中找到这些属性和方法
- 重申：原型链中的方法和属性，没有被复制到其他对象，它们的访问需要通过原型链；
- 注意：Object中有大量的属性和方法，但实际被继承的，就只有那些以 Object.prototype 开头的属性；是因为继承的属性和方法是定义在 prototype 属性之上的；比如：[Object.prototype.watch()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/watch)、[Object.prototype.valueOf()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/valueOf) 等；但：[Object.is()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/is)、[Object.keys()](https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Objects/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/keys)等不在 prototype 对象内的成员，仅能被 Object() 构造器自身使用，不会被对象实，或继承自 Object() 的对象类型所继承；
- prototype 属性的值是一个对象，希望被原型链下游的对象继承的属性和方法，都被储存在其中；
- 注意：一般很少将属性定义在构造器上的prototype上，因为不灵活；
- **<u>原型链模型</u>**：上游对象的方法，不会复制到下游的对象实例中；下游对象本身虽然没有定义这些方法，但通过上溯原型链、能从上游对象中找到它们；这种继承模型提供了一个强大而可扩展的功能系统；



**<u>原型链</u>**：即由原型对象组成，每个对象都有 `__proto__` 属性，指向了创建该对象的构造函数的原型，`__proto__` 将对象连接起来组成了原型链，是一个用来 <u>实现继承和共享属性</u> 的有限的对象链；它有两个机制和特点：

- **属性查找机制**：当查找对象的属性时，若实例对象自身不存在该属性，则沿着原型链往上一级查找，找到时则输出，不存在时，则继续沿着原型链往上一级查找，直至最顶级的原型对象 `Object.prototype`，如还是没找到，则输出 `undefined`；
- 比如：person.valueOf()；
- <img src="/Image/Basics/Special/Mode/44.png" style="zoom:50%;" align="left" />
- **属性修改机制**：只会修改实例对象本身的属性，若不存在，则进行添加该属性，若需要修改原型的属性时，则可用: `b.prototype.x = 2`；但会造成所有继承于该对象的实例的属性发生改变；
- 特点：对象的 hasOwnProperty() 来检查对象自身中是否含有该属性；
- 特点：使用 in 检查对象中是否含有某个属性时，如果对象中没有但是原型链中有，也会返回 true；

<img src="/Image/Basics/Special/Mode/2.png" style="zoom:50%;" />

<img src="/Image/Basics/Special/Mode/28.png" style="zoom:50%;" />

<img src="/Image/Basics/Special/Mode/29.png" style="zoom:50%;" />







#### 1-5、instance of

##### 1-5-1、理解一

在实例的 **原型对象链** 中找到该构造函数的 `prototype` 属性所指向的 **原型对象**，就返回`true`：

```js
// __proto__: 代表原型对象链
instance.[__proto__...] === instance.constructor.prototype
// return true
```



##### 1-5-2、理解二

应理解为：

检测左侧对象 L 的原型链上(即 L.__proto__.__proto__……)，是否存在右侧 R 的 prototype 原型(即 R.prototype)，如下图；

或者：用以判断某个构造函数，的 prototype 属性，是否存在于另外一个要检测对象，的原型链上；

```js
L instanceof R ==> L.__proto__.__proto__.... === R.prototype 
```



##### 1-5-3、模拟实现

instanceof 运算时会递归查找 left Value 的原型链，即 `left Value.__proto__.__proto__.__proto__`... ，直至找到 / 到达顶层为止

```js
function instance_of(L, R) {
  var O = R.prototype // 取 R 显式原型
  L = L.__proto__;		// 取 L 隐式原型
  while(true) {
    if(L === null) return false;
    if(L === O) return true;	// 注意严格相等
    L = L.__proto__;
  }
}
```



##### 1-5-4、注意事项与示例

- ```js
  function Foo() {     
      // ...  
  } 
  Foo.prototype.xxx = ...; 
  var a = new Foo(); 
  ```

<img src="/Image/Basics/Special/Mode/5.png" style="zoom:50%;" align="left" />

- instanceof 工作机制；若修改 prototype 的 值，则会改变原有(图2)

<img src="/Image/Basics/Special/Mode/6.png" style="zoom:50%;" align="left" />

<img src="/Image/Basics/Special/Mode/7.png" style="zoom:50%;" align="left" />

- Fun 是单纯的函数，`Fun.__proto__` 属于 Function.prototype，除非 new 出来，否则不属于 Fun.prototype；

<img src="/Image/Basics/Special/Mode/8.png" style="zoom:50%;" align="left" />

- JS 在访问 str 属性时创建临时 String 对象 (假设叫tmpStr)，并在得到此返回值时销毁临时对象，故此处是 `tmpStr.__proto__` 的值；而引用类型的字面量和基础类型的不一样(图2)；

<img src="/Image/Basics/Special/Mode/9.png" style="zoom:50%;" align="left" />

<img src="/Image/Basics/Special/Mode/10.png" style="zoom:50%;" align="left" />

- 对于三种基本类型的字面声明，instanceof 均返回 false；而其他类型的字面量声明则为 true；

<img src="/Image/Basics/Special/Mode/11.png" style="zoom:50%;" align="left" />

<img src="/Image/Basics/Special/Mode/12.png" style="zoom:50%;" align="left" />

- `Object.prototype.__proto__` 为 null，但 null 不等于 `Object.prototype`；

<img src="/Image/Basics/Special/Mode/13.png" style="zoom:50%;" align="left" />



##### 1-5-5、JS Object Layout

<img src="/Image/Basics/Special/Mode/14.png" style="zoom:50%;" align="left" />

- **Object instanceof Object**

<img src="/Image/Basics/Special/Mode/15.png" style="zoom:50%;" align="left" />

- **Function instanceof Function**

<img src="/Image/Basics/Special/Mode/16.png" style="zoom:50%;" align="left" />

- **Foo instanceof Foo**

<img src="/Image/Basics/Special/Mode/17.png" style="zoom:50%;" align="left" />



#### 1-X、编程分类

面向对象编程——OOP：

- 定义：把构成问题事务分解成单或多个对象，但分拆成对象并非为了完成某一步骤，而是为了描述某个事物在整个解决问题的步骤中的行为；
- 示例：Eat(Dog，Apple)；
- 示例：Refrigerator.open() —> Refrigerator.load(thing) —> Refrigerator.close()；
- 优点：具有良好的可移植性和可扩展性；
- 缺点：掌握难，容易偏向为面向过程；
- 特性：
  - 多态、封装、继承

面向过程编程——POP：

- 定义：分析出解决问题所需步骤，然后用方法将各个步骤逐一实现，使用时依次调用；
- 示例：Dog.eat(apple)；
- 示例：Open(Refrigerator) —> Load(Refrigerator，thing) —> Close(Refrigerator)；
- 优点：同步思维开发；
- 缺点：牵一发而动全身，移植性和可扩展性差；

面向组件编程——COP：(暂略)；

面向方面编程——AOP：(暂略)；

面向服务编程——SOP：(暂略)；



### 二、多态

基本：根据传入参数的个数不同，调用相应的方法

JS 是弱类型，不存在编译时要确定类型，天然支持多态。



### 三、封装

含义：将客观事物封装成抽象的类，隐藏属性和方法的实现细节，仅对外公开接口(可见性控制)；此点 JS 可通过闭包

ES6 class 为语法糖，在此之前没有类概念(实际上 JS 没有类，只是模拟行为)，均借助于：原型对象、构造函数来实现；

- 私有属性/方法：只能在构造函数内访问不能被外部所访问：在构造函数内使用 var 等声明的属性/方法；
- 公有属性/方法(或实例方法)：对象外可访问到对象内的属性和方法：在构造函数内使用 this 设置，或设置在构造函数原型 prototype 对象上；
- 静态属性/方法：定义在构造函数上的方法，无需实例即可调用；

使用 `for...in...` 能获取到实例对象自身的属性和原型链上的属性(可枚举属性)；

使用 `Object.keys()` 和 `Object.getOwnPropertyNames() `只能获取实例对象自身属性(可枚举属性)；

使用 `Object.hasOwnProperty()` 方法传入属性名来判断某属性是不是实例自身属性(可枚举属性)；

- 注意：类不会提升(不像普通变量和函数)，注意报错

  - ```js
    var a = new A()
    function A () {}
    console.log(a)
    // A{}
    
    var b = new B()
    class B {}
    console.log(b)
    // Uncaught ReferenceError: Cannot access 'B' before initialization
    ```

- 

  - ```js
    class TLP {
      constructor () {
        var type = 'fykms'
        this.name = 'tlp'
      }
      type = 'old man'
      getType = function () {
        console.log(this.type)
        console.log(type)
      }
    }
    var type = 'window'
    var tlp = new TLP()
    tlp.getType()
    // old man
    // window
    ```

- 注意：constructor 的 var 等声明变量为私有变量不可获取

- 注意：类中箭头函数转为 ES5 时，仍作为一个函数处理，只是处理后仍为箭头函数，保留箭头函数特性；

- 注意：若同名变量则以 constructor 为优先(优先是因为Babel转译顺序导致)，原因看Babel 转译结果

- <img src="/Image/Basics/Special/Mode/222.png" style="zoom:50%;" />

  







### 四、继承

将属性和方法组装成一个类的过程(私有化变量和方法 (通过 this 创建的属性视作为共有变量，而通过 <u>闭包</u> 还可实现对私有变量的访问))；

- 问题1：JS 中没有类概念；
- 解决2：可通过作用域的变量访问限制，以模拟类实现，比如：构造函数、`Object.create()`、点语法；
  - 方法1：<u>通过构造函数添加类</u>：在函数中创建 this 相关属性和方法，再通过 new 生成实例和绑定 this，例略；
    - 好处：实例间相互独立，不受影响；
    - 坏处：好处即坏处，通过 this 定义的属性或方法，每次实例化都复制一份，内存消耗大、复杂、可读性；
  - 方法2：<u>通过原型添加类</u>：基于 `实例.__proto__` 指向 函数原型，从而使用原型上的方法；
    - 好处：原型链上的属性和方法只需建立一次;
    - 坏处：原型链上的属性和方法为全体实例共用，若链上的属性是引用类型则会被改变(而链上的方法铁定会改变)，不能实现私有属性和私有方法；
  - 方法3：<u>通过点语法</u>：在构造函数身上通过点语法增加属性或方法；
    - 好处：仅创建一次；
    - 坏处：显而易见，实例无法访问，仅能用过自身访问；
- 问题2：JS没有 `private public protected` 关键字；
- 解决2：可通过作用域的变量访问限制，来模拟此类关键字：图1
  - Public：对所有用户开放，均可直接调用；
  - Private：自身属性或方法，仅自身能直接访问；
  - Protected：自身实例可访问，外部类不可访问；

<img src="/Image/Basics/Special/Mode/220.png" style="zoom:50%;" align="left" />

- 总结：JS 很容易模拟一个类，并且可以一定程度上做到面向对象中的三大特性：封装、继承、多态；
- 所以，从最初去模拟一个类，到 ES5 提供更便捷的原型操控API，到 ES6 中提供更多类相关的关键字，都是在帮助开发者减小 JS 中面向对象的使用成本；
- 虽然，JS 中的继承并非真正"继承"，类也不是真正的"类"，相比 Java 肯定还有很多实现不了的地方；
  - 比如，abstract class、Interface 等，只能通过一些 tricky 的办法去模拟；
- 因此 JS 中所谓的继承，是为方便程序员用面向对象的方式来组织代码；





<img src="/Image/Basics/Special/Mode/215.png" style="zoom:50%;" align="left" />



#### 4-2、构造函数的继承(原型继承演进)

##### 4-2-1、原型链继承

基本：构造函数、原型、实例间关系：每个 <u>构造函数</u> 都有一 <u>原型</u> 对象，<u>原型</u> 对象都包含一指向 <u>构造函数</u> 的指针，而 <u>实例</u> 都包含一 <u>原型对象</u> 的指针；

关键：`子类.prototype = new 父类();  子类.prototype.constructor = 子类;`

原理：直接让子类原型对象指向父类实例，当子类实例找不到相应属性和方法时，就会往其原型对象，也即父类实例上找，从而实现对父类属性和方法的继承；

注意：但凡对 prototype 作赋值操作，均需重新将 prototype.constructor 修正为子类；因 子类.constructor 属性默认调用 prototype 对象 constructor 属性；

```js
// 父类
function Parent() {
    this.name = '特朗普'
}
// 父类原型方法
Parent.prototype.getName = function() {
    return this.name
}
// 子类
function Child() {}

// 让子类的原型对象指向父类实例, 这样一来在 Child 实例中找不到的属性和方法就会到原型对象(父类实例)上寻找
Child.prototype = new Parent()
// 根据原型链的规则, 顺便绑定一下 constructor, 这一步不影响继承, 只是在用到 constructor 时会需要
// 帮助修复 子类实例的构造函数错误指向
Child.prototype.constructor = Child 

// 然后 Child 实例就能访问到父类及其原型上的 name 属性和 getName() 方法
const child = new Child()
child.name          // '特朗普'
child.getName()     // '特朗普'
```

优点：可使用父类方法；

缺点：

- 因直接 `子类.prototype = new 父类`，故会覆盖 `子类.prototype` 原有属性 (不解释)；

- 父类的引用属性会被所有子类实例共享，多个实例对引用类型的操作会相互影响；

  - 解释：由于所有子类实例原型都指向同一个父类实例，故对某个子类实例的父类引用类型变量修改会影响所有子类实例 (因为是多对一关系)

- 子类构建实例时不能向父类传递参数，即没有实现 `super()` 的功能 (你™怎么传参，子类与父类的关系纽带就靠 prototype 维系，无关构造)

  - ```js
    // Ex1:
    function Parent() {
        this.name = ['特朗普'] 
    }
    Parent.prototype.getName = function() {
        return this.name
    }
    function Child() {}
    Child.prototype = new Parent()
    Child.prototype.constructor = Child 
    
    // 测试
    const child1 = new Child()
    const child2 = new Child()
    child1.name[0] = 'foo'
    console.log(child1.name)  // ['foo']
    console.log(child2.name)  // ['foo'] (预期是['特朗普'], 对 child1.name 的修改引起了所有 child 实例的变化)
    ```
    
    



##### 4-2-2、构造函数继承

基本：使用父类的构造函数来增强子类实例，等同于复制父类的实例给子类(不使用原型)

关键： 在子类函数中执行：`父类函数.apply/call(this, arguments/…arguments);`

原理：即在子类的构造函数中执行父类的构造函数，并为其绑定子类的 `this`，让父类的构造函数将成员属性和方法，都挂到 `子类的this`上去，避免原型继承中，实例间共享同一原型实例问题，此外还能向父类构造方法传参；

```js
function Parent(name) {
    this.name = [name]
}
Parent.prototype.getName = function() {
    return this.name
}
function Child(...args) {
  	console.log(this);
  	this.name = ['child']			// 执行 call 后被覆盖
    Parent.call(this, args)   // 执行父类构造方法并绑定子类的 this, 使得父类中的属性能够赋到子类的 this 上
  	console.log(this);
}

// 传参测试
const child1 = new Child('test1')
const child2 = new Child('test2')
// 共享测试
child1.name[0] = 'foo'
console.log(child1.name)          // ['foo'] 
console.log(child2.name)          // ['test2']
// 原型链继承测试
child2.getName()                  // Error, 找不到 getName(), 无法继承父类原型上的属性和方法，因为只是单纯的在子类执行，获取父类构造中的方法和属性
```

优点：与原型链继承相反

- 父类的引用属性不会被共享；
- 子类构建实例时可向父类传递参数；

缺点：

- 只能继承父类的实例属性和方法，不能继承原型属性/方法 (因为只是单纯的在子类执行，获取父类构造中的方法和属性)；
- 无法实现复用，每个子类都有父类实例函数的副本，影响性能 (无法复用是因为父类原型链上属性方法子类完全无法用到)；



##### 4-2-3、组合式继承

基本：即组合上述两种方法，借用原型链实现对**原型**属性和方法的继承，借用构造函数技术来实现**实例**属性的继承；

原理：原型链继承和构造函数继承各有互补的优缺点，合体为组合式继承；

注意：但凡对 prototype 作赋值操作，均需重新将 prototype.constructor 修正为子类；因 子类.constructor 属性默认调用 prototype 对象 constructor 属性；

```js
function Parent(name) {
    this.name = [name];
  	this.play = [1, 2, 3];
}
Parent.prototype.getName = function() {
    return this.name
}
function Child(name, age) {
    // 1、构造函数的继承 复制父类构造属性方法给子类实例 - 第二次调用 Parent
    Parent.call(this, name);
  	this.age = age;
}
// 2、原型链的继承 - 第一次调用 Parent
Child.prototype = new Parent()
// 因上一句的关系，故须将指向修正为原本态: 指向自身构造函数, 否则指向的是 Parent
Child.prototype.constructor = Child
Child.prototype.getAge = function() {
    return this.age
}

// 传参测试
const child1 = new Child('TPP', 20)
const child2 = new Child('TLP', 70)
// 原型链继承测试
console.log('child1', child1);		
console.log(child1.getName(), child1.getAge()) // ['TPP'] 20
console.log(child1 instanceof Child, child1 instanceof Parent) // true true

child1.name[0] = 'foo'
child1.play.push(4);
// 共享测试
console.log(child1.play, child2.play); // [1,2,3,4] [1,2,3]
console.log(child1.name)          // ['foo']
console.log(child2.name)          // ['TLP']
child2.getName()                  // ['TLP']
```

优点：

- 父类的方法可以被复用；
- 父类的引用属性不会被共享；
- 子类构建实例时可以向父类传递参数；

缺点：每次创建子类实例都执行了两次构造函数，虽不影响对父类的继承，但子类创建实例时，原型中会存在两份相同的属性和方法，这并不优雅；

- 第一次调用 `Parent()`：给 `Child.prototype` 写入两个属性 name，play (可通过 `child1.__proto__.play` 访问得到)
- 第二次调用 `Parent()`：给 `Child` 写入两个属性 name、play；
- 再解释：实例对象 `child1` 上的两个属性就屏蔽了其原型对象 Child.prototype 的两个同名属性；所以，组合模式的缺点就是在使用子类创建实例对象时，其原型中会存在两份相同的父类实例的属性/方法；这种被覆盖的情况造成了性能上的浪费



#### 4-3、非构造函数的继承(普通对象的继承)

##### 4-3-1、原型式继承

<img src="/Image/Basics/Special/Mode/223.png" style="zoom:50%;" align="left" />

```js
const Chinese = {
  nation: '中国'
}

const Doctor = {
  career: '医生'
}

// How to make 'ChineseDoctor' ?
```

可利用 object() 方法：即将子对象的 prototype 属性，指向父对象，从而使得子对象与父对象连在一起；

其本质上是对传入其中的对象执行了一次 **<u>*浅拷贝*</u>**，将构造函数 `F` 的原型直接指向传入的对象；

```js
// ES5 中存在 Object.create() 方法，能覆盖下面这个方法
function object(obj) {
  function F() { }
  F.prototype = obj
  return new F()
}

let person = {
  name: "Nicholas",
  friends: ["Shelby", "Court", "Van"]
};

let anotherPerson = object(person);
anotherPerson.name = "Greg";
anotherPerson.friends.push("Rob");

let yetAnotherPerson = object(person);
yetAnotherPerson.name = "Linda";
yetAnotherPerson.friends.push("Barbie");

console.log(person.friends);   // "Shelby,Court,Van,Rob,Barbie"
```

ECMAScript 5 通过新增 [Object.create()](https://link.zhihu.com/?target=https%3A//developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create) 方法规范化了原型式继承；此方法接收两个参数：在传入一个参数情况下， Object.create 与 object() 方法行为相同；

- 一 个用作新对象原型的对象和(可选的)
- 一个为新对象定义额外属性的对象；

```js
let yetAnotherPerson = object(person)
//  => 
let yetAnotherPerson = Object.create(person)
```

**优点**：

- 父类方法可以复用

**缺点**：

- 原型链继承多个实例的引用类型属性指向相同，存在篡改的可能
- 子类构建实例时不能向父类传递参数



##### 4-3-2、寄生式继承

使用原型式继承获得一份目标对象的 `浅拷贝`，然后增强了此浅拷贝的能力；

优缺点：其实和原型式继承一样，寄生式继承说白了就是：能在拷贝来的对象上加点方法，也就是所谓增强能力；

```js
function object(obj) {
  function F() { }
  F.prototype = obj
  return new F()
}

function createAnother(original) {
  // 通过调用函数创建一个新对象
  let clone = object(original)
  // 以某种方式来增强这个对象
  clone.getName = function () {
    console.log('我有了getName方法: ' + this.name)
  }
  return clone
}

let person = {
  name: 'Asuna',
  friends: ['Kirito', 'Yuuki', 'Sinon']
}

let inst1 = createAnother(person)
let inst2 = createAnother(person)
```

**优点**：

- 父类方法可以复用

**缺点**：

- 原型链继承多个实例的引用类型属性指向相同，存在篡改的可能
- 子类构建实例时不能向父类传递参数



#### 4-4、寄生组合式继承

组合继承会有两次调用父类的构造函数而造成浪费的缺点，寄生组合继承就可解决此问题：

核心在于<u>让子类的 prototype 指向父类原型的拷贝</u>，如此就不会调用父类的构造函数，进而引发内存的浪费问题；

- 即构造函数被执行两次的问题，将 `指向父类实例` 改为 `指向父类原型`，减去一次构造函数的执行；

```js
function Parent(name) {
    this.name = [name];
  	this.play = [1, 2, 3];
}
Parent.prototype.getName = function() {
    return this.name
}
function Child(name, age) {
    // 1、构造函数的继承 复制父类构造属性方法给子类实例
    Parent.call(this, name);
  	this.age = age;
}
// 2、原型链的继承
// Child.prototype = new Parent()
// 3、优化组合继承 2 
Child.prototype = Parent.prototype  // 寄生组合式继承中，将组合式继承的: 指向父类实例 改为:指向父类原型
// 因上一句的关系，故须将指向修正为原本态: 指向自身构造函数, 否则指向的是 Parent
Child.prototype.constructor = Child
Child.prototype.getAge = function() {
    return this.age
}

// 传参测试
const child1 = new Child('TPP', 20)
const child2 = new Child('TLP', 70)
// 原型链继承测试
console.log('child1', child1);		
console.log(child1.getName(), child1.getAge()) // ['TPP'] 20
console.log(child1 instanceof Child, child1 instanceof Parent) // true true

child1.name[0] = 'foo'
child1.play.push(4);
// 共享测试
console.log(child1.play, child2.play); // [1,2,3,4] [1,2,3]
console.log(child1.name)          // ['foo']
console.log(child2.name)          // ['TLP']
child2.getName()                  // ['TLP']
```

问题：而由于子类原型和父类原型指向同一个对象：`Child.prototype = Parent.prototype`，故对子类原型的操作会影响到父类原型；

- 比如：给 `Child.prototype` 增加一个getName() 方法，会导致 `Parent.prototype` 也增加或被覆盖一个 getName() 方法；

解决：可对 `Parent.prototype` 做浅拷贝，利用 <u>空对象</u> 作为中介，此几乎不占内存，且修改 子类 的 prototype 对象，也不会影响到 父类 的 prototype 对象；

- 注意：后续演进中的 super() 作用也大致如此；
- 注意：继承后才在子类 prototype 上添加方法和属性；
- <img src="/Image/Basics/Special/Mode/218.png" style="zoom:50%;" align="left" />

```js
function Parent(name) {
    this.name = [name];
  	this.play = [1, 2, 3];
}
Parent.prototype.getName = function() {
    return this.name
}
function Child(name, age) {
    // 1、构造函数的继承 复制父类构造属性方法给子类实例
    Parent.call(this, name);
  	this.age = age;
}
// 2、原型链的继承
// Child.prototype = new Parent()
// 3、优化组合继承 2 
// Child.prototype = Parent.prototype  // 寄生组合式继承中，将组合式继承的: 指向父类实例 改为:指向父类原型
// 将 指向父类实例 改为 指向父类原型，并使用浅拷贝避免父子原型间的影响
Child.prototype = Object.create(Parent.prototype)  
// 因上一句的关系，故须将指向修正为原本态: 指向自身构造函数, 否则指向的是 Parent
Child.prototype.constructor = Child
Child.prototype.getAge = function() {
    return this.age
}

// 传参测试
const child1 = new Child('TPP', 20)
const child2 = new Child('TLP', 70)
// 原型链继承测试
console.log('child1', child1);		
console.log(child1.getName(), child1.getAge()) // ['TPP'] 20
console.log(child1 instanceof Child, child1 instanceof Parent) // true true

child1.name[0] = 'foo'
child1.play.push(4);
// 共享测试
console.log(child1.play, child2.play); // [1,2,3,4] [1,2,3]
console.log(child1.name)          // ['foo']
console.log(child2.name)          // ['TLP']
child2.getName()                  // ['TLP']
```





##### 4-4-1、最优解

```js
var inherit = (function(c,p){
	var F = function(){};
	return function(c,p){
    // 中间对象
		F.prototype = p.prototype;
    // 子类 prototype 通过中间对象寻找 父类 prototype, 避免子类原型操作影响父类
		c.prototype = new F();
    // 备用: 为子对象设置 uber 属性，其指向父对象的 prototype 属性，仅用欧冠与实现继承完备性，纯属备用性质
		c.uber = p.prototype;
		// 修复子类实例的构造函数错误指向
		c.prototype.constructor = c;
	}
})();



// 其他: ES6 语法糖 class / extends
// 拓展: Extend 编译源码
function _possibleConstructorReturn(self, call) {
    // ...
    return call && (typeof call === 'object' || typeof call === 'function') ? call : self;
}

// 核心
function _inherits(subClass, superClass) {
    // ...
 		// 子类的原型的__proto__指向父类的原型
    subClass.prototype = Object.create(superClass && superClass.prototype, {
      	// 给子类添加 constructor 属性 subclass.prototype.constructor === subclass
        constructor: {
            value: subClass,
            enumerable: false,
            writable: true,
            configurable: true
        }
    });
  	// 用来继承父类的静态方法, 寄生组合遗漏地方
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}


var Parent = function Parent() {
    // 验证是否是 Parent 构造出来的 this
    _classCallCheck(this, Parent);
};

var Child = (function (_Parent) {
  	// 采用寄生组合继承方式
    _inherits(Child, _Parent);
  	
    function Child() {
        _classCallCheck(this, Child);
        return _possibleConstructorReturn(this, (Child.__proto__ || Object.getPrototypeOf(Child)).apply(this, arguments));
    }
    return Child;
}(Parent));

// _possibleConstructorReturn 实现了 super
function _possibleConstructorReturn(self, call) {
  if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); 
  // 显示绑定 Child 的内置 [[prototype]] 到 this，即在 Child 中执行 Child 原型链上关联的属性
  return call && (typeof call === "object" || typeof call === "function") ? call : self; 
}
// 核心: _inherits 函数，采用的依然也是第五种方式————寄生组合继承方式，同时证明了这种方式的成功; 
// 注意: 此处增加 Object.setPrototypeOf(subClass, superClass)，用来继承父类的静态方法, 此乃寄生组合遗漏地方
```





#### 4-5、ES6 继承

虽 ES6 引入了关键字 class，但底层仍然是基于原型的实现，Class 只是语法糖，让对象原型的写法更加清晰、更像面向对象编程的语法而已；

##### 4-5-1、ES6 的 ES5 对应(结构)

- **constructor**

  - ```js
    // ES6
    class Person {
        constructor(name) {
            this.name = name;
        }
        sayHello() {
            return 'hello, I am ' + this.name;
        }
    }
    var kevin = new Person('Kevin');
    kevin.sayHello(); 														// hello, I am Kevin
    Object.keys(Person.prototype); 								// []
    Object.getOwnPropertyNames(Person.prototype); // ["constructor", "sayHello"]
    
    
    // ES5
    function Person(name) {
        this.name = name;
    }
    Person.prototype.sayHello = function () {
        return 'hello, I am ' + this.name;
    };
    var kevin = new Person('Kevin');
    kevin.sayHello(); 														// hello, I am Kevin
    Object.keys(Person.prototype); 								// ['sayHello']
    Object.getOwnPropertyNames(Person.prototype); // ["constructor", "sayHello"]
    
    // 1、ES5 的构造函数 Person，对应 ES6 的 Person 类的 constructor 方法
    // 2、类的内部所有定义的方法，都是不可枚举的（non-enumerable）
    ```
    
  - ```js
    class Point {
      	// constructor 构造函数，默认方法，通过 new 命令创建对象实例时，自动调用该方法；
      	// 一个类必须有 constructor 方法，若无显式定义，则会被默认添加
        constructor(x) {
            this.x = 1;
            this.p = 2;
        }
        print() {
          return this.x;
        }
    }
    Point.prototype.z = '4'
    class ColorPoint extends Point {
        constructor(x) {
            this.color = color; // ReferenceError
          	// 留意 super
            super(x, y);
            this.x = x; // 正确
        }
        m() {
         super.print();
       }
    }
    
    // 上述 Point 等同于
    function Points(x) {
      this.x = x;
      this.p = 2;
    }
    Points.prototype.print = function() {
      return '(' + this.x +')';
    }
    // 也即 constructor 代表在父类上加属性，而在 class 对象加方法属性等于在原型上的加
    // 而这些属性方法 只有通过 new 出的实例 或  extends 继承出来的实例才可获取到
    new Points().__proto__.print() 	// 可调用到 Points 的 print 方法
    new Points().x = 1 							// 可调用到 constructor 的 this.x = 1
    ```

    

- **实例属性**

  - ```js
    // ES6
    class Person {
        state = {
            count: 0
        };
    }
    
    
    // ES5
    function Person() {
        this.state = {
            count: 0
        };
    }
    ```

- **静态方法**

  - ```js
    // ES6
    class Person {
        static sayHello() {
            return 'hello';
        }
    }
    Person.sayHello() 				// 'hello'
    var kevin = new Person();
    kevin.sayHello(); 				// TypeError: kevin.sayHello is not a function
    
    
    // ES5
    function Person() {}
    Person.sayHello = function() {
        return 'hello';
    };
    Person.sayHello(); 				// 'hello'
    var kevin = new Person();
    kevin.sayHello(); 				// TypeError: kevin.sayHello is not a function
    ```

- **静态属性**

  - ```js
    // ES6
    class Person {}
    Person.name = 'kevin';
    或
    class Person {
      static name = 'kevin';
    }
    
    
    // ES5
    function Person() {};
    Person.name = 'kevin';
    ```

- **new 调用**

  - ```js
    class Person {}
    Person(); // TypeError: Class constructor Foo cannot be invoked without 'new'
    
    // 类必须使用 new 调用，否则会报错；这是它跟普通构造函数的一个主要区别，后者不用 new 也可以执行；
    ```

- **Getter&Setter**

  - ```js
    // ES6
    class Person {
        get name() {
            return 'kevin';
        }
        set name(newName) {
            console.log('new name 为：' + newName)
        }
    }
    let person = new Person();
    person.name = 'daisy';				// new name 为：daisy
    console.log(person.name);			// kevin
    
    
    // ES5
    function Person(name) {}
    Person.prototype = {
        get name() {
            return 'kevin';
        },
        set name(newName) {
            console.log('new name 为：' + newName)
        }
    }
    let person = new Person();
    person.name = 'daisy';				// new name 为：daisy
    console.log(person.name);			// kevin
    ```
  
- **综合**

  - ```js
    // ZH - 1
    class TLP {
      // 0、相当于 ES5 的静态属性/方法
      static test = 'anything'
      constructor() {
        // 1、constructor 中 var 变量，只存在于 constructor 这个构造函数中 - 私有属性/方法
        var name = "TLP";
    		// 2、this 属性方法则定义到实例上 - 公有属性/方法
        this.name = "TSL";
        this.say = function () {};
      }
      // 3、等号定义会定义到实例上 - 公有属性/方法(另类)
      age = 80;
      showName = function () {
        console.log("showName");
      };
    	// 4、直接定义方法则定义到原型上 - 相当于 ES5 的 prototype 方法 - 公有属性/方法
      showAge() {
        console.log("showAge");
      }
    }
    var tlp = new TLP();
    console.log(Cat.test)  // anything
    console.log(tlp); // {age: 80, name: "TSL", showName: ƒ, say: ƒ}
console.log(Object.keys(tlp)); // ["age", "showName", "name", "say"]
    console.log(tlp.__proto__) // { ... showAge... }
    tlp.showName();
    tlp.showAge();
    
    
    
    // ZH - 2
    class TLP {
      // 静态属性/方法
      static test = "static-test";
      static test2 = "static-test2";
      
      constructor() {
        // 私有属性/方法
        var type = "con-oldman";
        // 公有属性/方法(实例-优先级高)
        this.name = "con-this-tlp";
        this.type = "con-this-oldman"
        this.getType = () => {
          console.log(this.type);
          console.log(type);
        };
      }
      // 公有属性/方法(实例-优先级低)
      name = "tlp"
      type = "oldman";
      getType = () => {
        console.log(this.type);
        console.log(type);
      };
      // 公有属性/方法(原型链)
      showName() {
      	console.log(this.type)
      };
    }
    var type = "window";
    var tlp = new TLP();
    tlp.getType();
    // con-this-oldman
    // con-oldman
    console.log(tlp);
    // TLP {name: "con-this-tlp", type: "con-this-oldman", getType: ƒ}
    ```
    
  - <img src="/Image/Basics/Special/Mode/222.png" style="zoom:50%;" />



##### 4-5-2、ES6 的 ES5 对应(源码)

利用 Babel 进行转译观察结果，[ Try it out ](https://babeljs.io/repl/#?babili=false&evaluate=true&lineWrap=false&presets=es2015%2Creact%2Cstage-2&targets=&browsers=&builtIns=false&debug=false&code_lz=Q)：

##### 4-5-2-1、Class

- ```js
  // ES6
  class Person {
  }
  
  
  // Babel 转译结果
  "use strict";
  
  function _instanceof(left, right) {
    if (
      right != null &&
      typeof Symbol !== "undefined" &&
      right[Symbol.hasInstance]
    ) {
      return !!right[Symbol.hasInstance](left);
    } else {
      return left instanceof right;
    }
  }
  
  function _classCallCheck(instance, Constructor) {
    if (!_instanceof(instance, Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  
  var Person = function Person() {
    _classCallCheck(this, Person);
  };
  ```

##### 4-5-2-2、Constructor

- 注意：一个类必须有 constructor 方法，若无显式定义，则会被默认添加；所以上一代码虽无 constructor 但被默认添加；

- 注意：**<u>constructor 对应的就是 ES5 中的构造函数；</u>**

- 注意：**<u>因类必须通过 new 方式调用，否则报错，此乃类特性之一，通过 _classCallCheck 实现；其作用是检查 Person 是否是通过 new 的方式调用；</u>**

  - 比如：当一类 Person 以此种方式调用：`var person = Person()`，则 this 指向 window， `instance instanceof Constructor`  为 false，报错；

- ```js
  // ES6
  class Person {
      constructor(name) {
          this.name = name;
      }
  }
  
  
  // Babel 转译结果
  "use strict";
  
  function _instanceof(left, right) {
    if (
      right != null &&
      typeof Symbol !== "undefined" &&
      right[Symbol.hasInstance]
    ) {
      // ES6 环境则使用更为不可外部更改的 Symbol 去检查
      return !!right[Symbol.hasInstance](left);
    } else {
      // ES5 环境下则退化为 instanceof
      return left instanceof right;
    }
  }
  
  function _classCallCheck(instance, Constructor) {
    // 检查 Person 是否是通过 new 的方式调用, 实现类须通过 new 调用的特性
    if (!_instanceof(instance, Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  
  var Person = function Person(name) {
    _classCallCheck(this, Person);
  	// 与上一相比只增加此行
    this.name = name;
  };
  ```

##### 4-5-2-3、实例&静态属性

- 注意：**<u>ES6 Class 实例属性对应 ES5 构造函数中的 this 对象上的属性；</u>**

- 注意：**<u>ES6 Class 静态属性对应 ES5 构造函数的自身属性；</u>**

- 注意：上述对应关系通过 _defineProperty 实现，其为 Object.defineProperty 的实现封装；

- ```js
  // ES6
  class Person {
      // 实例属性
      foo = 'foo';
      // 静态属性
      static bar = 'bar';
      constructor(name) {
          this.name = name;
      }
  }
  
  
  // Babel 转译结果
  "use strict";
  
  function _instanceof(left, right) {
    if (
      right != null &&
      typeof Symbol !== "undefined" &&
      right[Symbol.hasInstance]
    ) {
      return !!right[Symbol.hasInstance](left);
    } else {
      return left instanceof right;
    }
  }
  
  function _classCallCheck(instance, Constructor) {
    if (!_instanceof(instance, Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  
  // 与上一相比增加此函数
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true,
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  
  var Person = function Person(name) {
      _classCallCheck(this, Person);
  		// 与上一相比增加此行1
      _defineProperty(this, "foo", "foo");
  
      this.name = name;
    };
  
  // 与上一相比增加此行2
  _defineProperty(Person, "bar", "bar");
  ```

##### 4-5-2-4、实例&静态方法

- 注意：**<u>ES6 Class 实例方法对应 ES5 构造函数中的原型对象上的方法；</u>**

- 注意：**<u>ES6 Class 静态方法对应 ES5 构造函数的自身方法；</u>**

- 注意：**<u>上述对应关系通过 _createClass 实现，作用是根据方法类型(protoProps/staticProps)安插相应位置，使用 _defineProperties 实现方法遍历；</u>**

- 注意：**<u>前一代码返回一个 Person 构造函数，而此处，为自动执行 _createClass 方法而实现方法的绑定，返回一 IIFE，IIFE 则返回绑定后的构造函数；</u>**

- ```js
  // ES6
  class Person {
      foo = 'foo';
      static bar = 'bar';
      constructor(name) {
          this.name = name;
      }
  		// 实例方法
      sayHello() {
          return 'hello, I am ' + this.name;
      }
  		// 静态方法
      static onlySayHello() {
          return 'hello'
      }
  }
  
  
  // Babel 转译结果
  "use strict";
  
  function _instanceof(left, right) {
    if (
      right != null &&
      typeof Symbol !== "undefined" &&
      right[Symbol.hasInstance]
    ) {
      return !!right[Symbol.hasInstance](left);
    } else {
      return left instanceof right;
    }
  }
  
  function _classCallCheck(instance, Constructor) {
    if (!_instanceof(instance, Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true,
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  
  // 与上一相比增加此函数1
  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      // 默认 enumerable 为 false，configurable 为 true，是为防止 Object.keys() 之类的方法遍历
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      // 通过判断 value 是否存在，来判断是否是 getter 和 setter
      // 若存在 value，就为 descriptor 添加 value 和 writable 属性，若不存在，就直接使用 get 和 set 属性
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  // 与上一相比增加此函数2
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }
  
  // 与上一相比增加此行1(IIFE)
  var Person = /*#__PURE__*/ (function () {
    function Person(name) {
      _classCallCheck(this, Person);
  
      _defineProperty(this, "foo", "foo");
  
      this.name = name;
    } 
  
    // 与上一相比增加此行2
    _createClass(
      Person,
      [
        {
          key: "sayHello",
          value: function sayHello() {
            return "hello, I am " + this.name;
          }, // 静态方法
        },
      ],
      [
        {
          key: "onlySayHello",
          value: function onlySayHello() {
            return "hello";
          },
        },
      ]
    );
  
    return Person;
  })();
  
  _defineProperty(Person, "bar", "bar");
  ```

##### 4-5-2-5、Getter&Setter

- 注意：**<u>ES6 Class  Getter&Setter 方法对应 ES5 构造函数中的原型对象上的方法；</u>**

- 注意：**<u>还通过 _createClass —>  _defineProperties 的 Object.defineProperty(target, descriptor.key, descriptor); 为 set get 对象绑定相关方法</u>**

  -     // 通过判断 value 是否存在，来判断是否是 getter 和 setter
        // 若存在 value，就为 descriptor 添加 value 和 writable 属性，若不存在，就直接使用 get 和 set 属性

  - 比如：`Object.defineProperty(target, 'name',  set: function set(newName) { console.log('new name 为：' + newName);});`

- ```js
  // ES6
  class Person {
      foo = 'foo';
      static bar = 'bar';
      constructor(name) {
          this.name = name;
      }
      sayHello() {
          return 'hello, I am ' + this.name;
      }
      static onlySayHello() {
          return 'hello'
      }
      // Getter
      get name() {
          return 'kevin';
      }
      // Setter
      set name(newName) {
          console.log('new name 为：' + newName)
      }
  }
  
  
  // Babel 转译结果
  "use strict";
  
  // ...
  
  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }
  
  // ...
  
  var Person = /*#__PURE__*/function () {
    function Person(name) {
      _classCallCheck(this, Person);
  
      _defineProperty(this, "foo", 'foo');
  
      this.name = name;
    }
  
    _createClass(Person, [{
      key: "sayHello",
      value: function sayHello() {
        return 'hello, I am ' + this.name;
      }
    }, {
      key: "name",
      get: function get() {
        return 'kevin';
      },
      set: function set(newName) {
        console.log('new name 为：' + newName);
      }
    }], [{
      key: "onlySayHello",
      value: function onlySayHello() {
        return 'hello';
      }
    }]);
  
    return Person;
  }();
  
  // ...
  ```









##### 4-5-2-6、Extend

首先，几个 Extend 特殊特性：

- **<u>super 关键字表示父类的构造函数，相当于 ES5 的 Parent.call(this)</u>**

- 子类必须在 constructor 方法中调用 super 方法，<u>**否则新建实例时会报错 (已优化了，可新建实例)**</u>；

  - 因为子类没有自己的 this 对象，而是继承父类的 this 对象，然后对其进行加工；**<u>若不调用 super 方法，子类就得不到 this 对象</u>**；
  - 同时也因为此原因，在子类的构造函数中，**<u>只有调用 super 之后，才可使用 this 关键字，否则会报错</u>**

- **<u>父类的静态方法，可被子类继承</u>**；

  - ```js
    class Foo {
      // 最终变为 ES5 构造函数自身方法
      static classMethod() {
        return 'hello';
      }
    }
    // extends 内部实现了静态方法的继承: Bar.__proto__ = Foo
    class Bar extends Foo {
    }
    
    Bar.classMethod(); // 'hello'
    ```

  - 因为 Class 作为构造函数的语法糖，同时有 prototype 属性和 `__proto__` 属性，因此同时存在两条继承链：

    - 子类的 `__proto__` 属性，表示构造函数的继承，总是指向父类；

    - 子类 prototype 属性的 `__proto__` 属性，表示方法的继承，总是指向父类的 prototype 属性；

    - ```js
      class Parent {
      }
      class Child extends Parent {
      }
      console.log(Child.__proto__ === Parent); // true
      console.log(Child.prototype.__proto__ === Parent.prototype); // true
      ```

    - <img src="/Image/Basics/Special/Mode/219.png" style="zoom:50%;" align="left" />

    - 相比寄生组合式继承，ES6 的 class 多了一个 `Object.setPrototypeOf(Child, Parent)` 的步骤，此步就是用来继承父类的静态方法；

- **<u>extends 关键字后面可以跟多种类型的值：Function & null；</u>**

  - 只要是一个有 prototype 属性的函数，就能被继承；而由于函数都有 prototype 属性(除了 Function.prototype 函数)，因此 A 可是任意函数

  - ```js
    class B extends A {
    }
    class A extends null {
    }
    console.log(A.__proto__ === Function.prototype); 	// true
    console.log(A.prototype.__proto__ === undefined); // true
    ```

然后，Babel 编译与 ES6 继承区别探究：

```js
// ES6
class Parent {
    constructor(name) {
        this.name = name;
    }
}
class Child extends Parent {
}


// Babel 转译结果
("use strict");

function _inherits(subClass, superClass) {
  // 实现特性: 继承父类必须为 Function 或 null
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  // 类似于 ES5 的寄生组合式继承，使用 Object.create，设置子类 prototype 属性的 __proto__ 属性指向父类的 prototype 属性
  // 并给 subClass.prototype 添加一个可配置可写不可枚举的 constructor 属性，该属性值为 subClass (修正指向)
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: { value: subClass, writable: true, configurable: true },
  });
  // 设置子类的 __proto__ 属性指向父类
  // 实现特性: 静态方法继承, ES5 与 ES6 继承区别之一: subClass.__proto__ = superClass
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf =
    Object.setPrototypeOf ||
    function _setPrototypeOf(o, p) {
    	// subClass.__proto__ = superClass
      o.__proto__ = p;
      return o;
    };
  return _setPrototypeOf(o, p);
}

// 函数测试是否存在 NativeReflectConstruct
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  // 检查 Proxy 是因为 Reflect 是一个内置的对象，它提供拦截 JavaScript 操作的方法。这些方法与proxy handlers的方法相同
  if (typeof Proxy === "function") return true;
  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

// 获取 o.__proto__ 
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf
    ? Object.getPrototypeOf
    : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
      };
  return _getPrototypeOf(o);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError(
      "this hasn't been initialised - super() hasn't been called"
    );
  }
  return self;
}

// 帮助确定调用父类构造函数的返回值
function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized(self);
}


// _createSuper(Child) 作用是检查 Reflect 若有则利用 Reflect 创建对象否则 Super.apply(this, arguments);
// Reflect.construct() 与 Object.create() 均可创建对象，两种方式结果相同，但在创建对象过程中仍一点不同: new.target 的值上
// 当使用 Object.create() 和 Function.prototype.apply() 时，若不使用 new 操作符调用构造函数，构造函数内部的 new.target 值会指向 undefined。
// 当调用 Reflect.construct() 来创建对象，new.target 值会自动指定到 target（或者 newTarget，前提是 newTarget 指定了)
// new.target 属性允许你检测函数或构造方法是否是通过 new 运算符被调用的
// 通过 new 运算符被初始化的函数或构造方法时，new.target 返回一个指向构造方法或函数的引用；在普通的函数调用中，new.target 值是 undefined
function _createSuper(Derived) {
  // 首先检查是否有定义 Reflect
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    // 获取父类: return o.__proto__ || Object.getPrototypeOf(o) 因为先前 SubClass.__proto__ = SuperClass
    var Super = _getPrototypeOf(Derived),
      result;
    // 若有定义 Reflect
    if (hasNativeReflectConstruct) {
      // 获取实例的 constructor 即 SubClass: (return o.__proto__ || Object.getPrototypeOf(o)).constructor
      var NewTarget = _getPrototypeOf(this).constructor;
      // result 将会是 NewTarget 即 SubClass 类型
      // Reflect.construct() 方法的行为有点像 new 操作符构造函数, 相当于运行 new target(...args).
      // Reflect.construct (target, argumentsList[, newTarget]) 
      // Reflect.construct (被运行的目标构造函数, 类数组-目标构造函数调用时的参数, 作为新创建对象的原型对象的 constructor 属性)
      // 返回: 以 target(若 newTarget 存在，则为 newTarget）函数为构造函数，argumentList 为其初始化参数的对象实例
      // new Foo(...args) === Reflect.construct(Foo, args)
      // 所以: Reflect.construct(Super, arguments, NewTarget); === new NewTarget(arguments)
      // result 将会是 NewTarget 即 SubClass 类型
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      // 不使用 Reflect 此时的 new.target 值为 undefined
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}

// 严格 typeof 实现
function _typeof(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj &&
        typeof Symbol === "function" &&
        obj.constructor === Symbol &&
        obj !== Symbol.prototype
        ? "symbol"
        : typeof obj;
    };
  }
  return _typeof(obj);
}
// 严格 instanceof 实现
function _instanceof(left, right) {
  if (
    right != null &&
    typeof Symbol !== "undefined" &&
    right[Symbol.hasInstance]
  ) {
    return !!right[Symbol.hasInstance](left);
  } else {
    return left instanceof right;
  }
}
// Class 须为 new 调用
function _classCallCheck(instance, Constructor) {
  if (!_instanceof(instance, Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

var Parent = function Parent(name) {
  _classCallCheck(this, Parent);
  this.name = name;
};

var Child = /*#__PURE__*/ (function (_Parent) {
  // 继承实现
  _inherits(Child, _Parent);
  // 返回闭包延迟执行
  var _super = _createSuper(Child);

  function Child() {
    _classCallCheck(this, Child);
    return _super.apply(this, arguments);
  }
  return Child;
})(Parent);
```

- 注意：**<u>Babel 创建 _inherits 函数帮助实现继承，又创建了 _possibleConstructorReturn 函数帮助确定调用父类构造函数的返回值</u>**；

- 注意：**<u>过去缺少调用 super 时新建实例会报错，但现已通过新增 var _super = _createSuper(Child); 优化，故可新建实例，但仍无法拿到 this；</u>**

  - `var _super = _createSuper(Child);` 作用是：

    - 若有 `Reflect`，则利用 `Reflect.construct` 创建对象；
    - 若无，则利用 `Super.apply(this, arguments);` (`Object.create()`) 创建，**<u>*相当于在子类执行父类构造，所以 result = 其构造函数返回值*</u>**

  - 注意：**<u>*为何如此大费周章*</u>**，是因为后者 new.target 值为 undefined，无法完美实现 ES6 继承特征，但也不一定需要，所以支持 apply 形式，而 apply 就是 ES5 寄生组合式继承的方式：`function Child() { Parent.call(this, name, ...) ...};` 

  - 注意：`Super = _getPrototypeOf(Child), 而 _getPrototypeOf == return o.__proto__ || Object.getPrototypeOf(o);`，Super 为父类；

  - 注意：`Reflect.construct()` 方法的行为有点像 new 操作符构造函数, 相当于运行 `new target(...args).`

    - `Reflect.construct (target, argumentsList[, newTarget])` 
    - `Reflect.construct (被运行的目标构造函数, 类数组-目标构造函数调用时的参数, 作为新创建对象的原型对象的 constructor 属性)`
    - 返回: `以 target (若 newTarget 存在，则为 newTarget) 函数为构造函数，argumentList 为其初始化参数的对象实例`
    - `new Foo(...args) === Reflect.construct(Foo, args)`
    - 所以: `Reflect.construct(Super, arguments, NewTarget); === new NewTarget(arguments)`
    - `NewTarget = _getPrototypeOf(this).constructor，即获取实例的 constructor 即 SubClass`
    - **<u>*所以 Reflect.construct() 方式下，result = SubClass 的实例；*</u>**

  - 注意：`Reflect.construct()` 与 `Object.create()` 均可创建对象，两种方式结果相同，但在创建对象过程中仍一点不同：体现在 `new.target` 的值上

    - 当使用 `Object.create` 和 `Function.prototype.apply` 时，若不用 new 操作符调用构造函数，则其内部的 `new.target` 值会指向 `undefined`；
    - 当调用 `Reflect.construct` 来创建对象，`new.target` 值会自动指定到 target (或 newTarget，前提是 newTarget 指定了)
    - `new.target` 属性允许检测函数或构造方法是否是通过 new 运算符被调用的:
      - 通过 new 运算符被初始化的函数或构造方法时，`new.target` 返回一个指向构造方法或函数的引用；
      - 而通过普通函数调用，则其值是 undefined；

  - 创建出来的对象 result 再经过 `_possibleConstructorReturn(this, result);` 处理，其帮助确定调用父类构造函数的返回值；

    - ```js
      // 此为旧版实现方式，新版实现的作用与之相同，只是做了功能分拆和细化，但旧版更容易理解
      function _possibleConstructorReturn(self, call) {
          if (!self) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }
          return call && (typeof call === "object" || typeof call === "function") ? call : self;
      }
      ```

    - 前面提到，result 有两种情况，一个是 Reflect.construct 的处理结果，为子类实例，一个是 Super.apply(this, arguments) 的处理结果；对于 result 值，如果是 object 类型或是 function 类型，则返回 result，如果是 null 或 基本类型的值 或 undefined，则返回 self 也即子类的 this；

    - ```js
      // Ex1 return null
      class Parent {
          constructor(name) {
            	this.name = name;
            	return null
          }
      }
      class Child extends Parent {
        	// Child 未增加 constructor & super 版
        	// ...
      
        	// Child 增加 constructor & super 版
          constructor(name, age) {
              super(name); 
              this.age = age;
          }
      }
      // Ex1 - Babel
      // ...
      function _createSuper(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct();
        return function _createSuperInternal() {
          // Super 为 Parent 构造函数
          var Super = _getPrototypeOf(Derived), result;	
          
          // 注意!!! 此段目的就是调用 Parent.call/apply(this, arguments)
          // 只是前者能使 new.target 有其值，后者 new.target 为 undefined
      		if (hasNativeReflectConstruct) {
            // NewTarget = Child 构造函数
            var NewTarget = _getPrototypeOf(this).constructor;
            // result = Child 实例
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            // result = null
            result = Super.apply(this, arguments);
          }
          
          // 注意!!! 此段目的就是根据 result 值
          // 方式1 result 为 Child 实例，返回 result
          // 方式2:
          //			若 result 为 null、undefined、基本值 则返回 Child 实例
        	// 			否则返回 result
          return _possibleConstructorReturn(this, result);
        };
      }
      function _possibleConstructorReturn(self, call) {
        if (call && (_typeof(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized(self);
      }
      
      function _assertThisInitialized(self) {
        if (self === void 0) {
          throw new ReferenceError(
            "this hasn't been initialised - super() hasn't been called"
          );
        }
        return self;
      }
      // ...
      var Parent = function Parent(name) {
        _classCallCheck(this, Parent);
        this.name = name;
        return null;
      };
      var Child = /*#__PURE__*/ (function (_Parent) {
        _inherits(Child, _Parent);
        var _super = _createSuper(Child);
      
        // Child 未增加 constructor & super 版
        function Child() {
          _classCallCheck(this, Child);
          return _super.apply(this, arguments);
        }
        // Child 增加 constructor & super 版
        function Child(name, age) {
          var _this; 												// undefined
          _classCallCheck(this, Child);
          _this = _super.call(this, name);  // Child 实例
          _this.age = age;
          return _this;
        }
        return Child;
      })(Parent);
      var child = new Child("TLP", 70)
      ```



##### 4-5-2-7、Extend 总结

```js
// ...
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    // Super 为 Parent 构造函数
    var Super = _getPrototypeOf(Derived), result;	
    
    // 注意!!! 此段目的就是调用 Parent.call/apply(this, arguments)
    // 只是前者能使 new.target 有其值，后者 new.target 为 undefined
		if (hasNativeReflectConstruct) {
      // NewTarget = Child 构造函数
      var NewTarget = _getPrototypeOf(this).constructor;
      // result = Child 实例
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      // result = null
      result = Super.apply(this, arguments);
    }
    
    // 注意!!! 此段目的就是根据 result 值
    // 方式1 result 为 Child 实例，返回 result
    // 方式2:
    //			若 result 为 null、undefined、基本值 则返回 Child 实例
  	// 			否则返回 result
    return _possibleConstructorReturn(this, result);
  };
}
function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; }
  return _assertThisInitialized(self);
}

function _assertThisInitialized(self) {
  if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}
  return self;
}
// ...
// 主体部分
var Parent = function Parent(name) {
  _classCallCheck(this, Parent);
  this.name = name;
  return null;
};
var Child = /*#__PURE__*/ (function (_Parent) {
  _inherits(Child, _Parent);
  var _super = _createSuper(Child);

  // Child 未增加 constructor & super 版
  function Child() {
    _classCallCheck(this, Child);
    return _super.apply(this, arguments);
  }
  
  // Child 增加 constructor & super 版
  function Child(name, age) {
    var _this; 												// undefined
    _classCallCheck(this, Child);
    _this = _super.call(this, name);  // Child 实例作为 this
    _this.age = age;
    return _this;
  }
  return Child;
})(Parent);
// ...
```

- 首先，执行 `_inherits(Child, Parent)`，建立 Child 和 Parent 的原型链关系，即：

  - ```js
    //  Object.setPrototypeOf(Child.prototype, Parent.prototype) 和 Object.setPrototypeOf(Child, Parent)
    function _inherits(subClass, superClass) {
      // 实现特性: 继承父类必须为 Function 或 null
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      // 类似于 ES5 的寄生组合式继承，使用 Object.create，设置子类 prototype 属性的 __proto__ 属性指向父类的 prototype 属性
      // 并给 subClass.prototype 添加一个可配置可写不可枚举的 constructor 属性，该属性值为 subClass (修正指向)
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: { value: subClass, writable: true, configurable: true },
      });
      // 设置子类的 __proto__ 属性指向父类
      // 实现特性: 静态方法继承, ES5 与 ES6 继承区别之一: subClass.__proto__ = superClass
      if (superClass) _setPrototypeOf(subClass, superClass);
    }
    ```

- 然后，调用 `_super.call(this, name)`，内部核心为   `Parent.call(this, name)`；
  - 若无调用 super()，则返回子类实例，_this 不可用；
  - 若调用 super，则将返回值(根据 Parent 构造函数的返回值类型，确定子类构造函数 this 的初始值)赋给 _this，_this 可用；

- 最终，根据子类构造函数，修改 _this 的值，然后返回该值；

- **<u>*问题：为何 super 调用前不能用 this；*</u>**

  - 因为 super 负责继承中的：构造函数的继承，复制父类构造属性方法给子类实例，倘若不加限制，在 super 前使用 this 为子类构造函数添加属性，则 super 调用后，父类构造函数属性就会覆盖掉先前设置的同名属性，所以 super 调用前不能使用 this；

  - ```js
    // 先看转换结果
    class Parent {
        constructor(name) {
          	this.name = name;
          	return null
        }
    }
    class Child extends Parent {
        constructor(name, age) {
          	console.log(this);
            super(name); 
            this.age = age;
        }
    }
    
    
    // ...
    function _assertThisInitialized(self) { 
    	if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } 
    	return self; 
    }
    
    // ...
    var Parent = function Parent(name) {
      _classCallCheck(this, Parent);
      this.name = name;
      return null;
    };
    
    var Child = /*#__PURE__*/function (_Parent) {
      _inherits(Child, _Parent);
      var _super = _createSuper(Child);
      function Child(name, age) {
        var _this;
        _classCallCheck(this, Child);
        console.log(_assertThisInitialized(_this)); // error
        _this = _super.call(this, name);
        _this.age = age;
        return _this;
      }
    
      return Child;
    }(Parent);
    // ...
    ```

- **<u>*区别：ES5 的寄生组合继承实现与 ES6 继承有细微差别：*</u>**

  - ES6 Class 中含有 Object.setPrototypeOf(subClass, superClass)，用以继承父类静态方法，但寄生组合没有；
  - super 机制，确保构造函数属性添加顺序进行；




#### 4-6、总结

- 首先，最容易想到的是 **<u>原型链继承</u>**，通过把子类实例的原型指向父类实例来继承父类的属性和方法，但原型链继承的缺陷在于<u>对子类实例继承的引用类型的修改会影响到所有的实例对象，以及无法向父类的构造方法传参</u>；
- 因此，引入了 **<u>构造函数继承</u>**, 通过在子类构造函数中调用父类构造函数并传入子类 this 来获取父类的属性和方法，但构造函数继承也存在缺陷，<u>构造函数继承不能继承到父类原型链上的属性和方法</u>；
- 所以，综合两种继承的优点，提出了 **<u>组合式继承</u>**，但组合式继承也引入了新的问题：<u>它每次创建子类实例都执行了两次父类构造方法</u>；最后，通过将子类原型指向父类实例，改为子类原型指向父类原型的浅拷贝来解决这一问题，也即最终实现：**<u>寄生组合式继承</u>**



#### 4-7、多继承

##### 4-7-1、基本

基本：没有几个语言能真正实现多继承，比如 C++ 和 python 提供了多继承的语法；

而 Java 只允许继承一个父类，但可同时 implements 多个接口类，也算一种变相的多继承；

```js
function MyClass() {
     SuperClass.call(this);
     OtherSuperClass.call(this);
}

// 继承一个类（就是寄生组合继承的套路）
MyClass.prototype = Object.create(SuperClass.prototype);

// 混合其它类，关键是 assign() 方法: 
// assign 会将 OtherSuperClass 原型上的函数拷贝到 MyClass 原型上，使 MyClass 的所有实例都可用 OtherSuperClass 的方法
Object.assign(MyClass.prototype, OtherSuperClass.prototype);

// 重新指定 constructor
MyClass.prototype.constructor = MyClass;

// 在之类上附加方法
MyClass.prototype.myMethod = function() {
  // do a thing
};
```

[Object.assign](https://link.zhihu.com/?target=https%3A//developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign) [ polyfilled](https://link.zhihu.com/?target=https%3A//developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign%23Polyfill)，支持旧浏览器可用使用 [jQuery.extend()](https://link.zhihu.com/?target=https%3A//api.jquery.com/jQuery.extend/) 或 [_.assign()](https://link.zhihu.com/?target=https%3A//lodash.com/docs/%23assign)、[MDN\] Object.create()](https://link.zhihu.com/?target=https%3A//developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create)



##### 4-7-2、多继承问题

- 问题：instanceof 指向

  - JS 只有 prototype 链，且约束了每一对象只能有一条 Prototype，则在多继承情况下， instanceof 须另外实现；

  - ```js
    class A {}
    class B {}
    // 假定有继承
    class C extend A, B {}
    // 此时 C 的实例，则应同时指向 A & B
    const c = new C();
    c instanceof A // true
    c instanceof B // true
    c instanceof C // true
    ```

- 问题：Diamond Problem 
  - 假如 ABC 三类均定义一同名函数，则 D 的实例应取谁为准
  - <img src="/Image/Basics/Special/Mode/219.png" style="zoom:50%;" align="left" />



##### 4-7-3、多继承解决

- 解决：instanceof

- 思路：借鉴 Java 思路，实际只继承一个类，而其他类则通过其他方式将其功能融入；

- Java 中可用 Interface 约束类该有的行为，当然 JS 也可参考使用 interface，但如此的话，除校验外别无他用，故 JS 改用 mixin 方式更为实在

- ```js
  // 构造一个中间类，让中间类直接继承 A，并且 mixin 了 B 的原型成员，然后再让 C 去继承这个中间类
  const mixinClass = (base, ...mixins) => {
    // tool
    const mixinProps = (target, source) => {
      Object.getOwnPropertyNames(source).forEach(prop => {
        if (/^constructor$/.test(prop)) { return; }
        Object.defineProperty(target, prop, Object.getOwnPropertyDescriptor(source, prop));
      })
    };
  
    let Ctor;
    
    // 由于 B 是通过 mixin 方式浅拷贝了一份，B.prototype 并不在 C 的原型链上（C.__proto__.__proto__），所以 c instanceof B 为 false
    if (base && typeof base === 'function') {
      Ctor = class extends base {
        constructor(...props) {
          super(...props);
        }
      };
      mixins.forEach(source => {
        mixinProps(Ctor.prototype, source.prototype);
      });
    } else {
      // 
      Ctor = class {};
    }
    return Ctor;
  };
  
  class A {
    methodA() {}
  }
  class B {
    methodB() {}
  }
  class C extends mixinClass(A, B) {
    methodA() { console.log('methodA in C'); }
    methodC() {}
  }
  
  let c = new C();
  c instanceof C  // true
  c instanceof A  // true
  c instanceof B  // false
  ```

- 解决 Diamond Problem 

- 思路：Method Resolution Order (MRO) 指的是在继承结构中确定类的线性顺序，例如 `C => B => A` 表示 C 继承 B，B 继承 A，那么 C 的 MRO 就是 `C B A`，也即当调用 C 实例中的一个函数时，会按照 `C B A` 的优先级顺序去“寻找”该函数。在单继承的结构中自然没有问题，而在多继承中 MRO 发挥着其作用；常用的 [C3算法](https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/C3_linearization) 就是用来计算 MRO

- 详见：[JS多继承](https://zhuanlan.zhihu.com/p/34693209)









### 五、设计模式

#### 5-1、面向对象的设计

##### 5-1-1、设计原则

- **单一职责原则**：一个类只负责一个功能领域中的相应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因；
- **开放封闭原则**：核心思想是软件实体(类、模块、函数等)是可扩展的、但不可修改；即对扩展是开放的,而对修改是封闭的；



##### 5-1-2、单例模式

即一个类只能构造出唯一实例，其意义在于**共享、唯一**；

比如：`Redux/Vuex`中的store、`JQ`的$或者业务场景中的购物车、登录框都是单例模式的应用

```js
class SingletonLogin {
  constructor(name,password){
    this.name = name
    this.password = password
  }
  static getInstance(name,password){
    // 判断对象是否已经被创建,若创建则返回旧对象
    if(!this.instance)this.instance = new SingletonLogin(name,password)
    return this.instance
  }
}
 
let obj1 = SingletonLogin.getInstance('TLP','123')
let obj2 = SingletonLogin.getInstance('TLP','321')
 
console.log(obj1===obj2)    // true
console.log(obj1)           // {name:TLP,password:123}
console.log(obj2)           // 输出的依然是 {name:TLP,password:123}
```



##### 5-1-3、工厂模式

即对创建对象逻辑的封装，或可简单理解为对 `new` 的封装，这种封装就像创建对象的工厂，故名工厂模式；

常见于大型项目，比如 JQ 的 对象，在创建选择器对象时之所以没有 new selector 就是因为其已是一个工厂方法；

比如：`React.createElement()`、`Vue.component()` 都是工厂模式的实现；

种类：`简单工厂模式`、`工厂方法模式`、`抽象工厂模式`；

##### 5-1-3-1、简单工厂模式

```js
class User {
  constructor(name, auth) {
    this.name = name
    this.auth = auth
  }
}

class UserFactory {
  static createUser(name, auth) {
    // 工厂内部封装了创建对象的逻辑:
    // 权限为admin时,auth=1, 权限为user时, auth为2
    // 使用者在外部创建对象时,不需要知道各个权限对应哪个字段, 不需要知道赋权的逻辑，只需要知道创建了一个管理员和用户
    if(auth === 'admin')  new User(name, 1)
    if(auth === 'user')  new User(name, 2)
  }
}

const admin = UserFactory.createUser('cxk', 'admin');
const user = UserFactory.createUser('cxk', 'user');
```



##### 5-1-4、观察者模式

观察者模式算是前端最常用的设计模式了，其概念简单：观察者监听被观察者的变化，被观察者发生改变时，通知所有的观察者；

观察者模式被广泛用于监听事件的实现；

注意：有些文章也把观察者模式称为发布订阅模式，其实二者是有所区别的，发布订阅相较于观察者模式多一个调度中心；

```js
//观察者
class Observer {    
  constructor (fn) {      
    this.update = fn    
  }
}
//被观察者
class Subject {    
    constructor() {        
        this.observers = []          // 观察者队列    
    }    
    addObserver(observer) {          
        this.observers.push(observer)// 往观察者队列添加观察者    
    }    
    notify() {                       // 通知所有观察者,实际上是把观察者的 update()都执行了一遍       
        this.observers.forEach(observer => {        
            observer.update()            // 依次取出观察者,并执行观察者的 update 方法        
        })    
    }
}

var subject = new Subject()       // 被观察者
const update = () => {console.log('被观察者发出通知')}  //收到广播时要执行的方法
var ob1 = new Observer(update)    // 观察者1
var ob2 = new Observer(update)    // 观察者2
subject.addObserver(ob1)          // 观察者1订阅 subject 的通知
subject.addObserver(ob2)          // 观察者2订阅 subject 的通知
subject.notify()                  // 发出广播,执行所有观察者的 update 方法
```



##### 5-1-5、装饰器模式

可理解为对类的一个包装，动态地拓展类的功能；

比如：ES7 的 <u>装饰器</u> 语法、React 中的 <u>高阶组件(HoC)</u> 、react-redux 的 connect()、都是此模式的实现；

```js
// 以 ES7 的装饰器为例
function info(target) {
  target.prototype.name = '张三'
  target.prototype.age = 10
}

@info
class Man {}

let man = new Man()
man.name // 张三
```



##### 5-1-6、适配器模式

即将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作；

```js
class Adaptee {
  test() {
      return '旧接口'
  }
}
 
class Target {
  constructor() {
      this.adaptee = new Adaptee()
  }
  test() {
      let info = this.adaptee.test()
      return `适配${info}`
  }
}
 
let target = new Target()
console.log(target.test())
```



##### 5-1-7、代理模式

```
const idol = {
  name: '特朗普',
  phone: 10086,
  price: 1000000  //报价
}

const agent = new Proxy(idol, {
  get: function(target) {
    // 拦截明星电话的请求,只提供经纪人电话
    return '经纪人电话: 10086'
  },
  set: function(target, key, value) {
    if(key === 'price' ) {
      // 经纪人过滤资质
      if(value < target.price) throw new Error('报价过低')
      target.price = value
    }
  }
})


agent.phone        // 经纪人电话:10086
agent.price = 100  // Uncaught Error: 报价过低
```





#### 5-2、面向组合的设计

**<u>继承最大问题在于：无法决定继承哪些属性，所有属性都得继承；</u>**

比如：B 类继承 A 类，为避免上述问题，可创建父类，把不必要的内容先剔除；但问题仍显著：

- 一方面：父类无法描述所有子类的细节情况，为不同子类特性去增加不同的父类，<u>代码大量重复</u>；
- 一方面：一旦子类有所变动，父类也要进行相应更新，<u>代码耦合性太高</u>，<u>难以维护</u>；

**<u>解决：使用组合，当今编程语法发展趋势，比如 golang 完全采用的是面向组合的设计方式；</u>**

其原理即先设计一系列零件，然后将这些零件进行拼装，来形成不同的实例或者类；

```js
function drive(){
  console.log("wuwuwu!");
}
function music(){
  console.log("lalala!")
}
function addOil(){
  console.log("kakaka！")
}

let car = compose(drive, music, addOil);
let newEnergyCar = compose(drive, music);
```







### X、架构模式

#### X-1、基本

软件架构模式—**<u>*Architectural Pattern*</u>**：MVC，MVP，MVVM，均是常见的软件架构模式(Architectural Pattern)；

软件架构模式通过分离关注点，来改进代码的组织方式，且相对独立不影响；

- 相同部分：**<u>*MV(Model-View)*</u>**
- 不同部分：**<u>*C(Controller)、P(Presenter)、VM(View-Model)*</u>**

架构模式不同于设计模式 (Design Pattern)

- 前者往往使用了多种设计模式；
- 后者只是为了解决一类问题而总结出的抽象方法；



#### X-2、M& V & C

##### X-2-1、Model

应用程序中用于，处理应用程序数据逻辑的部分；

用于封装和应用程序的业务逻辑相关的数据以及对数据的处理方法；

通常 Model 负责在数据库中存取数据；

##### X-2-2、View

应用程序中，处理数据显示的部分；

通常 View 依据模型数据创建；

##### X-2-3、Controller

应用程序中，处理用户交互的部分；

用于连接 Model & View，控制应用程序流程，定义用户界面对用户输入响应方式，处理用户行为和数据上的改变；

通常 Controller 负责从 View 读取数据，控制用户输入，并向 Model 发送数据，是一个中间件；



#### X-3、MV(C/P/VM)

分别用三种模式实现一个可以对数值进行加减操作的组件：

<img src="/Image/Basics/Special/Mode/200.png" style="zoom:50%;" align="left" />



##### X-3-1、MVC

<img src="/Image/Basics/Special/Mode/201.png" style="zoom:50%;" align="left" />

基本：View 负责接收用户的输入操作，Controller 负责业务逻辑的处理，Model 负责数据持久化(数据管理)，Controller 将结果反馈给 View

优点：

- 简化分组开发，实现同时开发；
- 利于管理，让开发人员更专注于开发；
- 职责明确，独立改变而不影响，较高的灵活性和重用性；

缺点：

- Controller 集中了过多业务逻辑；
- View 与 Controller 间耦合重，难以复用；
- 当每个事件都流经 Controller 时，Controller 变得臃肿；

应用：JavaEE 中的 SSH框架(Struts/Spring/Hibernate)、Struts(View, STL)、Spring(Controller, Ioc、Spring MVC)、Hibernate(Model, ORM)



- MVC 的 Model
  - 用于存储业务数据，数据发生变化，Model 将通知 View；
  - Model 和 View 间使用了观察者模式，View 事先在 Model 上注册从而观察 Model，当 Model 上数据发生改变时 View 则及时刷新(Controller)；
  - <img src="/Image/Basics/Special/Mode/202.png" style="zoom:50%;" align="left" />

- MVC 的 View
  - Controller 和 View 间使用了策略模式，View 引入 Controller 的实例 来实现特定的响应策略，如其中的按钮的 click 事件：
  - <img src="/Image/Basics/Special/Mode/203.png" style="zoom:50%;" align="left" />

- MVC 的 Controller
  - Controller 是 Model 和 View 间的纽带，MVC 将响应机制封装在 controller 对象中
  - 在 Controller 中响应 View 的事件并调用 Model 的接口对数据进行操作，一旦 Model 发生变化便通知 View 进行更新；
  - <img src="/Image/Basics/Special/Mode/204.png" style="zoom:50%;" align="left" />

此处实例化 View 并向对应的 Model 实例注册，当 Model 发生变化时就去通知 View 做更新，这里用到了观察者模式；

最后一步，使用 Controller 初始化：

- <img src="/Image/Basics/Special/Mode/205.png" style="zoom:50%;" align="left" />







##### X-3-2、MVP

<img src="/Image/Basics/Special/Mode/206.png" style="zoom:50%;" align="left" />

基本：MVP 是 MVC 模式的改良，其将 MVC 中的 Controller 换为 Presenter-呈现，同样负责业务逻辑；即 View 负责控件组成的页面，Model 负责实体数据库操作；而 View 和 Model 间的控件数据绑定操作则属于 Presenter，目的时隔绝 View 和 Model 间的通信，View 不再像 MVC 那样直接访问 Model，而此任务交由 Presenter 负责；

优点：

- 与 MVC 相比，解决了无法实现多个 View 共用一个 Controller的问题，降低 View 和 Controller 耦合度，可复用性提高
- 与 MVC 相比，MVP模式通过解耦 View 和 Model ，使职责划分更加清晰
- 隔绝 View 和 Model，可将 View 抽离封装成组件(往后只需提供接口提供给上层操作即可)

缺点：

- Presenter 还是很重，维护困难；
- Presenter 负责基本业务逻辑，还需管理 View 与 Model 间的数据流动；
- 由于没有数据绑定，若 View 需求增多，Presenter 也要改变

应用：[ASP.NET](http://asp.net/) 的 webform、winform 基于事件驱动的开发技术就是使用的 MVP 模式

注意：React 是 View 层的框架，Model 层的框架需要结合 Flux 或 Redux ；



- MVP 的 Model
  - 同 MVC，依然用于封装业务相关的数据和对应处理数据的方法
  - <img src="/Image/Basics/Special/Mode/207.png" style="zoom:50%;" align="left" />

- MVP 的 View
  - 用户对 View 的操作都转移到了Presenter
  - 待 Presenter 通知 Model 更新后，Presenter 调用 View 提供的接口更新视图(下 this)；
  - <img src="/Image/Basics/Special/Mode/208.png" style="zoom:50%;" align="left" />

- MVP 的 Presenter
  - 负责基本的业务逻辑，并管理 从 View 与 View 间的数据流动；
  - <img src="/Image/Basics/Special/Mode/209.png" style="zoom:50%;" align="left" />

最后一步，使用 View 初始化：(MVC 用的是 Controller 实例化)

- <img src="/Image/Basics/Special/Mode/210.png" style="zoom:50%;" align="left" />









##### X-3-3、MVVM

基本：MVP 是对 MVC 的改良，MVVM 则是变革，MVVM 将数据模型的，数据双向绑定的思想作为核心；MVVM 将 View 和 Model 的同步逻辑自动化，之间的同步不再需手动操作，而是交由框架提供的数据绑定功能来负责处理；即只需告诉框架 V层 显示的数据，对应 M层哪一部分即可；至此，V层 数据的变化会同时修改 M层的数据源，而 M层的数据变化也会立即反应到 V层上；

注意：ViewModel 是整个模式的重点，业务逻辑也主要集中在这里，其中的一大核心就是数据绑定；

优点：

- 与 MVC/P 相比，简化业务与界面的依赖，解决数据频繁更新的问题；
- 与 MVC/P 相比，V 层 和 M 层分离，低耦合，提高可复用性；
- 与 MVC/P 相比，MVVM 中的 View 通过使用模板语法来声明式的将数据渲染进 DOM；
- VM 对Model 进行更新时，会通过数据绑定，更新到 View

应用：.NET的 WPF、JS 的 Knockout、AngularJS、Angular 框架；

- MVVM 的 Model
  - 在 MVVM 中，可将 Model 称为数据层，仅关注数据本身，不关心任何行为；
  - <img src="/Image/Basics/Special/Mode/211.png" style="zoom:50%;" align="left" />
- MVVM 的 View
  - 与 MVC/MVP 不同的是，MVVM 中的 View 通过使用模板语法来声明式的将数据渲染进 DOM
  - VM 对 Model 进行更新时，会通过数据绑定，更新到 View；
  - <img src="/Image/Basics/Special/Mode/212.png" style="zoom:50%;" align="left" />
- MVVM 的 ViewModel
  - 与 MVP 不同的是，没有了 View 为 Presente 提供的接口；
  - 之前由 Presenter 负责的 View 和 Model 间的数据同步交给了 ViewModel 中的数据绑定进行处理；
  - Model 和 ViewModel 任一一个发生变化，就会自动更新对方；
  - <img src="/Image/Basics/Special/Mode/213.png" style="zoom:50%;" align="left" />

补充A：

**Model**: 代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑。我们可以把Model称为数据层，因为它仅仅关注数据本身，不关心任何行为

**View**: 用户操作界面。当ViewModel对Model进行更新的时候，会通过数据绑定更新到View

**ViewModel**： 业务逻辑层，View需要什么数据，ViewModel要提供这个数据；View有某些操作，ViewModel就要响应这些操作，所以可以说是Model for View.

**总结**： MVVM 模式简化了界面与业务的依赖，解决了数据频繁更新；在使用当中，利用双向绑定技术，使得 Model 变化时，ViewModel 会自动更新，而 ViewModel 变化时，View 也会自动变化；



补充B：

ViewModel 是由前端开发人员组织生成和维护的视图数据层。在这一层，前端开发者对从后端获取的 Model 数据进行转换处理，做二次封装，以生成符合 View 层使用预期的视图数据模型。需要注意的是 ViewModel 所封装出来的数据模型包括视图的状态和行为两部分，而 Model 层的数据模型是只包含状态的，比如页面的这一块展示什么，而页面加载进来时发生什么，点击这一块发生什么，这一块滚动时发生什么这些都属于视图行为（交互），视图状态和行为都封装在了 ViewModel 里。这样的封装使得 ViewModel 可以完整地去描述 View 层。

MVVM 框架实现了双向绑定，这样 ViewModel 的内容会实时展现在 View 层，前端开发者再也不必低效又麻烦地通过操纵 DOM 去更新视图，MVVM 框架已经把最脏最累的一块做好了，我们开发者只需要处理和维护 ViewModel，更新数据视图就会自动得到相应更新。这样 View 层展现的不是 Model 层的数据，而是 ViewModel 的数据，由 ViewModel 负责与 Model 层交互，这就完全解耦了 View 层和 Model 层，这个解耦是至关重要的，它是前后端分离方案实施的重要一环

```js
// View 层
<div id="app">
    <p>{{message}}</p>
    <button v-on:click="showMessage()">Click me</button>
</div>

// ViewModel 层
var app = new Vue({
    el: '#app',
    data: {  // 用于描述视图状态   
        message: 'Hello Vue!', 
    },
    methods: {  // 用于描述视图行为  
        showMessage(){
            let vm = this;
            alert(vm.message);
        }
    },
    created(){
        let vm = this;
        // Ajax 获取 Model 层的数据
        ajax({
            url: '/your/server/data/api',
            success(res){
                vm.message = res;
            }
        });
    }
})

// Model 层
{
    "url": "/your/server/data/api",
    "res": {
        "success": true,
        "name": "IoveC",
        "domain": "www.cnblogs.com"
    }
}
```









#### X-4、使用例子

##### X-4-1、Vue

<img src="/Image/Basics/Special/Mode/214.png" style="zoom:50%;" align="left" />

