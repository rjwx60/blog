---
typora-root-url: ../../Source
---



<img src="/Image/Basics/Special/Async/1.png" style="zoom:60%;" />



### 一、总结

#### 1-1、异步编程发展历程简述

- 阶段一：回调函数
  - 问题1：缺乏顺序性：其导致调试困难，并与大脑线性思维方式不符；
  - 问题2：缺乏可信任性： 控制反转导致系列信任问题；
- 阶段二：Promise 基于 PromiseA+ 规范的实现
  - 解决：上述问题2，重掌代码执行主动权；
- 阶段三：Generator(生成器函数) 用同步方式来书写代码
  - 解决：上述问题1，但需手动调用 next 方法，将回调成功返回的数据送回 JS 主流程中；
- 阶段四：Async/Await (结合 Promise & Generator)，在 await 后面跟 Promise，自动等待 Promise 决议值
  - 解决：Generator需要手动控制next(...)执行的问题、真正实现了用同步的方式书写异步代码；



#### 1-2、总结

- 回调函数
  - 优点：解决同步问题；
  - 缺点：地狱缺乏顺序性，调试困难，与大脑思维方式不符、函数间存在耦合性牵一发动全身(控制反转)、难以处理错误
- Promise
  - 优点：解决回调地狱问题，可链式调用，自动执行
  - 缺点：一旦新建即立即执行则无法停止、错误需通过回调函数来捕获、处于 pending 态时无法得知具体状态(刚开始/即将完成 )
- Generator
  - 优点：执行可控
  - 缺点：执行需手动触发
- Async/await
  - 优点：代码结构清晰(无需 then 链)
  - 缺点：将异步改为同步，多个无依赖的异步操作将导致性能降低





### 二、传统回调

<img src="/Image/Basics/Special/Async/2.png" style="zoom:50%;" align="left" />

问题1：回调地狱：充满回调嵌套，代码横向纵向扩展、难以调试和维护、bug 追踪难度大、不符人脑线性处理；

问题2：控制反转：即把程序一部分的执行控制交给某个第三方，而代码和第三方之间没有一份明确表达的契约；

比如：C 先传出接收数据，后异步传回，此时数据是不被 C 可控的，且在第三方的控制下；

<img src="/Image/Basics/Special/Async/3.png" style="zoom:50%;" align="left" />





### 三、Promise

**<u>意义：解决因控制反转导致的信任问题(此外还一定程度上解决了回调函数的书写结构问题，逻辑性、可读性增强，依赖层级清晰)</u>**



#### 3-1、Promise/A+规范

##### 3-1-1、基本内容

- 不变性：某个 Promise 必处于3态之一且不变(一旦决议，状态不再改变)：
  - 激发态——pending —> fulfilled 稳定态；
  - 激发态——pending —> rejected 稳定态；
- 可信任性
  - then 总能返回一个Promise：其中涉及 Promise 解析过程的抽象过程 [[Resolve]](promise, x)，可将某些非标准的：类Promise接口、对象、函数或值规范为标准 Promise；
- 注意：若 then  函数的2个参数不是函数，会导致 then 函数 返回一个与之前 promise 状态相同的 promise
- 核心1：Promise 本质是状态机，且状态只能为以下三种：Pending-等待态、Fulfilled-执行态、Rejected-拒绝态，状态变更单向；
- 核心2：then 接收 2 个可选参数，分别对应状态改变时触发的回调，then 返回 promise，then 可被同一个 promise 调用多次；



##### 3-1-2、基本原则

原则1：当通过 ***new Promise*(*function* (*resolve*, *reject*)*{}*)** 形式定义 *Promise* 时，构造用到函数就已在被执行，见下图；

原则*2*：函数在没有返回值时，会默认返回 *undefined*；

<img src="/Image/Basics/Special/Async/8.png" style="zoom:50%;" align="left" />



##### 3-1-3、解决的问题

- 解决了回调，调用过早问题：
  - Promise 调用 then 时，即使 Promise 已决议，也总会在当前 Js 事件处理完后再调用提供给 then 的回调
- 解决了回调，调用过晚问题：
  - Promise 对象调用 resolve 或 reject 时，通过 then 注册的回调会在下一个异步时间点上被触发；而若多个通过 then 注册的回调，都会在下一个异步时间点上被依次调用，这些注册回调中的异步回调均无法影响或延误对其他 then 上回调的调用；

<img src="/Image/Basics/Special/Async/9.png" style="zoom:50%;" align="left" />

- 解决了回调，调用次数太多或太少问题：
  - Promise 的定义方式使得它只能被决议一次，且会默默忽略任何后续调用，因此任何通过 then 注册的回调就只会被调用一次；
- 解决了回调，无法成功接收所传参数的问题：
  - resolve 或 reject，默认传值 undefined
  - resolve 或 reject，中的值不管是什么，都会被传给所有注册在 then 中的回调函数
  - resolve 或 reject，中传递多个参数时，第一个参数后的所有参数都会被忽略；故多参数传递需通过对象传递；
- 解决了吞掉可能出现的错误或异常问题：

<img src="/Image/Basics/Special/Async/10.png" style="zoom:50%;" align="left" />



##### 3-1-4、返回值

Promise 只是改变了传递回调的位置，只是将 callback 放到可信任的中间机构，并由这个机构去连接代码与接口，故本质上并没有完全摆脱回调；但是就是这样比单纯使用回调更值得信任，因为 Promise.resolve：

- 若向 Promise.resolve 传递1个真 Promise，则得到传递过去的同1个 Promise：
- <img src="/Image/Basics/Special/Async/11.png" style="zoom:50%;" align="left" />
- 若向 Promise.resolve 传递1个非 Promise、非 thenable 的立即值，则得到1个用这个值填充的 Promise：
- <img src="/Image/Basics/Special/Async/12.png" style="zoom:50%;" align="left" />
- 若向 Promise.resolve 传递1个非 Promise、真 thenable 的立即值，Promise.resolve 则会试图展开此值 ，且展开过程中会持续到提取出一个具体的非类 Promise 的规范后的最终值：
- <img src="/Image/Basics/Special/Async/13.png" style="zoom:50%;" align="left" />



##### 3-1-5、总结

无论传递什么值，从 Promise.resolve 得到的都是一个真正的  Promise，是一个可信任的值，所以通过Promise.resolve 过滤，以获取可信任性；故有跟传统回调相比，Promise 更值得信任的说法；



#### 3-2、Promise 实现

##### 3-2-1、低配版

```javascript
/**
 * 1、低配版 Promise
 */
class MyPromise1 {
  // 构造方法接收一个回调
  constructor(executor) {
    // then 收集的执行成功的回调队列
    this._resolveQueue = [];
    // then 收集的执行失败的回调队列
    this._rejectQueue = [];

    // 实现同 reject
    let _resolve = val => {
      // 从成功队列里取出回调依次执行
      while (this._resolveQueue.length) {
        const callback = this._resolveQueue.shift();
        callback(val);
      }
    };
    // 实现同 resolve
    let _reject = val => {
      // 从失败队列里取出回调依次执行
      while (this._rejectQueue.length) {
        const callback = this._rejectQueue.shift();
        callback(val);
      }
    };
    // new Promise()时立即执行 executor,并传入 resolve 和 reject
    executor(_resolve, _reject);
  }

  // then 方法,接收一个成功的回调和一个失败的回调，并 push 进对应队列
  then(resolveFn, rejectFn) {
    this._resolveQueue.push(resolveFn);
    this._rejectQueue.push(rejectFn);
  }
}

// 测试用例
const p1 = new MyPromise1((resolve, reject) => {
  setTimeout(() => {
    resolve("result");
  }, 1000);
});
// 1秒后输出 result
p1.then(res => console.log(res));
```



##### 3-2-2、结合 Promise/A 规范实现版本

```javascript
// 1、结合Promise/A 规范核心
// 核心1：Promise 本质是状态机，且状态只能为以下三种：Pending-等待态、Fulfilled-执行态、Rejected-拒绝态，状态变更单向；
// 核心2：then 接收 2 个可选参数，分别对应状态改变时触发的回调，then 返回 promise，then 可被同一个 promise 调用多次；

function P2() {
  //Promise/A+规范的三种状态
  const PENDING = "pending";
  const FULFILLED = "fulfilled";
  const REJECTED = "rejected";

  class MyPromise2 {
    // 构造方法接收一个回调
    constructor(executor) {
      // Promise 状态
      this._status = PENDING;
      // 成功队列, resolve 时触发
      this._resolveQueue = [];
      // 失败队列, reject 时触发
      this._rejectQueue = [];

      // 实现同 reject
      let _resolve = val => {
        // 实现规范要求的 "状态只能由 pending 到 fulfilled 或 rejected"
        if (this._status !== PENDING) return;
        // 变更状态
        this._status = FULFILLED;

        // 使用一个队列来储存回调，实现规范要求的 "then 方法可以被同一个 promise 调用多次"
        // 若使用一个变量而非队列来储存回调,那么即使多次 p1.then() 也只会执行一次回调
        while (this._resolveQueue.length) {
          const callback = this._resolveQueue.shift();
          callback(val);
        }
      };
      // 实现同 resolve
      let _reject = val => {
        // 实现规范要求的 "状态只能由 pending 到 fulfilled 或 rejected"
        if (this._status !== PENDING) return;
        // 变更状态
        this._status = REJECTED;

        // 使用一个队列来储存回调，实现规范要求的 "then 方法可以被同一个 promise 调用多次"
        // 若使用一个变量而非队列来储存回调,那么即使多次 p1.then() 也只会执行一次回调
        while (this._rejectQueue.length) {
          const callback = this._rejectQueue.shift();
          callback(val);
        }
      };
      // new Promise()时立即执行 executor, 并传入 resolve 和 reject
      executor(_resolve, _reject);
    }
    // then 方法,接收一个成功的回调和一个失败的回调
    then(resolveFn, rejectFn) {
      this._resolveQueue.push(resolveFn);
      this._rejectQueue.push(rejectFn);
    }
  }
}
```

<img src="/Image/Basics/Special/Async/14.png" style="zoom:50%;" align="left" />

```javascript
// 2、在上一版本基础上，实现链式调用
// 将 then 方法的返回值包装成 promise 
// then 的回调需要顺序执行，需要等待当前 Promise 状态变更后，才执行下一 then 收集的回调
function P3() {
  // Promise/A+规范的三种状态
  const PENDING = "pending";
  const FULFILLED = "fulfilled";
  const REJECTED = "rejected";

  class MyPromise3 {
    // 构造方法接收一个回调
    constructor(executor) {
      // Promise 状态
      this._status = PENDING;
      // 成功队列, resolve 时触发
      this._resolveQueue = [];
      // 失败队列, reject 时触发
      this._rejectQueue = [];

      // 实现同 reject
      let _resolve = val => {
        // 实现规范要求的 "状态只能由 pending 到 fulfilled 或 rejected"
        if (this._status !== PENDING) return;
        // 变更状态
        this._status = FULFILLED;
        // 使用一个队列来储存回调，实现规范要求的 "then 方法可以被同一个 promise 调用多次"
        // 若使用一个变量而非队列来储存回调,那么即使多次 p1.then() 也只会执行一次回调
        while (this._resolveQueue.length) {
          const callback = this._resolveQueue.shift();
          callback(val);
        }
      };
      // 实现同 resolve
      let _reject = val => {
        // 实现规范要求的 "状态只能由 pending 到 fulfilled 或 rejected"
        if (this._status !== PENDING) return;
        // 变更状态
        this._status = REJECTED;

        // 使用一个队列来储存回调，实现规范要求的 "then 方法可以被同一个 promise 调用多次"
        // 若使用一个变量而非队列来储存回调,那么即使多次 p1.then() 也只会执行一次回调
        while (this._rejectQueue.length) {
          const callback = this._rejectQueue.shift();
          callback(val);
        }
      };
      // new Promise()时立即执行 executor, 并传入 resolve 和 reject
      executor(_resolve, _reject);
    }

    // then 方法
    then(resolveFn, rejectFn) {
      // return 一个新的 promise
      return new MyPromise((resolve, reject) => {
        // 把 resolveFn 重新包装一下, 再 push 进 resolve 执行队列, 这是为了能够获取回调的返回值进行分类讨论
        const fulfilledFn = value => {
          try {
            // 执行第一个(当前的) Promise 的成功回调,并获取返回值
            let x = resolveFn(value);
            // 分类讨论返回值,如果是 Promise, 那么等待 Promise 状态变更,否则直接 resolve
            x instanceof MyPromise3 ? x.then(resolve, reject) : resolve(x);
          } catch (error) {
            reject(error);
          }
        };
        // 把后续 then 收集的依赖都 push 进当前 Promise 的成功回调队列中(_rejectQueue), 这是为了保证顺序调用
        this._resolveQueue.push(fulfilledFn);

        // reject 同理
        const rejectedFn = error => {
          try {
            let x = rejectFn(error);
            x instanceof MyPromise3 ? x.then(resolve, reject) : resolve(x);
          } catch (error) {
            reject(error);
          }
        };
        this._rejectQueue.push(rejectedFn);
      });
    }
  }
}

// 测试用例
const p3 = new MyPromise3((resolve, reject) => {
  setTimeout(() => {
    resolve(1);
  }, 500);
});

p3.then(res => {
  console.log(res);
  return 2;
})
.then(res => {
  console.log(res);
  return 3;
})
.then(res => {
  console.log(res);
});
// 1
// 2
// 3
```

<img src="/Image/Basics/Special/Async/15.png" style="zoom:50%;" align="left" />

```javascript
// 3、在上一版本基础上，实现值穿透与状态已变更情况
// 值穿透即：若 then 接收的参数类型不是 function 则应当忽略，让链式调用继续往下执行
// 处理状态为 resolve/reject 的情况，一般情况下 then 对应状态 pending，但特殊情况比如 Promise.resolve()/reject().then() 则此时状态为 resolve/reject，此时若还按照 pending 态时的做法：将 then 中回调 push 进 resolve/reject 队列中的话，回调将不会正确执行，故需对上述特殊情况进行处理，即对 fulfilled 状态和 rejected 情况进行处理：直接执行回调；

function P4() {
  //Promise/A+规范的三种状态
  const PENDING = "pending";
  const FULFILLED = "fulfilled";
  const REJECTED = "rejected";

  class MyPromise4 {
    // 构造方法接收一个回调
    constructor(executor) {
      // Promise 状态
      this._status = PENDING;
      // 成功队列, resolve 时触发
      this._resolveQueue = [];
      // 失败队列, reject 时触发
      this._rejectQueue = [];

      // 实现同 reject
      let _resolve = val => {
        // 实现规范要求的 "状态只能由 pending 到 fulfilled 或 rejected"
        if (this._status !== PENDING) return;
        // 变更状态
        this._status = FULFILLED;

        // 使用一个队列来储存回调，实现规范要求的 "then 方法可以被同一个 promise 调用多次"
        // 若使用一个变量而非队列来储存回调,那么即使多次 p1.then() 也只会执行一次回调
        while (this._resolveQueue.length) {
          const callback = this._resolveQueue.shift();
          callback(val);
        }
      };
      // 实现同 resolve
      let _reject = val => {
        // 实现规范要求的 "状态只能由 pending 到 fulfilled 或 rejected"
        if (this._status !== PENDING) return;
        // 变更状态
        this._status = REJECTED;

        // 使用一个队列来储存回调，实现规范要求的 "then 方法可以被同一个 promise 调用多次"
        // 若使用一个变量而非队列来储存回调,那么即使多次 p1.then() 也只会执行一次回调
        while (this._rejectQueue.length) {
          const callback = this._rejectQueue.shift();
          callback(val);
        }
      };
      // new Promise()时立即执行 executor, 并传入 resolve 和 reject
      executor(_resolve, _reject);
    }

    // then 方法,接收一个成功的回调和一个失败的回调
    then(resolveFn, rejectFn) {
      // 根据规范，若 then 参数不是 function，则需要忽略它, 让链式调用继续往下执行
      typeof resolveFn !== "function" ? (resolveFn = value => value) : null;
      typeof rejectFn !== "function"
        ? (rejectFn = reason => {
            throw new Error(reason instanceof Error ? reason.message : reason);
          })
        : null;

      // return 一个新的 promise
      return new MyPromise4((resolve, reject) => {
        // 把 resolveFn 重新包装一下, 再 push 进 resolve 执行队列,这是为了能够获取回调的返回值进行分类讨论
        const fulfilledFn = value => {
          try {
            // 执行第一个(当前的) Promise 的成功回调,并获取返回值
            let x = resolveFn(value);
            // 分类讨论返回值,如果是 Promise, 那么等待 Promise 状态变更, 否则直接 resolve
            x instanceof MyPromise4 ? x.then(resolve, reject) : resolve(x);
          } catch (error) {
            reject(error);
          }
        };

        // reject 同理
        const rejectedFn = error => {
          try {
            let x = rejectFn(error);
            x instanceof MyPromise ? x.then(resolve, reject) : resolve(x);
          } catch (error) {
            reject(error);
          }
        };

        switch (this._status) {
          // 当状态为 pending 时, 把 then 回调 push 进 resolve/reject 执行队列,等待执行
          case PENDING:
            this._resolveQueue.push(fulfilledFn);
            this._rejectQueue.push(rejectedFn);
            break;
          // 当状态已经变为 resolve/reject 时,直接执行 then 回调
          case FULFILLED:
            fulfilledFn(this._value);
            // this._value 是上一个 then 回调 return 的值(见完整版代码)
            break;
          case REJECTED:
            rejectedFn(this._value);
            break;
        }
      });
    }
  }
}
```

<img src="/Image/Basics/Special/Async/16.png" style="zoom:50%;" align="left" />

```javascript
// 4、在上一版本基础上，实现同步任务的兼容
// 目前 Promise 执行顺序是 new Promise -> then()收集回调 -> resolve/reject执行回调，但前提是异步任务，若为同步则会变为：new Promise -> resolve/reject执行回调 -> then()收集回调，解决方式是为同步任务包裹 setTimeout 强行变为异步任务

function P5() {
  //Promise/A+规定的三种状态
  const PENDING = "pending";
  const FULFILLED = "fulfilled";
  const REJECTED = "rejected";

  class MyPromise5 {
    // 构造方法接收一个回调
    constructor(executor) {
      // Promise 状态
      this._status = PENDING;
      // 储存 then 回调 return 的值
      this._value = undefined;
      // 成功队列, resolve 时触发
      this._resolveQueue = [];
      // 失败队列, reject 时触发
      this._rejectQueue = [];

      // 由于 resolve/reject 是在 executor 内部被调用, 因此需要使用箭头函数固定 this 指向, 否则找不到 this._resolveQueue
      let _resolve = val => {
        // 把 resolve 执行回调的操作封装成一个函数, 放进 setTimeout 里, 以兼容 executor 是同步代码的情况
        const run = () => {
          // 对应规范中的" 状态只能由 pending 到 fulfilled 或 rejected"
          if (this._status !== PENDING) return;
          this._status = FULFILLED; // 变更状态
          this._value = val; // 储存当前 value

          // 这里之所以使用一个队列来储存回调,是为了实现规范要求的 "then 方法可以被同一个 promise 调用多次"
          // 如果使用一个变量而非队列来储存回调,那么即使多次 p1.then() 也只会执行一次回调
          while (this._resolveQueue.length) {
            const callback = this._resolveQueue.shift();
            callback(val);
          }
        };
        setTimeout(run);
      };
      // 实现同 resolve
      let _reject = val => {
        const run = () => {
          if (this._status !== PENDING) return;
          // 对应规范中的"状态只能由 pending 到 fulfilled 或 rejected"
          this._status = REJECTED; // 变更状态
          this._value = val; // 储存当前 value
          while (this._rejectQueue.length) {
            const callback = this._rejectQueue.shift();
            callback(val);
          }
        };
        setTimeout(run);
      };
      // new Promise() 时立即执行 executor, 并传入 resolve 和 reject
      executor(_resolve, _reject);
    }

    // then 方法,接收一个成功的回调和一个失败的回调
    then(resolveFn, rejectFn) {
      // 根据规范，如果 then 的参数不是 function，则我们需要忽略它, 让链式调用继续往下执行
      typeof resolveFn !== "function" ? (resolveFn = value => value) : null;
      typeof rejectFn !== "function"
        ? (rejectFn = reason => {
            throw new Error(reason instanceof Error ? reason.message : reason);
          })
        : null;

      // return 一个新的 promise
      return new MyPromise5((resolve, reject) => {
        // 把 resolveFn 重新包装一下, 再 push 进 resolve 执行队列,这是为了能够获取回调的返回值进行分类讨论
        const fulfilledFn = value => {
          try {
            // 执行第一个(当前的)Promise 的成功回调,并获取返回值
            let x = resolveFn(value);
            // 分类讨论返回值, 如果是 Promise,那么等待 Promise 状态变更,否则直接 resolve
            x instanceof MyPromise5 ? x.then(resolve, reject) : resolve(x);
          } catch (error) {
            reject(error);
          }
        };

        // reject 同理
        const rejectedFn = error => {
          try {
            let x = rejectFn(error);
            x instanceof MyPromise5 ? x.then(resolve, reject) : resolve(x);
          } catch (error) {
            reject(error);
          }
        };

        switch (this._status) {
          // 当状态为 pending 时,把 then 回调 push 进 resolve/reject 执行队列,等待执行
          case PENDING:
            this._resolveQueue.push(fulfilledFn);
            this._rejectQueue.push(rejectedFn);
            break;
          // 当状态已经变为 resolve/reject 时,直接执行 then 回调
          case FULFILLED:
            fulfilledFn(this._value); // this._value 是上一个 then 回调 return 的值(见完整版代码)
            break;
          case REJECTED:
            rejectedFn(this._value);
            break;
        }
      });
    }
  }
}

// 测试用例
const p5 = new MyPromise5((resolve, reject) => {
  resolve(1); // 同步 executor 测试
});

p5.then(res => {
  console.log(res);
  return 2; // 链式调用测试
})
.then() // 值穿透测试
.then(res => {
  console.log(res);
  return new MyPromise5((resolve, reject) => {
    resolve(3); //返回 Promise 测试
  });
})
.then(res => {
  console.log(res);
  throw new Error("reject 测试"); //reject 测试
})
.then(
  () => {},
  err => {
    console.log(err);
  }
);
```

<img src="/Image/Basics/Special/Async/17.png" style="zoom:50%;" align="left" />

```javascript
// 5、在上一版本基础上，实现 promise.race/all/catch/resolve/reject/finally

function P6() {
  //Promise/A+规定的三种状态
  const PENDING = "pending";
  const FULFILLED = "fulfilled";
  const REJECTED = "rejected";

  class MyPromise6 {
    // 构造方法接收一个回调
    constructor(executor) {
      // Promise 状态
      this._status = PENDING; 
      // 储存 then 回调 return 的值
      this._value = undefined; 
      // 成功队列, resolve 时触发
      this._resolveQueue = []; 
      // 失败队列, reject 时触发
      this._rejectQueue = []; 

      // 由于 resolve/reject 是在 executor 内部被调用, 因此需要使用箭头函数固定 this 指向, 否则找不到 this._resolveQueue
      let _resolve = val => {
        //把 resolve 执行回调的操作封装成一个函数,放进 setTimeout 里,以兼容 executor 是同步代码的情况
        const run = () => {
          if (this._status !== PENDING) return; // 对应规范中的"状态只能由 pending 到 fulfilled 或 rejected"
          this._status = FULFILLED; // 变更状态
          this._value = val; // 储存当前 value

          // 这里之所以使用一个队列来储存回调,是为了实现规范要求的 "then 方法可以被同一个 promise 调用多次"
          // 如果使用一个变量而非队列来储存回调,那么即使多次 p1.then()也只会执行一次回调
          while (this._resolveQueue.length) {
            const callback = this._resolveQueue.shift();
            callback(val);
          }
        };
        setTimeout(run);
      };
      // 实现同 resolve
      let _reject = val => {
        const run = () => {
          if (this._status !== PENDING) return; // 对应规范中的"状态只能由 pending 到 fulfilled 或 rejected"
          this._status = REJECTED; // 变更状态
          this._value = val; // 储存当前 value
          while (this._rejectQueue.length) {
            const callback = this._rejectQueue.shift();
            callback(val);
          }
        };
        setTimeout(run);
      };
      // new Promise()时立即执行 executor,并传入 resolve 和 reject
      executor(_resolve, _reject);
    }

    // then 方法,接收一个成功的回调和一个失败的回调
    then(resolveFn, rejectFn) {
      // 根据规范，如果 then 的参数不是 function，则我们需要忽略它, 让链式调用继续往下执行
      typeof resolveFn !== "function" ? (resolveFn = value => value) : null;
      typeof rejectFn !== "function"
        ? (rejectFn = reason => {
            throw new Error(reason instanceof Error ? reason.message : reason);
          })
        : null;

      // return 一个新的 promise
      return new MyPromise6((resolve, reject) => {
        // 把 resolveFn 重新包装一下,再 push 进 resolve 执行队列,这是为了能够获取回调的返回值进行分类讨论
        const fulfilledFn = value => {
          try {
            // 执行第一个(当前的)Promise 的成功回调,并获取返回值
            let x = resolveFn(value);
            // 分类讨论返回值,如果是 Promise,那么等待 Promise 状态变更,否则直接 resolve
            x instanceof MyPromise6 ? x.then(resolve, reject) : resolve(x);
          } catch (error) {
            reject(error);
          }
        };

        // reject 同理
        const rejectedFn = error => {
          try {
            let x = rejectFn(error);
            x instanceof MyPromise6 ? x.then(resolve, reject) : resolve(x);
          } catch (error) {
            reject(error);
          }
        };

        switch (this._status) {
          // 当状态为 pending 时,把 then 回调 push 进 resolve/reject 执行队列,等待执行
          case PENDING:
            this._resolveQueue.push(fulfilledFn);
            this._rejectQueue.push(rejectedFn);
            break;
          // 当状态已经变为 resolve/reject 时,直接执行 then 回调
          case FULFILLED:
            fulfilledFn(this._value); // this._value 是上一个 then 回调 return 的值(见完整版代码)
            break;
          case REJECTED:
            rejectedFn(this._value);
            break;
        }
      });
    }

    //catch 方法其实就是执行一下 then 的第二个回调
    catch(rejectFn) {
      return this.then(undefined, rejectFn);
    }

    //finally 方法
    finally(callback) {
      return this.then(
        value => MyPromise.resolve(callback()).then(() => value), //执行回调,并 returnvalue 传递给后面的 then
        reason =>
          MyPromise.resolve(callback()).then(() => {
            throw reason;
          }) //reject 同理
      );
    }

    // 静态的 resolve 方法
    static resolve(value) {
      if (value instanceof MyPromise6) return value; //根据规范, 如果参数是 Promise 实例, 直接 return 这个实例
      return new MyPromise6(resolve => resolve(value));
    }

    // 静态的 reject 方法
    static reject(reason) {
      return new MyPromise6((resolve, reject) => reject(reason));
    }

    // 静态的 all 方法
    static all(promiseArr) {
      let index = 0;
      let result = [];
      return new MyPromise6((resolve, reject) => {
        promiseArr.forEach((p, i) => {
          //Promise.resolve(p)用于处理传入值不为 Promise 的情况
          MyPromise.resolve(p).then(
            val => {
              index++;
              result[i] = val;
              if (index === promiseArr.length) {
                resolve(result);
              }
            },
            err => {
              reject(err);
            }
          );
        });
      });
    }

    // 静态的 race 方法
    static race(promiseArr) {
      return new MyPromise6((resolve, reject) => {
        //同时执行 Promise,如果有一个 Promise 的状态发生改变,就变更新 MyPromise 的状态
        for (let p of promiseArr) {
          MyPromise.resolve(p).then(
            //Promise.resolve(p)用于处理传入值不为 Promise 的情况
            value => {
              resolve(value); //注意这个 resolve 是上边 new MyPromise 的
            },
            err => {
              reject(err);
            }
          );
        }
      });
    }
  }
}
```









### 四、Generator

**<u>意义：解决顺序性问题</u>**

优点：解决不符合大脑顺序、线性的思维方式问题；缺点：需要手动控制next()执行；



#### 4-1、ES6 新增2协议：可迭代协议 & 迭代器协议 (补充)：

##### 4-1、可迭代协议

协议允许 Js 对象去定义或定制它们的迭代行为；比如：定义在一个 for...of 结构中，什么值可被循环得到；其中：内置可迭代对象且有默认迭代行为如下 (注意：Object不符合可迭代协议，[但可实现](https://www.imooc.com/qadetail/265962?lastmedia=1))：

- Array
- Map
- Set
- String
- TypeArray
- 函数的 Arguments 对象
- NodeList 对象

注意：为了变成可迭代对象，1个对象必须实现@@iterator方法；即此对象须有一名为 [Symbol.iterator] 的属性，其值为返回一个对象(须符合迭代器协议)的无参函数 (或对象原型链 prototype chain上的某个对象含有)；而当一个对象需要被迭代的时候 (比如开始用于一个for...of循环中) ，其 @@iterator 方法被调用，且无参数，最后返回一个用于在迭代中获得值的迭代器，



##### 4-2、迭代器协议

协议定义一种标准方式，来产生一个有限或无限序列的值；比如：当1个对象被认为是1个迭代器时，其实现了1个next 方法，方法是返回一个对象的无参函数，被返回对象拥有2个属性；

- **done：boolean**
  - 若迭代器已经过了被迭代序列时，则为 true，此时 value 可能描述了该迭代器的返回值；
  - 若迭代器可产生序列中的下1个值，则为 false，这等效于连同 done 属性也不指定；
- **value：any**
  - 迭代器返回的任何 JS 值，done 为 true 时可忽略；

<img src="/Image/Basics/Special/Async/4.png" style="zoom:50%;" align="" />

<img src="/Image/Basics/Special/Async/5.png" style="zoom:50%;" align="" />



#### 4-2、Generator

符合大脑思维习惯的同步书写形式，将异步流程封装到外面，而成功的回调函数里面调用it.next()，将传回的数据放到任务队列里进行排队，当 Js 主线程空闲时则从任务队列里依次取出回调任务并执行；

<img src="/Image/Basics/Special/Async/6.png" style="zoom:50%;" align="left" />

<img src="/Image/Basics/Special/Async/7.png" style="zoom:50%;" align="left" />











### 五、Async/Await

**<u>意义：解决 Generator 需手动控制 next 执行的问题(真正实现用同步方式书写异步代码)</u>**

Async/Await 是 Generator 和 Promise 的组合，完全解决了基于传统回调的异步流程存在的两个问题(见上方)

Async：定义异步函数；自动将后方函数转为 Promise，并将其返回值通过 resolve 处理(故需使用 try-catch 进行错误捕获)；

Await：暂停异步函数的执行；注意 await 只能与 Promise 共用，无法与传统回调共用，await 等待 Promise 完成并返回其结果；

- 优点：解决了 Generator 需要手动控制 next 执行的问题；
- 优点：真正实现用同步的方式书写异步代码，逻辑和数据依赖清晰；
- 优点：无需写 .then、无需写匿名函数处理 Promise 的 resolve 值、无需定义多余变量、避免代码嵌套、提高可读性；
- 缺点：错误处理过于安静，往往需要用 try-catch 来捕获；



#### 5-2、实现

​	Promise 一旦新建即立即执行则无法停止，错误需通过回调函数来捕获，而 async/await 可进行更细粒度的操作，比如下图，而 async/await 实际上是对 Generator(生成器) 的封装，即语法糖，为何前者盛行是因为后者刚出现不久就被前者取代；

```javascript
// Promise 立即执行则无法停止
Promise.resolve(a).then(b => {}).then(c => {})
// Async/await
async function test() { 
	const a = await Promise.resolve(a);
  // do something else ..
  const b = await Promise.resolve(b);
  // do something else ..
  const c = await Promise.resolve(c);
  // do something else ..
}
```



##### 5-2-1、Generator 的简介

ES6 的 Generator 函数，可通过 yield 关键字，将函数执行挂起，并通过 next 方法切换到下一状态，以改变执行流程；

```javascript
// testGenerator1
function* testG1() {
  yield 'hello'
  yield 'guys'
  return '!'
}

const gen1 = testG1();
console.log(gen1.next()); // {value: "hello", done: false}
console.log(gen1.next()); // {value: "guys", done: false}
console.log(gen1.next()); // {value: "!", done: true}

// testGenerator2
function* testG2() {
  console.log(yield 'hello');
  console.log(yield 'guys');
  return '!'
}

const gen2 = testG2();
gen2.next();
// value: "hello", done: false}
gen2.next('anybody');
// anybody
// {value: "guys", done: false}
gen2.next('here');
// here
// {value: "!", done: true}
gen2.next('!!!');
// {value: undefined, done: true}
```



##### 5-2-2、Generator 与 Async/Await 区别

- async/await 自带执行器，无需手动调用 next 方法即可自动执行下一步；
- async 函数返回值为 Promise 对象，Generator 则是生成器对象；
- await 能返回 Promise 的 resolve/reject 值；



##### 5-2-3、基于 Generator 实现 Async/Await

```javascript
// 1、让 Generator 类似 Async 行为第1步：让 yield(await) 能返回 resolve 值
function* myGenerator() {
  yield Promise.resolve(1);
  yield Promise.resolve(2);
  yield Promise.resolve(3);
}
// 手动执行迭代器
const gen = myGenerator()
gen.next().value.then(val => {
  gen.next(val).value.then(val => {
    gen.next(val).value.then(val => {
      gen.next(val)
    })
  })
})


// 2、让 Generator 类似 Async 行为第2步：自动调用并输出(通过封装递归执行函数实现)
function run(gen) {
  var g = gen()   
  function _next(val) {             // 通过内部函数递归执行 g.next()
    var res = g.next(val)           // 获取迭代器对象 res，并传入上轮 resolve 出的值
    if(res.done) return res.value   // 根据 Generator 迭代器对象的值来作为递归终止判断
    res.value.then(val => {         // 通过 Promise 的 then 方法实现自动迭代
      _next(val)                    // 等待 Promise 完成就自动执行下一个 next，并传入 resolve 的值
    })
  };
  _next();
}
run(myGenerator)




// 3、让 Generator 类似 Async 行为第3步：返回 Promise、增加错误处理、基本类型值也能实现
function run(gen) {
  // 将返回值包装成 Promise
  return new Promise((resolve, reject) => {
    var g = gen()
    function _next(val) {
      // 用 tryCatch 实现错误处理
      try {
        var res = g.next(val) 
      } catch(err) {
        return reject(err); 
      }
      // 递归结束
      if(res.done) {
        return resolve(res.value);
      }
      // 利用 Promise 特性处理基本类型值，以兼容 yield 后面跟基本类型的情况
      // 将 res.value 包装为 Promise
      Promise.resolve(res.value).then(
        val => {
          _next(val);
        }, 
        err => {
          // 抛出错误
          g.throw(err)
        });
    }
    _next();
  });
}




// 4、测试
function* myGenerator() {
  try {
    console.log(yield Promise.resolve(1)) 
    console.log(yield 2)   //2
    console.log(yield Promise.reject('error'))
  } catch (error) {
    console.log(error)
  }
}
const result = run(myGenerator) // result是一个Promise
// 输出 1 2 error
```



##### 5-2-4、Babel 对 Async/Await 的转译

```javascript
// 相当于 run()
function _asyncToGenerator(fn) {
  // return 一个 function，和 async 保持一致，而 run 直接执行了 Generator，略不符规范
  return function() {
    var self = this
    var args = arguments
    return new Promise(function(resolve, reject) {
      var gen = fn.apply(self, args);
      // 相当于 _next()
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'next', value);
      }
      // 处理异常
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'throw', err);
      }
      _next(undefined);
    });
  };
}

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}


// 测试
const foo = _asyncToGenerator(function* () {
  try {
    console.log(yield Promise.resolve(1))   //1
    console.log(yield 2)                    //2
    return '3'
  } catch (error) {
    console.log(error)
  }
})
foo().then(res => {
  console.log(res)                          //3
})
```







#### 5-x、示例与注意事项

##### 5-x-1、示例1

<img src="/Image/Basics/Special/Async/18.png" style="zoom:50%;" align="left" />

<img src="/Image/Basics/Special/Async/19.png" style="zoom:50%;" align="left" />

##### 5-x-2、示例2

<img src="/Image/Basics/Special/Async/20.png" style="zoom:50%;" align="left" />

##### 5-x-3、注意1

- 若不使用await，异步函数会被同步执行

<img src="/Image/Basics/Special/Async/21.png" style="zoom:50%;" align="left" />



##### 5-x-4、注意2

- async-await 主要解决的就是将异步问题同步化，降低异步编程的认知负担；
- async-await 是 promise 和 generator 的语法糖，故无法取代 Promsie 地位，如并行执行需要结合 Promise.all；
- async 函数执行后，总是返回一个 promise 对象，可调用 then 等方法，而里面 await 所在的行的语句是同步的；
- async 函数即将 Generator 函数的星号（*）替换成 async，将 yield 替换成 await；
- async 函数的实现，即将 Generator 函数和自动执行器，包装在一个函数中；

<img src="/Image/Basics/Special/Async/22.png" style="zoom:50%;" align="left" />



##### 5-x-5、注意3

- 同 Generator 函数一样，async 函数返回一个 Promise 对象，可以使用 then 方法添加回调函数

<img src="/Image/Basics/Special/Async/23.png" style="zoom:50%;" align="left" />



##### 5-x-6、注意4

- await 命令后面的 Promise 对象，运行结果可能是 rejected，故最好将 await 命令放在 try...catch 中，try..catch 错误处理也比较符合我们平常编写同步代码时候处理的逻辑
- await 调用，是让其后的语句做一个递归执行，直到获取到结果并使其状态变更，才会 resolve 掉，而只有 resolve 掉，await 那行代码才算执行完，才继续往下一行执行
- awaiit 后面跟 promsie 才能有线程效果，且 promise 内必须加 resolve

<img src="/Image/Basics/Special/Async/24.png" style="zoom:50%;" align="left" />



##### 5-x-7、注意5

- async + 函数 的原型是一个 [AsyncFunction](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/AsyncFunction)，而紧跟 async 后的函数最终返回的是 Promise，

<img src="/Image/Basics/Special/Async/25.png" style="zoom:50%;" align="left" />

<img src="/Image/Basics/Special/Async/26.png" style="zoom:50%;" align="left" />

- 即便函数 return 某些值，但最终都会封装成 Promsie

<img src="/Image/Basics/Special/Async/27.png" style="zoom:50%;" align="left" />