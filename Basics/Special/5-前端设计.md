---
typora-root-url: ../../Source
---



### 一、基本

#### 1-1、基本

- **<u>原型 prototype</u>**： 创建的每一个函数，都有一个prototype属性，该属性指向一个对象，这个对象就是原型

  - 定B：一个简单的对象，用于实现对象的 **属性继承**；可简单的理解成对象的爹；

  - 比如：在火狐、谷歌中，每个 JS 对象中都包含一`__proto__`    属性(非标)指向它爹(该对象原型)，即 `obj.__proto__` 进行访问；

  - 定C：原型是构造调用时，也即在实例创建过程中，系统自动创建出来的、与构造函数相关联的一个空的对象，可由 `构造函数.prototype` 访问到；

  - 注意：`实例.__proto__`，指向函数原型，于是在原型上增加属性或方法，便可成为实例的共有属性和方法；

  - 补充：原型对象是一个内部对象，官方没有给出能直接访问的方法，浏览器提供了一个 __proto__ 属性，通过它来访问对象原型：

    原型对象在 JS 标准中用 [[prototype]] 表示 (参见 [ECMAScript](https://developer.mozilla.org/en-US/docs/Glossary/ECMAScript))；

- **<u>构造函数</u>**：可通过 `new` 来 **新建一个对象** 的函数；

  - 本质：即函数、专用于同 new 操作符一起实例化对象、new 调用的时候称为构造调用；
  - 约定：大写字母开头、应仅作为构造调用使用；

- **<u>实例</u>**：通过构造函数和 `new` 创建出来的对象(或中间对象，或函数在中间对象环境下调用产生的结果)，即实例； 

  - **实例通过`__proto__`指向原型，通过`constructor`指向构造函数**；




##### 1-1-1、注意事项

<img src="/Image/Basics/Special/Mode/21.png" style="zoom:50%;" align="left" />

<img src="/Image/Basics/Special/Mode/22.png" style="zoom:50%;" align="left" />

- 注意：每个对象的 `__proto__` 属性，指向对象的构造函数的 prototype；
- 所以：上面图中，对象为 Foo.prototype(原型)，对象的构造函数为 Object，对象指向对象的构造函数的原型即 Object.prototype；
- 所以：此处对象乃原型，是故原型的构造函数为 Object；
- 那么：若对象为 Object.prototype(原型)，则又指向谁呢？null；

<img src="/Image/Basics/Special/Mode/23.png" style="zoom:50%;" align="left" />





#### 1-2、关系

在 JS 中，每当定义一个函数数据类型(普通函数、类)时候，都会天生自带一个 prototype 属性，这个属性指向函数的 **<u>原型对象</u>**；

当函数经过 new 调用时，此函数便作为 **<u>构造函数</u>**，返回一全新的 **<u>实例</u>** 对象，此实例对象有一个__proto__属性，指向构造函数的原型对象；

```js
// 实例为 instance, 构造函数为 Object, 构造函数拥有一个 prototype 属性指向原型
const instance = new Object()
const prototype = Object.prototype
```

##### 1-2-1、构造与实例

构造函数、实例之间关系：

创建和被创建的关系，实例需通过 `__proto__` 找原型，再通过原型的 constructor 找构造其的函数；

<img src="/Image/Basics/Special/Mode/30.png" style="zoom:50%;" align="left"/>



##### 1-2-2、构造与原型

构造函数、原型之间关系：

函数的原型对象即：`构造函数的原型对象.constructor === 函数`；

<img src="/Image/Basics/Special/Mode/31.png" style="zoom:50%;" align="left"/>



##### 1-2-3、实例与原型

某某实例、原型之间关系**：**

实例的原型 === 构造实例的函数的原型对象，即：`实例.__proto__ === 构造实例的函数.prototype`；

<img src="/Image/Basics/Special/Mode/32.png" style="zoom:50%;" align="left"/>



##### 1-2-4、prototype 与 proto

显式原型：prototype：

- 含义：每一个函数，在创建之后都会拥有一个名为 prototype 的属性，属性指向函数的原型对象；
- 作用：用以实现基于原型的继承与属性共享；
  - 注意：通过 Function.prototype.bind 构造出的函数是例外，其没有 prototype 属性；

隐式原型：`__proto__`：

- 含义：任意 JS 对象，都有内置属性 [[prototype]]，指向创建此对象的函数的显式原型 prototype；
- 作用：用以构成原型链，同样可用以实现基于原型的继承与属性共享，当找寻某对象属性或方法时，便会沿此进行搜索；
  - 注意：ES5 前，没有标准方法访问此属性(prototype)，但大多数浏览器均支持通过 `__proto__` 访问；
  - 注意：ES5 后，有标准方法可访问：Object.getPrototypeOf()：`Object.getPrototypeOf(fn) == test.prototype // true`
  - 注意：Object.prototype 是唯一的，没有原型的对象：

两者关系：

- 对象的隐式原型 `__proto__` 指向，创建这个对象的函数(constructor)，的显式原型 prototype；
- <img src="/Image/Basics/Special/Mode/38.png" style="zoom:50%;" align="left"/>

两者区别：

- prototype：对象且函数才有属性；
- `__proto__`：对象皆有的属性，但并非规范属性 (部分浏览器实现，标准属性为 [[Prototype]]
- <img src="/Image/Basics/Special/Mode/39.png" style="zoom:50%;" align="left"/>

注意事项：

- `__proto__` 为 构造器原型；

  - ```js
    __proto__ == constructor.prototype // true
    ```

- `__proto__` 实际上是 getter setter，源于 Object.prototype，使用时可理解成返回 Object.getPrototypeOf(obj)；

  - ```js
    Object.getPrototypeOf(fn) == fn__proto__ // true
    ```

- `__proto__` 指向取决于对象创建的实现方式，图3-5；

<img src="/Image/Basics/Special/Mode/40.png" style="zoom:50%;" align="left"/>

<img src="/Image/Basics/Special/Mode/41.png" style="zoom:50%;" align="left"/>

<img src="/Image/Basics/Special/Mode/42.png" style="zoom:50%;" align="left"/>



##### 1-2-5、constructor

constructor 属性是原型对象的属性，指向这个原型对象所对应的构造函数；

每个对象实例都具有 [constructor](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/constructor) 属性，它指向创建该实例的构造器函数

- 比如：person2.constructor，返回 Person() 构造器
- 比如：new person2.constructor()，返回 Person() 构造器 创建的新实例



##### 1-2-6、关系综述

```js
// 三者的关系(再述):
实例.__proto__ === 原型

原型.constructor === 构造函数

构造函数.prototype === 原型

实例.constructor === 构造函数
// 注意: 其实实例上并不是真正有 constructor 这个指针，它其实是从原型链上获取的: 
// instance.hasOwnProperty('constructor') === false 

// 例如: 
// const o = new Object()
// o.constructor === Object   --> true
// o.__proto__ = null;
// o.constructor === Object   --> false 

// 对象原型 prototype 属性 与 构造函数 prototype 属性间区别：
// 前者可通过 Object.getPrototypeOf(obj) 或，已被弃用的 __proto__ 属性获得
// 前者是每个实例上都有的属性，后者是构造函数的属性
// 也就是说，Object.getPrototypeOf(new Foobar())和 Foobar.prototype 指向着同一个对象
// function Foobar(){} -> undefined
// foobar = new Foobar() -> Foobar {}
// Object.getPrototypeOf(foobar) == Foobar.prototype -> true
```

<img src="/Image/Basics/Special/Mode/4.png" style="zoom:35%;" />

<img src="/Image/Basics/Special/Mode/43.png" style="zoom:50%;" />

##### 1-2-6-1、大图解说

再叙：实例对象的原型([[Prototype]] 或 `__proto__`) === 构造实例的函数的原型对象，即构造实例的函数的 prototype 属性；

再叙：构造函数的 prototype 属性，即原型对象，又可作为新的实例对象，实例对象的原型又指向下一轮；

再叙：一直到达 Object.prototype，其原型，即 `Object.prototype.__proto__ === null`；

再叙：`对象.__proto__…..__proto__`为 Object.prototype，随即 `Object.prototype. __proto__` 指向 Null；

<img src="/Image/Basics/Special/Mode/14.png" style="zoom:50%;" align="left" />

- 分析：`__proto__` 即实例对象的原型 `[[Prototype]]`;
- 注意：`__proto__` 是私有属性，现代浏览器将其暴露给用户，修改此值会改变继承关系；

- 分析：函数构建出的实例对象的原型 `__proto__`，指向函数的原型 `Foo.prototype`，图左上角；
- 分析：函数的属性 prototype，指向函数原型，即 `Foo.prototype`，图中上方；

- 分析：函数原型的原型，即 `Foo.prototype.__proto__` ，指向 Object 原型 `Object.prototype`，图右上角；

- 注意：唯一例外：Function 构造函数，可用 `Function.__proto__` 来访问 `Function.prototype` 
  - 一般情况是：实例的__proto__指向实例构造函数的 prototype ;
- 因为：Function 构造函数即其自身，故作为实例化对象来访问；
  - `Function.__proto__(作为实例) == Function.prototype(作为构造函数)`；

- 注意：唯一例外：`Function.prototype` 并非普通对象，而是函数对象 (特殊匿名函数，此函数的 `__proto__` 指向 Object.prototype)；
- 而且：所有构造函数中，只有 Function 的 prototype 属性为函数

<img src="/Image/Basics/Special/Mode/35.png" style="zoom:50%;" align="left" />

<img src="/Image/Basics/Special/Mode/34.png" style="zoom:50%;" align="left" />



##### 1-2-6-2、大图解说

<img src="/Image/Basics/Special/Mode/36.png" style="zoom:50%;" align="left" />

注意：任何对象均函数，均继承 Function 所有属性和方法，而 Function 是内置的构造函数也是对象，均继承 Object 的所有属性方法；

注意：各种 function、Object、Function 等实际上均为 new Function() 后的实例，而这些实例原型 `__proto__` 均指向 Function.prototype；

同理：Object、Number、String、Array、Function、Date 等均为函数，而所有函数均由 Function 创建，故其原型 `__proto__` 指向 Function.prototype：

<img src="/Image/Basics/Special/Mode/37.png" style="zoom:50%;" align="left" />







#### 1-3、new 

##### 1-3-1、new 过程

<img src="/Image/Basics/Special/Mode/19.png" style="zoom:55%;" align="left"/>

构造调用过程即 new 过程：

- 首先，创建全新的对象 (中间对象) obj；
- 然后，新对象会被执行 [[ 原型 ]] 连接 (将中间对象的原型，指向函数原型，此后便可使用函数原型上的方法和属性)； 
  - `obj.__proto__ = Target.prototype`
- 然后，新对象会绑定到函数调用的 this (即将函数内部 this 指向中间对象)；
- 最后，若函数返回基本类型，则返回中间对象；若返回对象，则代替中间对象，返回函数返回的对象；

再说：new 调用过程：

- 它创建了一个全新的对象
- 它会被执行[[Prototype]]（也即 `__proto__`）链接
- 它使 this 指向新创建的对象
- 通过 new 创建的每个对象将最终被[[Prototype]]链接到这个函数的prototype对象上
- 如果函数没有返回对象类型 Object(包含Functoin, Array, Date, RegExg, Error)，那么new表达式中的函数调用将返回该对象引用

再说：new 调用过程：

- 创建(或者说构造)一个全新对象；
- 这个新对象会被执行 [[ Prototype ]] 连接；
- 这个新对象会绑定到函数调用的 this；
- 若函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象；

<img src="/Image/Basics/Special/Mode/20.png" style="zoom:50%;" align="left" />

再说：new 调用过程：

- **创建一个新对象，并继承其构造函数的`prototype`**；此步是为了继承构造函数原型上的属性和方法；
- **执行构造函数，方法内的`this`被指定为该新实例**；此步是为了执行构造函数内的赋值操作；
- **返回新实例** (规范规定，若构造方法返回了一个对象，则返回该对象，否则返回第一步创建的新对象)；

```js
// new 是关键字, 这里用函数来模拟, new Foo(args) <=> myNew(Foo, args)
function myNew(foo, ...args) {
  // 创建新对象, 并继承构造方法的 prototype 属性
  // 此步是为了把 obj 挂原型链上, 相当于 obj.__proto__ = Foo.prototype
  let obj = Object.create(foo.prototype)  
  
  // 执行构造方法, 并为其绑定新 this
  // 此步是为了让构造方法能进行 this.name = name 类似操作, args 是构造方法的入参, 因为此处用 myNew 模拟, 故入参从 myNew 传入
  let result = foo.apply(obj, args)

  // 若构造方法已 return 了一个对象，则就返回该对象，否则返回 myNew 创建的新对象
  // 一般情况下，构造方法不会返回新实例，但使用者可以选择返回新实例来覆盖 new 创建的对象
  return Object.prototype.toString.call(result) === '[object Object]' ? result : obj
}

// 测试：
function Foo(name) {
  this.name = name
}
const newObj = myNew(Foo, 'zhangsan')
console.log(newObj)                 // Foo {name: "zhangsan"}
console.log(newObj instanceof Foo)  // true
```



##### 1-3-2、创建对象方式

创建对象的三种方式：字面量、new、Object.create()，但本质的只有1种：new；

- 字面量是方便创建对象的语法糖，本质是 new Object()
- new Object 内部还是通过 new 创建

```js
// Object.create
function object(o) {
	function F(){};
	F.prototype = o;
	return new F();
}
```





#### 1-4、原型链

**<u>原型链</u>**：即 JS 对象通过 `__proto__`  指向父类对象，直到指向 Object 对象为止，形成的一个原型指向的链条；

**<u>原型链</u>**：即相互关联的原型组成的链条结构；

[[Prototype]] 内置属性，其实就是对其他对象的引用，几乎所有对象在创建时 [[Prototype]] 属性都会被赋予一非空值；

- 查找操作：
  - 如果，在对象上没有找到需要的属性或者方法引用，引擎就会继续在 [[Prototype]] 关联的对象上进行查找；
  - 如果，在后者中也没有找到需要的引用就会继续查找它的 [[Prototype]]，以此类推；
  - 这一系列对象的链接即 **<u>原型链</u>**；

- Get 操作：试图引用对象的属性时会触发[[Get]] 操作，比如 myObject.a：
  - 首先，检查对象本身是否有这个 [[Prototype]] 内置属性，若有则使用它，若没有，则需使用对象的 [[Prototype]] 链；
  - 但若，anotherObject 中也找不到 a 且 [[Prototype]] 链不为空，则继续查找下去，此过程会持续到找到匹配属性名或查找完整条 [[Prototype]] 链；
  - 最后，若还是找不到那个值，[[Get]] 操作返回 undefined；
- Set 操作：试图给一个 对象设置属性 或 修改已有的属性值会触发 [[Set]] 操作，myObject.foo = "bar”：
  - 首先，若 myObject 对象中包含名为 foo 的普通数据访问属性，则只修改已有属性值；
    - 若 myObject 的 [[Prototype]] 链上层也有 foo，此时发生屏蔽，因 myObject.foo 总是会选择原型链中最底层的 foo 属性；
  - 然后，若 foo 非直接存在于 myObject 中，[[Prototype]] 链就会被遍历，类似 [[Get]] 操作：
    - 若原型链上找不到 foo，foo 就会被直接添加到 myObject 上。
    - 若原型链上存在 foo (在 [[Prototype]] 链上层存在名为 foo)： 
      - 情况1：其为没有被标记为只读(writable:false)，则会直接在 myObject 中添加一个名为 foo 的新属性，它是屏蔽属性；
      - 情况2：其为被标记为只读(writable:false)，则无法修改已有属性或者在 myObject 上创建屏蔽属性；
        - 如果，运行在严格模式下会抛出一个错误，否则，这条赋值语句会被忽略，总之，不会发生屏蔽；
      - 情况3：其为一个 setter ，则一定会调用这个 setter；
        - foo 不会被添加到(或说屏蔽于)myObject，也不会重新定义 foo 这个 setter；

<img src="/Image/Basics/Special/Mode/24.png" style="zoom:50%;" align=""/>

- 注意：使用 for..in ，遍历对象时原理和查找 [[Prototype]] 链类似，任何可通过原型链访问到且是 enumerable的属性都会被枚举；
- 注意：使用 in 操作符，检查属性在对象中是否存在时，同样会查找对象的整条原型链(此时无论属性是否可枚举)；
- 注意：所有普通 [[Prototype]] 链，最终均指向内置的 Object.prototype：
  - 由于所有普通内置对象都“源于”(将 [[Prototype]] 链的顶端设置为)此 Object.prototype 对象，故包含 JS 中许多通用的功能：
  - 比如： .toString() 和 .valueOf()， .hasOwnProperty(..) 和 .isPrototypeOf(..)；



**<u>原型链</u>**：每一对象都有自己的原型对象：实例对象有原型，原型对象也是对象(此处原型对象相当于上一级原型的实例)，故也有其原型(上一级原型对象)，如此形成的一个链式结构；

比如：下图：`实例.__proto__`指向其原型，`原型.__proto__`又指向其原型，然后指向 Object.prototype，最终指向 null；

<img src="/Image/Basics/Special/Mode/25.png" style="zoom:50%;" align="left"/>

<img src="/Image/Basics/Special/Mode/26.png" style="zoom:50%;" align="left"/>

<img src="/Image/Basics/Special/Mode/27.png" style="zoom:50%;" align="left" />



**<u>原型链</u>**：Js 是一种基于原型的语言：每个对象，拥有一个原型对象，对象以其原型为模板，从原型继承方法和属性原型对象也可能拥有原型，并从中继承方法和属性，一层一层、以此类推，此种关系被称为原型链；

- 意义：它解释了为何一个对象会拥有，“定义在其他对象中的属性和方法”。更准确说，它解释了为何一个对象会拥有，定义在 Object的，构造器函数(constructor functions)上的，prototype属性上的属性和方法，而非定义在对象实例上；
- 注意：Js 中并不是复制，而是建立链接：传统的 OOP 中，定义类后，创建对象实例时，类中定义的所有属性和方法都被，复制到实例中，但在 JS 中，并不是复制在 JS 中，是在对象实例，和它的构造器间，建立一个链接（它是 `__proto__` 属性，是从构造函数的prototype 属性派生的）之后通过上溯原型链，在构造器中找到这些属性和方法
- 重申：原型链中的方法和属性，没有被复制到其他对象，它们的访问需要通过原型链；
- 注意：Object中有大量的属性和方法，但实际被继承的，就只有那些以 Object.prototype 开头的属性；是因为继承的属性和方法是定义在 prototype 属性之上的；比如：[Object.prototype.watch()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/watch)、[Object.prototype.valueOf()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/valueOf) 等；但：[Object.is()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/is)、[Object.keys()](https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Objects/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/keys)等不在 prototype 对象内的成员，仅能被 Object() 构造器自身使用，不会被对象实，或继承自 Object() 的对象类型所继承；
- prototype 属性的值是一个对象，希望被原型链下游的对象继承的属性和方法，都被储存在其中；
- 注意：一般很少将属性定义在构造器上的prototype上，因为不灵活；
- **<u>原型链模型</u>**：上游对象的方法，不会复制到下游的对象实例中；下游对象本身虽然没有定义这些方法，但通过上溯原型链、能从上游对象中找到它们；这种继承模型提供了一个强大而可扩展的功能系统；



**<u>原型链</u>**：即由原型对象组成，每个对象都有 `__proto__` 属性，指向了创建该对象的构造函数的原型，`__proto__` 将对象连接起来组成了原型链，是一个用来 <u>实现继承和共享属性</u> 的有限的对象链；它有两个机制和特点：

- **属性查找机制**：当查找对象的属性时，若实例对象自身不存在该属性，则沿着原型链往上一级查找，找到时则输出，不存在时，则继续沿着原型链往上一级查找，直至最顶级的原型对象 `Object.prototype`，如还是没找到，则输出 `undefined`；
- 比如：person.valueOf()；
- <img src="/Image/Basics/Special/Mode/44.png" style="zoom:50%;" align="left" />
- **属性修改机制**：只会修改实例对象本身的属性，若不存在，则进行添加该属性，若需要修改原型的属性时，则可用: `b.prototype.x = 2`；但会造成所有继承于该对象的实例的属性发生改变；
- 特点：对象的 hasOwnProperty() 来检查对象自身中是否含有该属性；
- 特点：使用 in 检查对象中是否含有某个属性时，如果对象中没有但是原型链中有，也会返回 true；

<img src="/Image/Basics/Special/Mode/2.png" style="zoom:50%;" />

<img src="/Image/Basics/Special/Mode/28.png" style="zoom:50%;" />

<img src="/Image/Basics/Special/Mode/29.png" style="zoom:50%;" />







#### 1-5、instance of

##### 1-5-1、理解一

在实例的 **原型对象链** 中找到该构造函数的 `prototype` 属性所指向的 **原型对象**，就返回`true`：

```js
// __proto__: 代表原型对象链
instance.[__proto__...] === instance.constructor.prototype
// return true
```



##### 1-5-2、理解二

应理解为：

检测左侧对象 L 的原型链上(即 L.__proto__.__proto__……)，是否存在右侧 R 的 prototype 原型(即 R.prototype)，如下图；

或者：用以判断某个构造函数，的 prototype 属性，是否存在于另外一个要检测对象，的原型链上；

```js
L instanceof R ==> L.__proto__.__proto__.... === R.prototype 
```



##### 1-5-3、模拟实现

instanceof 运算时会递归查找 left Value 的原型链，即 `left Value.__proto__.__proto__.__proto__`... ，直至找到 / 到达顶层为止

```js
function instance_of(L, R) {
  var O = R.prototype // 取 R 显式原型
  L = L.__proto__;		// 取 L 隐式原型
  while(true) {
    if(L === null) return false;
    if(L === O) return true;	// 注意严格相等
    L = L.__proto__;
  }
}
```



##### 1-5-4、注意事项与示例

- ```js
  function Foo() {     
      // ...  
  } 
  Foo.prototype.xxx = ...; 
  var a = new Foo(); 
  ```

<img src="/Image/Basics/Special/Mode/5.png" style="zoom:50%;" align="left" />

- instanceof 工作机制；若修改 prototype 的 值，则会改变原有(图2)

<img src="/Image/Basics/Special/Mode/6.png" style="zoom:50%;" align="left" />

<img src="/Image/Basics/Special/Mode/7.png" style="zoom:50%;" align="left" />

- Fun 是单纯的函数，`Fun.__proto__` 属于 Function.prototype，除非 new 出来，否则不属于 Fun.prototype；

<img src="/Image/Basics/Special/Mode/8.png" style="zoom:50%;" align="left" />

- JS 在访问 str 属性时创建临时 String 对象 (假设叫tmpStr)，并在得到此返回值时销毁临时对象，故此处是 `tmpStr.__proto__` 的值；而引用类型的字面量和基础类型的不一样(图2)；

<img src="/Image/Basics/Special/Mode/9.png" style="zoom:50%;" align="left" />

<img src="/Image/Basics/Special/Mode/10.png" style="zoom:50%;" align="left" />

- 对于三种基本类型的字面声明，instanceof 均返回 false；而其他类型的字面量声明则为 true；

<img src="/Image/Basics/Special/Mode/11.png" style="zoom:50%;" align="left" />

<img src="/Image/Basics/Special/Mode/12.png" style="zoom:50%;" align="left" />

- `Object.prototype.__proto__` 为 null，但 null 不等于 `Object.prototype`；

<img src="/Image/Basics/Special/Mode/13.png" style="zoom:50%;" align="left" />



##### 1-5-5、JS Object Layout

<img src="/Image/Basics/Special/Mode/14.png" style="zoom:50%;" align="left" />

- **Object instanceof Object**

<img src="/Image/Basics/Special/Mode/15.png" style="zoom:50%;" align="left" />

- **Function instanceof Function**

<img src="/Image/Basics/Special/Mode/16.png" style="zoom:50%;" align="left" />

- **Foo instanceof Foo**

<img src="/Image/Basics/Special/Mode/17.png" style="zoom:50%;" align="left" />



#### 1-6、代码复用形式

- 函数封装
- 继承
- 复制 `extend`
- 混入 `mixin`
- 借用 `apply/call`





### 二、继承

#### 2-1、JS 面向对象编程：封装

原始：创建空对象 {}、在对象上赋值 cat.xx

- 问题：麻烦、实例与原型间关系不明了；

改进：函数封装返回对象；

- 问题：实例间无内在联系，无法反映源于同一原型；

改进：引入构造函数模式，内部使用 this 变量，并对构造函数使用 new 运算符，即可生成实例，且 this 变量会绑定在实例对象上，并可用 constructor 回溯等；

- 问题：每次调用均需开辟新内存，内存性能低下；

改进：引入 prototype 模式，构造函数都有一个 prototype 属性，指向另一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承；不同部分通过构造函数方式创建，相同部分通过 prototype 实现，并提供 isPrototypeOf、hasOwnPrototype、in 等方法；



#### 2-2、构造函数的继承(原型继承演进)

##### 2-2-1、原型链继承

关键：`子类.prototype = new 父类();  子类.prototype.constructor = 子类;`

- 注意：但凡对 prototype 的赋值操作，均需重新将 prototype.constructor 重新修正为子类；因为子类.constructor属性默认调用prototype 对象的 constructor 属性；

原理：原理很简单，直接让子类的原型对象指向父类实例，当子类实例找不到对应的属性和方法时，就会往它的原型对象，也就是父类实例上找，从而实现对父类的属性和方法的继承；

```js
// 父类
function Parent() {
    this.name = '特朗普'
}
// 父类原型方法
Parent.prototype.getName = function() {
    return this.name
}
// 子类
function Child() {}

// 让子类的原型对象指向父类实例, 这样一来在 Child 实例中找不到的属性和方法就会到原型对象(父类实例)上寻找
Child.prototype = new Parent()
// 根据原型链的规则, 顺便绑定一下constructor, 这一步不影响继承, 只是在用到 constructor 时会需要
// 帮助修复 子类实例的构造函数错误指向
Child.prototype.constructor = Child 

// 然后 Child 实例就能访问到父类及其原型上的 name 属性和 getName() 方法
const child = new Child()
child.name          // '特朗普'
child.getName()     // '特朗普'
```

缺点：

- 覆盖子类上 prototype 原有属性(因直接 子类.prototype = new 父类l();)，耗内存(需建立父类实例 new 父类())；

- 由于所有 Child 实例原型都指向同一个 Parent 实例, 因此对某个 Child 实例的父类引用类型变量修改会影响所有 Child 实例

- 在创建子类实例时无法向父类构造传参，即没有实现 `super()` 的功能

- ```js
  // 示例:
  function Parent() {
      this.name = ['特朗普'] 
  }
  Parent.prototype.getName = function() {
      return this.name
  }
  function Child() {}
  Child.prototype = new Parent()
  Child.prototype.constructor = Child 
  
  // 测试
  const child1 = new Child()
  const child2 = new Child()
  child1.name[0] = 'foo'
  console.log(child1.name)  // ['foo']
  console.log(child2.name)  // ['foo'] (预期是['特朗普'], 对 child1.name 的修改引起了所有 child 实例的变化)
  ```



##### 2-2-2、构造函数继承

关键： 在子类函数中执行：`父类函数.apply/call(this, arguments/…arguments);`

原理：即在子类的构造函数中执行父类的构造函数，并为其绑定子类的 `this`，让父类的构造函数把成员属性和方法，都挂到 `子类的this`上去，如此能避免实例间共享同一个原型实例，又能向父类构造方法传参；

```js
function Parent(name) {
    this.name = [name]
}
Parent.prototype.getName = function() {
    return this.name
}
function Child() {
    Parent.call(this, 'zhangsan')   // 执行父类构造方法并绑定子类的 this, 使得父类中的属性能够赋到子类的 this 上
}

// 测试
const child1 = new Child()
const child2 = new Child()
child1.name[0] = 'foo'
console.log(child1.name)          // ['foo']
console.log(child2.name)          // ['zhangsan']
child2.getName()                  // 报错, 找不到 getName(), 构造函数继承的方式继承不到父类原型上的属性和方法
```

缺点：继承不到父类原型上的属性和方法



##### 2-2-3、组合式继承

原理：原型链继承和构造函数继承各有互补的优缺点，合体为组合式继承；

```js
function Parent(name) {
    this.name = [name];
  	this.play = [1, 2, 3];
}
Parent.prototype.getName = function() {
    return this.name
}
function Child() {
    // 构造函数继承
    Parent.call(this, 'zhangsan') 
}
// 原型链继承
Child.prototype = new Parent()
Child.prototype.constructor = Child

// 测试
const child1 = new Child()
const child2 = new Child()
child1.name[0] = 'foo'
child1.play.push(4);
console.log(child1.play, child2.play); // [1,2,3,4] [1,2,3]
console.log(child1.name)          // ['foo']
console.log(child2.name)          // ['zhangsan']
child2.getName()                  // ['zhangsan']
```

缺点：每次创建子类实例都执行了两次构造函数(`Parent.call()`和`new Parent()`)，虽并不影响对父类的继承，但子类创建实例时，原型中会存在两份相同的属性和方法，这并不优雅；



##### 2-2-4、寄生组合式继承

为了解决构造函数被执行两次的问题，将 `指向父类实例` 改为 `指向父类原型`，减去一次构造函数的执行；

```js
function Parent(name) {
    this.name = [name]
}
Parent.prototype.getName = function() {
    return this.name
}
function Child() {
    // 构造函数继承
    Parent.call(this, 'zhangsan') 
}
// 原型链继承
// Child.prototype = new Parent()
Child.prototype = Parent.prototype  // 将 指向父类实例 改为 指向父类原型
Child.prototype.constructor = Child

// 测试
const child1 = new Child()
const child2 = new Child()
child1.name[0] = 'foo'
console.log(child1.name)          // ['foo']
console.log(child2.name)          // ['zhangsan']
child2.getName()                  // ['zhangsan']
```

问题：由于子类原型和父类原型指向同一个对象，故对子类原型的操作会影响到父类原型；比如给 `Child.prototype` 增加一个getName() 方法，会导致 `Parent.prototype` 也增加或被覆盖一个 getName() 方法；

解决：为避免上述问题，可对 `Parent.prototype` 做浅拷贝，利用 <u>空对象</u> 作为中介，几乎不占内存，且修改 子类 的 prototype 对象，也不会影响到 父类 的 prototype 对象；

- 注意：后续演进中的 super() 作用也大致如此；
- 注意：继承后才在子类 prototype 上添加方法和属性；

```js
function Parent(name) {
    this.name = [name]
}
Parent.prototype.getName = function() {
    return this.name
}
function Child() {
    // 构造函数继承
    Parent.call(this, 'zhangsan') 
}
// 原型链继承
// Child.prototype = new Parent()
// 将 指向父类实例 改为 指向父类原型，并使用浅拷贝避免父子原型间的影响
Child.prototype = Object.create(Parent.prototype)  
Child.prototype.constructor = Child

// 测试
const child = new Child()
const parent = new Parent()
child.getName()                  // ['zhangsan']
parent.getName()                 // 报错, 找不到getName()
```



##### 2-2-5、总结

首先，最容易想到的是 **<u>原型链继承</u>**，通过把子类实例的原型指向父类实例来继承父类的属性和方法，但原型链继承的缺陷在于<u>对子类实例继承的引用类型的修改会影响到所有的实例对象，以及无法向父类的构造方法传参</u>；
因此，引入了 **<u>构造函数继承</u>**, 通过在子类构造函数中调用父类构造函数并传入子类 this 来获取父类的属性和方法，但构造函数继承也存在缺陷，<u>构造函数继承不能继承到父类原型链上的属性和方法</u>；
所以，综合两种继承的优点，提出了 **<u>组合式继承</u>**，但组合式继承也引入了新的问题：<u>它每次创建子类实例都执行了两次父类构造方法</u>；最后，通过将子类原型指向父类实例，改为子类原型指向父类原型的浅拷贝来解决这一问题，也即最终实现：**<u>寄生组合式继承</u>**



##### 2-2-6、最优解

```js
var inherit = (function(c,p){
	var F = function(){};
	return function(c,p){
		F.prototype = p.prototype;
		c.prototype = new F();
    // 为子对象设置 uber 属性，其指向父对象的 prototype 属性，仅用欧冠与实现继承完备性，纯属备用性质
		c.uber = p.prototype;
		c.prototype.constructor = c;
	}
})();

// 其他: ES6 语法糖 class / extends
// 拓展: Extend
function _possibleConstructorReturn(self, call) {
    // ...
    return call && (typeof call === 'object' || typeof call === 'function') ? call : self;
}

// 核心
function _inherits(subClass, superClass) {
    // ...
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            enumerable: false,
            writable: true,
            configurable: true
        }
    });
  	// 用来继承父类的静态方法, 寄生组合遗漏地方
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}


var Parent = function Parent() {
    // 验证是否是 Parent 构造出来的 this
    _classCallCheck(this, Parent);
};

var Child = (function (_Parent) {
    _inherits(Child, _Parent);
    function Child() {
        _classCallCheck(this, Child);
        return _possibleConstructorReturn(this, (Child.__proto__ || Object.getPrototypeOf(Child)).apply(this, arguments));
    }
    return Child;
}(Parent));
// 核心: _inherits 函数，采用的依然也是第五种方式————寄生组合继承方式，同时证明了这种方式的成功; 
// 注意此处增加 Object.setPrototypeOf(subClass, superClass)，用来继承父类的静态方法, 此乃寄生组合遗漏地方
```



#### 2-3、非构造函数的继承(普通对象的继承)

方法1：object 方式：即将子对象的 prototype 属性，指向父对象，从而使得子对象与父对象连在一起；

- 注意：JSON 格式的发明人 Douglas Crockford 提出；

```js
function object(o) {
	function F(){};
	F.prototype = o;
	return new F();
}
```

方法2：浅拷贝

方法3：深拷贝(递归使用浅拷贝)





### 三、设计模式



#### 3-1、面向对象的设计

##### 3-1-1、设计原则

- **单一职责原则**：一个类只负责一个功能领域中的相应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因；
- **开放封闭原则**：核心思想是软件实体（类、模块、函数等）是可扩展的、但不可修改；即对扩展是开放的,而对修改是封闭的；



##### 3-1-2、单例模式

即一个类只能构造出唯一实例，其意义在于**共享、唯一**；

比如：`Redux/Vuex`中的store、`JQ`的$或者业务场景中的购物车、登录框都是单例模式的应用

```js
class SingletonLogin {
  constructor(name,password){
    this.name = name
    this.password = password
  }
  static getInstance(name,password){
    // 判断对象是否已经被创建,若创建则返回旧对象
    if(!this.instance)this.instance = new SingletonLogin(name,password)
    return this.instance
  }
}
 
let obj1 = SingletonLogin.getInstance('TLP','123')
let obj2 = SingletonLogin.getInstance('TLP','321')
 
console.log(obj1===obj2)    // true
console.log(obj1)           // {name:TLP,password:123}
console.log(obj2)           // 输出的依然是 {name:TLP,password:123}
```



##### 3-1-3、工厂模式

即对创建对象逻辑的封装，或可简单理解为对 `new` 的封装，这种封装就像创建对象的工厂，故名工厂模式；

常见于大型项目，比如 JQ 的 对象，在创建选择器对象时之所以没有 new selector 就是因为其已是一个工厂方法；

比如：`React.createElement()`、`Vue.component()` 都是工厂模式的实现；

种类：`简单工厂模式`、`工厂方法模式`、`抽象工厂模式`；

##### 3-1-3-1、简单工厂模式

```js
class User {
  constructor(name, auth) {
    this.name = name
    this.auth = auth
  }
}

class UserFactory {
  static createUser(name, auth) {
    // 工厂内部封装了创建对象的逻辑:
    // 权限为admin时,auth=1, 权限为user时, auth为2
    // 使用者在外部创建对象时,不需要知道各个权限对应哪个字段, 不需要知道赋权的逻辑，只需要知道创建了一个管理员和用户
    if(auth === 'admin')  new User(name, 1)
    if(auth === 'user')  new User(name, 2)
  }
}

const admin = UserFactory.createUser('cxk', 'admin');
const user = UserFactory.createUser('cxk', 'user');
```



##### 3-1-4、观察者模式

观察者模式算是前端最常用的设计模式了，其概念简单：观察者监听被观察者的变化，被观察者发生改变时，通知所有的观察者；

观察者模式被广泛用于监听事件的实现；

注意：有些文章也把观察者模式称为发布订阅模式，其实二者是有所区别的，发布订阅相较于观察者模式多一个调度中心；

```js
//观察者
class Observer {    
  constructor (fn) {      
    this.update = fn    
  }
}
//被观察者
class Subject {    
    constructor() {        
        this.observers = []          // 观察者队列    
    }    
    addObserver(observer) {          
        this.observers.push(observer)// 往观察者队列添加观察者    
    }    
    notify() {                       // 通知所有观察者,实际上是把观察者的 update()都执行了一遍       
        this.observers.forEach(observer => {        
            observer.update()            // 依次取出观察者,并执行观察者的 update 方法        
        })    
    }
}

var subject = new Subject()       // 被观察者
const update = () => {console.log('被观察者发出通知')}  //收到广播时要执行的方法
var ob1 = new Observer(update)    // 观察者1
var ob2 = new Observer(update)    // 观察者2
subject.addObserver(ob1)          // 观察者1订阅 subject 的通知
subject.addObserver(ob2)          // 观察者2订阅 subject 的通知
subject.notify()                  // 发出广播,执行所有观察者的 update 方法
```



##### 3-1-5、装饰器模式

可理解为对类的一个包装，动态地拓展类的功能；

比如：ES7 的 <u>装饰器</u> 语法、React 中的 <u>高阶组件(HoC)</u> 、react-redux 的 connect()、都是此模式的实现；

```js
// 以 ES7 的装饰器为例
function info(target) {
  target.prototype.name = '张三'
  target.prototype.age = 10
}

@info
class Man {}

let man = new Man()
man.name // 张三
```



##### 3-1-6、适配器模式

即将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作；

```js
class Adaptee {
  test() {
      return '旧接口'
  }
}
 
class Target {
  constructor() {
      this.adaptee = new Adaptee()
  }
  test() {
      let info = this.adaptee.test()
      return `适配${info}`
  }
}
 
let target = new Target()
console.log(target.test())
```



##### 3-1-7、代理模式

```
const idol = {
  name: '特朗普',
  phone: 10086,
  price: 1000000  //报价
}

const agent = new Proxy(idol, {
  get: function(target) {
    // 拦截明星电话的请求,只提供经纪人电话
    return '经纪人电话: 10086'
  },
  set: function(target, key, value) {
    if(key === 'price' ) {
      // 经纪人过滤资质
      if(value < target.price) throw new Error('报价过低')
      target.price = value
    }
  }
})


agent.phone        // 经纪人电话:10086
agent.price = 100  // Uncaught Error: 报价过低
```





#### 3-2、面向组合的设计

**<u>继承最大问题在于：无法决定继承哪些属性，所有属性都得继承；</u>**

比如：B 类继承 A 类，为避免上述问题，可创建父类，把不必要的内容先剔除；但问题仍显著：

- 一方面：父类无法描述所有子类的细节情况，为不同子类特性去增加不同的父类，<u>代码大量重复</u>；
- 一方面：一旦子类有所变动，父类也要进行相应更新，<u>代码耦合性太高</u>，<u>难以维护</u>；

**<u>解决：使用组合，当今编程语法发展趋势，比如 golang 完全采用的是面向组合的设计方式；</u>**

其原理即先设计一系列零件，然后将这些零件进行拼装，来形成不同的实例或者类；

```js
function drive(){
  console.log("wuwuwu!");
}
function music(){
  console.log("lalala!")
}
function addOil(){
  console.log("kakaka！")
}

let car = compose(drive, music, addOil);
let newEnergyCar = compose(drive, music);
```



