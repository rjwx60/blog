---
typora-root-url: ../../Source
---



### 一、基本

#### 1-1、基本

- **<u>原型 prototype</u>**： 一个简单的对象，用于实现对象的 **属性继承**；可简单的理解成对象的爹；

  - 在 Firefox 和 Chrome 中，每个 JS 对象中都包含一个`__proto__`    属性(非标)指向它爹(该对象的原型)，即`obj.__proto__`进行访问；

- **<u>构造函数</u>**：可通过 `new` 来 **新建一个对象** 的函数；

- **<u>实例</u>**：通过构造函数和 `new` 创建出来的对象，即实例； 

  - **实例通过`__proto__`指向原型，通过`constructor`指向构造函数**；

  

#### 1-2、关系

在 JS 中，每当定义一个函数数据类型(普通函数、类)时候，都会天生自带一个 prototype 属性，这个属性指向函数的 **<u>原型对象</u>**；

当函数经过 new 调用时，这个函数就成为了 **<u>构造函数</u>**，返回一个全新的 **<u>实例</u>** 对象，这个实例对象有一个__proto__属性，指向构造函数的原型对象；

```js
// 实例
const instance = new Object()
// 实例为 instance, 构造函数为 Object, 构造函数拥有一个 prototype 属性指向原型
// 原型
const prototype = Object.prototype
```

```js
// 三者的关系:
实例.__proto__ === 原型

原型.constructor === 构造函数

构造函数.prototype === 原型

实例.constructor === 构造函数
// 注意: 其实实例上并不是真正有 constructor 这个指针，它其实是从原型链上获取的: instance.hasOwnProperty('constructor') === false 
// 例如: 
// const o = new Object()
// o.constructor === Object   --> true
// o.__proto__ = null;
// o.constructor === Object   --> false 
```

<img src="/Image/Basics/Special/Mode/4.png" style="zoom:35%;" />



#### 1-3、原型链

JS 对象通过 __proto__  指向父类对象，直到指向 Object 对象为止，形成了一个原型指向的链条，即 **<u>原型链</u>**；原型链是由原型对象组成，每个对象都有 `__proto__` 属性，指向了创建该对象的构造函数的原型，`__proto__` 将对象连接起来组成了原型链，是一个用来 <u>实现继承和共享属性</u> 的有限的对象链；它有两个机制和特点：

- **属性查找机制**：当查找对象的属性时，若实例对象自身不存在该属性，则沿着原型链往上一级查找，找到时则输出，不存在时，则继续沿着原型链往上一级查找，直至最顶级的原型对象 `Object.prototype`，如还是没找到，则输出 `undefined`；
- **属性修改机制**：只会修改实例对象本身的属性，若不存在，则进行添加该属性，若需要修改原型的属性时，则可用: `b.prototype.x = 2`；但会造成所有继承于该对象的实例的属性发生改变；

- 对象的 hasOwnProperty() 来检查对象自身中是否含有该属性；
- 使用 in 检查对象中是否含有某个属性时，如果对象中没有但是原型链中有，也会返回 true；

<img src="/Image/Basics/Special/Mode/2.png" style="zoom:50%;" />

#### 1-4、instance of

在实例的 **原型对象链** 中找到该构造函数的 `prototype` 属性所指向的 **原型对象**，就返回`true`：

```js
// __proto__: 代表原型对象链
instance.[__proto__...] === instance.constructor.prototype
// return true
```




### 二、继承

```js
// 1、借助 call
// 可获取父类属性值；但问题是: 父类原型对象中一旦存在方法则子类无法继承
function Parent1(){
	this.name = 'parent1';
}
function Child1(){
	Parent1.call(this);
	this.type = 'child1'
}
console.log(new Child1);


// 2、借助原型链
// 解决上一问题, 父类的方法和属性都能够访问；但不足是: 多个实例共用同一原型对象
function Parent2() {
  this.name = 'parent2';
  this.play = [1, 2, 3]
}
function Child2() {
  this.type = 'child2';
}
Child2.prototype = new Parent2();
console.log(new Child2());


// 3、将上述两者结合
// 解决上一问题, 实例间无法共用同一原型对象；但不足是: Parent3 构造函数被多执行了一次: Child3.prototype = new Parent3();
function Parent3 () {
  this.name = 'parent3';
  this.play = [1, 2, 3];
}
function Child3() {
  Parent3.call(this);
  this.type = 'child3';
}
Child3.prototype = new Parent3();
var s3 = new Child3();
var s4 = new Child3();
s3.play.push(4);
console.log(s3.play, s4.play);


// 4、组合继承优化
// 将父类原型对象直接给到子类，父类构造函数只执行一次，而且父类属性和方法均能访问；但不足是: 子类实例的构造函数错误指向
function Parent4 () {
  this.name = 'parent4';
  this.play = [1, 2, 3];
}
function Child4() {
  Parent4.call(this);
  this.type = 'child4';
}
Child4.prototype = Parent4.prototype;
var s3 = new Child4();
var s4 = new Child4();
console.log(s3)


// 5、寄生组合式继承
function Parent5 () {
  this.name = 'parent5';
  this.play = [1, 2, 3];
}
function Child5() {
  Parent5.call(this);
  this.type = 'child5';
}
Child5.prototype = Object.create(Parent5.prototype);
Child5.prototype.constructor = Child5;


// 6、最优
var inherit = (function(c,p){
	var F = function(){};
	return function(c,p){
		F.prototype = p.prototype;
		c.prototype = new F();
		c.uber = p.prototype;
		c.prototype.constructor = c;
	}
})();


// 5+、Extend
function _possibleConstructorReturn(self, call) {
    // ...
    return call && (typeof call === 'object' || typeof call === 'function') ? call : self;
}

// 核心
function _inherits(subClass, superClass) {
    // ...
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            enumerable: false,
            writable: true,
            configurable: true
        }
    });
  	// 用来继承父类的静态方法, 寄生组合遗漏地方
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}


var Parent = function Parent() {
    // 验证是否是 Parent 构造出来的 this
    _classCallCheck(this, Parent);
};

var Child = (function (_Parent) {
    _inherits(Child, _Parent);
    function Child() {
        _classCallCheck(this, Child);
        return _possibleConstructorReturn(this, (Child.__proto__ || Object.getPrototypeOf(Child)).apply(this, arguments));
    }
    return Child;
}(Parent));
// 核心: _inherits 函数，采用的依然也是第五种方式————寄生组合继承方式，同时证明了这种方式的成功; 
// 注意此处增加 Object.setPrototypeOf(subClass, superClass)，用来继承父类的静态方法, 此乃寄生组合遗漏地方
```



### 三、设计模式

#### 3-1、面向对象的设计

#### 3-2、面向组合的设计

**<u>继承最大问题在于：无法决定继承哪些属性，所有属性都得继承；</u>**

比如：B 类继承 A 类，为避免上述问题，可创建父类，把不必要的内容先剔除；但问题仍显著：

- 一方面：父类无法描述所有子类的细节情况，为不同子类特性去增加不同的父类，<u>代码大量重复</u>；
- 一方面：一旦子类有所变动，父类也要进行相应更新，<u>代码耦合性太高</u>，<u>难以维护</u>；

**<u>解决：使用组合，当今编程语法发展趋势，比如 golang 完全采用的是面向组合的设计方式；</u>**

其原理即先设计一系列零件，然后将这些零件进行拼装，来形成不同的实例或者类；

```js
function drive(){
  console.log("wuwuwu!");
}
function music(){
  console.log("lalala!")
}
function addOil(){
  console.log("kakaka！")
}

let car = compose(drive, music, addOil);
let newEnergyCar = compose(drive, music);
```



