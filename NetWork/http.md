---
typora-root-url: ../Source
---



### 一、历史

#### 1-1、总览

##### 1-1-1、1.0 协议缺陷

- 无法复用链接，完成即断开，**重新慢启动和 TCP 3次握手**；
- head of line blocking：**线头阻塞**，导致请求之间互相影响；

##### 1-1-2、1.1 协议改进

- **长连接：** 默认 keep-alive，支持长连接和请求的流水线，在一个 TCP 连接上可传送多个 HTTP 请求，避免了因为多次建立 TCP 连接的时间消耗和延时
- **Host 头指定对应虚拟站点：** 在 1.0 中认为每台服务器都有唯一的IP地址，但随着虚拟主机技术发展，多主机共享单一 IP 地址愈发普遍；HTTP1.1 引入 Host 头部字段，且请求消息中若无 Host 头域会报 400 错误；
- **新增功能:**
  - 断点续传：引入 Range 头部；
  - 身份认证
  - 状态管理
  - 缓存处理：引入缓存相关头部字段来控制缓存，详看浏览器缓存章节
    - Cache-Control
    - Expires
    - Last-Modified
    - Etag

##### 1-1-3、2.0 协议增强

- **二进制格式：** 采用二进制格式传输数据，相比于 HTTP/1.1 的文本格式，二进制格式具有更好的解析性和拓展性；
- **多路复用：** 即多个请求都通过一个 TCP 连接并发地完成；
- **首部压缩：** 压缩消息头，减少传输数据的大小；
- **服务端推送：** 服务端能够主动把资源推送给客户端；



##### 1-1-4、3.0 协议改进

HTTP/2 仍然存在一些缺陷，但缺陷并非来自 HTTP/2 协议本身，而是来源于底层的 TCP 协议：虽然 TCP 连接是可靠连接，若出现丢包，则整个连接都要等待重传；HTTP/1.1 可同时使用 6 个 TCP 连接，一旦发生阻塞则另外 5 个还能工作，但 HTTP/2 只有1个 TCP 连接，也即阻塞问题被放大；

由于 TCP 协议已被广泛使用，故很难直接修改 TCP 协议，基于此 HTTP/3 选择了折衷办法：QUIC 基于 UDP 实现，是 HTTP/3 中的底层支撑协议，该协议基于 UDP，又取了 TCP 中的精华，实现了即快又可靠的协议；

- 注意：HTTP/3 之前名为 HTTP-over-QUIC，HTTP/3 最大的改造就是使用了 QUIC；

QUIC 虽然基于 UDP，但是在原本的基础上新增了很多功能，比如：<u>多路复用、0-RTT、使用 TLS1.3 加密、流量控制、有序交付、重传</u>等等功能：

- 多路复用：虽然 HTTP/2 支持了多路复用，但是 TCP 协议终究是没有这个功能；但 QUIC 原生就实现了此功能，并且传输的单个数据流可以保证有序交付且不会影响其他的数据流，这样的技术就解决了之前 TCP 存在的问题；并且 QUIC 在移动端的表现也会比 TCP 好，因为 TCP 是基于 IP 和端口去识别连接的，这种方式在多变的移动端网络环境下是很脆弱的，但 QUIC 是通过 ID 的方式去识别一个连接，不管你网络环境如何变化，只要 ID 不变，就能迅速重连上；

- 0-RTT：通过使用类似 TCP 快速打开的技术，缓存当前会话的上下文，在下次恢复会话时，只需要将之前的缓存传递给服务端验证通过就可进行传输；

- 纠错机制：比如发送三个包，则协议会算出这三个包的异或值并单独发出一个校验包，也即总共发出了四个包；当出现其中的非校验包丢包时，可通过另外三个包计算出丢失的数据包的内容；仅限于丢失一个包的情况下，若出现丢失多个包就不能使用纠错机制，只能使用重传的方式；

详看： [http发展史(http0.9、http1.0、http1.1、http2、http3)](https://juejin.im/post/5dbe8eba5188254fe019dabb#heading-9)



##### 1-1-5、HTTPS 增加安全层

- 证书(公钥)
  - HTTPS 需要申请证书；
- SSL 加密
  - HTTP 是超文本传输协议，是明文传输；HTTPS 是 HTTP 经过 SSL 层加密，传输更安全；
  - HTTPS 比 HTTP 慢，因为 HTTPS 除了 TCP 握手的三个包，还要加上 SSL 握手的九个包；
- 端口 443 
  - HTTPS 使用 443 端口，HTTP 使用80；



#### 1-2、演进

- **HTTP/0.9** 于 **1990 年**问世，并没有作为正式的标准被建立；
- 作为正式的标准被建立是 **HTTP/1.0**，于 **1996年5月** 发布；
- 目前主流的版本是 **HTTP/1.1**，于 **1997年1月** 发布；
- **2015年5月** 正式发布 **HTTP/2**；(不叫 HTTP/2.0，是因为标准委员会不打算发布子版本，下一个版本直接是 HTTP/3)；



#### 1-3、同层协议

- FTP：文件传输协议，用来在客户机和FTP服务器之间传输文件；
- DNS：提供域名到IP地址之间的解析服务；
- SMTP：邮件发送协议，用户通过SMTP服务器发送邮件；
- DHCP：动态主机配置协议，DHCP服务器为客户机动态分配IP地址；
- POP3：邮件接收协议，用于从POP3服务器接收邮件；



### 二、HTTP协议

​	是通常跑在`TCP/IP协议栈`之上，依靠`IP协议实现寻址和路由`、`TCP协议实现可靠数据传输`、`DNS协议实现域名查找`、`SSL/TLS协议实现安全通信`；当然，WebSocket、DNS 依赖于 HTTP；

#### 2-1、协议特点

##### 2-1-1、优点/特点

- 无状态(优缺同体)：状态指通信过程的上下文信息；无状态指每次请求均为独立无关联，默认不保留状态信息；具体场景具体分析；
  - 比如若仅为获取某些数据的场景下，而无需保存连接的上下文信息，此时的无状态能有效减少网络开销；
- 灵活可扩展
  - 语义自由：只规定基本格式(分隔符、换行分隔等)，而其他部分无严格语法限制；
  - 形式多样：传输形式多样，可传输文本、图片、视频等任意数据；
- 可靠传输：HTTP 基于 TCP/IP，继承其特性；
- 请求响应模式：报文须一发一收、有来有回；
- <u>持久连接</u>：建立一次 TCP 连接即可进行多次请求或响应的交互，只要有一方没有明确的提出断开连接，则保持连接状态；
  - 原理：HTTP的初始版本是每进行一次HTTP通信就要断开一次TCP连接，下次再进行的时候又要重新连接断开。再如今请求的资源越来越大，每次请求如果都有无谓TCP连接和断开是很大的开销。
  - 优点：减少 TCP 连接和断开的造成的额外开销，减轻服务端的负载，Web 页面加载变快；
  - 注意：HTTP/1.1 中所有连接均默认持久连接 (也即首部字段 `Connection: keep-alive`，若想要关闭可将值设置为 close)，但 HTTP/1.0 并未标准化
- <u>管线化</u>：同时并行发送多个请求，而不必等前一个请求完毕才能发送下一个，<u>但因为各种原因被各大厂商废弃了</u>

##### 2-1-2、缺点/不足

- 无状态(优缺同体)：状态指通信过程的上下文信息；无状态指每次请求均为独立无关联，默认不保留状态信息；具体场景具体分析；
  - 对于一些长连接的场景需要保存上下文信息，以免传输重复的数据。
  - 对于一些应用只是为了获取数据不需要保存上下文信息，无状态减少了网络开销。
- 明文传输：即报文传输使用文本形式而非二进制形式，虽便于调试但暴露了内部信息，内容能被窃取；
- 队头阻塞：当 http 开启长连接时将共用一个 TCP 连接，同一时刻只能处理一个请求，此时若某请求耗时过长，则会导致其它请求处于阻塞状态；
  - 根本原因：在于 HTTP 基于 <u>请求响应</u> 模型，在同一 TCP 长连接中，前一请求没有得到响应，后面的请求就会被阻塞；
  - 注意：与 TCP 队头阻塞区别：TCP 传输的单位是数据包，其队头阻塞表示的是前一个报文没有收到便不会将下一个报文上传给应用层；而 HTTP 队头阻塞是在 请求-响应 层面，前一个请求还没有处理完，后面的请求就被阻塞；

##### 2-1-3、缺点应对

- 无状态：详看：WebSocket
- 明文传输：HTTPS，详看：三：HTTPS
- 队头阻塞：HTTP 传输基于`请求-应答` 模式，报文须一发一收，而其中任务放在任务队列中串行执行，一旦队首请求处理太慢，就会阻塞后续请求的处理：
  - 并发连接：一个域名允许分配多个长连接，相当于增加任务队列数量；
    - 注意：RFC2616 规定过客户端最多并发 2 个连接，而实际中的浏览器上限要比它大，比如 Chrome 中是 6；
  - 域名分片：通过增加域名以实现增加发送数量；
    - 比如：content1.sanyuan.com 、content2.sanyuan.com
  - HTTP/2 多路复用：上述 HTTP/1.1 方式并无真正从协议层面解决问题，只是增加 TCP 连接分摊风险，且多条 TCP 连接也会竞争有限的带宽，让真正优先级高的请求不能优先处理；而 HTTP/2 的多路复用真正从协议层面解决此问题，详看 4-1-2；



#### 2-2、报文格式

<img src="/Image/NetWork/http/17.png" style="zoom:50%;" align="left"/>

与TCP 的`tcp头部 + 数据部分`类似，即 `http头部(header) + 数据部分(body)`

还可进一步分拆为 `header(起始行 + 头部 + 空行) + body(实体)` 四部分，其中头部又可分为请求头部和响应头部；



##### 2-2-1、起始行

请求报文起始行由：`方法 + 路径 + http版本` 组成，比如：`GET /home HTTP/1.1`

响应报文起始行由：`http版本 + 状态码 + 原因` 组成，比如：`HTTP/1.1 200 OK`

- 注意：响应报文的起始行也叫做状态行；

- 注意：起始行中每2个部分间用**空格**隔开，最后一部分后还应接**换行**，遵循 [ABNF规范](https://en.wikipedia.org/wiki/Augmented_Backus–Naur_form)

##### 2-2-2、头部

下图分别为请求头部与响应头部，其中各个字段须遵循以下格式：

- 字段名不区分大小写、不允许出现空格，不可出现下划线 `_`
- 字段名后面必须紧跟冒号 `:` 不得空隙；

<img src="/Image/NetWork/http/1.png" style="zoom:35%;" align="left" />

<img src="/Image/NetWork/http/2.png" style="zoom:35%;" align="left" />

##### 2-2-3、空行

用以区分头部与实体，若将空行位置上移，则往后内容均被视为实体部分；

##### 2-2-4、实体

即数据部分；







#### 2-3、报文字段—[MDN](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers)

##### 2-3-X、通用头

<img src="/Image/NetWork/http/18.png" style="zoom:50%;" align="left" />

<img src="/Image/NetWork/http/30.png" style="zoom:50%;" align="left" />



##### 2-3-X、请求头

<img src="/Image/NetWork/http/19.png" style="zoom:50%;" align="left" />

<img src="/Image/NetWork/http/31.png" style="zoom:50%;" align="left" />



##### 2-3-X、响应头

<img src="/Image/NetWork/http/20.png" style="zoom:50%;" align="left" />

<img src="/Image/NetWork/http/32.png" style="zoom:50%;" align="left" />



##### 2-3-U、实体头

即针对请求报文和响应报文的实体部分使用首部

<img src="/Image/NetWork/http/21.png" style="zoom:50%;" align="left" />

<img src="/Image/NetWork/http/33.png" style="zoom:50%;" align="left" />



##### 2-3-1、Method

Http1.1 规定的以下请求方法(大写)：

- GET：获取资源，幂等操作
- HEAD：获取报文首部，和GET很像但是不返回报文主体，幂等操作
- POST: 创建或更新资源，非幂等操作
- PUT: 创建或更新资源本身，幂等操作
- PATCH：对资源进行局部更新，幂等操作
- DELETE：删除资源，和PUT功能相反，幂等操作
- OPTIONS：查询服务器端支持的HTTP方法种类(幂等操作)
- CONNECT：建立连接隧道，用于代理服务器，幂等操作
- TRACE：追踪请求，查询发出去的请求是怎样被加工/篡改的，幂等操作。容易引发XST跨站追踪攻击；
- 注意：OPTIONS、CONNECT、TRACE只在HTTP/1.1以上被支持
- 注意：LINK、UNLINK在HTTP/1.1中被废弃





##### 2-3-1-1、GET & POST 区别

<u>GET：可以缓存、相对危险(参数URL、有历史记录)、请求参数长度有限制、参数一般寄放 URL，URL编码仅支持 ASCII字符</u>

- 无副作用：不修改资源，比如对服务器上的资源做改变，搜索是无副作用的，注册是副作用的；
- 幂等：请求次数与资源无关，指发送 M 和 N 次请求（两者不相同且都大于 1），服务器上资源的状态一致；
  - 比如：注册 10 个和 11 个帐号是不幂等的；
  - 比如：对文章进行更改 10 次和 11 次是幂等的；因为前者是多了一个账号（资源），后者只是更新同一个资源；

<u>POST：不能缓存、相对安全、请求参数长度非常大、参数寄放请求体、 支持更多的编码类型且不对数据类型限制；</u>

- 注意：实际上，HTTP 协议并无要求 GET/POST 请求参数必须放在 URL上 或请求体中，也无规定 GET 请求长度，而目前对 URL 的长度限制，是各家浏览器设置的限制；GET 和 POST 的根本区别在于：<u>**GET 请求是幂等性的，而 POST 请求不是**</u>；
- 幂等，指对某一资源进行一或多次请求都具有相同的副作用；比如搜索就是一个幂等操作，而删除、新增则不是；由于 GET 请求是幂等，在网络不好的环境中，GET 请求可能会重复尝试，造成重复操作数据的风险，因此，GET 请求用于无副作用的操作(比如搜索)，新增/删除等操作更适合用 POST；
- 注意：从 TCP 角度上，GET 请求会将请求报文一次性发出，但 POST 会分为2个 TCP 数据包；首先发送的是 header 部分，若是服务器响应 100(continue)，则会发送 body 部分，火狐浏览器除外，它的 POST 请求只发一个 TCP 包，但并非表示 GET 比 POST 更有效：
  - 首先，GET 和 POST 均有自身语义，最好不要混用；
  - 另外，在网络条件好的情况下，发一次包和发两次包相差的时间基本可无视；否则，两次发包的 TCP 在验证数据包的完整性上还有更大优势；
  - 再者，也并非所有浏览器的 POST 请求都会发送两次 TCP 数据包(不可以偏概全)；

- 详看：[HTTP｜GET 和 POST 区别](https://juejin.im/entry/597ca6caf265da3e301e64db)

<img src="/Image/NetWork/http/16.png" style="zoom:50%;" align="left"/>



##### 2-3-1-2、幂等

方法幂等，实际即判断方法重复执行多次，产生效果是不是一样的；若为幂等，则其本质上意味着：成功执行请求的结果同它执行的次数无关；只有 **POST** 和 **PATCH** 是 **非幂等** 的，**其它都是幂等操作**：

- GET 方法用于获取资源，不应该有副作用，故**幂等**；
- HEAD 方法 与 GET 情况一样，只不过它只用于获取报文首部，不返回报文主体，故也是**幂等**；
- POST、PUT 均可用于创建、更新资源，但本质差别就在于幂等性上：
  - POST 方法目标主体是 <u>资源操作主体</u> 的操作，对同一URI 进行多次 PUT 的副作用和一次 PUT 是相同的，故为 **非幂等**；
  - PUT 方法目标主体是 <u>资源本身</u> 的更新操作，对同一URI 进行多次 PUT 的副作用和一次 PUT 是相同的，故为 **幂等**；
- DELETE 方法用于删除资源，有副作用，但它却是**幂等**的，因调用一次和调用 N 次对系统产生的副作用相同；
- OPTIONS 这个很好理解，只是为了获取服务器支持的方法，**幂等**；








##### 2-3-2、Status Code

RFC 规定 HTTP 的状态码为三位数，被分为五类:

- 1XX：表示目前是协议处理的中间状态，还需后续操作；
  - 100 Continue：继续，客户端应继续其请求；
  - <u>101 Switching Protocols：切换协议；服务器根据客户端的请求切换协议，但注意只能切换到更高级的协议；</u>
    - 比如：切换到 HTTP 的新版本协议；
    - 比如：当 HTTP 升级为 WebSocket 时，若服务器同意变更，也会回送此码；
- 2XX：表示成功状态；
  - 200 OK：成功状态码；响应体有数据；一般用于GET与POST请求；
  - 201 Created：已创建；成功请求服务端并创建了新的资源；
  - 202 Accepted：已接受；服务端已接受请求但未处理完成；
  - 203 Non-Authoritative Information：非授权信息；请求成功，但返回的 meta 信息不在原始服务器，而是一个副本；
  - <u>204 No Content：含义与 200 类似，服务器成功处理，但未返回内容(响应体无数据)；</u>
    - 比如：在未更新网页的情况下，可确保浏览器继续显示当前文档；
  - <u>205 Reset Content：重置内容；表示服务器处理成功，此时用户终端应重置文档视图；</u>
    - 比如：可通过此返回码清除浏览器的表单域；
  - <u>206 Partial Content：表示部分内容，服务器成功处理了部分GET请求；</u>
    - 比如：使用场景为 HTTP 分块下载和断点续传，当然也会带上相应的响应头字段 Content-Range；
- 3XX：表示重定向状态，资源位置发生变动，需重新请求；
  - 300 Multiple Choices：多种选择，请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表以供用户选择；
  - <u>301 Moved Permanently：永久重定向，请求的资源已被永久移动到新 URI，返回信息会包括新 URI，浏览器会自动定向到新 URI，且浏览器会作缓存优化，后续访问时自动访问缓存后的新 URI；</u>
  - <u>302 Found：临时重定向，与301类似，但资源只是临时被移动，客户端应继续使用原有URI，浏览器不作缓存优化；</u>
  - <u>303 See Other：临时重定向，请求的资源临时被移动到了别的URI上，但是明确表示客户端应该使用GET方法获取资源；</u>
  - <u>304 Not Modified：未修改，所请求的资源未修改，服务器返回此状态码时，不会返回任何资源；当协商缓存命中时返回的状态码；</u>
  - 305 Use Proxy：使用代理，所请求的资源必须通过代理访问；
  - 306 Unused：已经被废弃的HTTP状态码；
  - <u>307 Temporary Redirect：临时重定向，但是比 302 更明确，重定向的请求方法和实体都不允许变动；</u>
  - 比如：HSTS 协议，强制客户端使用 `https` 建立连接，若某网站从 `HTTP` 升级到 `HTTPS`，但还是以 http 形式访问时接收到；
  - **302 Found，基本的临时重定向**
  - **303 SeeOther，明确表示客户端应该使用GET方法**
  - **307 Temprary Redirect，请求方法和实体都不允许变动**
  
- 4XX：表示请求报文有误；
  - <u>400 Bad Request：客户端请求的语法错误，服务器无法理解；</u>
  - <u>401 Unauthorized：请求要求用户的身份认证；</u>
  - 402 Payment Required：保留码，将来使用；
  - <u>403 Forbidden：服务器理解请求客户端的请求，但是拒绝执行此请求(原因有很多，比如法律禁止、信息敏感、数据保护等)；</u>
  - <u>404 Not Found：服务器无法根据客户端的请求找到资源；</u>
  - 405 Method Not Allowed：客户端请求中的方法被禁止；
  - 406 Not Acceptable：服务器无法根据客户端请求的内容特性完成请求；
  - 407 Proxy Authentication Required：请求要求代理的身份认证，与 401 类似，但请求者应当使用代理进行授权；
  - 408 Request Timeout：服务器等待客户端发送的请求时间过长，超时；
  - 409 Conflict：服务器处理请求时发生了冲突；
    - 比如：服务器完成客户端的 PUT 请求；
  - 410 Gone：客户端请求的资源已不存在；
    - 注意：410 不同于 404：若资源过去存在，但现在被永久删除可使用 410 代码，亦可通过 301 码指定资源新位置；
  - 411 Length Required：服务器无法处理客户端发送的不带Content-Length的请求信息
  - 412 Precondition Failed：客户端请求信息的先决条件错误
  - 413 Request Entity Too Large：请求体过大，服务器无法处理，因此拒绝请求；
    - 注意：为防止客户端的连续请求，服务器可能会关闭连接。若只是服务器暂时无法处理，则会返回包含 Retry-After 的响应信息；
  - 414 Request-URI Too Long：请求行的 URI 过长，服务器无法处理；
  - 415 Unsupported Media Type：服务器无法处理请求附带的媒体格式；
  - 416 Requested range not satisfiable：客户端请求的范围无效；
  - 417 Expectation Failed：服务器无法满足 Expect 的请求头信息；
  - 429 Too Many Request：客户端发送请求过多；
  - 431 Request Header Fields Too Large：请求头的字段内容太大；

- 5XX：表示服务器端发生错误；
  - <u>500 Internal Server Error：服务器内部错误，且无提示具体错误原因，无法完成请求；</u>
  - <u>501 Not Implemented：表示服务器不支持请求的功能，无法完成请求</u>
  - 502 Bad Gateway：表示充当网关或代理的服务器，从远端服务器接收到了一个无效的请求；
  - <u>503 Service Unavailable：表示服务器当前正忙(由于超载或系统维护)，服务器暂时的无法处理客户端的请求；</u>
  - 504 Gateway Time-out：充当网关或代理的服务器，未及时从远端服务器获取请求；
  - 505 HTTP Version not supported：服务器不支持请求的 HTTP 协议版本，无法完成处理；

<img src="/Image/NetWork/http/3.png" style="zoom:50%;" align="left"/>

<img src="/Image/NetWork/http/4.png" style="zoom:50%;" align="left"/>



##### 2-3-3、Accept-### & Content-###

此类字段用于双方确定对方可接收的 **<u>数据格式、压缩方式、支持语言和所使用的字符集</u>**：

<img src="/Image/NetWork/http/6.png" style="zoom:60%;" align="left"/>

<u>*注意：下述内容中，将接收端想象为客户端，将发送端想象为服务端会较好理解；*</u>

- 数据类型：标记数据类型
  - 接收端通过 Accept 字段表示想接收到的数据类型；
  - 发送端通过 Content-type 表示发送数据的类型；
    - text： text/html, text/plain, text/css 等；
    - image: image/gif, image/jpeg, image/png 等；
    - audio/video: audio/mpeg, video/mp4 等；
    - application: application/json, application/javascript, application/pdf, application/octet-stream；
    - 注意：上述取值参考于 **标准 MIME(Multipurpose Internet Mail Extensions, 多用途互联网邮件扩展)**；
- 压缩方式：标记对数据编码压缩的方式
  - 接收端通过 Accept-Encoding 表示可接受的压缩方式；
  - 发送端通过 Content-Encoding 表示对数据采取了何种压缩方式；
    - gzip: 当今最流行的压缩格式；
    - deflate：另外一种著名的压缩格式；
    - br：一种专门为 HTTP 发明的压缩算法；
- 支持语言：标记本机环境所支持的语言
  - 接收端通过 Accept-Language 表示可支持的语言；
  - 发送端通过 Content-Language 表示可支持的语言；
- 字符集：标记可接受的字符集
  - 接收端通过 Accept-Charset 表示可支持的字符集；
  - 发送端通过 Content-Type 表示可支持的字符集；

<img src="/Image/NetWork/http/7.png" style="zoom:40%;" align="left"/>



##### 2-3-4、Cookie

HTTP 是一个无状态的协议，每次请求均为独立、无关，默认不需要保留状态信息，为保存状态，HTTP 引入了 Cookie 字段；**<u>其本质是浏览器中内部以键值对形式存储的、很小的一个文本文件</u>**，浏览器向同一域名下发送请求，都会自动携带相同的 Cookie，服务器拿到 Cookie 进行解析，就能拿到客户端状态；服务端可通过设置响应头的 `Set-Cookie` 字段来为客户端写入`Cookie`，缺点有下：

```http
// 请求头
Cookie: a=xxx;b=xxx
// 响应头
Set-Cookie: a=xxx
set-Cookie: b=xxx
```

- 容量缺陷：Cookie 体积上限只有 `4KB`；
- 性能缺陷：Cookie 紧跟域名，同域所有地址均自动携带发送完整 Cookie，随着请求数的增多，造成性能损耗，可通过 `Domain` 和 `Path` 指定 **作用域** 解决；
- 安全缺陷：Cookie 以纯文本形式在网络中传递，易被非法用户截获和篡改(尤其在有效期内发送)；此外在 `HttpOnly: false` 情况下，Cookie 能直接通过 JS 脚本来读取；



##### 2-3-4-1、Cookie 生存周期与作用域

Cookie 的有效期可通过 **Expires** 和 **Max-Age** 两个属性来设置，若 Cookie 过期，则 Cookie 会被删除，并不会发送给服务端：

- **Expires**：即过期时间；
- **Max-Age**：即时间间隔，单位秒，从浏览器收到报文开始计算；

Cookie 的作用域可通过 **Domain **和 **path** 两个属性来设置，若给 Cookie 绑定域名和路径后，在发送请求前，发现域名或路径与属性不匹配，则不会带上 Cookie；注意：若 Path 设置 `Path: /`：表示域名下任意路径均允许 Cookie；



##### 2-3-4-2、Cookie 安全

- 若 Cookie 字段带上 `Secure`，表示只能通过 HTTPS 传输 cookie；
- 若 Cookie 字段带上`HttpOnly`，表示只能通过 HTTP 协议传输，不能通过 JS 访问，**<u>此乃预防 XSS 攻击的重要手段</u>**；
- 若 Cookie 字段带上 `SameSite`，可用于防御 CSRF 攻击，可设置 3 个值，`Strict`、`Lax`和`None`：
  - None 模式：默认模式，请求会自动携带 Cookie；
  - Strict 模式：浏览器完全禁止三方请求携带Cookie；
    - 比如：请求 `bilili.com` ，则只能在 `bilili.com ` 域名下的请求才能携带 Cookie，其他网站请求均不能；
  - Lax 模式：宽松模式，但只能在 `get 方法提交表单` 或 `a 标签发送 get 请求` 的情况下才可携带 Cookie，其他情况均不能；



##### 2-3-5、Content-Length

用于标识报文长度(body 部分)，**<u>发送定长包体</u>**，此属性对于 http 传输过程起十分关键的作用，若设置不当可直接导致传输失败；

- 若设置值 < 实际报文长度会根据设置值截断；
- 若设置值 > 实际报文长度则会报错："该网页无法正常运作"；

```javascript
res.setHeader('Content-Type', 'text/plain');
// ContentLength = "helloworld".length 输出正常
res.setHeader('Content-Length', 10);
res.write("helloworld");
// helloworld

// ContentLength < "helloworld".length 输出被截断
res.setHeader('Content-Length', 5);
res.write("helloworld");
// hello

// ContentLength > "helloworld".length 报错
res.setHeader('Content-Length', 11);
res.write("helloworld");
// error
```



##### 2-3-6、Transfer-Encoding: chunked

用于表示分块传输数据，**<u>发送不定长包体</u>**，设置此字段后会自动产生 2 个效果:

- Content-Length 字段会被忽略；
- 基于长连接持续推送动态内容；

```javascript
const http = require('http');
const server = http.createServer();

server.on('request', (req, res) => {
  if(req.url === '/') {
    res.setHeader('Content-Type', 'text/html; charset=utf8');
    // Content-Length 会被忽略
    res.setHeader('Content-Length', 10);
    res.setHeader('Transfer-Encoding', 'chunked');
    res.write("<p>来啦</p>");
    setTimeout(() => {
      res.write("第一次传输<br/>");
    }, 1000);
    setTimeout(() => {
      res.write("第二次传输");
      res.end()
    }, 2000);
  }
})
server.listen(8009, () => { console.log("成功启动");})
```

<img src="/Image/NetWork/http/14.png" style="zoom:50%;" align="left"/>

```
chunk长度(16进制的数)
第一个chunk的内容
chunk长度(16进制的数)
第二个chunk的内容
......
0

```



##### 2-3-7、Content-Type

HTTP 有 2 种主要的表单提交方式，体现在 2 种不同的`Content-Type`取值：

- application/x-www-form-urlencoded
- multipart/form-data

因表单提交一般是 `POST`请求，很少考虑`GET`，故此处默认提交的数据放在请求体中；

##### 2-3-7-1、application/x-www-form-urlencoded

对于 `application/x-www-form-urlencoded` 格式的表单内容，有以下特点:

- 数据会被编码成以`&`分隔的键值对；
- 字母原样，但字符以 <u>URL编码方式</u> 编码；

```
// 转换过程: 
{a: 1, b: 2} -> a=1&b=2 -> "a%3D1%26b%3D2"
```

##### 2-3-7-2、multipart/form-data

`multipart/form-data` 格式最大特点在于：**每个表单元素均为独立的资源表述**；实际场景中，对于图片等文件的上传，基本采用 `multipart/form-data` 字段而非 `application/x-www-form-urlencoded`，原因是没必要做 URL 编码；

- 请求头中的 `Content-Type` 字段会包含 `boundary(分隔符)`，此值值由浏览器默认指定；
  - 比如： `Content-Type: multipart/form-data;boundary=----WebkitFormBoundaryRRJKeWfHPGrS4LKe`；
  - 注意：`boundary` 是切实存在的，但浏览器和 HTTP 封装了这一系列操作；
- 数据会被拆分成多个部分、部分之间通过分隔符分隔、每部分的表述均有 HTTP 头部描述子包体，比如 `Content-Type`，在最后的分隔符会加上`--`表示结束；
  - 比如：相应的请求体是下面这样:

```http
Content-Disposition: form-data;name="data1";
Content-Type: text/plain
data1
----WebkitFormBoundaryRRJKeWfHPGrS4LKe
Content-Disposition: form-data;name="data2";
Content-Type: text/plain
data2
----WebkitFormBoundaryRRJKeWfHPGrS4LKe--
```



##### 2-3-8、Range

对于大文件上传，为避免影响用户体验，HTTP 提供 <u>范围请求</u> 方式，允许客户端仅请求资源的某部分(前提是服务端支持 <u>范围请求</u>，可从服务端的响应报文获悉)，

```http
// 服务端告知客户端自身支持范围请求
Accept-Ranges: none
```

具体请求哪部分，客户端可通过 Range 请求字段确定，格式为 `bytes=x-y`，书写格式如下：

- **0-499**：表示从开始到第 499 个字节；
- **500**- ：表示从第 500 字节到文件终点；
- **-100**：表示文件的最后100个字节；

当服务器收到请求后，首先会验证范围 **是否合法**，若越界则返回 `416` 错误码，否则读取相应片段，返回 `206` 状态码；同时，服务器还会在响应报文头部添加  `Content-Range` 字段，此字段的格式根据请求头中 `Range` 字段的不同而不同；具体来说，请求 `单段数据` 和请求 `多段数据`，响应头是不一样的：

##### 2-3-8-1、Range—单段数据

```javascript
// 单段数据
Range: bytes=0-9
// 响应报文:
HTTP/1.1 206 Partial Content
Content-Length: 10
Accept-Ranges: bytes
Content-Range: bytes 0-9/100

hello world

```

其中 Content-Range 字段，0-9 表示请求的返回，100 表示资源的总大小；

##### 2-3-8-2、Range—多段数据

```javascript
// 多段数据
Range: bytes=0-9, 30-39
// 响应报文:
HTTP/1.1 206 Partial Content
Content-Type: multipart/byteranges; boundary=00000010101
Content-Length: 189
Connection: keep-alive
Accept-Ranges: bytes


--00000010101
Content-Type: text/plain
Content-Range: bytes 0-9/96

i am xxxxx
--00000010101
Content-Type: text/plain
Content-Range: bytes 20-29/96

eex jspy e
--00000010101--

```

其中 `Content-Type: multipart/byteranges;boundary=00000010101`，表示：

- 请求一定是多段数据请求
- 响应体中的分隔符是 00000010101

因此，在响应体中各段数据之间会由这里指定的分隔符分开，而且在最后的分隔末尾添上`--`表示结束；



##### 2-3-9、代理相关字段

代理服务器有诸多作用：

- **负载均衡**：客户端请求只会先到达代理服务器，随后通过特定算法(随机算法、轮询、一致性hash、LRU)分发给不同源服务器，让各源服务器负载尽量均衡；
- **保障安全**：利用心跳机制监控后台服务器，一旦发现故障机就移出服务器集群，并对其上下行数据进行过滤，对非法 IP 限流等；
- **缓存代理**：将内容缓存到代理服务器，使客户端可直接从代理获取资源而不用去源服务器；

##### 2-3-9-1、Via

代理服务器需表明自身身份，在 HTTP 传输中留下痕迹，可通过字段 Via 实现记录，其值为在 HTTP 传输中报文传达的顺序：

```javascript
// 客户端 -> 代理1 -> 代理2 -> 源服务器
// 源服务器收到请求后，在请求头部拿到:
Via: proxy_server1, proxy_server2

// 客户端收到响应后，在响应头部拿到:
Via: proxy_server2, proxy_server1
```

##### 2-3-9-2、X-Forwarded-For

记录 <u>请求方(包括代理)</u> IP 地址的字段，表示为谁转发；

- 此外：还有 `X-Forwarded-Host` 和 `X-Forwarded-Proto`，分别记录 `域名` 和 `协议名` (注意：此刻又不包括代理)；
- 问题：`X-Forwarded-For` 的值会随着代理的变更而变更，即代理必须解析 HTTP 请求头，然后才可进行修改，比直接转发数据效率低；且在 HTTPS 通信加密的过程中，原始报文是不允许修改的；
- 解决：通过 <u>代理协议</u> 解决：在HTTP 请求行上面加上以下格式文本：

```http
// PROXY + TCP4/TCP6 + 请求方地址 + 接收方地址 + 请求端口 + 接收端口
PROXY TCP4 0.0.0.1 0.0.0.2 1111 2222
GET / HTTP/1.1
...
```

##### 2-3-9-3、X-Real-IP

记录最初客户端的 IP 的字段，而不管经过多少代理；



##### 2-3-10、缓存相关字段

强缓存与协商缓存请看浏览器一章，总结如下：

- 首先，通过 `Cache-Control` 验证强缓存是否可用
  - 若强缓存可用，直接使用，不发送请求；
  - 否则进入协商缓存，发送 HTTP 请求，服务器通过请求头中的 `If-Modified-Since` 或 `If-None-Match` 的这些 <u>条件请求字段</u> 检查资源是否更新
    - 若资源更新，则返回资源和 200 状态码
    - 否则返回 304 状态码，告诉浏览器应直接从缓存获取资源；

代理缓存：即专门负责提供资源缓存服务的代理服务器，分管源服务器的 HTTP 缓存，减少源服务器压力(尤其是流量巨大时段)，客户端缓存过期后可 <u>就近</u> 到代理缓存中获取，而代理缓存过期时则请求源服务器，缓存代理的控制分为 2 部分：<u>源服务器端的控制</u>，<u>客户端的控制</u>：

- **<u>源服务器的缓存控制</u>**

##### 2-3-10-1、private 和 public

源服务器通过在响应中加上 `Cache-Control` 字段来进行缓存控制，其值通常为：

- `public`：允许代理服务器缓存；
- `private`：禁止代理服务器缓存；
  - 注意：此举能防范极私密数据，缓存到代理服务器，从而被恶意用户访问获取；

##### 2-3-10-2、proxy-revalidate

- `must-revalidate`：指示**客户端**缓存过期就去源服务器获取；

- `proxy-revalidate`：指示**代理服务器**缓存过期后到源服务器获取；

##### 2-3-10-3、s-maxage

限定缓存在 <u>代理服务器</u> 中可存放多长时间，`s` 即 `share`，与限制客户端缓存时间的 `max-age` 并不冲突

```javascript
// 源服务器在响应头
Cache-Control: public, max-age=1000, s-maxage=2000
// 表示此响应允许代理服务器缓存，客户端缓存过期则到代理中拿，且在客户端的缓存时间为 1000 s，在代理服务器中的缓存时间为 2000 s;
```



- **<u>客户端的缓存控制</u>**

##### 2-3-10-4、max-stale 和 min-fresh

客户端的请求头中，可加入这 2 个字段，来对代理服务器上的缓存进行 <u>宽容</u> 和 <u>限制</u> 操作：

```
max-stale: 10
// 表示客户端从代理服务器上拿缓存时，即使代理缓存过期也不要紧，只要过期时间在 10 秒之内，就可从代理中获取
min-fresh: 5
// 表示代理缓存需要一定新鲜度，不要等到缓存刚好到期再拿，一定要在到期前 5 秒前的时间拿，否则拿不到
```



##### 2-3-10-5、only-if-cached

表明客户端只接受代理缓存，而不接受源服务器响应；若代理缓存无效，则直接返回 `504（Gateway Timeout）`





#### 2-x、其他补充

##### 2-x-1、URI—统一资源标识符

**<u>*URI(Uniform Resource Identifie)*</u>** 包含 URL 与 URN 两部分，其作用是区分互联网上不同的资源；其只能使用 ASCII 编码，不支持显示 ASCII 以外字符，为顺利表示其他字符，URI 引入一套编码机制：将所有 **<u>非 ASCII 码字符和界定符</u>** 转为十六进制字节值，然后在前面加个 `%`；比如空格被转义成了 `%20`；URI 结构如下：
<img src="/Image/NetWork/http/5.png" style="zoom:40%;" align="center"/>

- **scheme**：协议名；诸如 `http`、 `https`、 `file` 等，须跟 `://` 连用；
- **user:passwd@**：表示登录主机时的用户信息，不安全，不推荐使用，不常用；
- **host:port**：主机名:端口；
- **path**：请求路径，标记资源所在位置；
- **query**：查询参数，键值对形式，键值对间用 `&` 分隔；path 与 query 则用 `?` 分隔；
- **fragment**：URI 所定位的资源内的<u>锚点</u>，浏览器可根据此<u>锚点</u>跳转到对应的位置；

```http
https://www.baidu.com/s?wd=HTTP&rsv_spt=1
scheme = https
host:port = www.baidu.com (http 和 https 的默认端口分别为80、443)
path = /s
query = ?wd=HTTP&rsv_spt=1
```







### 三、HTTPS

#### 3-1、基本介绍

​	HTTP 特性是明文传输，对外完全透明，传输的任一环节(TCP、路由、运营商等)都有可能被第三方窃取或篡改(中间人攻击)，为确保安全性，继而诞生 HTTPS，但实际上 HTTPS 并非新协议，而是在 HTTP 之下新增一层 SSL/TLS 协议的集合的统称，即：`HTTPS = HTTP + SSL/TLS`；通俗点说就是在 HTTP 与  TCP 间加入中间层，HTTP 向 TCP 通讯时，须先经过中间层进行加密，中间层则将加密后的数据传给 TCP；TCP 向 HTTP 通讯时，须将数据交由中间层解密才能传给上层 HTTP；这个中间层也叫安全层，其核心作用是对数据加解密；

- 注意：HTTPS 并非是新的协议，它只是在 HTTP 和 TCP 的传输中建立了一个安全层，并利用 `对称加密` 和 `非对称加密` 结合的方式 + 数字证书认证的方式，让传输过程的安全性大大提高；




#### 3-2、加密方式与应用

##### 3-2-1、加密演变(greate)

##### 3-2-1-1、对称加密

最简单的加密方式，指 **加密** 和 **解密** 使用的是 **相同的密钥**；即：客户端和服务器公用一个密匙用来对消息加解密；客户端和服务器约定好一个加密的密匙。客户端在发消息前用该密匙对消息加密，发送给服务器后，服务器再用该密匙进行解密拿到消息；

<img src="/Image/NetWork/http/22.png" style="zoom:50%;" />

意义：在一定程度上保证数据的安全性，但密钥一旦泄露(密钥在传输过程中被截获)，传输内容就会暴露，因此需要寻找一种更为安全传递密钥的方法；



##### 3-2-1-2、非对称加密

假设有 A、B 两把密钥，用 A 加密过的数据包只能用 B 解密，反之用 B 加密过的数据包只能用 A 解密；即：采用非对称加密时，客户端和服务端均拥有一个公钥和私钥，公钥加密的内容只有对应的私钥能解密；私钥自己留着，公钥发给对方；这样在发送消息前，先用对方的公钥对消息进行加密，收到后再用自己的私钥进行解密；这样攻击者只拿到传输过程中的公钥也无法破解传输的内容；

<img src="/Image/NetWork/http/23.png" style="zoom:50%;" />

意义：虽解决了由于密钥被获取而导致传输内容泄露的问题，但中间人仍可以用 `篡改公钥`的方式来获取/篡改传输内容，且非对称加密的性能比对称加密的差；

<img src="/Image/NetWork/http/24.png" style="zoom:50%;" />



##### 3-2-1-3、数字证书

上述问题在于：客户端不知道公钥是由服务端返回，还是中间人返回；由此可引入一个第三方认证的环节：即第三方使用私钥加密客户端的 `自己的公钥`，浏览器已内置一些权威第三方认证机构的公钥，浏览器会使用`第三方的公钥`来解开`用第三方的私钥加密过的客户端的自己的公钥`，从而获取公钥，若能成功解密，**<u>则说明获取到公钥是合法的(但仍无法确定是否被篡改，因为"水平厉害"的中间人也能申请证书，只能防范"水平一般"的中间人)</u>**；**证书的申请流程看：3-2-1-4**

意义：第三方认证也未能完全解决问题，第三方认证是面向所有人，中间人也能申请证书，若中间人使用自己证书掉包原证书，客户端还是无法确认公钥真伪；

<img src="/Image/NetWork/http/25.png" style="zoom:50%;" />



##### 3-2-1-4、数字签名

<img src="/Image/NetWork/http/35.png" style="zoom:40%;" align="left"/>

上述问题在于：传输过程中内容可能被篡改，证书可能被调包，为解决通信方身份遭伪装问题，验明通信方的身份；此时可引入 <u>数字签名</u>，以保证数据完整性(一旦中途被篡改即可发现)，**<u>而数字签名随数字证书的申请流程绑定，具体流程如下</u>**：

- 首先，服务器的运营人员会向 <u>双方皆信任的权威数字认证机构(简称CA)</u> 提交 服务器的公钥、组织信息、个人信息、网站等信息并申请认证；
- 然后，CA 在拿到这些信息后会通过线上、线下等各种途径验证申请者提交信息的真实性；
- 然后，在确认其真实性后，CA 给 <u>明文信息</u> 进行数字签名：(注意：将申请者的公钥、组织信息、个人信息及 CA 自己的信息等简称为 <u>明文信息</u>；)
  - 首先，通过单向 Hash 算法(比如MD5)，处理明文信息，生成一串信息摘要；
    - 注意：此摘要是上述信息的 <u>唯一标识(一旦构成数字签名的信息发生变化，Hash 值就会改变)</u>；
  - 然后，CA 使用自身私钥对信息摘要进行加密，此时，生成的文件即 **<u>数字签名</u>**；
- 最后，CA 会将 **<u>明文信息 和 数字签名 组合而成的证书</u>**，颁发给申请者，也即服务器；
- **<u>上述为颁发流程，颁发到申请者手中时，申请者还需验证是否本体：</u>**
  - 首先，CA 会将原文、数字签名(也就是加密后的摘要)一起发送给申请方；
  - 然后，申请方接收后，利用用 Hash 函数处理原文，得到消息摘要A；同时用发送方的公钥(浏览器自带)解密 数字签名得到消息摘要B；
  - 最后，只要比对两份消息摘要是否相等，即可验证出数据有无被篡改；(相等意味着证明了 CA 颁发可信任，数据没有被篡改)
  - 注意：验证证书的过程不仅是数字签名的验证，客户端还会验证证书相关的域名信息，有效时间，是不是在CRL吊销列表里，和它的上一级是否有效等；
  - 注意：验证上一级是否有效是一个递归过程，直到验证到根证书也即操作系统内置的 Root 证书或浏览器内置 Root 证书为止；
- **<u>下述为客户端验证流程，验证服务器证书是否被篡改：</u>**
  - 浏览器拿到数字签名后，会使用 <u>浏览器本地内置</u> 的 CA 公钥解开数字证书并验证，验证流程类似同上，验证通过则拿到正确公钥；
  - 由于非对称加密性能低下，拿到公钥以后，客户端会随机生成一个对称密钥，使用这个公钥加密并发送给服务端，服务端用自己的私钥解开对称密钥，此后的加密连接就通过这个对称密钥进行对称加密；

综上：HTTPS 在验证阶段使用  <u>非对称加密</u> + <u>数字证书</u> + <u>数字签名</u> **获取正确的公钥**，获取到正确的公钥后以 <u>对称加密</u> 的方式通信；

- 非对称加密：增加握手期攻击成本；
- 数字证书：防范无证书认证攻击者；
- 数字签名：防范有认证证书的攻击者；
- 对称加密：降低成本，提高效率





##### 3-2-2、加密的应用

浏览器和服务器进行协商加解密

- **使用对称加密应用**：
  - 首先，浏览器向服务器发送随机数 `client_random` 、加密方法列表；
  - 然后，服务器接收后，给浏览器返回 `server_random`、加密方法；
    - 此时，两者拥有三样相同凭证：`client_random`、`server_random`、加密方法；
  - 最后，双方利用加密方法，利用 2 个随机数生成密钥，此密钥就是浏览器和服务端通信的 <u>密钥</u>；
  - **<u>缺点</u>**：若传输途中被三方窃取，则可轻易制造相同密钥；

- **使用非对称加密**：
  - 服务器保存 **<u>公钥</u>(所有客户端均可获得并被分配到)** 与 **<u>私钥</u>(只有服务端自身知道)**
  - 首先，浏览器向服务器发送 `client_random` 、加密方法列表；
  - 然后，服务器接收后，给浏览器返回 `server_random`、加密方法、**<u>公钥</u>**；
    - 此时，两者拥有三样相同凭证：`client_random`、`server_random`、加密方法；而服务器含公私两钥，客户端含公钥；
  - 然后，浏览器利用加密方法，使用 **<u>公钥</u>** 将 `client_random` 和 `server_random` 加密，生成与服务器通信的 <u>密钥</u>；
    - 注意：<u>非对称加密：公钥加密的数据只能用私钥解密，私钥加密的数据只能用公钥解密</u>；
  - **<u>优点</u>**：可防范中间人窃取客户端发出的信息并破解(因无私钥)；
  - **<u>缺点</u>**：安全问题：因服务器数据只能使用私钥进行加密(无法利用公钥加密否则客户端无法解密)，所以一旦中间人截取到公钥(第二步)，则无法阻止其窃取从服务端发出的消息；
  - **<u>缺点</u>**：能消耗问题；

- **使用对称与非对称相结合的加密形式：**
  - 首先，浏览器向服务器发送 `client_random`、加密方法列表；
  - 然后，服务器接收后，给浏览器返 `server_random`、加密方法、**<u>公钥</u>**；
    - 此时，两者拥有三样相同凭证：`client_random`、`server_random`、加密方法；而服务器含公私两钥，客户端含公钥；
  - 然后，浏览器接收后，生成另一个随机数 `pre_random`，并用公钥加密，回传给服务器，后者则用私钥解密这个被加密后的 **<u>pre_random</u>**；
    - 此时，两者拥有四样相同凭证：`client_random`、`server_random`、`pre_random`、加密方法；而服务器含公私两钥，客户端含公钥；
  - 然后，双方通过相同加密方法，利用三个随机数，生成最终 <u>密钥</u>；
  - 最后，浏览器和服务器使用同样的密钥进行通信，即使用 <u>对称加密</u>；
  - <u>**优点**</u>：安全性提升：最重要是 **防止了私钥加密的数据外传**，单纯使用非对称加密时是通过传送的公钥进行加密得到的密钥，但公钥在飞行过程中可能会被截获，但此处公钥只是作为生成生成最终密钥的所需参数 `pre_random`(并无直接参与密钥的生成)，而此参数发往服务端时，即便被中间人截获，因无私钥也无法破译；从而保证了安全；
  - **<u>缺点</u>**：若所有步骤均被监听窃取……
  - **<u>缺点</u>**：若服务器是假的……
- **使用数字证书**：为解决上述安全问题：若黑客如果采用 DNS 劫持，将目标地址替换成黑客服务器地址，然后黑客再伪造一份公私钥，则照样能进行数据传输；而对于浏览器用户而言，无法知道自己正访问一个危险服务器；解决方式是引入 **<u>数字证书，让服务器证明自己的合法身份</u>**；而为获取数字证书，服务器运营者需要向 ***<u>第三方认证机构 CA—Certificate Authority</u>*** 获取授权，通过认证则向服务器颁发 **数字证书**，其作用如下：
  - 服务器向浏览器证明自己的身份；
  - 将公钥传给浏览器；

随后，当客户端欲发起 TLS 握手时，服务器接收请求后，会响应 `server_random`、加密方法、**<u>数字证书(包含公钥)</u>**；

然后，在浏览器接收之后，就会开始验证数字证书；若验证通过，则后续过程照常进行，否则拒绝执行；验证流程：

- 首先，读取证书中的明文内容；CA 进行数字证书的签名时会保存一个 Hash 函数，来这个函数来计算明文内容得到 `信息A`；
- 然后，用公钥解密明文内容得到 `信息B`，将两份信息进行比对，一致则表示认证合法；
- 注意：CA 的可信任性通过层级保证，若浏览器无法信任 CA，其会查找 CA 的上级 CA，以同样的信息比对方式验证上级 CA 的合法性，而一般根级的 CA 会内置在操作系统当中；若向上找没有找到根级的 CA，则将被视为不合法；



#### 3-3、TLS (SSL)

​	***SSL(Secure Sockets Layer—安全套接层)***，在 OSI 七层模型中处于第5层会话层；此前 SSL 出过 3 个大版本，当它发展到第 3 个版本时被标准化，成为 ***TLS(Transport Layer Security—传输层安全)***，并称 TLS1.0 版本 (SSL3.1)；目前主流版本是 <u>TLS1.2</u>，之前的 TLS1.0、TLS1.1 均被认为是不安全，在不久将来会被完全淘汰；而在 2018 年 <u>TLS1.3</u> 问世，更大大优化 TLS 握手过程；



#### 3-4、TLS 握手过程

- 第一阶段：建立安全能力 包括协议版本 会话Id 密码构件 压缩方法和初始随机数
- 第二阶段：服务器发送证书 密钥交换数据和证书请求，最后发送请求-相应阶段的结束信号
- 第三阶段：如果有证书请求客户端发送此证书 之后客户端发送密钥交换数据 也可以发送证书验证消息
- 第四阶段：变更密码构件和结束握手协议

##### 3-4-1、TLS 握手—RSA

<img src="/Image/NetWork/http/15.png" style="zoom:60%;" />

- 首先，浏览器向服务器发送 `client_random`、TSL 版本号、加密方法套件(含 RSA)；
- 然后，服务器接收后，给浏览器返 `server_random`、确认 TSL 版本号、加密方法套件(含 RSA)、**<u>数字证书(含公钥)</u>**；
  - 此时，两者拥有三样相同凭证：`client_random`、`server_random`、加密方法；而服务器含公私两钥，客户端含公钥；
- 然后，在浏览器接收之后，就会开始验证数字证书；若验证通过，浏览器利用 **<u>RSA</u>** 生成另一个随机数 `pre_random`，并利用服务器公钥(从证书中获取)进行加密，回传给服务器，后者则用私钥解密得到 **<u>pre_random</u>**；
  - 此时，两者拥有四样相同凭证：`client_random`、`server_random`、`pre_random`、加密方法；而服务器含公私两钥，客户端含公钥；
- 然后，双方通过相同加密方法，利用三个随机数，通过一个 <u>伪随机函数</u> 生成最终 <u>密钥</u>；
- 最后，浏览器和服务器使用同样的密钥进行通信，即使用 <u>对称加密</u>；



##### 3-4-2、TLS1.2 握手—ECDHE

<img src="/Image/NetWork/http/8.png" style="zoom:60%;" />

<img src="/Image/NetWork/http/34.png" style="zoom:60%;" />

- 首先，客户端在首次发送 HTTPS 请求时，会将以下内容发送给服务器；
  - TSL 版本号；
  - `随机值A—client_random`；
  - 加密套件列表；
  - (或自身证书，以供服务端验证自身身份和防信息篡改)；
- 然后，服务器在接收确认 TSL 版本号，同时发送以下内容给客户端(注意：此步若需验证客户端证书需要说明；)；
  - `随机值B—server_random`；
  - `server_params`；
  - 需要使用的加密套件；
  - 服务器证书；
- 然后，客户端在收到信息后，首先会对 <u>服务器证书</u> 进行验证：
  - 若验证成功，表示可利用服务端返回的数据有如下内容，并生成和回送  `client_params` 给服务器；
    - `随机值B—server_random`；
    - `server_param`；
  - 同时，客户端会通过 **<u>ECDHE算法</u>**，利用参数 `client_params`、 `server_params` 计算出一个 `随机值C—pre_random`；
  - 补充：ECDHE 基于椭圆曲线离散对数，传入的两个参数也被叫做椭圆曲线的公钥：`ECDHE(client_params,  server_params) = per_random`；
  - 此时，客户端同时拥有下述参数，并利用此些参数通过 **伪随机函数** 计算得出最终后续通信所使用的 <u>**对称密钥 secret**</u>；
    -  `随机值A—client_random`；
    - `随机值B—server_random`；
    - `随机值C—pre_random`；
- 然后，客户端生成完 <u>对称密钥</u> 后，会给服务器发送 <u>收尾消息</u>，告知服务器后续使用对称加密，且对称加密的算法采用首次请求时约定好的；
- 然后，服务器接收到传递来的 `client_params` 后，也会使用和客户端一样的方式，生成  <u>**对称密钥 secret**</u>，并且也会发送 <u>收尾消息</u> 给客户端；
- 最后，当双方都收到收尾消息并验证成功后，握手结束；后面开始用此 <u>对称密钥</u> 加密报文进行传输；
- 总结：在 TLS 握手阶段，两端使用非对称加密方式通信，但因非对称加密损耗的性能比对称加密大，所以在正式传输数据时，两端使用对称加密的方式通信；
- 总结：HTTPS 在验证阶段使用  <u>非对称加密</u> + <u>数字证书</u> + <u>数字签名</u> **获取正确的公钥**，获取到正确的公钥后以 <u>对称加密</u> 的方式通信；
  - 非对称加密：增加握手期攻击成本；
  - 数字证书：防范无证书认证攻击者；
  - 数字签名：防范有认证证书的攻击者；
  - 对称加密：降低成本，提高效率



##### 3-4-2-1、Client 协商

浏览器向服务端发送 TLS 版本、client_random、加密套件列表：

- TLS 版本：略；

- `client_random`：用以最终生成 secret 的一个参数；
- 使用的加密套件列表：`TLS_ECDHE_WITH_AES_128_GCM_SHA256`(类似形式)
  - 含义：`TLS` 握手过程中，使用 `ECDHE` 算法生成 `pre_random`，并用 `128` 位的 `AES` 算法进行对称加密，且加密过程中使用主流的 `GCM `分组模式(如何分组是对称加密中很重要的问题)，并告知采用 `SHA256` 算法作为 <u>哈希摘要算法</u>；



##### 3-4-2-2、Server 协商

服务端向客户端回送 `server_random`、`server_params`、确认 TLS 版本、使用的加密套件列表、服务器使用证书；

- 确认 TLS 版本：略；

- `server_random`：用以最终生成 `secret` 的一个参数；
- 使用的加密套件列表：`TLS_ECDHE_WITH_AES_128_GCM_SHA256`(类似形式)
  - 含义：`TLS` 握手过程中，使用 `ECDHE` 算法生成 `pre_random`，并用 `128` 位的 `AES` 算法进行对称加密，且加密过程中使用主流的 `GCM `分组模式(如何分组是对称加密中很重要的问题)，并告知采用 `SHA256` 算法作为 <u>哈希摘要算法</u>；
- 服务器使用证书：用于供客户端验证(验证通过则生成 `client_params`：用于计算 `pre_random` 的一个参数2/1)

- `server_params`：用于计算 `pre_random` 的一个参数2/2；



##### 3-4-2-3、Client 验证证书并生成 secret

客户端验证服务端传来的证书和签名是否通过，若验证通过，则生成并传递参数 `client_params` 给服务器；随后客户端通过 `ECDHE` 算法，传入参数 `server_params` 和 `client_params`，计算出 `pre_random`；(`ECDHE` 基于椭圆曲线离散对数，传入的两个参数也称作椭圆曲线的公钥)；此刻客户端拥有 **<u>client_random</u>**、**<u>server_random</u>**、**<u>pre_random</u>**，最后利用此 3 个数，通过一个伪随机数函数来计算出最终 `secret`；



##### 3-4-2-4、Server 生成 secret

服务端接收客户端的 `client_params`，通过 `ECDHE` 算法，传入参数 `server_params` 和 `client_params`，计算出 `pre_random`；最后，使用与客户端同样的伪随机数函数生成最终 `secret`；



##### 3-4-2-5、注意事项

- 注意(待定)：验证数字证书阶段：服务端利用自身数字证书信息，通过哈希摘要算法，生成一个 **摘要(字符串)** ，用以 **标识** 自身身份，并利用私钥加密，随后将 **加密后的标识(摘要)**，连同 **自身公钥** 传给客户端；随后客户端通过 **公钥** 来解密，生成另外一份摘要；对前后 2 个摘要进行对比，若相同则能确认服务端的身份；此亦就 **数字签名** 原理；整一过程中，除了哈希算法，最重要 **私钥加密，公钥解密**；
  - 若传输过程信息被窃取，则窃取人可获取公钥、解密标识…
  - 若不考虑传输过程的信息窃取，则关键是对数字证书的可信任性；

- 综述：TLS 目的是双方约定唯一 `serect` 进行加密解密操作，类似过去的密码表，但现今还要先确认双方关系，及避免传输过程被三方窃取篡改；`serect` 通过 **<u>client_random</u>**、**<u>server_random</u>**、**<u>pre_random</u>** 生成，前两者通过双方协商传输获得，后者须通过 **<u>server_params</u>** 和 **<u>client_params</u>** 计算得到，而这两个值须通过各自校验后才会生成并发送对方；比如 client_params 的生成须先验证服务端响应的数字证书，通过后才生成，如此确认双方身份；

- 注意：TLS 握手是一个双向认证的过程：前两次传输中，双方均向对方发送了：TLS版本相关内容、**<u>xxx_random</u>**、使用的加密套件列表，而服务端向客户端多发送了数字证书与 **<u>server_params</u>**，目的是供客户端校验服务端身份；校验通过后，客户端生成 **<u>client_params</u>** 并回传，此时服务端也要验证客户端身份，即同样需要走：哈希摘要 + 私钥加密 + 公钥解密 的认证流程；

- 注意：客户端生成 `secret` 后，会给服务端发送一收尾消息，告诉服务器之后内容都用对称加密，对称加密的算法就用首次约定的方式；服务端亦然；而此收尾消息包括 2 部分：

  - Change Cipher Spec：表示后续内容加密传输；
  - Finished消息：此消息是对之前所有发送的数据做的摘要，对摘要进行加密，让对方验证一下；

  当双方均验证通过后，TLS 握手才正式结束，后续 HTTP 正式开始传输加密报文；

- 注意：**<u>RSA 和 ECDHE 握手过程的区别：</u>**

  - 生成对称密钥过程不同：RSA 是使用 RSA 算法生成一个 `pre_random` 并用服务器的公钥加密 `pre_random` 发送给服务器，然后各自用 伪随机函数生成相同的 <u>对称密钥</u>；而在 ECDHE握手中，没有用到 RSA算法，而是用 ECDHE 算法生成的 pre_random，且这个过程中比 RSA 多了 client_params 和 server_params 两个参数；
  - 使用 `ECDHE`，客户端发送完收尾消息后即可提前抢跑，直接发送 HTTP 报文，不必等到收尾消息到达服务器，节省一个 RTT；然后等服务器返回收尾消息给自己，直接开始发请求，这也叫`TLS False Start`；
  - 最主要区别：RSA不具备向前安全性(一次破解并不影响历史信息的性质就是向前安全性)，ECDHE 有；
    - 向前安全性：
    - 比如：RSA 握手过程中，客户端拿到服务端公钥，然后利用公钥加密 `pre_random` 给服务端；若此时有第三方有服务端的私钥，并且截获之前所有报文时，则它就可以破解这段密文并拿到 `pre_random`、`client_random`、`server_random`，并根据对应的伪随机函数生成 secret，即拿到最终通信的 <u>对称密钥</u>，每一个历史报文都能通过这样的方式进行破解，不具有向前安全性；
    - 但是：ECDHE 在每次握手的时候都会产生一个零时的密钥对(也即 `client_params`、`server_params`)，即使第三方有私钥可以破解，但对之前的历史报文并没有影响，它就具有向前安全性；
  - 



##### 3-4-2-6、疑问合集

- 若握手期间信息被三方窃取(WIFI)并最终掌握 sercet 怎么办? ——数字签名防范此类问题；
- 若中间人不修改证书只修改 server_param 怎么办？—— 无法生成相一致的对称密钥，无法通信；
- 若中间人不作任何修改，只监听和盗取怎么办?——全链路 HTTPS；
- 与 [TLS 中间人攻击](https://www.zhihu.com/question/20744215) 有何不同?



#### 3-5、TLS 1.3

TLS 1.3 主要对 TLS 1.2 做了系列改进：废除大量算法，提升安全性，同时利用会话复用，节省重新生成密钥时间，并利用 `PSK`  实现 `0-RTT` 连接：

##### 3-5-1、安全提升

TLS1.3 废除大量有安全漏洞的加密算法，且最后只保留 5 个加密套件：

`TLS_AES_128_GCM_SHA256`、`TLS_AES_256_GCM_SHA384`、`TLS_CHACHA20_POLY1305_SHA256`、`TLS_AES_128_GCM_SHA256`、`TLS_AES_128_GCM_8_SHA256`

- 对称加密算法：保留 **AES** 和 **CHACHA20**；
- 分组模式：保留 **GCM** 和 **POLY1305**；
- 哈希摘要算法：保留 **SHA256** 和 **SHA384**；



那你可能会问了, 之前`RSA`这么重要的非对称加密算法怎么不在了？

我觉得有两方面的原因:

**第一**、2015年发现了`FREAK`攻击，即已经有人发现了 RSA 的漏洞，能够进行破解了。

**第二**、一旦私钥泄露，那么中间人可以通过私钥计算出之前所有报文的`secret`，破解之前所有的密文。

为什么？回到 RSA 握手的过程中，客户端拿到服务器的证书后，提取出服务器的公钥，然后生成`pre_random`并用**公钥**加密传给服务器，服务器通过**私钥**解密，从而拿到真实的`pre_random`。当中间人拿到了服务器私钥，并且截获之前所有报文的时候，那么就能拿到`pre_random`、`server_random`和`client_random`并根据对应的随机数函数生成`secret`，也就是拿到了 TLS 最终的会话密钥，每一个历史报文都能通过这样的方式进行破解。

但`ECDHE`在每次握手时都会生成临时的密钥对，即使私钥被破解，之前的历史消息并不会收到影响。这种一次破解并不影响历史信息的性质也叫**前向安全性**。

`RSA` 算法不具备前向安全性，而 `ECDHE` 具备，因此在 TLS1.3 中彻底取代了`RSA`。



##### 3-5-2、性能提升

<img src="/Image/NetWork/http/9.png" style="zoom:60%;" />

TLS 1.3 握手流程大体与 TLS1.2 类似，但比后者减少一个 RTT， 服务端不必等待对方验证数字证书后才能拿到 `client_params`，而是直接在首次握手时即可拿到， 拿到后由 **<u>client_random</u>**、**<u>server_random</u>**、**<u>pre_random(client_params、server_params)</u>  **立即计算 `secret`，节省大量非必需等待时间；此种握手方式亦称 **1-RTT 握手**，此外还可在此基础上进行进一步优化：

- 会话复用—1RTT优化
  - Session ID 方式：首先，客户端和服务器首次连接后各自保存会话 ID，并存储会话密钥；然后，当再次连接时，客户端发送会话 ID，服务器根据 ID 是否存在，选择直接复用先前会话状态、重用会话密钥；或拒绝；缺点是当客户端数量庞大时，对服务端存储、性能要求非常大；
  - Session Ticket 方式：针对上一种方式存在的问题，将服务端压力分摊给客户端(卑鄙)；首先，双方连接成功后，服务器 加密并将 Session Ticket 发给客户端并告知存储；然后客户端下次重连时，发送 Ticket，服务端解密后验证过期与否，若无则直接恢复先前会话状态；缺点是存在安全问题，每次用一个固定密钥来解密 Ticket 数据，一旦黑客拿到密钥，先前所有历史记录也被破解，故密钥需要定期进行更换；

- PSK(Pre-Shared Key)—0RTT优化：
  - 优化至 0RTT：在发送 Session Ticket 的同时携带应用数据，而不用等到服务端确认；缺点是存在安全问题，中间人截获 PSK 数据，不断向服务器发送，类似于 TCP 首次握手即携带数据，增加了服务器被攻击的风险；





#### 3-x、补充













### 四、HTTP/2

​	HTTPS 专注于安全提升，而 HTTP/2 则专注性能方面的提升(头部压缩、多路复用)，并增加诸多功能(设置请求优先级、服务器推送)；

​	在 HTTP/1 中，为性能考虑，会引入雪碧图、将小图内联、使用多个域名等等的方式；这一切都是因为浏览器限制了同一域名下的请求数量(Chrome-6)，当页面中需要请求很多资源时，队头阻塞（Head of line blocking）就会导致在达到最大请求数量时，剩余资源需要等待其他资源请求完成后才能发起请求(排队)；

<img src="/Image/NetWork/http/29.png" style="zoom:30%;" />

​	在 HTTP/2 中引入了多路复用的技术，这个技术可只通过一个 TCP 连接就可传输所有的请求数据；多路复用很好的解决了浏览器限制同一个域名下的请求数量的问题，同时也间接更容易实现全速传输，毕竟新开一个 TCP 连接都需要慢慢提升传输速度； [HTTP/1与HTTP/2 速度对比](https://http2.akamai.com/demo) ；

<img src="/Image/NetWork/http/28.png" style="zoom:30%;" />

​	

#### 4-1、二进制帧

​	HTTP/2 中所有加强性能的核心点在于此。在之前的 HTTP 版本中，是通过文本的方式传输数据；但在 HTTP/2 中引入了新的编码机制，所有传输的数据都会被分割，并采用二进制格式编码；

<img src="/Image/NetWork/http/26.png" style="zoom:50%;" />

​	HTTP/2 将报文全部换成二进制格式，即全部传输`01`串，以方便机器解析，减少因字符多义性的状态问题的判断，提升解析效率；原来的 `Headers + Body` 的报文格式被分拆成<u>**二进制帧**</u>，并使用 <u>Headers帧</u> 存放头部字段，用 <u>Data帧</u> 存放请求体数据；HTTP/2 传输的二进制帧格式如下：

<img src="/Image/NetWork/http/12.png" style="zoom:50%;" />

​	每个二进制帧由 **<u>帧头—Frame Header</u>** 和 **<u>帧体—Frame Payload</u>** 组成；

- 帧长度：表示 <u>帧体</u> 的长度；
- 帧类型：可分为 **数据帧** 和 **控制帧** 2 种；前者用来存放 HTTP 报文，后者用来管理 <u>流</u> 的传输，比如实现 **优先级** 与 **流量控制**；
- 帧标志：共有 8 个标志位，常用的有 **END_HEADERS **表示头数据结束，**END_STREAM **表示单方向数据发送结束；
- 流标识符—Stream ID：供接收方从乱序二进制帧中选择出 ID 相同的帧，并按顺序(ID按顺序递增)还原成请求/响应报文；
  - 注意：所谓乱序，指的是不同 ID 的 Stream 乱序发送，但同一 Stream ID 的帧一定是按顺序传输。二进制帧到达后对方会将 Stream ID 相同的二进制帧顺序组装(通过 TCP 顺序性实现)成完整的报文；



##### 4-1-1、流及流的状态变化

通信双方均可给对方发送二进制帧，这种二进制帧的<u>**双向传输的序列**</u>，称作 **<u>*流(Stream)*</u>**；而在 HTTP/2 请求和响应过程中，流的状态变化是通过标志位实现：

<img src="/Image/NetWork/http/13.png" style="zoom:60%;" />

- 首先，双方均未空闲状态，当客户端发送 `Headers帧` 后，开始分配 `Stream ID` ，此时客户端的 <u>流(序列)</u> 打开，而服务端在接收后也打开 <u>流(序列)</u> ，双方均打开 <u>流(序列)</u>  后，即可互相传递二进制帧；
- 然后，当客户端需要关闭时，向服务端发送 `END_STREAM帧`，进入 `半关闭状态`，此时客户端只能接收数据，不能发送数据；
- 然后，当服务端收到 `END_STREAM帧`，也进入 `半关闭状态`，此时服务端只能发送数据，不能接收数据，与客户端情况相反；
- 随后，服务端向客户端发送 `END_STREAM帧`，表示数据发送完毕，双方进入 `关闭状态`；
- 注意：若下次开启新的 <u>流(序列)</u> ，流 ID 需自增直到上限为止(4字节，最高位保留，范围 0-2^31 ≈ 21 亿)，到达上限后开一个新的 TCP 连接重头开始计数；



##### 4-1-2、流的传输特性

- 并发性：一个 HTTP/2 连接可同时发送多个帧，与 HTTP/1 不同，**<u>这是实现多路复用的基础</u>**；
- 自增性：流 ID 不可重用，按顺序递增，达到上限之后又新开 TCP 连接从头开始(没有回绕问题)；
- 双向性：客户端和服务端均可创建流，互不干扰，双方均可作为发送方或接收方；
- 可设置优先级：通过设置数据帧的优先级，让服务端先处理重要资源，优化用户体验；



#### 4-2、性能提升

##### 4-2-1、头部压缩

HTTP/1.1 及低版本中，使用文本的形式传输报文，在携带 cookie 的情况下，可能每次都需要重复传输几百到几千的字节；虽然 <u>请求报文请求体</u> 可通过 `Content-Encoding` 头部字段，指定压缩算法压缩请求体；而 HTTP/2 后，<u>请求报文头部</u> 也可通过 HPACK 压缩算法压缩 (GET 请求头部往往是主体，优化力度大)，HPACK 特点有二：

- 首先，服务器和客户端分别建立、维护哈希表，并将用到的字段存放在此表中，随后在传输时对于先前出现过的值，只需将把索引值传给对方即可，对方拿到索引后查表即可完成字段搜索；让请求头字段得到极大程度的精简和复用；
- 然后，对于整数和字符串进行 <u>哈夫曼编码</u>，此编码原理是：先将所有出现的字符建立一张索引表，然后让出现次数多的字符对应的索引尽可能短，传输时也是传输这样的**索引序列**，可达到非常高的压缩率；
- 注意：HTTP/2 废除了起始行概念，将起始行中的请求方法、URI、状态码转换成头字段，并用前缀 `:` 区分请求头；

<img src="/Image/NetWork/http/10.png" style="zoom:40%;" />



##### 4-2-2、多路复用

HTTP/2 解决的是 HTTP/1.1存在的问题：

- **TCP 慢启动：** TCP 连接建立后，会经历一个先慢后快的发送过程，如同汽车启动一般，若网页文件(HTML/JS/CSS/icon)都经过一次慢启动，对性能是不小的损耗；另外慢启动是 TCP 为减少网络拥塞的一种策略，没有办法改变；
- **多条 TCP 连接竞争带宽：** 若同时建立多条TCP连接，当带宽不足时就会竞争带宽，影响关键资源的下载；
- **HTTP/1.1 队头阻塞：** 虽 HTTP/1.1长链接可通过一 TCP 连接传输多个请求，但同一时刻只能处理一个请求，当前请求未结束，其他请求就只能被阻塞；

而在 HTTP/2 中，有两个非常重要的概念，分别是帧 (frame) 和流 (stream)；

- 帧代表着最小的数据单位，每个帧会标识出该帧属于哪个流；流也就是多个帧组成的数据流；

多路复用：是 HTTP/2 在一个域名里，只使用一个TCP⻓连接来传输数据，而且请求直接是并行的、非阻塞的，也就是说在一个 TCP 连接中可以存在多条流；可发送多个请求，对端可以通过帧中的标识知道属于哪个请求；通过这个技术，可避免 HTTP 旧版本中的队头阻塞问题、减少多条 TCP 连接竞争带宽问题，极大的提高传输性能；

实现原理： HTTP/2 引入一个二进制分帧层，客户端和服务端进行传输时，数据会先经过二进制分帧层处理，转化为一个个带有请求 ID 的帧，这些帧在传输完成后再根据 ID 组合成对应的数据；通俗说就是：多路复用即 HTTP/2 用 <u>流</u> 来在一个 TCP 连接上来进行多个数据帧的通信；因通过拆分报文为二进制帧，而一个 HTTP/2 连接可同时发送多个帧，且接收端可通过相同 StreamID 帧顺序组合还原报文，发送无先后关系，不用排队发送，故 HTTP/2 从协议层面解决 HTTP队头阻塞问题(前一请求未处理完，后续请求被阻塞(不同于 TCP 队头阻塞，后者是前一个报文数据包未收到就不会将提前到达的后续数据包向上传递，为数据包层面，HTTP 队头阻塞是请求层面))





#### 4-3、功能增加

##### 4-3-1、设置请求优先级

##### 4-3-2、服务器推送(Server Push)

在 HTTP/2 当中，服务器已不再是完全被动地接收响应请求，服务器可以在客户端某个请求后，主动推送其他资源；

当 TCP 连接建立之后，比如浏览器请求一个 HTML 文件，服务器就可在返回 HTML 基础上，将 HTML 中引用到的其他资源一并返回给客户端，减少客户端等待；

而某些资源客户端是一定会请求的，这时亦可采取服务端 push 的技术，提前给客户端推送必要的资源，减少一点延迟时间；

<img src="/Image/NetWork/http/11.png" style="zoom:40%;" />



### 五、HTTP/3

HTTP/2 仍然存在一些缺陷，但缺陷并非来自 HTTP/2 协议本身，而是来源于底层的 TCP 协议：虽然 TCP 连接是可靠连接，若出现丢包，则整个连接都要等待重传；HTTP/1.1 可同时使用 6 个 TCP 连接，一旦发生阻塞则另外 5 个还能工作，但 HTTP/2 只有1个 TCP 连接，也即阻塞问题被放大；

由于 TCP 协议已被广泛使用，故很难直接修改 TCP 协议，基于此 HTTP/3 选择了折衷办法：QUIC 基于 UDP 实现，是 HTTP/3 中的底层支撑协议，该协议基于 UDP，又取了 TCP 中的精华，实现了即快又可靠的协议；

- 注意：HTTP/3 之前名为 HTTP-over-QUIC，HTTP/3 最大的改造就是使用了 QUIC；

QUIC 虽然基于 UDP，但是在原本的基础上新增了很多功能，比如：<u>多路复用、0-RTT、使用 TLS1.3 加密、流量控制、有序交付、重传</u>等等功能：

- 多路复用：虽然 HTTP/2 支持了多路复用，但是 TCP 协议终究是没有这个功能；但 QUIC 原生就实现了此功能，并且传输的单个数据流可以保证有序交付且不会影响其他的数据流，这样的技术就解决了之前 TCP 存在的问题；并且 QUIC 在移动端的表现也会比 TCP 好，因为 TCP 是基于 IP 和端口去识别连接的，这种方式在多变的移动端网络环境下是很脆弱的，但 QUIC 是通过 ID 的方式去识别一个连接，不管你网络环境如何变化，只要 ID 不变，就能迅速重连上；

- 0-RTT：通过使用类似 TCP 快速打开的技术，缓存当前会话的上下文，在下次恢复会话时，只需要将之前的缓存传递给服务端验证通过就可进行传输；

- 纠错机制：比如发送三个包，则协议会算出这三个包的异或值并单独发出一个校验包，也即总共发出了四个包；当出现其中的非校验包丢包时，可通过另外三个包计算出丢失的数据包的内容；仅限于丢失一个包的情况下，若出现丢失多个包就不能使用纠错机制，只能使用重传的方式；

详看： [http发展史(http0.9、http1.0、http1.1、http2、http3)](https://juejin.im/post/5dbe8eba5188254fe019dabb#heading-9)





### X、转载